Released HL*1.6*142 SEQ #114
Extracted from mail message
**KIDS**:HL*1.6*142^

**INSTALL NAME**
HL*1.6*142
"BLD",1088,0)
HL*1.6*142^HEALTH LEVEL SEVEN^0^3090323^y^^
"BLD",1088,4,0)
^9.64PA^773^1
"BLD",1088,4,773,0)
773
"BLD",1088,4,773,2,0)
^9.641^773^1
"BLD",1088,4,773,2,773,0)
HL7 MESSAGE ADMINISTRATION  (File-top level)
"BLD",1088,4,773,2,773,1,0)
^9.6411^100^8
"BLD",1088,4,773,2,773,1,2,0)
MESSAGE ID
"BLD",1088,4,773,2,773,1,100,0)
LAST DATE/TIME UPDATED
"BLD",1088,4,773,2,773,1,102,0)
TIME START TO SEND
"BLD",1088,4,773,2,773,1,103,0)
TIME SENT
"BLD",1088,4,773,2,773,1,104,0)
TIME OF COMMIT ACK
"BLD",1088,4,773,2,773,1,105,0)
TIME OF APPLICATION ACK
"BLD",1088,4,773,2,773,1,106,0)
TIME START PROCESSING
"BLD",1088,4,773,2,773,1,107,0)
TIME PROCESSED
"BLD",1088,4,773,222)
y^n^p^^^^n^^n
"BLD",1088,4,773,224)

"BLD",1088,4,"APDD",773,773)

"BLD",1088,4,"APDD",773,773,2)

"BLD",1088,4,"APDD",773,773,100)

"BLD",1088,4,"APDD",773,773,102)

"BLD",1088,4,"APDD",773,773,103)

"BLD",1088,4,"APDD",773,773,104)

"BLD",1088,4,"APDD",773,773,105)

"BLD",1088,4,"APDD",773,773,106)

"BLD",1088,4,"APDD",773,773,107)

"BLD",1088,4,"B",773,773)

"BLD",1088,6.3)
17
"BLD",1088,"INID")
n^y
"BLD",1088,"INIT")
POST^HLP142
"BLD",1088,"KRN",0)
^9.67PA^779.2^20
"BLD",1088,"KRN",.4,0)
.4
"BLD",1088,"KRN",.401,0)
.401
"BLD",1088,"KRN",.402,0)
.402
"BLD",1088,"KRN",.403,0)
.403
"BLD",1088,"KRN",.5,0)
.5
"BLD",1088,"KRN",.84,0)
.84
"BLD",1088,"KRN",3.6,0)
3.6
"BLD",1088,"KRN",3.8,0)
3.8
"BLD",1088,"KRN",9.2,0)
9.2
"BLD",1088,"KRN",9.8,0)
9.8
"BLD",1088,"KRN",9.8,"NM",0)
^9.68A^16^16
"BLD",1088,"KRN",9.8,"NM",1,0)
HLDIE^^0^B70092394
"BLD",1088,"KRN",9.8,"NM",2,0)
HLTP3^^0^B126319348
"BLD",1088,"KRN",9.8,"NM",3,0)
HLUOPT3^^0^B6856566
"BLD",1088,"KRN",9.8,"NM",4,0)
HLMA3^^0^B51960807
"BLD",1088,"KRN",9.8,"NM",5,0)
HLUTIL^^0^B15676217
"BLD",1088,"KRN",9.8,"NM",6,0)
HLCSUTL^^0^B46767214
"BLD",1088,"KRN",9.8,"NM",7,0)
HLUTIL4^^0^B24031445
"BLD",1088,"KRN",9.8,"NM",8,0)
HLCSMON1^^0^B13446685
"BLD",1088,"KRN",9.8,"NM",9,0)
HLTP3A^^0^B2797877
"BLD",1088,"KRN",9.8,"NM",10,0)
HLTP4^^0^B46055553
"BLD",1088,"KRN",9.8,"NM",11,0)
HLTPCK2A^^0^B29587641
"BLD",1088,"KRN",9.8,"NM",12,0)
HLCSTCP2^^0^B83786254
"BLD",1088,"KRN",9.8,"NM",13,0)
HLCSMON^^0^B55215393
"BLD",1088,"KRN",9.8,"NM",14,0)
HLCSTCP1^^0^B73827538
"BLD",1088,"KRN",9.8,"NM",15,0)
HLTF^^0^B24387774
"BLD",1088,"KRN",9.8,"NM",16,0)
HLMA^^0^B53088927
"BLD",1088,"KRN",9.8,"NM","B","HLCSMON",13)

"BLD",1088,"KRN",9.8,"NM","B","HLCSMON1",8)

"BLD",1088,"KRN",9.8,"NM","B","HLCSTCP1",14)

"BLD",1088,"KRN",9.8,"NM","B","HLCSTCP2",12)

"BLD",1088,"KRN",9.8,"NM","B","HLCSUTL",6)

"BLD",1088,"KRN",9.8,"NM","B","HLDIE",1)

"BLD",1088,"KRN",9.8,"NM","B","HLMA",16)

"BLD",1088,"KRN",9.8,"NM","B","HLMA3",4)

"BLD",1088,"KRN",9.8,"NM","B","HLTF",15)

"BLD",1088,"KRN",9.8,"NM","B","HLTP3",2)

"BLD",1088,"KRN",9.8,"NM","B","HLTP3A",9)

"BLD",1088,"KRN",9.8,"NM","B","HLTP4",10)

"BLD",1088,"KRN",9.8,"NM","B","HLTPCK2A",11)

"BLD",1088,"KRN",9.8,"NM","B","HLUOPT3",3)

"BLD",1088,"KRN",9.8,"NM","B","HLUTIL",5)

"BLD",1088,"KRN",9.8,"NM","B","HLUTIL4",7)

"BLD",1088,"KRN",19,0)
19
"BLD",1088,"KRN",19,"NM",0)
^9.68A^^0
"BLD",1088,"KRN",19.1,0)
19.1
"BLD",1088,"KRN",101,0)
101
"BLD",1088,"KRN",409.61,0)
409.61
"BLD",1088,"KRN",771,0)
771
"BLD",1088,"KRN",779.2,0)
779.2
"BLD",1088,"KRN",870,0)
870
"BLD",1088,"KRN",870,"NM",0)
^9.68A^2^2
"BLD",1088,"KRN",870,"NM",1,0)
VA-VIE^^0
"BLD",1088,"KRN",870,"NM",2,0)
VAORL^^0
"BLD",1088,"KRN",870,"NM","B","VA-VIE",1)

"BLD",1088,"KRN",870,"NM","B","VAORL",2)

"BLD",1088,"KRN",8989.51,0)
8989.51
"BLD",1088,"KRN",8989.52,0)
8989.52
"BLD",1088,"KRN",8994,0)
8994
"BLD",1088,"KRN","B",.4,.4)

"BLD",1088,"KRN","B",.401,.401)

"BLD",1088,"KRN","B",.402,.402)

"BLD",1088,"KRN","B",.403,.403)

"BLD",1088,"KRN","B",.5,.5)

"BLD",1088,"KRN","B",.84,.84)

"BLD",1088,"KRN","B",3.6,3.6)

"BLD",1088,"KRN","B",3.8,3.8)

"BLD",1088,"KRN","B",9.2,9.2)

"BLD",1088,"KRN","B",9.8,9.8)

"BLD",1088,"KRN","B",19,19)

"BLD",1088,"KRN","B",19.1,19.1)

"BLD",1088,"KRN","B",101,101)

"BLD",1088,"KRN","B",409.61,409.61)

"BLD",1088,"KRN","B",771,771)

"BLD",1088,"KRN","B",779.2,779.2)

"BLD",1088,"KRN","B",870,870)

"BLD",1088,"KRN","B",8989.51,8989.51)

"BLD",1088,"KRN","B",8989.52,8989.52)

"BLD",1088,"KRN","B",8994,8994)

"BLD",1088,"PRE")
HLP142
"BLD",1088,"QUES",0)
^9.62^^
"BLD",1088,"REQB",0)
^9.611^1^1
"BLD",1088,"REQB",1,0)
HL*1.6*140^2
"BLD",1088,"REQB","B","HL*1.6*140",1)

"FIA",773)
HL7 MESSAGE ADMINISTRATION
"FIA",773,0)
^HLMA(
"FIA",773,0,0)
773PI
"FIA",773,0,1)
y^n^p^^^^n^^n
"FIA",773,0,10)

"FIA",773,0,11)

"FIA",773,0,"RLRO")

"FIA",773,0,"VR")
1.6^HL
"FIA",773,773)
1
"FIA",773,773,2)

"FIA",773,773,100)

"FIA",773,773,102)

"FIA",773,773,103)

"FIA",773,773,104)

"FIA",773,773,105)

"FIA",773,773,106)

"FIA",773,773,107)

"INIT")
POST^HLP142
"IX",773,773,"AHNEW",0)
773^AHNEW^This x-ref is used to look up the original message to check duplicate^MU^^F^IR^I^773^^^^^A
"IX",773,773,"AHNEW",1)
N HDR,FLD S HDR=$G(^HLMA(DA,"MSH",1,0)) Q:HDR']""  S:$G(^HLMA(DA,"MSH",2,0))]"" HDR=HDR_$G(^HLMA(DA,"MSH",2,0)) S FLD=$E(HDR,4) Q:FLD']""  S HDR=$P(HDR,FLD,3,6) S:HDR]"" ^HLMA("AH-NEW",HDR,X,DA)=""
"IX",773,773,"AHNEW",2)
N HDR,FLD S HDR=$G(^HLMA(DA,"MSH",1,0)) Q:HDR']""  S:$G(^HLMA(DA,"MSH",2,0))]"" HDR=HDR_$G(^HLMA(DA,"MSH",2,0)) S FLD=$E(HDR,4) Q:FLD']""  S HDR=$P(HDR,FLD,3,6) K:HDR]"" ^HLMA("AH-NEW",HDR,X,DA)
"IX",773,773,"AHNEW",2.5)
K ^HLMA("AH-NEW")
"IX",773,773,"AHNEW",11.1,0)
^.114IA^1^1
"IX",773,773,"AHNEW",11.1,1,0)
1^F^773^2^60^1^F
"IX",773,773,"C",0)
773^C^This is a regular index of new-style cross-reference on the Message ID field^R^^F^IR^I^773^^^^^LS
"IX",773,773,"C",.1,0)
^^2^2^3070731^
"IX",773,773,"C",.1,1,0)
This cross reference allows a user to look up an HL7 message by its 
"IX",773,773,"C",.1,2,0)
unique message ID.
"IX",773,773,"C",1)
S ^HLMA("C",$E(X,1,60),DA)=""
"IX",773,773,"C",2)
K ^HLMA("C",$E(X,1,60),DA)
"IX",773,773,"C",2.5)
K ^HLMA("C")
"IX",773,773,"C",11.1,0)
^.114IA^1^1
"IX",773,773,"C",11.1,1,0)
1^F^773^2^60^1^F
"KRN",870,233,-1)
0^1
"KRN",870,233,0)
VA-VIE^^TCP^^^^^^^^^^^^^^^^^^
"KRN",870,233,200)
^^^^^^^^^R
"KRN",870,233,400)
^8090^C^N^^^^^
"KRN",870,355,-1)
0^2
"KRN",870,355,0)
VAORL^ORLANDO VAMC^TCP^^^^ORLANDO.MED.VA.GOV^HL7.ORLANDO.MED.VA.GOV^^^^^^^^^^^^^
"KRN",870,355,200)
^^^^^^^^^R
"KRN",870,355,400)
10.71.39.120^5000^C^N^^^^5001^
"MBREQ")
0
"ORD",13,870)
870;13;1;;HLLL^XPDTA1;;HLLLE^XPDIA1;;;HLLLDEL^XPDIA1(%)
"ORD",13,870,0)
HL LOGICAL LINK
"PKG",9,-1)
1^1
"PKG",9,0)
HEALTH LEVEL SEVEN^HL^DHCP IMPLEMENTATION OF HEALTH LEVEL SEVEN^
"PKG",9,20,0)
^9.402P^^
"PKG",9,22,0)
^9.49I^1^1
"PKG",9,22,1,0)
1.6^2980130^2980130^6
"PKG",9,22,1,"PAH",1,0)
142^3090323
"PRE")
HLP142
"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
NO
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
NO
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
NO
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
17
"RTN","HLCSMON")
0^13^B55215393^B54162059
"RTN","HLCSMON",1,0)
HLCSMON ;SF-DISPLAY DRIVER PROGRAM  ;06/26/2008  14:35
"RTN","HLCSMON",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**34,40,48,49,65,66,73,109,122,142**;Oct 13, 1995;Build 17
"RTN","HLCSMON",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLCSMON",4,0)
 ;
"RTN","HLCSMON",5,0)
 ;This Program drives a real-time display monitor for the HL7
"RTN","HLCSMON",6,0)
 ;Package. All the data used by this display is stored in file
"RTN","HLCSMON",7,0)
 ;# 870. Several callable entry points were broken
"RTN","HLCSMON",8,0)
 ;out of this routine and placed into HLCSMON1
"RTN","HLCSMON",9,0)
 ;
"RTN","HLCSMON",10,0)
 ;This routine has no required input parameters other than require that
"RTN","HLCSMON",11,0)
 ;U be defined, it does not instantiate any parameters either.
"RTN","HLCSMON",12,0)
 ;
"RTN","HLCSMON",13,0)
 ;
"RTN","HLCSMON",14,0)
 ;HLARY=array of all,HLARYD=array of display,HLARYO=array of old values
"RTN","HLCSMON",15,0)
 ;HLPTR1=top of display,HLPTR2=bottom of display,HLPTR3=last in HLVARY
"RTN","HLCSMON",16,0)
INIT N HLARY,HLARYD,HLARYO,HLCOFF,HLCON,HLDISP,HLPTR1,HLPTR2,HLPTR3,HLRESP
"RTN","HLCSMON",17,0)
 N HLDEV,HLERR,HLEVL,HLHDR,HLNODE,HLOCK
"RTN","HLCSMON",18,0)
 N HLPARAM,HLPROC,HLPROD,HLSEND,HLSENT,HLSITE
"RTN","HLCSMON",19,0)
 N HLI,HLREC,HLRUNCNT,HLSTAT,HLTMSTAT,HLLMSTAT,HLVIEW,HLXX,HLYY,X,Y,DX,DY
"RTN","HLCSMON",20,0)
 ;
"RTN","HLCSMON",21,0)
 ; patch HL*1.6*122 start
"RTN","HLCSMON",22,0)
 D HOME^%ZIS
"RTN","HLCSMON",23,0)
 W @IOF
"RTN","HLCSMON",24,0)
 ; patch HL*1.6*122 end
"RTN","HLCSMON",25,0)
 ;
"RTN","HLCSMON",26,0)
 D ^HLCSTERM ;Sets up variables to control display attributes
"RTN","HLCSMON",27,0)
INIT1 ;
"RTN","HLCSMON",28,0)
 ; Next 4 lines copied here from top of START by patch 73...
"RTN","HLCSMON",29,0)
 ;HLRUNCNT=number of in filers^out filers, HLDISP=display mode
"RTN","HLCSMON",30,0)
 S HLRUNCNT="-1^-1",HLPTR1=1 S:'$D(HLDISP) HLDISP="S"
"RTN","HLCSMON",31,0)
 D BUILDARY ;Build an array for display
"RTN","HLCSMON",32,0)
 QUIT:$$LOCKED(.HLOCK)  ;-> Anything locked?
"RTN","HLCSMON",33,0)
 ;
"RTN","HLCSMON",34,0)
 W HLCOFF ;Shut Cursor off
"RTN","HLCSMON",35,0)
 D HEADER^HLCSTERM ;Write header
"RTN","HLCSMON",36,0)
 D WDATA^HLCSMON1(5,17,"","","Incoming filers running => ")
"RTN","HLCSMON",37,0)
 D WDATA^HLCSMON1(5,18,"","","Outgoing filers running => ")
"RTN","HLCSMON",38,0)
 D WDATA^HLCSMON1(5,20,"","","Select a Command:")
"RTN","HLCSMON",39,0)
 D WDATA^HLCSMON1(1,21,"","","(N)EXT  (B)ACKUP  (A)LL LINKS  (S)CREENED  (V)IEWS  (Q)UIT  (?) HELP: ")
"RTN","HLCSMON",40,0)
 ;HLRUNCNT=number of in filers^out filers, HLDISP=display mode
"RTN","HLCSMON",41,0)
 S HLRUNCNT="-1^-1",HLPTR1=1 S:'$D(HLDISP) HLDISP="S"
"RTN","HLCSMON",42,0)
START ;
"RTN","HLCSMON",43,0)
 D BUILDARY ;Build an array for display
"RTN","HLCSMON",44,0)
 D DISPLAY^HLCSMON1 ;Display the array just built
"RTN","HLCSMON",45,0)
 D READ
"RTN","HLCSMON",46,0)
 ;HLRESP=user response
"RTN","HLCSMON",47,0)
 I '$L(HLRESP) G START
"RTN","HLCSMON",48,0)
 G:HLRESP="Q" EXIT
"RTN","HLCSMON",49,0)
 ;any of following commands, kill old values
"RTN","HLCSMON",50,0)
 K HLARYO,HLTMSTAT,HLLMSTAT
"RTN","HLCSMON",51,0)
 I HLRESP="?" D HELP G INIT1
"RTN","HLCSMON",52,0)
 I HLRESP="V" D VIEW G INIT1
"RTN","HLCSMON",53,0)
 I "AS"[HLRESP K HLARY,HLEVL S HLDISP=HLRESP G INIT1
"RTN","HLCSMON",54,0)
 I "NB"[HLRESP D NEXT
"RTN","HLCSMON",55,0)
 G START
"RTN","HLCSMON",56,0)
 ;
"RTN","HLCSMON",57,0)
READ ;Prompt the user for the next action
"RTN","HLCSMON",58,0)
 D WDATA^HLCSMON1(71,21,"","","",1)
"RTN","HLCSMON",59,0)
 W HLCON
"RTN","HLCSMON",60,0)
 R X#1:3
"RTN","HLCSMON",61,0)
 W HLCOFF
"RTN","HLCSMON",62,0)
 S HLRESP=$S(X="":X,"Qq^"[X:"Q","Bb"[X:"B","Nn"[X:"N","Aa"[X:"A","Vv"[X:"V",X="?":"?","Ss"[X:"S",1:"")
"RTN","HLCSMON",63,0)
 Q
"RTN","HLCSMON",64,0)
 ;
"RTN","HLCSMON",65,0)
VIEW ;select new view
"RTN","HLCSMON",66,0)
 W HLCON,!!
"RTN","HLCSMON",67,0)
 N DIC
"RTN","HLCSMON",68,0)
 S DIC="^HLCS(869.3,1,6,",DIC(0)="QEA"
"RTN","HLCSMON",69,0)
 D ^DIC Q:Y<0
"RTN","HLCSMON",70,0)
 S HLVIEW=+Y,HLDISP="V"
"RTN","HLCSMON",71,0)
 W HLCOFF
"RTN","HLCSMON",72,0)
 Q
"RTN","HLCSMON",73,0)
 ;
"RTN","HLCSMON",74,0)
NEXT ;
"RTN","HLCSMON",75,0)
 ;Next page
"RTN","HLCSMON",76,0)
 I HLRESP="N" D
"RTN","HLCSMON",77,0)
 . ;no more
"RTN","HLCSMON",78,0)
 . I HLPTR2=HLPTR3 D EOB Q
"RTN","HLCSMON",79,0)
 . S Y=HLPTR2+10,HLEVL(HLPTR1)=""
"RTN","HLCSMON",80,0)
 . ;exceed list, get last 10
"RTN","HLCSMON",81,0)
 . I Y>HLPTR3 S HLPTR2=HLPTR3,HLPTR1=HLPTR2-9 Q
"RTN","HLCSMON",82,0)
 . S HLPTR1=HLPTR2,HLPTR2=Y
"RTN","HLCSMON",83,0)
 ;
"RTN","HLCSMON",84,0)
 ;Backup a page
"RTN","HLCSMON",85,0)
 I HLRESP="B" D
"RTN","HLCSMON",86,0)
 . ;top of list
"RTN","HLCSMON",87,0)
 . I HLPTR1=1 D EOB Q
"RTN","HLCSMON",88,0)
 . I HLDISP="S" S HLPTR1=$O(HLEVL(HLPTR1),-1) Q
"RTN","HLCSMON",89,0)
 . S Y=HLPTR1-9
"RTN","HLCSMON",90,0)
 . ;can't go back 10, reset to top
"RTN","HLCSMON",91,0)
 . I Y'>0 S HLPTR1=1,HLPTR2=10 Q
"RTN","HLCSMON",92,0)
 . S HLPTR2=HLPTR1,HLPTR1=Y
"RTN","HLCSMON",93,0)
 ;
"RTN","HLCSMON",94,0)
 ;Erase what might be displayed on line 22
"RTN","HLCSMON",95,0)
 D WDATA^HLCSMON1(1,22,IOELALL,"","")
"RTN","HLCSMON",96,0)
 Q
"RTN","HLCSMON",97,0)
EOB D WDATA^HLCSMON1(5,22,IORVON,IORVOFF,"CANNOT "_$S(HLRESP="N":"ADVANCE",1:"BACKUP")_" BEYOND END OF BUFFER")
"RTN","HLCSMON",98,0)
 W $C(7) H 2
"RTN","HLCSMON",99,0)
 Q
"RTN","HLCSMON",100,0)
 ;
"RTN","HLCSMON",101,0)
BUILDARY ;
"RTN","HLCSMON",102,0)
 K HLARYD
"RTN","HLCSMON",103,0)
 ;
"RTN","HLCSMON",104,0)
 ;if view is defined, get links
"RTN","HLCSMON",105,0)
 I $G(HLVIEW) D  S HLVIEW=0,HLDISP="V"
"RTN","HLCSMON",106,0)
 . N HLTMP
"RTN","HLCSMON",107,0)
 . K HLARY,HLEVL S HLI=0
"RTN","HLCSMON",108,0)
 . F  S HLI=$O(^HLCS(869.3,1,6,HLVIEW,1,HLI)) Q:'HLI  S HLYY=+$P($G(^(HLI,0)),U,2) D
"RTN","HLCSMON",109,0)
 .. S Y=$P($G(^HLCS(870,HLI,0)),U) Q:Y=""
"RTN","HLCSMON",110,0)
 .. ;build array by DISPLAY ORDER and then by NAME
"RTN","HLCSMON",111,0)
 .. I HLYY S HLTMP(HLYY,HLI)="" Q
"RTN","HLCSMON",112,0)
 .. S HLTMP(Y,HLI)=""
"RTN","HLCSMON",113,0)
 . S (HLI,HLYY)=0
"RTN","HLCSMON",114,0)
 . ;rebuild array to put in proper order
"RTN","HLCSMON",115,0)
 . F  S HLI=$O(HLTMP(HLI)),HLXX=0 Q:HLI=""  D
"RTN","HLCSMON",116,0)
 .. F  S HLXX=$O(HLTMP(HLI,HLXX)) Q:'HLXX  S HLYY=HLYY+1,HLARY(HLYY,HLXX)=""
"RTN","HLCSMON",117,0)
 . S HLPTR3=HLYY
"RTN","HLCSMON",118,0)
 ;
"RTN","HLCSMON",119,0)
 I '$D(HLARY)  S HLYY=0,HLXX="" D
"RTN","HLCSMON",120,0)
 . ;build array in alphabetical order
"RTN","HLCSMON",121,0)
 . F  S HLXX=$O(^HLCS(870,"B",HLXX)) Q:HLXX=""  S Y=$O(^(HLXX,0)),HLYY=HLYY+1,HLARY(HLYY,Y)=""
"RTN","HLCSMON",122,0)
 . S HLPTR3=HLYY
"RTN","HLCSMON",123,0)
 ;
"RTN","HLCSMON",124,0)
 S HLI=HLPTR1,HLYY=6 ;HLYY=6TH Line of display
"RTN","HLCSMON",125,0)
 ;HLARYD(6) through HLARYD(15) with 6 through 15 also representing line
"RTN","HLCSMON",126,0)
 ;numbers on the display
"RTN","HLCSMON",127,0)
 F HLI=HLI:1 S HLXX=$O(HLARY(HLI,0)) Q:HLYY=16!'HLXX  D COPY
"RTN","HLCSMON",128,0)
 S HLPTR2=HLI-1
"RTN","HLCSMON",129,0)
 ;Set all HLARY elements not defined on this pass to null
"RTN","HLCSMON",130,0)
 F HLYY=HLYY:1:15 S HLARYD(HLYY)=""
"RTN","HLCSMON",131,0)
 Q
"RTN","HLCSMON",132,0)
COPY ;
"RTN","HLCSMON",133,0)
 Q:'$D(^HLCS(870,HLXX))
"RTN","HLCSMON",134,0)
 ;
"RTN","HLCSMON",135,0)
 ;These lock tags lock nodes in the global so that the screen is
"RTN","HLCSMON",136,0)
 ;refreshed in real-time. The lock forces the buffer to be refreshed,
"RTN","HLCSMON",137,0)
 ;so that the display is up to date.
"RTN","HLCSMON",138,0)
 ;
"RTN","HLCSMON",139,0)
 ;**109**
"RTN","HLCSMON",140,0)
 ;L +^HLCS(870,HLXX,0):0 L -^HLCS(870,HLXX,0) D CHKLOCK
"RTN","HLCSMON",141,0)
 ;
"RTN","HLCSMON",142,0)
 ; Set, even if not able to lock...
"RTN","HLCSMON",143,0)
 S Y=$G(^HLCS(870,HLXX,0))
"RTN","HLCSMON",144,0)
 ;
"RTN","HLCSMON",145,0)
 ;name^rec^proc^send^sent^device^state^error
"RTN","HLCSMON",146,0)
 S HLARYD(HLYY)=$P(Y,U)_"^^^^^"_$P(Y,U,4)_"^"_$P(Y,U,5)_"^"_$P(Y,U,19)
"RTN","HLCSMON",147,0)
 ; patch HL*1.6*142
"RTN","HLCSMON",148,0)
 ; if the link in-queue is set to 1 (stop), display it
"RTN","HLCSMON",149,0)
 I $P(Y,U,9) S $P(HLARYD(HLYY),"^",6)=$P(Y,U,4)_"/I-off"
"RTN","HLCSMON",150,0)
 ;
"RTN","HLCSMON",151,0)
 ;**109**
"RTN","HLCSMON",152,0)
 ;L +^HLCS(870,HLXX,"IN QUEUE BACK POINTER"):0 D CHKLOCK
"RTN","HLCSMON",153,0)
 ;L -^HLCS(870,HLXX,"IN QUEUE BACK POINTER")
"RTN","HLCSMON",154,0)
 ;
"RTN","HLCSMON",155,0)
 S $P(HLARYD(HLYY),U,2)=$G(^HLCS(870,HLXX,"IN QUEUE BACK POINTER"))
"RTN","HLCSMON",156,0)
 ;
"RTN","HLCSMON",157,0)
 ;**109**
"RTN","HLCSMON",158,0)
 ;L +^HLCS(870,HLXX,"IN QUEUE FRONT POINTER"):0 D CHKLOCK
"RTN","HLCSMON",159,0)
 ;L -^HLCS(870,HLXX,"IN QUEUE FRONT POINTER")
"RTN","HLCSMON",160,0)
 ;
"RTN","HLCSMON",161,0)
 S $P(HLARYD(HLYY),U,3)=$G(^HLCS(870,HLXX,"IN QUEUE FRONT POINTER"))
"RTN","HLCSMON",162,0)
 ;
"RTN","HLCSMON",163,0)
 ;**109**
"RTN","HLCSMON",164,0)
 ;L +^HLCS(870,HLXX,"OUT QUEUE BACK POINTER"):0 D CHKLOCK
"RTN","HLCSMON",165,0)
 ;L -^HLCS(870,HLXX,"OUT QUEUE BACK POINTER")
"RTN","HLCSMON",166,0)
 ;
"RTN","HLCSMON",167,0)
 S $P(HLARYD(HLYY),U,4)=$G(^HLCS(870,HLXX,"OUT QUEUE BACK POINTER"))
"RTN","HLCSMON",168,0)
 ;
"RTN","HLCSMON",169,0)
 ;**109**
"RTN","HLCSMON",170,0)
 ;L +^HLCS(870,HLXX,"OUT QUEUE FRONT POINTER"):0 D CHKLOCK
"RTN","HLCSMON",171,0)
 ;L -^HLCS(870,HLXX,"OUT QUEUE FRONT POINTER")
"RTN","HLCSMON",172,0)
 ;
"RTN","HLCSMON",173,0)
 S $P(HLARYD(HLYY),U,5)=$G(^HLCS(870,HLXX,"OUT QUEUE FRONT POINTER"))
"RTN","HLCSMON",174,0)
 ;
"RTN","HLCSMON",175,0)
 S X=HLARYD(HLYY),Y=$P(X,U,2)+$P(X,U,3)+$P(X,U,4)+$P(X,U,5)
"RTN","HLCSMON",176,0)
 ;if Select and the Y=0, nothing to report
"RTN","HLCSMON",177,0)
 I 'Y,HLDISP="S" S HLARYD(HLYY)="" Q
"RTN","HLCSMON",178,0)
 S HLYY=HLYY+1
"RTN","HLCSMON",179,0)
 Q
"RTN","HLCSMON",180,0)
 ;
"RTN","HLCSMON",181,0)
CHKLOCK ; Call here immediately after trying to lock.  And, BE SURE that 
"RTN","HLCSMON",182,0)
 ; nothing might occur that would change $T after the lock attempt!!
"RTN","HLCSMON",183,0)
 ; $T,HLXX -- req
"RTN","HLCSMON",184,0)
 N NM870
"RTN","HLCSMON",185,0)
 QUIT:$T  ;-> Lock obtained...
"RTN","HLCSMON",186,0)
 S NM870=$P($G(^HLCS(870,+HLXX,0)),U)
"RTN","HLCSMON",187,0)
 S NM870=$S(NM870]"":NM870_" (IEN #"_HLXX_")",1:"IEN #"_HLXX)
"RTN","HLCSMON",188,0)
 S HLOCK(NM870)=""
"RTN","HLCSMON",189,0)
 QUIT
"RTN","HLCSMON",190,0)
 ;
"RTN","HLCSMON",191,0)
HELP ;
"RTN","HLCSMON",192,0)
 W HLCON,@IOF
"RTN","HLCSMON",193,0)
 W !,"You have the following options when monitoring the Messaging System:"
"RTN","HLCSMON",194,0)
 W !,"Enter the command letter parentheses: N,B,Q,A,S,V or ?"
"RTN","HLCSMON",195,0)
 W !!,"(N) takes you to the next page of the display of Logical Links."
"RTN","HLCSMON",196,0)
 W !!,"(B) takes you back one page."
"RTN","HLCSMON",197,0)
 W !!,"(Q) terminates the monitor."
"RTN","HLCSMON",198,0)
 W !!,"(A) provides a display of all links defined on your system."
"RTN","HLCSMON",199,0)
 W !!,"(S) displays only those links that have had message traffic."
"RTN","HLCSMON",200,0)
 W !!,"(V) prompts for a view name and displays links defined in view."
"RTN","HLCSMON",201,0)
 W !!,"    Note that (S) is the default display at startup."
"RTN","HLCSMON",202,0)
 W !!,"**PRESS <RET> TO CONTINUE**"
"RTN","HLCSMON",203,0)
 R X:DTIME
"RTN","HLCSMON",204,0)
 W @IOF
"RTN","HLCSMON",205,0)
 W !,?25,"Device Types and corresponding prefixes:"
"RTN","HLCSMON",206,0)
 W !!,?30,"PC -- Persistent TCP/IP Client"
"RTN","HLCSMON",207,0)
 W !!,?30,"NC -- Non-Persistent TCP/IP Client"
"RTN","HLCSMON",208,0)
 W !!,?30,"SS -- Single-threaded TCP/IP Server"
"RTN","HLCSMON",209,0)
 W !!,?30,"MS -- Multi-threaded TCP/IP Server"
"RTN","HLCSMON",210,0)
 W !!,?30,"SH -- Serial HLLP"
"RTN","HLCSMON",211,0)
 W !!,?30,"SX -- Serial X3.28"
"RTN","HLCSMON",212,0)
 W !!,?30,"MM -- MailMan"
"RTN","HLCSMON",213,0)
 W !!,"**PRESS <RET> TO CONTINUE**"
"RTN","HLCSMON",214,0)
 R X:DTIME
"RTN","HLCSMON",215,0)
 W HLCOFF
"RTN","HLCSMON",216,0)
 Q
"RTN","HLCSMON",217,0)
EXIT ;
"RTN","HLCSMON",218,0)
 ;Turn Cursor back on
"RTN","HLCSMON",219,0)
 W HLCON
"RTN","HLCSMON",220,0)
 D KVAR^HLCSTERM
"RTN","HLCSMON",221,0)
 Q
"RTN","HLCSMON",222,0)
 ;
"RTN","HLCSMON",223,0)
LOCKED(HLOCK) ; Anything locked?
"RTN","HLCSMON",224,0)
 ;
"RTN","HLCSMON",225,0)
 ;
"RTN","HLCSMON",226,0)
 ; Nothing locked...
"RTN","HLCSMON",227,0)
 I '$D(HLOCK) QUIT "" ;->
"RTN","HLCSMON",228,0)
 ;
"RTN","HLCSMON",229,0)
 W !!,"Editing of logical link data is occurring right now.  For this reason, some of"
"RTN","HLCSMON",230,0)
 W !,"the information on the 'System Link Monitor' report might not be accurate for"
"RTN","HLCSMON",231,0)
 W !,"the following node(s)..."
"RTN","HLCSMON",232,0)
 W !
"RTN","HLCSMON",233,0)
 ;
"RTN","HLCSMON",234,0)
 S HLOCK=""
"RTN","HLCSMON",235,0)
 F  S HLOCK=$O(HLOCK(HLOCK)) Q:HLOCK']""  D
"RTN","HLCSMON",236,0)
 .  W !,?5,HLOCK
"RTN","HLCSMON",237,0)
 ;
"RTN","HLCSMON",238,0)
 S ACTION=$$BTE("Press RETURN to print report or '^' to exit... ",1)
"RTN","HLCSMON",239,0)
 ;
"RTN","HLCSMON",240,0)
 QUIT $S(ACTION=1:1,1:"")
"RTN","HLCSMON",241,0)
 ;
"RTN","HLCSMON",242,0)
BTE(PMT,FF) ; 
"RTN","HLCSMON",243,0)
 N DIR,DIRUT,DTOUT,DUOUT,X,Y
"RTN","HLCSMON",244,0)
 F X=1:1:$G(FF) W !
"RTN","HLCSMON",245,0)
 S DIR(0)="EA",DIR("A")=PMT
"RTN","HLCSMON",246,0)
 D ^DIR
"RTN","HLCSMON",247,0)
 QUIT $S(Y=1:"",1:1)
"RTN","HLCSMON",248,0)
 ;
"RTN","HLCSMON1")
0^8^B13446685^B10975872
"RTN","HLCSMON1",1,0)
HLCSMON1 ;SF-Utilities for Driver Program  ;06/26/2008  15:30
"RTN","HLCSMON1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**15,40,49,65,109,122,142**;Oct 13, 1995;Build 17
"RTN","HLCSMON1",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLCSMON1",4,0)
 ;
"RTN","HLCSMON1",5,0)
 ;This routine contains several entry points called from HLCSMON
"RTN","HLCSMON1",6,0)
 ;no input parameters are required. All variables used which are
"RTN","HLCSMON1",7,0)
 ;not newed here are newed in HLCSMON
"RTN","HLCSMON1",8,0)
 ;
"RTN","HLCSMON1",9,0)
DISPLAY ;display link info
"RTN","HLCSMON1",10,0)
 ;turn of line wrap
"RTN","HLCSMON1",11,0)
 S HLXX=0,X=0 X ^%ZOSF("RM")
"RTN","HLCSMON1",12,0)
 F  S HLXX=$O(HLARYD(HLXX)) Q:(HLXX'>0)  D WLINE(HLXX)
"RTN","HLCSMON1",13,0)
 ;DISPLAY INCOMING FILER STATUS
"RTN","HLCSMON1",14,0)
 ; patch HL*1.6*142 start
"RTN","HLCSMON1",15,0)
 ; call STAT^%ZTLOAD for each display in CNTFLR^HLCSUTL2.
"RTN","HLCSMON1",16,0)
 ; patch HL*1.6*122
"RTN","HLCSMON1",17,0)
 ; S HLXX=$P(HLRUNCNT,"^",1)
"RTN","HLCSMON1",18,0)
 ; I (+HLXX)=-1 S HLXX=$$CNTFLR^HLCSUTL2("IN")
"RTN","HLCSMON1",19,0)
 S HLXX=$$CNTFLR^HLCSUTL2("IN")
"RTN","HLCSMON1",20,0)
 ; patch HL*1.6*142 end
"RTN","HLCSMON1",21,0)
 ;
"RTN","HLCSMON1",22,0)
 ;ONLY UPDATE SCREEN IF COUNT HAS CHANGED
"RTN","HLCSMON1",23,0)
 I (HLXX'=+HLRUNCNT) D
"RTN","HLCSMON1",24,0)
 .D WDATA(5,17,"","",$J(" ",31)),WDATA^HLCSMON1(5,17,"","","Incoming filers running => ",35)
"RTN","HLCSMON1",25,0)
 .I (HLXX) D WDATA(32,17,"","",HLXX)
"RTN","HLCSMON1",26,0)
 .I ('HLXX) D WDATA(32,17,IOINHI,IOINORM,"Zero")
"RTN","HLCSMON1",27,0)
 .S $P(HLRUNCNT,"^",1)=HLXX
"RTN","HLCSMON1",28,0)
 ;DISPLAY OUTGOING FILER STATUS
"RTN","HLCSMON1",29,0)
 ; patch HL*1.6*142 start
"RTN","HLCSMON1",30,0)
 ; call STAT^%ZTLOAD for each display in CNTFLR^HLCSUTL2.
"RTN","HLCSMON1",31,0)
 ; patch HL*1.6*122
"RTN","HLCSMON1",32,0)
 ; S HLXX=$P(HLRUNCNT,"^",2)
"RTN","HLCSMON1",33,0)
 ; I (+HLXX)=-1 S HLXX=$$CNTFLR^HLCSUTL2("OUT")
"RTN","HLCSMON1",34,0)
 S HLXX=$$CNTFLR^HLCSUTL2("OUT")
"RTN","HLCSMON1",35,0)
 ; patch HL*1.6*142 end
"RTN","HLCSMON1",36,0)
 ;
"RTN","HLCSMON1",37,0)
 ;ONLY UPDATE SCREEN IF COUNT HAS CHANGED
"RTN","HLCSMON1",38,0)
 I (HLXX'=+$P(HLRUNCNT,"^",2)) D
"RTN","HLCSMON1",39,0)
 .D WDATA(5,18,"","",$J(" ",31)),WDATA^HLCSMON1(5,18,"","","Outgoing filers running => ",35)
"RTN","HLCSMON1",40,0)
 .I (HLXX) D WDATA(32,18,"","",HLXX)
"RTN","HLCSMON1",41,0)
 .I ('HLXX) D WDATA(32,18,IOINHI,IOINORM,"Zero")
"RTN","HLCSMON1",42,0)
 .S $P(HLRUNCNT,"^",2)=HLXX
"RTN","HLCSMON1",43,0)
 S X=$$TM^%ZTLOAD
"RTN","HLCSMON1",44,0)
 I X'=$G(HLTMSTAT) D
"RTN","HLCSMON1",45,0)
 .S HLTMSTAT=X
"RTN","HLCSMON1",46,0)
 .S HLXX=$S('HLTMSTAT:"***TASKMAN NOT RUNNING!!!***",1:"")
"RTN","HLCSMON1",47,0)
 .I 'HLTMSTAT D WDATA^HLCSMON1(45,17,IOELEOL_IOBON_IORVON,IOBOFF_IORVOFF,HLXX) I 1
"RTN","HLCSMON1",48,0)
 .E  D WDATA(45,17,IOELEOL,"",$J("TaskMan running ",16)) ;D WDATA(5,19,IOELALL,"","")
"RTN","HLCSMON1",49,0)
 S X=$$STAT^HLCSLM
"RTN","HLCSMON1",50,0)
 I X'=$G(HLLMSTAT) D
"RTN","HLCSMON1",51,0)
 .S HLLMSTAT=X Q:HLLMSTAT=3
"RTN","HLCSMON1",52,0)
 .S HLXX=$S('HLLMSTAT:"***LINK MANAGER NOT RUNNING!!!***",1:"")
"RTN","HLCSMON1",53,0)
 .I 'HLLMSTAT D WDATA^HLCSMON1(45,18,IOELEOL_IOBON_IORVON,IOBOFF_IORVOFF,HLXX) I 1
"RTN","HLCSMON1",54,0)
 .E  D WDATA^HLCSMON1(45,18,IOELEOL,"",$J("Link Manager running",18))
"RTN","HLCSMON1",55,0)
 ;Turn terminal line wrap back on
"RTN","HLCSMON1",56,0)
 D WDATA(45,19,IOELEOL,"",$$SLM^HLEVUTIL) ; HL*1.6*109
"RTN","HLCSMON1",57,0)
 S X=IOM X ^%ZOSF("RM")
"RTN","HLCSMON1",58,0)
 Q
"RTN","HLCSMON1",59,0)
 ;
"RTN","HLCSMON1",60,0)
WLINE(HLXX) ;write line from HLARYD=current values, HLARYO=old values
"RTN","HLCSMON1",61,0)
 ;if values haven't changed, don't do anything
"RTN","HLCSMON1",62,0)
 I HLARYD(HLXX)]"",HLARYD(HLXX)=$G(HLARYO(HLXX)) Q
"RTN","HLCSMON1",63,0)
 S HLARYO(HLXX)=HLARYD(HLXX),HLERR=$P(HLARYD(HLXX),U,8),DX=1
"RTN","HLCSMON1",64,0)
 ; patch HL*1.6*122
"RTN","HLCSMON1",65,0)
 ; F X=1:1:7 S @$P("HLNODE^HLREC^HLPROC^HLSEND^HLSENT^HLDEV^HLSTAT",U,X)=$E($P(HLARYD(HLXX),U,X)_"        ",1,8)
"RTN","HLCSMON1",66,0)
 F X=1,7 S @$P("HLNODE^HLREC^HLPROC^HLSEND^HLSENT^HLDEV^HLSTAT",U,X)=$E($P(HLARYD(HLXX),U,X)_"        ",1,10)
"RTN","HLCSMON1",67,0)
 F X=2:1:5 S @$P("HLNODE^HLREC^HLPROC^HLSEND^HLSENT^HLDEV^HLSTAT",U,X)=$E($P(HLARYD(HLXX),U,X)_"        ",1,8)
"RTN","HLCSMON1",68,0)
 ; patch HL*1.6*142
"RTN","HLCSMON1",69,0)
 ; if the link in-queue is set to 1 (stop), display it from HLDEV
"RTN","HLCSMON1",70,0)
 ; S X=6,@$P("HLNODE^HLREC^HLPROC^HLSEND^HLSENT^HLDEV^HLSTAT",U,X)=$E($P(HLARYD(HLXX),U,X)_"        ",1,7)
"RTN","HLCSMON1",71,0)
 I $P(HLARYD(HLXX),U,6)["/I-off" D
"RTN","HLCSMON1",72,0)
 . S X=6,@$P("HLNODE^HLREC^HLPROC^HLSEND^HLSENT^HLDEV^HLSTAT",U,X)=$E($P(HLARYD(HLXX),U,X)_"        ",1,8)
"RTN","HLCSMON1",73,0)
 E  S X=6,@$P("HLNODE^HLREC^HLPROC^HLSEND^HLSENT^HLDEV^HLSTAT",U,X)=$E($P(HLARYD(HLXX),U,X)_"        ",1,7)
"RTN","HLCSMON1",74,0)
 ;
"RTN","HLCSMON1",75,0)
 ;if link is in error, write node in rev. video
"RTN","HLCSMON1",76,0)
 I HLERR]"" D WDATA(5,HLXX,IOBON_IORVON,IOBOFF_IORVOFF,HLNODE,8) S DX=14
"RTN","HLCSMON1",77,0)
 ;Turn off terminal line wrap & inform O/S where cursor is located
"RTN","HLCSMON1",78,0)
 S DY=HLXX X IOXY,^%ZOSF("XY")
"RTN","HLCSMON1",79,0)
 ; patch HL*1.6*122
"RTN","HLCSMON1",80,0)
 W:HLERR="" ?4,HLNODE
"RTN","HLCSMON1",81,0)
 ; patch HL*1.6*142
"RTN","HLCSMON1",82,0)
 ; if the link in-queue is set to 1 (stop), display it
"RTN","HLCSMON1",83,0)
 ; W ?16,HLREC,?26,HLPROC,?37,HLSEND,?47,HLSENT,?58,HLDEV,?63,HLSTAT
"RTN","HLCSMON1",84,0)
 I HLDEV["/I-off" D
"RTN","HLCSMON1",85,0)
 . W ?16,HLREC,?26,HLPROC,?37,HLSEND,?47,HLSENT,?56,HLDEV,?65,HLSTAT
"RTN","HLCSMON1",86,0)
 E  W ?16,HLREC,?26,HLPROC,?37,HLSEND,?47,HLSENT,?58,HLDEV,?63,HLSTAT
"RTN","HLCSMON1",87,0)
 ;
"RTN","HLCSMON1",88,0)
 Q
"RTN","HLCSMON1",89,0)
 ;
"RTN","HLCSMON1",90,0)
WDATA(DX,DY,IO1,IO2,HLDATA,HLENGTH) ;
"RTN","HLCSMON1",91,0)
 ;
"RTN","HLCSMON1",92,0)
 ;First erase the data block then write to it. Attributes are 
"RTN","HLCSMON1",93,0)
 ;contained in IO1 & IO2
"RTN","HLCSMON1",94,0)
 ;
"RTN","HLCSMON1",95,0)
 N X S X=0 X ^%ZOSF("RM") X ^%ZOSF("XY")
"RTN","HLCSMON1",96,0)
 ;Turn off terminal line wrap & inform O/S where cursor is located
"RTN","HLCSMON1",97,0)
 I '$D(HLENGTH) S HLENGTH=$L(HLDATA)
"RTN","HLCSMON1",98,0)
 X IOXY W IOSC,$E($J(" ",79),1,HLENGTH),IORC W IO1,$E(HLDATA,1,HLENGTH),IO2
"RTN","HLCSMON1",99,0)
 S X=IOM X ^%ZOSF("RM")
"RTN","HLCSMON1",100,0)
 ;Turn terminal line wrap back on
"RTN","HLCSMON1",101,0)
 Q
"RTN","HLCSTCP1")
0^14^B73827538^B73767277
"RTN","HLCSTCP1",1,0)
HLCSTCP1 ;SFIRMFO/RSD - BI-DIRECTIONAL TCP ;08/19/08  15:57
"RTN","HLCSTCP1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**19,43,57,64,71,133,132,122,140,142**;OCT 13,1995;Build 17
"RTN","HLCSTCP1",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLCSTCP1",4,0)
 ;Receiver
"RTN","HLCSTCP1",5,0)
 ;connection is initiated by sender and listener accepts connection
"RTN","HLCSTCP1",6,0)
 ;and calls this routine
"RTN","HLCSTCP1",7,0)
 ;
"RTN","HLCSTCP1",8,0)
 N $ETRAP,$ESTACK S $ETRAP="D ERROR^HLCSTCP1"
"RTN","HLCSTCP1",9,0)
 N HLMIEN,HLASTMSG
"RTN","HLCSTCP1",10,0)
 ;
"RTN","HLCSTCP1",11,0)
 ; patch HL*1.6*140, save IO
"RTN","HLCSTCP1",12,0)
 S HLTCPORT("IO")=IO ;RWF
"RTN","HLCSTCP1",13,0)
 ; patch HL*1.6*122 start
"RTN","HLCSTCP1",14,0)
 ; variable to replace ^TMP
"RTN","HLCSTCP1",15,0)
 N HLTMBUF
"RTN","HLCSTCP1",16,0)
 ;
"RTN","HLCSTCP1",17,0)
 ; for HL7 application proxy user
"RTN","HLCSTCP1",18,0)
 ;; N HLDUZ,DUZ  ; patch HL*1.6*122 TEST v2: DUZ code removed
"RTN","HLCSTCP1",19,0)
 N HLDUZ
"RTN","HLCSTCP1",20,0)
 S HLDUZ=+$G(DUZ)
"RTN","HLCSTCP1",21,0)
 ;
"RTN","HLCSTCP1",22,0)
 D MON^HLCSTCP("Open")
"RTN","HLCSTCP1",23,0)
 ; K ^TMP("HLCSTCP",$J,0)
"RTN","HLCSTCP1",24,0)
 S HLMIEN=0,HLASTMSG=""
"RTN","HLCSTCP1",25,0)
 ;
"RTN","HLCSTCP1",26,0)
 ; patch HL*1.6*122 TEST v2: DUZ code removed
"RTN","HLCSTCP1",27,0)
 ; set DUZ for application proxy user
"RTN","HLCSTCP1",28,0)
 ;; D PROXY^HLCSTCP4
"RTN","HLCSTCP1",29,0)
 ;
"RTN","HLCSTCP1",30,0)
 F  D  Q:$$STOP^HLCSTCP  I 'HLMIEN D MON^HLCSTCP("Idle") H 3
"RTN","HLCSTCP1",31,0)
 . ; clean variables
"RTN","HLCSTCP1",32,0)
 . D CLEANVAR^HLCSTCP4
"RTN","HLCSTCP1",33,0)
 . ; patch HL*1.6*140, restore the saved IO
"RTN","HLCSTCP1",34,0)
 . S IO=HLTCPORT("IO") ;RWF
"RTN","HLCSTCP1",35,0)
 . S HLMIEN=$$READ
"RTN","HLCSTCP1",36,0)
 . Q:'HLMIEN
"RTN","HLCSTCP1",37,0)
 . ;
"RTN","HLCSTCP1",38,0)
 . ; patch HL*1.6*122 TEST v2: DUZ code removed
"RTN","HLCSTCP1",39,0)
 . ; DUZ comparison/reset for application proxy user
"RTN","HLCSTCP1",40,0)
 . ;; D HLDUZ^HLCSTCP4
"RTN","HLCSTCP1",41,0)
 . D HLDUZ2^HLCSTCP4
"RTN","HLCSTCP1",42,0)
 . ; protect HLDUZ
"RTN","HLCSTCP1",43,0)
 . N HLDUZ
"RTN","HLCSTCP1",44,0)
 . D PROCESS
"RTN","HLCSTCP1",45,0)
 ; patch HL*1.6*122 end
"RTN","HLCSTCP1",46,0)
 Q
"RTN","HLCSTCP1",47,0)
 ;
"RTN","HLCSTCP1",48,0)
PROCESS ;check message and reply
"RTN","HLCSTCP1",49,0)
 ;HLDP=LL in 870
"RTN","HLCSTCP1",50,0)
 N HLTCP,HLTCPI,HLTCPO
"RTN","HLCSTCP1",51,0)
 S HLTCP="",HLTCPO=HLDP,HLTCPI=+HLMIEN
"RTN","HLCSTCP1",52,0)
 ;update monitor, msg. received
"RTN","HLCSTCP1",53,0)
 D LLCNT^HLCSTCP(HLDP,1)
"RTN","HLCSTCP1",54,0)
 D NEW^HLTP3(HLMIEN)
"RTN","HLCSTCP1",55,0)
 ;I IO'=HLTCPORT("IO") D ^%ZTER ;RWF
"RTN","HLCSTCP1",56,0)
 ;update monitor, msg. processed
"RTN","HLCSTCP1",57,0)
 D LLCNT^HLCSTCP(HLDP,2)
"RTN","HLCSTCP1",58,0)
 Q
"RTN","HLCSTCP1",59,0)
 ;
"RTN","HLCSTCP1",60,0)
READ() ;read 1 message, returns ien in 773^ien in 772 for message
"RTN","HLCSTCP1",61,0)
 D MON^HLCSTCP("Reading")
"RTN","HLCSTCP1",62,0)
 N HLDB,HLDT,HLDEND,HLACKWT,HLDSTRT,HLHDR,HLIND1,HLINE,HLMSG,HLRDOUT,HLRS,HLX,X
"RTN","HLCSTCP1",63,0)
 ;HLDSTRT=start char., HLDEND=end char., HLRS=record separator
"RTN","HLCSTCP1",64,0)
 S HLDSTRT=$C(11),HLDEND=$C(28),HLRS=$C(13)
"RTN","HLCSTCP1",65,0)
 ;HLRDOUT=exit read loop, HLINE=line count, HLIND1=ien 773^ien 772
"RTN","HLCSTCP1",66,0)
 ;HLHDR=have a header, HLTMBUF()=excess from last read, HLACKWT=wait for ack
"RTN","HLCSTCP1",67,0)
 ; HL*1.6*122 start
"RTN","HLCSTCP1",68,0)
 ; S (HLRDOUT,HLINE,HLIND1,HLHDR)=0,HLX=$G(^TMP("HLCSTCP",$J,0)),HLACKWT=HLDBACK
"RTN","HLCSTCP1",69,0)
 S (HLRDOUT,HLINE,HLIND1,HLHDR)=0,HLX=$G(HLTMBUF(0)),HLACKWT=HLDBACK
"RTN","HLCSTCP1",70,0)
 N HLBUFF,HLXX,MAXWAIT
"RTN","HLCSTCP1",71,0)
 ; based on patch 132 for readtime
"RTN","HLCSTCP1",72,0)
 S MAXWAIT=$S((HLACKWT>HLDREAD):HLACKWT,1:HLDREAD)
"RTN","HLCSTCP1",73,0)
 S HLRS("START-FLAG")=0
"RTN","HLCSTCP1",74,0)
 S HLTMBUF(0)=""
"RTN","HLCSTCP1",75,0)
 ; variable used to store data in HLBUFF
"RTN","HLCSTCP1",76,0)
 S HLX(1)=$G(HLTMBUF(1))
"RTN","HLCSTCP1",77,0)
 S HLTMBUF(1)=""
"RTN","HLCSTCP1",78,0)
 S HLBUFF("START")=0
"RTN","HLCSTCP1",79,0)
 S HLBUFF("END")=0
"RTN","HLCSTCP1",80,0)
 I (HLX]"")!(HLX(1)]"") D
"RTN","HLCSTCP1",81,0)
 . I (HLX[HLDSTRT)!(HLX(1)[HLDSTRT) D
"RTN","HLCSTCP1",82,0)
 .. S HLBUFF("START")=1
"RTN","HLCSTCP1",83,0)
 . I (HLX[HLDEND)!(HLX(1)[HLDEND) D
"RTN","HLCSTCP1",84,0)
 .. S HLBUFF("END")=1
"RTN","HLCSTCP1",85,0)
 F  D RDBLK Q:HLRDOUT
"RTN","HLCSTCP1",86,0)
 ;**132**
"RTN","HLCSTCP1",87,0)
 ;switch to null device if opened to prevent 'leakage'
"RTN","HLCSTCP1",88,0)
 I $G(IO(0))]"",IO(0)'=IO U IO(0)
"RTN","HLCSTCP1",89,0)
 ;
"RTN","HLCSTCP1",90,0)
 ;save any excess for next time
"RTN","HLCSTCP1",91,0)
 S:HLX]"" HLTMBUF(0)=HLX
"RTN","HLCSTCP1",92,0)
 S:HLX(1)]"" HLTMBUF(1)=HLX(1)
"RTN","HLCSTCP1",93,0)
 I +HLIND1,'$P(HLIND1,U,3) D DELMSG(HLIND1) S HLIND1=0
"RTN","HLCSTCP1",94,0)
 Q HLIND1
"RTN","HLCSTCP1",95,0)
 ;
"RTN","HLCSTCP1",96,0)
RDBLK ;
"RTN","HLCSTCP1",97,0)
 ; initialize
"RTN","HLCSTCP1",98,0)
 S HLBUFF=""
"RTN","HLCSTCP1",99,0)
 ;
"RTN","HLCSTCP1",100,0)
 ;S HLDB=HLDBSIZE-$L(HLX)
"RTN","HLCSTCP1",101,0)
 ; store the total length of HLX and HLX(1) in HLDB(1)
"RTN","HLCSTCP1",102,0)
 S HLDB(1)=$L(HLX)+$L(HLX(1))
"RTN","HLCSTCP1",103,0)
 ;
"RTN","HLCSTCP1",104,0)
 ;**132 **
"RTN","HLCSTCP1",105,0)
 ;U IO R X#HLDB:HLDREAD
"RTN","HLCSTCP1",106,0)
 ; U IO R X#HLDB:MAXWAIT
"RTN","HLCSTCP1",107,0)
 ;
"RTN","HLCSTCP1",108,0)
 ; remove the readcount to speedup GT.M
"RTN","HLCSTCP1",109,0)
 U IO
"RTN","HLCSTCP1",110,0)
 R:(HLDB(1)<HLDBSIZE) HLBUFF:MAXWAIT
"RTN","HLCSTCP1",111,0)
 ;
"RTN","HLCSTCP1",112,0)
 I HLBUFF]"" D
"RTN","HLCSTCP1",113,0)
 . I HLBUFF[HLDSTRT,(HLBUFF("START")=0) D
"RTN","HLCSTCP1",114,0)
 .. ; remove the extraneous text prefixing the "START" char
"RTN","HLCSTCP1",115,0)
 .. I $P(HLBUFF,HLDSTRT)]"" S HLBUFF=HLDSTRT_$P(HLBUFF,HLDSTRT,2,99)
"RTN","HLCSTCP1",116,0)
 .. S HLBUFF("START")=1
"RTN","HLCSTCP1",117,0)
 . ;
"RTN","HLCSTCP1",118,0)
 . I HLBUFF[HLDEND,(HLBUFF("END")=0) S HLBUFF("END")=1
"RTN","HLCSTCP1",119,0)
 ; detect disconnect for GT.M
"RTN","HLCSTCP1",120,0)
 I $G(^%ZOSF("OS"))["GT.M",$DEVICE S $ECODE=",UREAD,"
"RTN","HLCSTCP1",121,0)
 ; timedout, <clean up>, quit
"RTN","HLCSTCP1",122,0)
 ;I '$T,X="",HLX="" S HLACKWT=HLACKWT-HLDREAD D:HLACKWT<0&'HLHDR CLEAN Q
"RTN","HLCSTCP1",123,0)
 ;I '$T,X="",HLX="" D:'HLHDR CLEAN Q
"RTN","HLCSTCP1",124,0)
 ; patch HL*1.6*140
"RTN","HLCSTCP1",125,0)
 ; I '$T,HLBUFF="",HLX="",HLX(1)="" D  Q
"RTN","HLCSTCP1",126,0)
 I HLBUFF="",HLX="",HLX(1)="" D  Q
"RTN","HLCSTCP1",127,0)
 . D:('HLHDR)&('HLIND1) CLEAN
"RTN","HLCSTCP1",128,0)
 ;add incoming line to what wasn't processed in last read
"RTN","HLCSTCP1",129,0)
 ;S HLX=$G(HLX)_X
"RTN","HLCSTCP1",130,0)
 ; get block of characters from read buffer HLBUFF
"RTN","HLCSTCP1",131,0)
 ; every 'for-loop' deal with one read at most, and one message at most
"RTN","HLCSTCP1",132,0)
 ; if HLX is not empty, loop continues even no data is read
"RTN","HLCSTCP1",133,0)
 ; quit, if both HLDBUFF and HLX(1) are empty, means one read is done
"RTN","HLCSTCP1",134,0)
 ; quit, when HLRDOUT is set to 1, means one message is encountered
"RTN","HLCSTCP1",135,0)
 ; an "end"
"RTN","HLCSTCP1",136,0)
 ; F  D  Q:HLXX=""!(HLRDOUT)
"RTN","HLCSTCP1",137,0)
 F  D  Q:(HLRDOUT)!(HLBUFF=""&(HLX(1)=""))
"RTN","HLCSTCP1",138,0)
 . ;
"RTN","HLCSTCP1",139,0)
 . ; if HLX(1) is not empty
"RTN","HLCSTCP1",140,0)
 . I HLX(1)]"" D
"RTN","HLCSTCP1",141,0)
 .. ; hldb(2) is the number of characters extracted from hlx(1)
"RTN","HLCSTCP1",142,0)
 .. ; to be concatenated with hlx
"RTN","HLCSTCP1",143,0)
 .. S HLDB(2)=HLDBSIZE-$L(HLX)
"RTN","HLCSTCP1",144,0)
 .. ; hlx(2) stores the first hldb(2) characters extracted
"RTN","HLCSTCP1",145,0)
 .. ; from hlx(1)
"RTN","HLCSTCP1",146,0)
 .. S HLX(2)=$E(HLX(1),1,HLDB(2))
"RTN","HLCSTCP1",147,0)
 .. S HLX(1)=$E(HLX(1),HLDB(2)+1,$L(HLX(1)))
"RTN","HLCSTCP1",148,0)
 .. S HLX=$G(HLX)_HLX(2)
"RTN","HLCSTCP1",149,0)
 . ;
"RTN","HLCSTCP1",150,0)
 . ; if HLX(1) is empty, and HLBUFF contains data
"RTN","HLCSTCP1",151,0)
 . ; all the data in hlx(1) need to be extracted first
"RTN","HLCSTCP1",152,0)
 . I HLX(1)="",HLBUFF]"" D
"RTN","HLCSTCP1",153,0)
 .. S HLDB=HLDBSIZE-$L(HLX)
"RTN","HLCSTCP1",154,0)
 .. S HLXX=$E(HLBUFF,1,HLDB)
"RTN","HLCSTCP1",155,0)
 .. S HLBUFF=$E(HLBUFF,HLDB+1,$L(HLBUFF))
"RTN","HLCSTCP1",156,0)
 .. S HLX=$G(HLX)_HLXX
"RTN","HLCSTCP1",157,0)
 . ; quit when HLX is empty
"RTN","HLCSTCP1",158,0)
 . Q:(HLX="")
"RTN","HLCSTCP1",159,0)
 . ; ** 132 **
"RTN","HLCSTCP1",160,0)
 . ; if no segment end, HLX not full, go back for more
"RTN","HLCSTCP1",161,0)
 . I $L(HLX)<HLDBSIZE,HLX'[HLRS,HLX'[HLDEND Q
"RTN","HLCSTCP1",162,0)
 . ;add incoming line to what wasn't processed
"RTN","HLCSTCP1",163,0)
 . D RDBLK2
"RTN","HLCSTCP1",164,0)
 ;
"RTN","HLCSTCP1",165,0)
 ; it is possible one message is encountered an "end" and other
"RTN","HLCSTCP1",166,0)
 ; messages left in buffer,HLBUFF, save it in HLX for next run
"RTN","HLCSTCP1",167,0)
 I HLBUFF]"" D
"RTN","HLCSTCP1",168,0)
 . ; variable HLBUFF may remain data with size more than HLDBSIZE
"RTN","HLCSTCP1",169,0)
 . ; variable HLBUFF is not empty, only if the total length of
"RTN","HLCSTCP1",170,0)
 . ; HLX and HLX(1) is less than HLDBSIZE and HLX(1) should be
"RTN","HLCSTCP1",171,0)
 . ; empty when the command s hlx(1)=$g(hlx(1))_hlbuff is executed
"RTN","HLCSTCP1",172,0)
 . ; use hlx(1) to store the data of hlbuff to avoid "MAXTRING" error
"RTN","HLCSTCP1",173,0)
 . S HLX(1)=$G(HLX(1))_HLBUFF
"RTN","HLCSTCP1",174,0)
 . S HLBUFF=""
"RTN","HLCSTCP1",175,0)
 Q
"RTN","HLCSTCP1",176,0)
 ;
"RTN","HLCSTCP1",177,0)
RDBLK2 ;data stream: <sb>dddd<cr><eb><cr>
"RTN","HLCSTCP1",178,0)
 ; HL*1.6*122 end
"RTN","HLCSTCP1",179,0)
 ; look for segment= <CR>
"RTN","HLCSTCP1",180,0)
 F  Q:HLX'[HLRS  D  Q:HLRDOUT
"RTN","HLCSTCP1",181,0)
 . ; Get the first piece, save the rest of the line
"RTN","HLCSTCP1",182,0)
 . S HLINE=HLINE+1,HLMSG(HLINE,0)=$P(HLX,HLRS),HLX=$P(HLX,HLRS,2,999)
"RTN","HLCSTCP1",183,0)
 . ; check for start block, Quit if no ien
"RTN","HLCSTCP1",184,0)
 . I HLMSG(HLINE,0)[HLDSTRT!HLHDR D  Q
"RTN","HLCSTCP1",185,0)
 .. S HLRS("START-FLAG")=1 ; HL*1.6*122
"RTN","HLCSTCP1",186,0)
 .. D:HLMSG(HLINE,0)[HLDSTRT
"RTN","HLCSTCP1",187,0)
 ... S X=$L(HLMSG(HLINE,0),HLDSTRT)
"RTN","HLCSTCP1",188,0)
 ... S:X>2 HLMSG(HLINE,0)=HLDSTRT_$P(HLMSG(HLINE,0),HLDSTRT,X)
"RTN","HLCSTCP1",189,0)
 ... S HLMSG(HLINE,0)=$P(HLMSG(HLINE,0),HLDSTRT,2)
"RTN","HLCSTCP1",190,0)
 ... D RESET:(HLINE>1)
"RTN","HLCSTCP1",191,0)
 .. ;
"RTN","HLCSTCP1",192,0)
 .. ; patch HL*1.6*122
"RTN","HLCSTCP1",193,0)
 .. ; if the first line less than 10 characters
"RTN","HLCSTCP1",194,0)
 .. I HLHDR,$L(HLMSG(1,0))<10,$D(HLMSG(2,0)) D
"RTN","HLCSTCP1",195,0)
 ... S HLMSG(1,0)=HLMSG(1,0)_$E(HLMSG(2,0),1,10)
"RTN","HLCSTCP1",196,0)
 ... S HLMSG(2,0)=$E(HLMSG(2,0),11,9999999)
"RTN","HLCSTCP1",197,0)
 .. ;
"RTN","HLCSTCP1",198,0)
 .. ;ping message
"RTN","HLCSTCP1",199,0)
 .. I $E(HLMSG(1,0),1,9)="MSH^PING^" D PING Q
"RTN","HLCSTCP1",200,0)
 .. ; get next ien to store
"RTN","HLCSTCP1",201,0)
 .. D MIEN^HLCSTCP4
"RTN","HLCSTCP1",202,0)
 .. K HLMSG
"RTN","HLCSTCP1",203,0)
 .. S (HLINE,HLHDR)=0
"RTN","HLCSTCP1",204,0)
 . ; check for end block; <eb><cr>
"RTN","HLCSTCP1",205,0)
 . I HLMSG(HLINE,0)[HLDEND D
"RTN","HLCSTCP1",206,0)
 .. ; patch HL*1.6*122 start
"RTN","HLCSTCP1",207,0)
 .. ;no msg. ien
"RTN","HLCSTCP1",208,0)
 .. ; Q:'HLIND1
"RTN","HLCSTCP1",209,0)
 .. I 'HLIND1 D CLEAN Q
"RTN","HLCSTCP1",210,0)
 .. ; Kill just the last line if no data before HLDEND
"RTN","HLCSTCP1",211,0)
 .. I $P(HLMSG(HLINE,0),HLDEND)']"" D
"RTN","HLCSTCP1",212,0)
 ... K HLMSG(HLINE,0) S HLINE=HLINE-1
"RTN","HLCSTCP1",213,0)
 .. E  S HLMSG(HLINE,0)=$P(HLMSG(HLINE,0),HLDEND)
"RTN","HLCSTCP1",214,0)
 .. ; patch HL*1.6*122 end
"RTN","HLCSTCP1",215,0)
 .. ;
"RTN","HLCSTCP1",216,0)
 .. ; move into 772
"RTN","HLCSTCP1",217,0)
 .. D SAVE(.HLMSG,"^HL(772,"_+$P(HLIND1,U,2)_",""IN"")")
"RTN","HLCSTCP1",218,0)
 .. ;mark that end block has been received
"RTN","HLCSTCP1",219,0)
 .. ;HLIND1=ien in 773^ien in 772^1 if end block was received
"RTN","HLCSTCP1",220,0)
 .. S $P(HLIND1,U,3)=1
"RTN","HLCSTCP1",221,0)
 .. S HLBUFF("HLIND1")=HLIND1
"RTN","HLCSTCP1",222,0)
 .. ;reset variables for next message
"RTN","HLCSTCP1",223,0)
 .. D CLEAN
"RTN","HLCSTCP1",224,0)
 . ;add blank line for carriage return
"RTN","HLCSTCP1",225,0)
 . I HLINE'=0,HLMSG(HLINE,0)]"" S HLINE=HLINE+1,HLMSG(HLINE,0)=""
"RTN","HLCSTCP1",226,0)
 Q:HLRDOUT
"RTN","HLCSTCP1",227,0)
 ;If the line is long and no <CR> move it into the array.
"RTN","HLCSTCP1",228,0)
 I ($L(HLX)=HLDBSIZE),(HLX'[HLRS),(HLX'[HLDEND),(HLX'[HLDSTRT) D  Q
"RTN","HLCSTCP1",229,0)
 . S HLINE=HLINE+1,HLMSG(HLINE,0)=HLX,HLX=""
"RTN","HLCSTCP1",230,0)
 ;have start block but no record separator
"RTN","HLCSTCP1",231,0)
 I HLX[HLDSTRT D  Q
"RTN","HLCSTCP1",232,0)
 . ;check for more than 1 start block
"RTN","HLCSTCP1",233,0)
 . S X=$L(HLX,HLDSTRT) S:X>2 HLX=HLDSTRT_$P(HLX,HLDSTRT,X)
"RTN","HLCSTCP1",234,0)
 . ;
"RTN","HLCSTCP1",235,0)
 . ; patch HL*1.6*122
"RTN","HLCSTCP1",236,0)
 . ; S:$L($P(HLX,HLDSTRT,2))>8 HLINE=HLINE+1,HLMSG(HLINE,0)=$P(HLX,HLDSTRT,2),HLX="",HLHDR=1
"RTN","HLCSTCP1",237,0)
 . S HLINE=HLINE+1,HLMSG(HLINE,0)=$P(HLX,HLDSTRT,2),HLX="",HLHDR=1
"RTN","HLCSTCP1",238,0)
 . ;
"RTN","HLCSTCP1",239,0)
 . D RESET:(HLHDR&(HLINE>1))
"RTN","HLCSTCP1",240,0)
 ;if no ien, reset
"RTN","HLCSTCP1",241,0)
 ; patch HL*1.6*122
"RTN","HLCSTCP1",242,0)
 ; I 'HLIND1 D CLEAN Q
"RTN","HLCSTCP1",243,0)
 I (HLRS("START-FLAG")=1),'HLIND1 D CLEAN Q
"RTN","HLCSTCP1",244,0)
 ; big message-merge from local to global every 100 lines
"RTN","HLCSTCP1",245,0)
 I (HLINE-$O(HLMSG(0)))>100 D
"RTN","HLCSTCP1",246,0)
 . M ^HL(772,+$P(HLIND1,U,2),"IN")=HLMSG
"RTN","HLCSTCP1",247,0)
 . ; reset working array
"RTN","HLCSTCP1",248,0)
 . K HLMSG
"RTN","HLCSTCP1",249,0)
 Q
"RTN","HLCSTCP1",250,0)
 ;
"RTN","HLCSTCP1",251,0)
SAVE(SRC,DEST) ;save into global & set top node
"RTN","HLCSTCP1",252,0)
 ;SRC=source array (passed by ref.), DEST=destination global
"RTN","HLCSTCP1",253,0)
 ;
"RTN","HLCSTCP1",254,0)
 ; patch HL*1.6*122: MPI-client/server
"RTN","HLCSTCP1",255,0)
 I DEST["HLMA" D
"RTN","HLCSTCP1",256,0)
 . F  L +^HLMA(+HLIND1):10 Q:$T  H 1
"RTN","HLCSTCP1",257,0)
 E  D
"RTN","HLCSTCP1",258,0)
 . F  L +^HL(772,+$P(HLIND1,U,2)):10 Q:$T  H 1
"RTN","HLCSTCP1",259,0)
 ;
"RTN","HLCSTCP1",260,0)
 M @DEST=SRC
"RTN","HLCSTCP1",261,0)
 S @DEST@(0)="^^"_HLINE_"^"_HLINE_"^"_DT_"^"
"RTN","HLCSTCP1",262,0)
 ;
"RTN","HLCSTCP1",263,0)
 I DEST["HLMA" L -^HLMA(+HLIND1)
"RTN","HLCSTCP1",264,0)
 E  L -^HL(772,+$P(HLIND1,U,2))
"RTN","HLCSTCP1",265,0)
 ;
"RTN","HLCSTCP1",266,0)
 Q
"RTN","HLCSTCP1",267,0)
 ;
"RTN","HLCSTCP1",268,0)
DELMSG(HLMAMT) ;delete message from Message Administration/Message Text files.
"RTN","HLCSTCP1",269,0)
 N DIK,DA
"RTN","HLCSTCP1",270,0)
 S DA=+HLMAMT,DIK="^HLMA("
"RTN","HLCSTCP1",271,0)
 D ^DIK
"RTN","HLCSTCP1",272,0)
 S DA=$P(HLMAMT,U,2),DIK="^HL(772,"
"RTN","HLCSTCP1",273,0)
 D ^DIK
"RTN","HLCSTCP1",274,0)
 Q
"RTN","HLCSTCP1",275,0)
PING ;process PING message
"RTN","HLCSTCP1",276,0)
 S X=HLMSG(1,0)
"RTN","HLCSTCP1",277,0)
 ; patch HL*1.6*140, flush character- HLTCPLNK("IOF")
"RTN","HLCSTCP1",278,0)
 ; I X[HLDEND U IO W X,! D
"RTN","HLCSTCP1",279,0)
 ; I X[HLDEND U IO W X,HLTCPLNK("IOF") D
"RTN","HLCSTCP1",280,0)
 ; patch HL*1.6*142
"RTN","HLCSTCP1",281,0)
 I X[HLDEND U IO W X,@HLTCPLNK("IOF") D
"RTN","HLCSTCP1",282,0)
 . ; switch to null device if opened to prevent 'leakage'
"RTN","HLCSTCP1",283,0)
 . I $G(IO(0))]"",$G(IO(0))'=IO U IO(0)
"RTN","HLCSTCP1",284,0)
CLEAN ;reset var. for next message
"RTN","HLCSTCP1",285,0)
 K HLMSG
"RTN","HLCSTCP1",286,0)
 S HLINE=0,HLRDOUT=1
"RTN","HLCSTCP1",287,0)
 Q
"RTN","HLCSTCP1",288,0)
 ;
"RTN","HLCSTCP1",289,0)
ERROR ; Error trap for disconnect error and return back to the read loop.
"RTN","HLCSTCP1",290,0)
 ; patch HL*1.6*122
"RTN","HLCSTCP1",291,0)
 ; move to routine HLCSTCP4 (splitted-size over 10000)
"RTN","HLCSTCP1",292,0)
 D ERROR1^HLCSTCP4
"RTN","HLCSTCP1",293,0)
 Q
"RTN","HLCSTCP1",294,0)
 ;
"RTN","HLCSTCP1",295,0)
CC(X) ;cleanup and close
"RTN","HLCSTCP1",296,0)
 D MON^HLCSTCP(X)
"RTN","HLCSTCP1",297,0)
 H 2
"RTN","HLCSTCP1",298,0)
 Q
"RTN","HLCSTCP1",299,0)
RESET ;reset info as a result of no end block
"RTN","HLCSTCP1",300,0)
 N %
"RTN","HLCSTCP1",301,0)
 S HLMSG(1,0)=HLMSG(HLINE,0)
"RTN","HLCSTCP1",302,0)
 F %=2:1:HLINE K HLMSG(%,0)
"RTN","HLCSTCP1",303,0)
 S HLINE=1
"RTN","HLCSTCP1",304,0)
 Q
"RTN","HLCSTCP2")
0^12^B83786254^B70352129
"RTN","HLCSTCP2",1,0)
HLCSTCP2 ;SFIRMFO/RSD - BI-DIRECTIONAL TCP ;10/31/2008 09:18
"RTN","HLCSTCP2",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**19,43,49,57,63,64,66,67,76,77,87,109,133,122,140,142**;Oct 13,1995;Build 17
"RTN","HLCSTCP2",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLCSTCP2",4,0)
 ;Sender 
"RTN","HLCSTCP2",5,0)
 ;Request connection, send outbound message(s) delimited by MLLP
"RTN","HLCSTCP2",6,0)
 ;Input : HLDP=Logical Link to use
"RTN","HLCSTCP2",7,0)
 ; Set up error trap
"RTN","HLCSTCP2",8,0)
 N $ETRAP,$ESTACK S $ETRAP="D ERROR^HLCSTCP2"
"RTN","HLCSTCP2",9,0)
 N HLMSG,HLPORT,HLRETRY,HLRETMG,HLTCPO,POP
"RTN","HLCSTCP2",10,0)
 ;HLRETRY=number of retranmission for this link,HLRETMG=alert sent
"RTN","HLCSTCP2",11,0)
 S HLTCPO=HLDP,HLMSG="",(HLRETRY,HLRETMG)=0
"RTN","HLCSTCP2",12,0)
 ;
"RTN","HLCSTCP2",13,0)
 ; patch 122
"RTN","HLCSTCP2",14,0)
 ; patch 133
"RTN","HLCSTCP2",15,0)
 ; set IO(0) to the null device
"RTN","HLCSTCP2",16,0)
 I $G(^%ZOSF("OS"))]"",^%ZOSF("OS")'["GT.M" D
"RTN","HLCSTCP2",17,0)
 . S IO(0)=$S(^%ZOSF("OS")["OpenM":$S($$OS^%ZOSV()["VMS":"_NLA0:",$$OS^%ZOSV()["UNIX":"/dev/null",1:$P),^%ZOSF("OS")["DSM":"_NLA0:",1:$P)
"RTN","HLCSTCP2",18,0)
 . O IO(0) U IO(0)
"RTN","HLCSTCP2",19,0)
 ;
"RTN","HLCSTCP2",20,0)
 ;persistent conection, open connection first, HLPORT=open port
"RTN","HLCSTCP2",21,0)
 I $G(HLTCPLNK)["Y" F  Q:$$OPEN  G EXIT:$$STOP^HLCSTCP H 1
"RTN","HLCSTCP2",22,0)
 F  D QUE Q:$$STOP^HLCSTCP  D:'HLMSG  Q:$G(HLCSOUT)
"RTN","HLCSTCP2",23,0)
 . ;no messages to send
"RTN","HLCSTCP2",24,0)
 . D MON^HLCSTCP("Idle") H 3
"RTN","HLCSTCP2",25,0)
 . ;persistent connection, no retention
"RTN","HLCSTCP2",26,0)
 . Q:$G(HLTCPLNK)["Y"
"RTN","HLCSTCP2",27,0)
 . D MON^HLCSTCP("Retention")
"RTN","HLCSTCP2",28,0)
 . N % I 0
"RTN","HLCSTCP2",29,0)
 . ;if message comes in or ask to stop
"RTN","HLCSTCP2",30,0)
 . F %=1:1:HLTCPRET H 1 I $$STOP^HLCSTCP!$O(^HLMA("AC","O",HLDP,0)) Q
"RTN","HLCSTCP2",31,0)
 . E  S HLCSOUT=2 Q
"RTN","HLCSTCP2",32,0)
 . Q:$$STOP^HLCSTCP
"RTN","HLCSTCP2",33,0)
 . D MON^HLCSTCP("Idle")
"RTN","HLCSTCP2",34,0)
 ;Close port
"RTN","HLCSTCP2",35,0)
 I $D(HLPORT) D CLOSE^%ZISTCP K HLPORT
"RTN","HLCSTCP2",36,0)
EXIT Q
"RTN","HLCSTCP2",37,0)
 ;
"RTN","HLCSTCP2",38,0)
QUE ; -- Check "OUT" queue for processing IF there is a message do it
"RTN","HLCSTCP2",39,0)
 ; and then check the link if it open or not
"RTN","HLCSTCP2",40,0)
 N HL,HLN,HLARR,HLHDR,HLI,HLJ,HLMSA,HLRESP,HLRESLT,HLRETRM,HLTCP,HLTCPI,X,Z,HLREREAD
"RTN","HLCSTCP2",41,0)
 N HLTMBUF
"RTN","HLCSTCP2",42,0)
 D MON^HLCSTCP("CheckOut")
"RTN","HLCSTCP2",43,0)
 ;HLMSG=next msg, set at tag DONE
"RTN","HLCSTCP2",44,0)
 I 'HLMSG S HLMSG=+$O(^HLMA("AC","O",HLDP,0)),HLRETRY=0 Q:'HLMSG
"RTN","HLCSTCP2",45,0)
 ;
"RTN","HLCSTCP2",46,0)
 S HLI=+$G(^HLMA(HLMSG,0)),HLJ=$O(^("MSH",0)),HLTCP=""
"RTN","HLCSTCP2",47,0)
 ;don't have message text or MSH, kill x-ref and decrement 'to send'
"RTN","HLCSTCP2",48,0)
 ;
"RTN","HLCSTCP2",49,0)
 ; patch HL*1.6*122: MPI-client/server
"RTN","HLCSTCP2",50,0)
 ; I 'HLI!'HLJ K ^HLMA("AC","O",HLDP,HLMSG) D LLCNT^HLCSTCP(HLDP,3,1) S HLMSG=0 Q
"RTN","HLCSTCP2",51,0)
 I 'HLI!'HLJ D  Q
"RTN","HLCSTCP2",52,0)
 . F  L +^HLMA("AC","O",HLDP,HLMSG):10 Q:$T  H 1
"RTN","HLCSTCP2",53,0)
 . K ^HLMA("AC","O",HLDP,HLMSG)
"RTN","HLCSTCP2",54,0)
 . L -^HLMA("AC","O",HLDP,HLMSG)
"RTN","HLCSTCP2",55,0)
 . D LLCNT^HLCSTCP(HLDP,3,1)
"RTN","HLCSTCP2",56,0)
 . S HLMSG=0
"RTN","HLCSTCP2",57,0)
 ;
"RTN","HLCSTCP2",58,0)
 ; patch HL*1.6*142 start
"RTN","HLCSTCP2",59,0)
 ; to prevent data contention of end-user from competing with the link
"RTN","HLCSTCP2",60,0)
 ; processes sending data to backup workstations (for BCBU application)
"RTN","HLCSTCP2",61,0)
 I ($P(^HLMA(HLMSG,0),4)="D"),'$P($G(^HL(772,HLI,"P")),"^",2) D
"RTN","HLCSTCP2",62,0)
 . N COUNT
"RTN","HLCSTCP2",63,0)
 . F COUNT=1:1:15 Q:$P($G(^HL(772,HLI,"P")),"^",2)  H COUNT
"RTN","HLCSTCP2",64,0)
 ; patch HL*1.6*142 end
"RTN","HLCSTCP2",65,0)
 ;
"RTN","HLCSTCP2",66,0)
 ;update msg status to 'being transmitted'; if cancelled decrement link and quit
"RTN","HLCSTCP2",67,0)
 I '$$CHKMSG(1.5) D LLCNT^HLCSTCP(HLDP,3,1) S HLMSG=0 Q
"RTN","HLCSTCP2",68,0)
 ;number of retransmissions for message
"RTN","HLCSTCP2",69,0)
 S HLRETRM=+$P(^HLMA(HLMSG,"P"),U,5)
"RTN","HLCSTCP2",70,0)
 ;retries exceeded, HLRETRA:action i=ignore, r=restart, s=shutdown
"RTN","HLCSTCP2",71,0)
 ;quit if restart or shutdown, link is going down
"RTN","HLCSTCP2",72,0)
 I HLRETRY>HLDRETR D  Q:"I"'[HLRETRA
"RTN","HLCSTCP2",73,0)
 . D MON^HLCSTCP("Error")
"RTN","HLCSTCP2",74,0)
 . ;only 1 alert per link up time, don't send if restart
"RTN","HLCSTCP2",75,0)
 . D:'HLRETMG&(HLRETRA'="R")
"RTN","HLCSTCP2",76,0)
 .. ;send alert
"RTN","HLCSTCP2",77,0)
 .. N XQA,XQAMSG,XQAOPT,XQAROU,XQAID,Z
"RTN","HLCSTCP2",78,0)
 .. ;get mailgroup from file 869.3
"RTN","HLCSTCP2",79,0)
 .. S HLRETMG=1,Z=$P($$PARAM^HLCS2,U,8) Q:Z=""
"RTN","HLCSTCP2",80,0)
 .. S XQA("G."_Z)="",XQAMSG=$$HTE^XLFDT($H,2)_" HL7 LL "_$P(^HLCS(870,HLDP,0),U)_" exceeded retries. LL will "_$S(HLRETRA="S":"shutdown.",HLRETRA="R":"restart.",1:"keep trying.")
"RTN","HLCSTCP2",81,0)
 .. D SETUP^XQALERT
"RTN","HLCSTCP2",82,0)
 . ;quit if action is ignore
"RTN","HLCSTCP2",83,0)
 . Q:"I"[HLRETRA
"RTN","HLCSTCP2",84,0)
 . ;this will shutdown this link
"RTN","HLCSTCP2",85,0)
 . S HLCSOUT=1
"RTN","HLCSTCP2",86,0)
 . ;action is shutdown, set shutdown flag so LM won't restart
"RTN","HLCSTCP2",87,0)
 . S:HLRETRA="S" $P(^HLCS(870,HLDP,0),U,15)=1
"RTN","HLCSTCP2",88,0)
 . D STATUS^HLTF0(HLMSG,4,103,"LLP Exceeded Retry Param")
"RTN","HLCSTCP2",89,0)
 I '$$OPEN Q
"RTN","HLCSTCP2",90,0)
 D MON^HLCSTCP("Send")
"RTN","HLCSTCP2",91,0)
 ; -- data passed in global array, success=1
"RTN","HLCSTCP2",92,0)
 ; patch HL*1.6*142
"RTN","HLCSTCP2",93,0)
 ; time: starts to send this message
"RTN","HLCSTCP2",94,0)
 S $P(^HLMA(HLMSG,"S"),"^",2)=$$NOW^XLFDT
"RTN","HLCSTCP2",95,0)
 I $$WRITE(HLMSG)<0 Q
"RTN","HLCSTCP2",96,0)
 ; patch HL*1.6*142
"RTN","HLCSTCP2",97,0)
 ; time: this message has been sent
"RTN","HLCSTCP2",98,0)
 S $P(^HLMA(HLMSG,"S"),"^",3)=$$NOW^XLFDT
"RTN","HLCSTCP2",99,0)
 S (HLTCP,HLTCPI)=HLMSG,HLRETRY=HLRETRY+1,HLRETRM=HLRETRM+1
"RTN","HLCSTCP2",100,0)
 ;update status to awaiting response, decrement link if cancelled
"RTN","HLCSTCP2",101,0)
 I '$$CHKMSG(1.7) D LLCNT^HLCSTCP(HLDP,3,1) S HLMSG=0 Q
"RTN","HLCSTCP2",102,0)
 ;set transmission count, get ACKTIMEOUT override
"RTN","HLCSTCP2",103,0)
 S $P(^HLMA(HLMSG,"P"),U,5)=HLRETRM I $P(^("P"),U,7) S HLN("ACKTIME")=+$P(^("P"),U,7)
"RTN","HLCSTCP2",104,0)
 ;get header of message just sent
"RTN","HLCSTCP2",105,0)
 K HLJ M HLJ=^HLMA(HLMSG,"MSH")
"RTN","HLCSTCP2",106,0)
 ;first component of sending app.
"RTN","HLCSTCP2",107,0)
 S HLN("ECH")=$$P^HLTPCK2(.HLJ,2),HLN("SAN")=$P($$P^HLTPCK2(.HLJ,3),$E(HLN("ECH")))
"RTN","HLCSTCP2",108,0)
 ;msg type, msg. id, commit ack, and app. ack parameter
"RTN","HLCSTCP2",109,0)
 S HLN("TYPE")=$$P^HLTPCK2(.HLJ,1),HLN("MID")=$$P^HLTPCK2(.HLJ,10),HLN("ACAT")=$$P^HLTPCK2(.HLJ,15),HLN("APAT")=$$P^HLTPCK2(.HLJ,16)
"RTN","HLCSTCP2",110,0)
 ;MSA segment, message is a response, can't have an a. ack.
"RTN","HLCSTCP2",111,0)
 S Z=$$MSA^HLTP3(+^HLMA(HLMSG,0)) I Z]"" S:HLN("ACAT")="" HLN("ACAT")="NE" S HLN("APAT")="NE"
"RTN","HLCSTCP2",112,0)
 ;for batch/file with commit ack, reset c. ack and a. ack variables
"RTN","HLCSTCP2",113,0)
 I "BHS,FHS"[HLN("TYPE") S Z=$E(HLJ(1,0),5),X=$$P^HLTPCK2(.HLJ,9),HLN("ACAT")=$P(X,Z,5),HLN("APAT")=$P(X,Z,6),HLN("MID")=$$P^HLTPCK2(.HLJ,11)
"RTN","HLCSTCP2",114,0)
 ;get event protocol
"RTN","HLCSTCP2",115,0)
 S HLN("EID")=+$P(^HLMA(HLMSG,0),U,8),X=$G(^ORD(101,HLN("EID"),770))
"RTN","HLCSTCP2",116,0)
 ;set link counter to msg sent
"RTN","HLCSTCP2",117,0)
 D LLCNT^HLCSTCP(HLDP,4)
"RTN","HLCSTCP2",118,0)
 ;commit and app. ack is never, update status to complete and hang UNI-DIRECTIONAL WAIT
"RTN","HLCSTCP2",119,0)
 I HLN("ACAT")="NE",HLN("APAT")="NE" D  Q
"RTN","HLCSTCP2",120,0)
 .D DONE(3)
"RTN","HLCSTCP2",121,0)
 .;
"RTN","HLCSTCP2",122,0)
 .;
"RTN","HLCSTCP2",123,0)
 .H $G(HLDWAIT)
"RTN","HLCSTCP2",124,0)
 ;
"RTN","HLCSTCP2",125,0)
 ;do structure is to stack error
"RTN","HLCSTCP2",126,0)
 D
"RTN","HLCSTCP2",127,0)
 . N $ETRAP,$ESTACK S $ETRAP="D RDERR^HLCSTCP2"
"RTN","HLCSTCP2",128,0)
 . ;HL*1.6*87: Read acknowledgement.  
"RTN","HLCSTCP2",129,0)
 . ;Loop to re-read from buffer when receiving incorrect ack.
"RTN","HLCSTCP2",130,0)
 . F  D  Q:'+$G(HLREREAD)
"RTN","HLCSTCP2",131,0)
 .. S HLREREAD=1
"RTN","HLCSTCP2",132,0)
 .. ;override ack timeout
"RTN","HLCSTCP2",133,0)
 .. I $G(HLN("ACKTIME")) N HLDBACK S HLDBACK=HLN("ACKTIME")
"RTN","HLCSTCP2",134,0)
 .. ;check for response, quit if no-response, msg will be resent
"RTN","HLCSTCP2",135,0)
 .. ;HLRESP=ien 773^ien 772 for response message
"RTN","HLCSTCP2",136,0)
 .. S HLRESP=$$READ^HLCSTCP1()
"RTN","HLCSTCP2",137,0)
 .. ;if no response, decrement counter and quit
"RTN","HLCSTCP2",138,0)
 .. I 'HLRESP D  Q
"RTN","HLCSTCP2",139,0)
 ...D LLCNT^HLCSTCP(HLDP,4,1)
"RTN","HLCSTCP2",140,0)
 ...S HLREREAD="0^No Response"
"RTN","HLCSTCP2",141,0)
 ...;check if the port needs to be closed and re-opened before the next re-transmission attempt
"RTN","HLCSTCP2",142,0)
 ...I $G(HLDRETRY("CLOSE")) D CLOSE^%ZISTCP K HLPORT
"RTN","HLCSTCP2",143,0)
 .. ;X 0=re-read msg, 1=commit ack, 3=app ack success, 4=error
"RTN","HLCSTCP2",144,0)
 .. S X=$$RSP^HLTP31(HLRESP,.HLN)
"RTN","HLCSTCP2",145,0)
 .. ;X=0, re-read msg. Incorrect ack (bad MSH,MSA,msg id,or sending app)
"RTN","HLCSTCP2",146,0)
 .. Q:'X 
"RTN","HLCSTCP2",147,0)
 .. ;commit ack - done
"RTN","HLCSTCP2",148,0)
 .. ; patch HL*1.6*142
"RTN","HLCSTCP2",149,0)
 .. ; time: this message has received commit ACK
"RTN","HLCSTCP2",150,0)
 .. S $P(^HLMA(HLMSG,"S"),"^",4)=$$NOW^XLFDT
"RTN","HLCSTCP2",151,0)
 .. I X=1 D  S HLREREAD="0^Commit Ack" Q
"RTN","HLCSTCP2",152,0)
 ... ;don't need app. ack, set status to complete
"RTN","HLCSTCP2",153,0)
 ... I "NE"[HLN("APAT") D  Q
"RTN","HLCSTCP2",154,0)
 ....D DONE(3)
"RTN","HLCSTCP2",155,0)
 ....;
"RTN","HLCSTCP2",156,0)
 ... ;response is deferred, set status to awaiting ack
"RTN","HLCSTCP2",157,0)
 ... D DONE(2)
"RTN","HLCSTCP2",158,0)
 ...;
"RTN","HLCSTCP2",159,0)
 .. ;Error, HLRESLT=error number^error message from HLTP3
"RTN","HLCSTCP2",160,0)
 .. I X=4 D  Q
"RTN","HLCSTCP2",161,0)
 ... D DONE(4,+$G(HLRESLT),$P($G(HLRESLT),U,2))
"RTN","HLCSTCP2",162,0)
 ...;
"RTN","HLCSTCP2",163,0)
 ... S HLREREAD="0^Error"
"RTN","HLCSTCP2",164,0)
 .. ;app ack was successful
"RTN","HLCSTCP2",165,0)
 .. D DONE(3) S HLREREAD="0^App Ack"
"RTN","HLCSTCP2",166,0)
 ..;
"RTN","HLCSTCP2",167,0)
 Q
"RTN","HLCSTCP2",168,0)
 ;
"RTN","HLCSTCP2",169,0)
DCSEND ;direct connect
"RTN","HLCSTCP2",170,0)
 ; Set up error trap
"RTN","HLCSTCP2",171,0)
 N $ETRAP,$ESTACK S $ETRAP="D ERROR^HLCSTCP2"
"RTN","HLCSTCP2",172,0)
 ; patch HL*1.6*122
"RTN","HLCSTCP2",173,0)
 N HLTMBUF
"RTN","HLCSTCP2",174,0)
 ;override ack timeout
"RTN","HLCSTCP2",175,0)
 I $G(HLP("ACKTIME")) N HLDBACK S HLDBACK=HLP("ACKTIME")
"RTN","HLCSTCP2",176,0)
 ; patch HL*1.6*142
"RTN","HLCSTCP2",177,0)
 ; time: starts to send this message
"RTN","HLCSTCP2",178,0)
 S $P(^HLMA(HLMSG,"S"),"^",2)=$$NOW^XLFDT
"RTN","HLCSTCP2",179,0)
 I $$WRITE(HLMSG)<0 D:$G(HLERROR)]""  Q  ;HL*1.6*77
"RTN","HLCSTCP2",180,0)
 .  D STATUS^HLTF0(HLMSG,4,$P(HLERROR,"^"),$P(HLERROR,"^",2),1) ;HL*1.6*77
"RTN","HLCSTCP2",181,0)
 .  D LLCNT^HLCSTCP(HLDP,3,1)
"RTN","HLCSTCP2",182,0)
 ; patch HL*1.6*142
"RTN","HLCSTCP2",183,0)
 ; time: this message has been sent
"RTN","HLCSTCP2",184,0)
 S $P(^HLMA(HLMSG,"S"),"^",3)=$$NOW^XLFDT
"RTN","HLCSTCP2",185,0)
 D LLCNT^HLCSTCP(HLDP,4)
"RTN","HLCSTCP2",186,0)
 ;do structure is to stack error
"RTN","HLCSTCP2",187,0)
 D
"RTN","HLCSTCP2",188,0)
 . N $ETRAP,$ESTACK S $ETRAP="D RDERR^HLCSTCP2"
"RTN","HLCSTCP2",189,0)
 . ;HLRESP=ien 773^ien 772 for response message
"RTN","HLCSTCP2",190,0)
 . S HLRESP=$$READ^HLCSTCP1()
"RTN","HLCSTCP2",191,0)
 ;
"RTN","HLCSTCP2",192,0)
 ; patch HL*1.6*142
"RTN","HLCSTCP2",193,0)
 ; time: this message has received app ACK
"RTN","HLCSTCP2",194,0)
 S $P(^HLMA(HLMSG,"S"),"^",4)=$$NOW^XLFDT
"RTN","HLCSTCP2",195,0)
 D DONE(3):$G(HLRESP),DONE(4,108,$S($G(HLERROR)]"":$P(HLERROR,"^",2),1:"No response")):'$G(HLRESP)
"RTN","HLCSTCP2",196,0)
 I $G(HLERROR)']"" D
"RTN","HLCSTCP2",197,0)
 .D MON^HLCSTCP("Idle")
"RTN","HLCSTCP2",198,0)
 .I '$G(HLRESP) S HLERROR="108^No response"
"RTN","HLCSTCP2",199,0)
 ;Close port
"RTN","HLCSTCP2",200,0)
 I $D(HLPORT) D CLOSE^%ZISTCP K HLPORT
"RTN","HLCSTCP2",201,0)
 Q
"RTN","HLCSTCP2",202,0)
 ;
"RTN","HLCSTCP2",203,0)
DONE(ST,ERR,ERRMSG) ;set status to complete
"RTN","HLCSTCP2",204,0)
 ;ST=status, ERR=error ien, ERRMSG=error msg
"RTN","HLCSTCP2",205,0)
 D STATUS^HLTF0(HLMSG,ST,$G(ERR),$G(ERRMSG),1)
"RTN","HLCSTCP2",206,0)
 ;
"RTN","HLCSTCP2",207,0)
 D DEQUE^HLCSREP(HLDP,"O",HLMSG)
"RTN","HLCSTCP2",208,0)
 ;
"RTN","HLCSTCP2",209,0)
 ;check for more msg.
"RTN","HLCSTCP2",210,0)
 I $G(HLPRIO)'="I" S HLMSG=+$O(^HLMA("AC","O",HLDP,0)),HLRETRY=0
"RTN","HLCSTCP2",211,0)
 Q
"RTN","HLCSTCP2",212,0)
 ;
"RTN","HLCSTCP2",213,0)
CHKMSG(HLI) ;check status of message and update if not cancelled
"RTN","HLCSTCP2",214,0)
 ;input: HLI=new status, HLMSG=ien of msg in 773
"RTN","HLCSTCP2",215,0)
 ;returns 1=msg was updated, 0=msg has been canceled
"RTN","HLCSTCP2",216,0)
 N X
"RTN","HLCSTCP2",217,0)
 ;
"RTN","HLCSTCP2",218,0)
 ; New HL*1.6*77 code starting here...
"RTN","HLCSTCP2",219,0)
 I '$D(^HLMA(HLMSG,"P")) D  Q 0
"RTN","HLCSTCP2",220,0)
 .  S HLERROR="2^Missing status field"
"RTN","HLCSTCP2",221,0)
 .  D STATUS^HLTF0(HLMSG,4,$P(HLERROR,U),$P(HLERROR,U,2),1)
"RTN","HLCSTCP2",222,0)
 .;
"RTN","HLCSTCP2",223,0)
 . D DEQUE^HLCSREP(HLDP,"O",HLMSG)
"RTN","HLCSTCP2",224,0)
 ;
"RTN","HLCSTCP2",225,0)
 ; End of HL*1.6*77
"RTN","HLCSTCP2",226,0)
 ;
"RTN","HLCSTCP2",227,0)
 ;get status, quit if msg was cancelled
"RTN","HLCSTCP2",228,0)
 ;
"RTN","HLCSTCP2",229,0)
 S X=+^HLMA(HLMSG,"P") Q:X=3 0
"RTN","HLCSTCP2",230,0)
 ;
"RTN","HLCSTCP2",231,0)
 ;update status if it is different
"RTN","HLCSTCP2",232,0)
 I $G(HLI),HLI'=X D STATUS^HLTF0(HLMSG,HLI)
"RTN","HLCSTCP2",233,0)
 ;
"RTN","HLCSTCP2",234,0)
 Q 1
"RTN","HLCSTCP2",235,0)
 ;
"RTN","HLCSTCP2",236,0)
WRITE(HLDA) ; write message in HL7 format
"RTN","HLCSTCP2",237,0)
 ;  HLDA       - ien of message in 773
"RTN","HLCSTCP2",238,0)
 ;             - start block $C(11)
"RTN","HLCSTCP2",239,0)
 ;             - end block $C(28)
"RTN","HLCSTCP2",240,0)
 ;             - record separator $C(13)
"RTN","HLCSTCP2",241,0)
 ;Output(s): 1 - Successful
"RTN","HLCSTCP2",242,0)
 ;           -1 - Unsuccessful
"RTN","HLCSTCP2",243,0)
 ;
"RTN","HLCSTCP2",244,0)
 N HLDA2,HLAR,HLI,LINENO,X,CRCOUNT
"RTN","HLCSTCP2",245,0)
 S CRCOUNT=0
"RTN","HLCSTCP2",246,0)
 ;set error trap, used when called from HLTP3
"RTN","HLCSTCP2",247,0)
 ;
"RTN","HLCSTCP2",248,0)
 ; New HL*1.6*77 code starts here...
"RTN","HLCSTCP2",249,0)
 N $ETRAP,$ESTACK S $ETRAP="D ERROR^HLCSTCP2"
"RTN","HLCSTCP2",250,0)
 I $G(^HLMA(HLDA,0))'>0 D  Q -1
"RTN","HLCSTCP2",251,0)
 .  S HLERROR="2^Message Text pointer missing"
"RTN","HLCSTCP2",252,0)
 S HLDA2=+$G(^HLMA(HLDA,0))
"RTN","HLCSTCP2",253,0)
 ; End of HL*1.6*77 modifications...
"RTN","HLCSTCP2",254,0)
 ;
"RTN","HLCSTCP2",255,0)
 Q:'$G(^HLMA(HLDA,0)) -1 ;HL*1.6*77
"RTN","HLCSTCP2",256,0)
 ; header is in ^HLMA(, message is in ^HL(772,
"RTN","HLCSTCP2",257,0)
 S LINENO=1,HLI=0,HLAR="^HLMA(HLDA,""MSH"")"
"RTN","HLCSTCP2",258,0)
 U IO
"RTN","HLCSTCP2",259,0)
 D  W $C(13) S HLAR="^HL(772,HLDA2,""IN"")",HLI=0 D
"RTN","HLCSTCP2",260,0)
 . F  S HLI=$O(@HLAR@(HLI)) Q:'HLI  S X=$G(^(HLI,0)) D
"RTN","HLCSTCP2",261,0)
 .. ;first line, need start block char.
"RTN","HLCSTCP2",262,0)
 .. S:LINENO=1 X=$C(11)_X
"RTN","HLCSTCP2",263,0)
 .. ; HL*1.6*122
"RTN","HLCSTCP2",264,0)
 .. ; I X]"" W X,!
"RTN","HLCSTCP2",265,0)
 .. N LENGTH
"RTN","HLCSTCP2",266,0)
 .. S LENGTH=$L(X)
"RTN","HLCSTCP2",267,0)
 .. ; patch HL*1.6*142 start
"RTN","HLCSTCP2",268,0)
 .. ; buffer should be limited to 510
"RTN","HLCSTCP2",269,0)
 .. ; I LENGTH>512 D
"RTN","HLCSTCP2",270,0)
 .. I LENGTH>510 D
"RTN","HLCSTCP2",271,0)
 ... N X1
"RTN","HLCSTCP2",272,0)
 ... ; F  Q:LENGTH<512  D
"RTN","HLCSTCP2",273,0)
 ... F  Q:LENGTH<511  D
"RTN","HLCSTCP2",274,0)
 .... ; S X1=$E(X,1,512),X=$E(X,513,999999)
"RTN","HLCSTCP2",275,0)
 .... S X1=$E(X,1,510),X=$E(X,511,999999)
"RTN","HLCSTCP2",276,0)
 .... S LENGTH=$L(X)
"RTN","HLCSTCP2",277,0)
 .... ; patch HL*1.6*140
"RTN","HLCSTCP2",278,0)
 .... ; W X1,@IOF
"RTN","HLCSTCP2",279,0)
 .... W X1,@HLTCPLNK("IOF")
"RTN","HLCSTCP2",280,0)
 .. ; patch HL*1.6*142 end
"RTN","HLCSTCP2",281,0)
 .. ;
"RTN","HLCSTCP2",282,0)
 .. ; @HLTCPLNK("IOF") (! or #) for flush character
"RTN","HLCSTCP2",283,0)
 .. I X]"" W X,@HLTCPLNK("IOF") S CRCOUNT=0
"RTN","HLCSTCP2",284,0)
 .. ;send CR
"RTN","HLCSTCP2",285,0)
 .. I X="" W $C(13) S CRCOUNT=CRCOUNT+1
"RTN","HLCSTCP2",286,0)
 .. ; prevent from maxstring error
"RTN","HLCSTCP2",287,0)
 .. I CRCOUNT>200 W @HLTCPLNK("IOF") S CRCOUNT=0
"RTN","HLCSTCP2",288,0)
 .. S LINENO=LINENO+1
"RTN","HLCSTCP2",289,0)
 ; Sends end block for this message
"RTN","HLCSTCP2",290,0)
 S X=$C(28)_$C(13)
"RTN","HLCSTCP2",291,0)
 ; U IO W X,!
"RTN","HLCSTCP2",292,0)
 U IO W X,@HLTCPLNK("IOF")
"RTN","HLCSTCP2",293,0)
 ;switch to null device
"RTN","HLCSTCP2",294,0)
 I $G(IO(0))'="",$G(IO(0))'=IO U IO(0)
"RTN","HLCSTCP2",295,0)
 Q 1
"RTN","HLCSTCP2",296,0)
 ;
"RTN","HLCSTCP2",297,0)
OPEN() ; -- Open TCP/IP device (Client)
"RTN","HLCSTCP2",298,0)
 ;HLPORT=port, defined only if port is open
"RTN","HLCSTCP2",299,0)
 ;HLPORTA=number of attempted opens
"RTN","HLCSTCP2",300,0)
 I $D(HLPORT) S IO=HLPORT D  Q 1
"RTN","HLCSTCP2",301,0)
 . U IO
"RTN","HLCSTCP2",302,0)
 . I HLOS["OpenM" X "U IO:(::""-M"")" ;use packet mode on Cache'
"RTN","HLCSTCP2",303,0)
 N HLDOM,HLI,HLIP,HLPORTA
"RTN","HLCSTCP2",304,0)
 G OPENA^HLCSTCP3
"RTN","HLCSTCP2",305,0)
 ;
"RTN","HLCSTCP2",306,0)
RDERR D RDERR^HLCSTCP4 Q
"RTN","HLCSTCP2",307,0)
ERROR D ERROR^HLCSTCP4 Q
"RTN","HLCSTCP2",308,0)
 ;
"RTN","HLCSTCP2",309,0)
CC(X) ;cleanup and close
"RTN","HLCSTCP2",310,0)
 D MON^HLCSTCP(X)
"RTN","HLCSTCP2",311,0)
 I $D(HLPORT) D CLOSE^%ZISTCP K HLPORT
"RTN","HLCSTCP2",312,0)
 ; patch HL*1.6*140
"RTN","HLCSTCP2",313,0)
 ; H 2
"RTN","HLCSTCP2",314,0)
 H 1
"RTN","HLCSTCP2",315,0)
 Q
"RTN","HLCSUTL")
0^6^B46767214^B42003607
"RTN","HLCSUTL",1,0)
HLCSUTL ;ALB/MTC - CS Utility Routines ;06/03/2008 11:57
"RTN","HLCSUTL",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**2,19,58,64,65,142**;Oct 13, 1995;Build 17
"RTN","HLCSUTL",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLCSUTL",4,0)
 ;
"RTN","HLCSUTL",5,0)
 Q
"RTN","HLCSUTL",6,0)
 ;
"RTN","HLCSUTL",7,0)
READ(HLDHANG,HLDBSIZE,HLTRM) ;  This function will perform a read on the device and
"RTN","HLCSUTL",8,0)
 ;  return the characters read and the termination character.
"RTN","HLCSUTL",9,0)
 ;
"RTN","HLCSUTL",10,0)
 ; INPUT : HLDHANG - TimeOut for read
"RTN","HLCSUTL",11,0)
 ;         HLDBSIZE- Block Size for read
"RTN","HLCSUTL",12,0)
 ;         HLTRM   - Passed by reference to return termination char
"RTN","HLCSUTL",13,0)
 ; OUTPUT:          <Data> - Ok
"RTN","HLCSUTL",14,0)
 ;                  -1^TIMEOUT : fails
"RTN","HLCSUTL",15,0)
 ;         
"RTN","HLCSUTL",16,0)
 N RESULT,X,Y
"RTN","HLCSUTL",17,0)
 ;
"RTN","HLCSUTL",18,0)
 K HLTOUT
"RTN","HLCSUTL",19,0)
 ;-- do read
"RTN","HLCSUTL",20,0)
 U IO R X#HLDBSIZE:HLDHANG I '$T S RESULT="-1^TIMEOUT" G READQ
"RTN","HLCSUTL",21,0)
 X ^%ZOSF("TRMRD") S HLTRM=Y
"RTN","HLCSUTL",22,0)
 S RESULT=X
"RTN","HLCSUTL",23,0)
 ;
"RTN","HLCSUTL",24,0)
READQ Q RESULT
"RTN","HLCSUTL",25,0)
 ;
"RTN","HLCSUTL",26,0)
NEXTLINE(LL0,LL1,LINE,ARR,QUE) ;  This function will return the next line from the
"RTN","HLCSUTL",27,0)
 ; Logical Link file #870 specified by LL0 and the position in the queue
"RTN","HLCSUTL",28,0)
 ; specified by QUE at the position LL1. This function will return the
"RTN","HLCSUTL",29,0)
 ; line in the array specifed by ARR. And the position in the WP
"RTN","HLCSUTL",30,0)
 ; field where the last part of the segment was found.
"RTN","HLCSUTL",31,0)
 ; Lastly a <CR> will be appended to the end of the segment
"RTN","HLCSUTL",32,0)
 ;
"RTN","HLCSUTL",33,0)
 ; INPUT :
"RTN","HLCSUTL",34,0)
 ;        LL0 - IFN of logical link
"RTN","HLCSUTL",35,0)
 ;        LL1 - Position in QUE to begin search for next line
"RTN","HLCSUTL",36,0)
 ;        LINE- Last line position, "" will return first line
"RTN","HLCSUTL",37,0)
 ;        ARR - Array to store next line. The output will be in the
"RTN","HLCSUTL",38,0)
 ;              following format ARR(1), ARR(2)
"RTN","HLCSUTL",39,0)
 ;        QUE - Will specify "IN" or "OUT" queue to pull data from
"RTN","HLCSUTL",40,0)
 ;
"RTN","HLCSUTL",41,0)
 ; OUTPUT:
"RTN","HLCSUTL",42,0)
 ;        ARR - As specified above
"RTN","HLCSUTL",43,0)
 ;        RESULT - Position last segment was found or "" if no line
"RTN","HLCSUTL",44,0)
 ;                 was found.
"RTN","HLCSUTL",45,0)
 ;
"RTN","HLCSUTL",46,0)
 ; 
"RTN","HLCSUTL",47,0)
 N RESULT,HLQUE,X,I
"RTN","HLCSUTL",48,0)
 S RESULT="",HLQUE=$S(QUE="IN":1,QUE="OUT":2,1:"")
"RTN","HLCSUTL",49,0)
 ;-- start looking for next line
"RTN","HLCSUTL",50,0)
 S X=+LINE,I=0 F  S X=$O(^HLCS(870,LL0,HLQUE,LL1,1,X)) Q:'X  D  I $G(^HLCS(870,LL0,HLQUE,LL1,1,X,0))="" S RESULT=X,@ARR@(I)=@ARR@(I)_$C(13) Q
"RTN","HLCSUTL",51,0)
 . I $D(^HLCS(870,LL0,HLQUE,LL1,1,X,0)),^(0)'="" S I=I+1,@ARR@(I)=$G(^HLCS(870,LL0,HLQUE,LL1,1,X,0))
"RTN","HLCSUTL",52,0)
 ;
"RTN","HLCSUTL",53,0)
 Q RESULT
"RTN","HLCSUTL",54,0)
 ;
"RTN","HLCSUTL",55,0)
FLD(NODE,FLD) ;This function will return the value for the field
"RTN","HLCSUTL",56,0)
 ;INPUT: NODE=HLNODE from the HLNEXT call, passed by reference
"RTN","HLCSUTL",57,0)
 ;       FLD=field position in segment
"RTN","HLCSUTL",58,0)
 ;       HL("FS") must be defined
"RTN","HLCSUTL",59,0)
 ;OUTPUT: value for the field in this segment
"RTN","HLCSUTL",60,0)
 Q:$G(HL("FS"))=""!($G(NODE)="")!('$G(FLD)) ""
"RTN","HLCSUTL",61,0)
 N I,L,L1,X,Y
"RTN","HLCSUTL",62,0)
 S NODE(0)=NODE,L=0,Y=1,X=""
"RTN","HLCSUTL",63,0)
 ;Y=begining piece of each node, L1=number of pieces in each node
"RTN","HLCSUTL",64,0)
 ;L=last piece in each node, quit when last piece is greater than FLD
"RTN","HLCSUTL",65,0)
 F I=0:1 Q:'$D(NODE(I))  S L1=$L(NODE(I),HL("FS")),L=L1+Y-1 D  Q:Y>FLD
"RTN","HLCSUTL",66,0)
 . ;if FLD is less than last piece, this node has field you want
"RTN","HLCSUTL",67,0)
 . S:FLD'>L X=X_$P(NODE(I),HL("FS"),(FLD-Y+1))
"RTN","HLCSUTL",68,0)
 . S Y=L
"RTN","HLCSUTL",69,0)
 K NODE(0)
"RTN","HLCSUTL",70,0)
 Q X
"RTN","HLCSUTL",71,0)
 ;
"RTN","HLCSUTL",72,0)
CHKSUM(HLTEXT) ; This function will return the checksum for the segment
"RTN","HLCSUTL",73,0)
 ; contained in the array ARR. If no checksum can be calculated an -1
"RTN","HLCSUTL",74,0)
 ; will be returned.
"RTN","HLCSUTL",75,0)
 ;
"RTN","HLCSUTL",76,0)
 ;  INPUT - HLTEXT the name of the array to be used in the calulation
"RTN","HLCSUTL",77,0)
 ;          of the checksum. The format is ARR(1,N),...ARR(M,N)
"RTN","HLCSUTL",78,0)
 ; OUTPUT - Decimal checksum %ZOSF("LPC")^Lenght of segment
"RTN","HLCSUTL",79,0)
 ;
"RTN","HLCSUTL",80,0)
 N RESULT,LEN,X,X1,X2,X3,Y,I
"RTN","HLCSUTL",81,0)
 S RESULT="",LEN=0,X1=0
"RTN","HLCSUTL",82,0)
 ;
"RTN","HLCSUTL",83,0)
 F  S X1=$O(@HLTEXT@(X1)) Q:'X1  S X=@HLTEXT@(X1),X2=$D(@HLTEXT@(X1)),LEN=LEN+$L(X) D
"RTN","HLCSUTL",84,0)
 . X ^%ZOSF("LPC") S RESULT=RESULT_$C(Y)
"RTN","HLCSUTL",85,0)
 . I X2=11 S X3=0 F  S X3=$O(@HLTEXT@(X1,X3)) Q:'X3  D
"RTN","HLCSUTL",86,0)
 .. S X=@HLTEXT@(X1,X3),LEN=LEN+$L(X) X ^%ZOSF("LPC") S RESULT=RESULT_$C(Y)
"RTN","HLCSUTL",87,0)
 ;
"RTN","HLCSUTL",88,0)
 S X=RESULT X ^%ZOSF("LPC") S RESULT=Y
"RTN","HLCSUTL",89,0)
 Q RESULT_"^"_LEN
"RTN","HLCSUTL",90,0)
 ;
"RTN","HLCSUTL",91,0)
CHKSUM2(HLTEXT) ; *** Add in <CR> *** This function will return the checksum for the segment
"RTN","HLCSUTL",92,0)
 ; contained in the array ARR. If no checksum can be calculated an -1
"RTN","HLCSUTL",93,0)
 ; will be returned.
"RTN","HLCSUTL",94,0)
 ;
"RTN","HLCSUTL",95,0)
 ;  INPUT - HLTEXT the name of the array to be used in the calulation
"RTN","HLCSUTL",96,0)
 ;          of the checksum. The format is ARR(1,N),...ARR(M,N)
"RTN","HLCSUTL",97,0)
 ; OUTPUT - Decimal checksum %ZOSF("LPC")^Lenght of segment
"RTN","HLCSUTL",98,0)
 ;
"RTN","HLCSUTL",99,0)
 N RESULT,LEN,X,X1,X2,X3,Y,I
"RTN","HLCSUTL",100,0)
 S RESULT="",LEN=0,X1=0
"RTN","HLCSUTL",101,0)
 ;
"RTN","HLCSUTL",102,0)
 F  S X1=$O(@HLTEXT@(X1)) Q:'X1  S X=@HLTEXT@(X1),X2=$D(@HLTEXT@(X1)),LEN=LEN+$L(X) D
"RTN","HLCSUTL",103,0)
 . X ^%ZOSF("LPC") S RESULT=RESULT_$C(Y)
"RTN","HLCSUTL",104,0)
 . I X2=1 S RESULT=RESULT_$C(13),LEN=LEN+1 Q
"RTN","HLCSUTL",105,0)
 . I X2=11 S X3=0 F  S X3=$O(@HLTEXT@(X1,X3)) Q:'X3  D
"RTN","HLCSUTL",106,0)
 .. S X=@HLTEXT@(X1,X3),LEN=LEN+$L(X) X ^%ZOSF("LPC") S RESULT=RESULT_$C(Y)
"RTN","HLCSUTL",107,0)
 ..I $O(@HLTEXT@(X1,X3))="" S RESULT=RESULT_$C(13),LEN=LEN+1
"RTN","HLCSUTL",108,0)
 ;
"RTN","HLCSUTL",109,0)
 S X=RESULT X ^%ZOSF("LPC") S RESULT=Y
"RTN","HLCSUTL",110,0)
 Q RESULT_"^"_LEN
"RTN","HLCSUTL",111,0)
 ;
"RTN","HLCSUTL",112,0)
APPEND(HLTEXT,LL0,LL1) ; This function will append the data contained in
"RTN","HLCSUTL",113,0)
 ; the HLTEXT array into the IN queue multiple (LL1) of the Logical
"RTN","HLCSUTL",114,0)
 ; Link (LL0) file 870.
"RTN","HLCSUTL",115,0)
 ;  INPUT : HLTEXT - Array containing text to append
"RTN","HLCSUTL",116,0)
 ;          LL0    - IEN of File 870
"RTN","HLCSUTL",117,0)
 ;          LL1    - IEN of IN queue multiple
"RTN","HLCSUTL",118,0)
 ;
"RTN","HLCSUTL",119,0)
 N HLI,X,X1,X2,X3
"RTN","HLCSUTL",120,0)
 S X=""
"RTN","HLCSUTL",121,0)
 S HLI=$P($G(^HLCS(870,LL0,1,LL1,1,0)),U,3)
"RTN","HLCSUTL",122,0)
 S:'HLI HLI=0
"RTN","HLCSUTL",123,0)
 F  S X=$O(@HLTEXT@(X)) Q:'X  S HLI=HLI+1,^HLCS(870,LL0,1,LL1,1,HLI,0)=@HLTEXT@(X),X2=$D(@HLTEXT@(X)) D
"RTN","HLCSUTL",124,0)
 . I X2=11 S ^HLCS(870,LL0,1,LL1,2,HLI,0)="" S X3=0 F  S X3=$O(@HLTEXT@(X,X3)) Q:'X3  D
"RTN","HLCSUTL",125,0)
 .. S HLI=HLI+1,^HLCS(870,LL0,1,LL1,1,HLI,0)=$G(@HLTEXT@(X,X3))
"RTN","HLCSUTL",126,0)
 . S HLI=HLI+1,^HLCS(870,LL0,1,LL1,1,HLI,0)="" Q
"RTN","HLCSUTL",127,0)
 ;
"RTN","HLCSUTL",128,0)
 ;-- update 0 node
"RTN","HLCSUTL",129,0)
 S ^HLCS(870,LL0,1,LL1,1,0)="^^"_HLI_"^"_HLI_"^"_DT_"^"
"RTN","HLCSUTL",130,0)
 Q
"RTN","HLCSUTL",131,0)
 ;
"RTN","HLCSUTL",132,0)
HLNEXT ;-- This routine is used to return the next segment from file 772
"RTN","HLCSUTL",133,0)
 ;   during processing of an inbound message. The following variables
"RTN","HLCSUTL",134,0)
 ;   are used for the processing.
"RTN","HLCSUTL",135,0)
 ;   HLMTIEN - Entry in 772 where message is
"RTN","HLCSUTL",136,0)
 ;   HLQUIT  - Curent ien of "IN" wp field
"RTN","HLCSUTL",137,0)
 ;   HLNODE  - Data is returned in HLNODE=Segment and HLNODE(n) if
"RTN","HLCSUTL",138,0)
 ;             segmemt is greater than 245 chars.
"RTN","HLCSUTL",139,0)
 ;
"RTN","HLCSUTL",140,0)
 K HLNODE
"RTN","HLCSUTL",141,0)
 N HLI,HLDONE,HLX
"RTN","HLCSUTL",142,0)
 S HLNODE="",HLDONE=0
"RTN","HLCSUTL",143,0)
 I HLQUIT="" S HLQUIT=0
"RTN","HLCSUTL",144,0)
 ;HLMTIEN is undef, no response to process
"RTN","HLCSUTL",145,0)
 I '$G(HLMTIEN) S HLQUIT=0 Q
"RTN","HLCSUTL",146,0)
 ;first time, check if new format
"RTN","HLCSUTL",147,0)
 I '$D(HLDONE1) D  Q:HLQUIT
"RTN","HLCSUTL",148,0)
 . S HLX=$O(^HLMA("B",HLMTIEN,0))
"RTN","HLCSUTL",149,0)
 . ;old format, set HLDONE1 so we won't come here again
"RTN","HLCSUTL",150,0)
 . I 'HLX S HLDONE1=0 Q
"RTN","HLCSUTL",151,0)
 . ;already got header, reset HLQUIT for text
"RTN","HLCSUTL",152,0)
 . I HLQUIT S (HLDONE1,HLQUIT)=0 Q
"RTN","HLCSUTL",153,0)
 . ;new format, get header in 773
"RTN","HLCSUTL",154,0)
 . S HLQUIT=$O(^HLMA(HLX,"MSH",HLQUIT))
"RTN","HLCSUTL",155,0)
 . ;there is no header
"RTN","HLCSUTL",156,0)
 . I 'HLQUIT S (HLDONE1,HLQUIT)=0 Q
"RTN","HLCSUTL",157,0)
 . S HLNODE=$G(^HLMA(HLX,"MSH",HLQUIT,0)),HLI=0
"RTN","HLCSUTL",158,0)
 . F  S HLQUIT=$O(^HLMA(HLX,"MSH",HLQUIT)) Q:'HLQUIT  D  Q:HLDONE
"RTN","HLCSUTL",159,0)
 .. I ^HLMA(HLX,"MSH",HLQUIT,0)="" S HLDONE=1 Q
"RTN","HLCSUTL",160,0)
 .. S HLI=HLI+1,HLNODE(HLI)=$G(^HLMA(HLX,"MSH",HLQUIT,0)) Q
"RTN","HLCSUTL",161,0)
 . S HLQUIT=1 Q
"RTN","HLCSUTL",162,0)
 S HLQUIT=$O(^HL(772,HLMTIEN,"IN",HLQUIT))
"RTN","HLCSUTL",163,0)
 I HLQUIT D  Q
"RTN","HLCSUTL",164,0)
 . ; patch HL*1.6*142 start
"RTN","HLCSUTL",165,0)
 . N HLQUIT2  ; use to save the last ien
"RTN","HLCSUTL",166,0)
 . S HLNODE=$G(^HL(772,HLMTIEN,"IN",HLQUIT,0)),HLI=0
"RTN","HLCSUTL",167,0)
 . ; F  S HLQUIT=$O(^HL(772,HLMTIEN,"IN",HLQUIT)) Q:'HLQUIT  D  Q:HLDONE
"RTN","HLCSUTL",168,0)
 . F  S HLQUIT2=HLQUIT,HLQUIT=$O(^HL(772,HLMTIEN,"IN",HLQUIT)) Q:'HLQUIT  D  Q:HLDONE
"RTN","HLCSUTL",169,0)
 .. I ^HL(772,HLMTIEN,"IN",HLQUIT,0)="" S HLDONE=1 Q
"RTN","HLCSUTL",170,0)
 .. S HLI=HLI+1,HLNODE(HLI)=$G(^HL(772,HLMTIEN,"IN",HLQUIT,0)) Q
"RTN","HLCSUTL",171,0)
 . ; for the occurrence when the last segment is not followed by <CR>
"RTN","HLCSUTL",172,0)
 . I HLQUIT="" S HLQUIT=HLQUIT2
"RTN","HLCSUTL",173,0)
 . ; patch HL*1.6*142 end
"RTN","HLCSUTL",174,0)
 ;no more nodes, kill flag and quit
"RTN","HLCSUTL",175,0)
 K HLDONE1 Q
"RTN","HLCSUTL",176,0)
 ;
"RTN","HLCSUTL",177,0)
MSGLINE(HLMID) ;return the number of lines in a message, TCP type only
"RTN","HLCSUTL",178,0)
 ;input: HLMID=message id
"RTN","HLCSUTL",179,0)
 Q:$G(HLMID)="" 0
"RTN","HLCSUTL",180,0)
 N HLCNT,HLIENS,HLIEN
"RTN","HLCSUTL",181,0)
 ;can't find message
"RTN","HLCSUTL",182,0)
 S HLIENS=$O(^HLMA("C",HLMID,0)) Q:'HLIENS 0
"RTN","HLCSUTL",183,0)
 S HLIEN=+$G(^HLMA(HLIENS,0)) Q:'HLIEN 0
"RTN","HLCSUTL",184,0)
 S HLCNT=$P($G(^HLMA(HLIENS,"MSH",0)),U,4)+$P($G(^HL(772,HLIEN,"IN",0)),U,4)
"RTN","HLCSUTL",185,0)
 Q HLCNT
"RTN","HLCSUTL",186,0)
 ;
"RTN","HLCSUTL",187,0)
MSGSIZE(HLIENS) ;return the number of characters in a message, TCP type only
"RTN","HLCSUTL",188,0)
 ;input: HLIENS= ien in file 773
"RTN","HLCSUTL",189,0)
 Q:'$G(HLIENS) 0
"RTN","HLCSUTL",190,0)
 N HLCNT,HLI,HLIEN,HLZ
"RTN","HLCSUTL",191,0)
 ;HLIEN=ien in file 772, message text.  Blank lines are CR, add 1
"RTN","HLCSUTL",192,0)
 Q:'$G(^HLMA(HLIENS,0)) 0 S HLIEN=+(^(0)) Q:'HLIEN 0
"RTN","HLCSUTL",193,0)
 S (HLCNT,HLI,HLZ)=0
"RTN","HLCSUTL",194,0)
 ;get header
"RTN","HLCSUTL",195,0)
 F  S HLI=$O(^HLMA(HLIENS,"MSH",HLI)) Q:'HLI  S HLZ=$L($G(^(HLI,0))),HLCNT=HLCNT+$S(HLZ:HLZ,1:1)
"RTN","HLCSUTL",196,0)
 ;if last line of header wasn't blank, add 1 for CR
"RTN","HLCSUTL",197,0)
 S:HLZ HLCNT=HLCNT+1
"RTN","HLCSUTL",198,0)
 ;get body
"RTN","HLCSUTL",199,0)
 S HLI=0 F  S HLI=$O(^HL(772,HLIEN,"IN",HLI)) Q:'HLI  S HLZ=$L($G(^(HLI,0))),HLCNT=HLCNT+$S(HLZ:HLZ,1:1)
"RTN","HLCSUTL",200,0)
 Q HLCNT
"RTN","HLCSUTL",201,0)
 ;
"RTN","HLCSUTL",202,0)
MSG(HLMID,HLREST) ;return the message text in the reference HLREST
"RTN","HLCSUTL",203,0)
 ;only for TCP type messages
"RTN","HLCSUTL",204,0)
 ;input: HLMID=message id,  HLREST=closed local or global reference
"RTN","HLCSUTL",205,0)
 ;to place message text
"RTN","HLCSUTL",206,0)
 ;output:  return 1 for success and 0 if message doesn't exist
"RTN","HLCSUTL",207,0)
 Q:$G(HLMID)=""!($G(HLREST)="") 0
"RTN","HLCSUTL",208,0)
 N HLCNT,HLI,HLIENS,HLIEN,HLZ
"RTN","HLCSUTL",209,0)
 ;can't find message
"RTN","HLCSUTL",210,0)
 S HLIENS=$O(^HLMA("C",HLMID,0)) Q:'HLIENS 0
"RTN","HLCSUTL",211,0)
 S HLIEN=+$G(^HLMA(HLIENS,0)) Q:'HLIEN 0
"RTN","HLCSUTL",212,0)
 ;RESULT must be close reference
"RTN","HLCSUTL",213,0)
 D  I '$D(HLREST) Q 0
"RTN","HLCSUTL",214,0)
 . Q:HLREST'["("
"RTN","HLCSUTL",215,0)
 . I $E(HLREST,$L(HLREST))=")",$F(HLREST,")")>($F(HLREST,"(")+1) Q
"RTN","HLCSUTL",216,0)
 . K HLREST
"RTN","HLCSUTL",217,0)
 S (HLCNT,HLI)=0,HLZ=""
"RTN","HLCSUTL",218,0)
 ;get header
"RTN","HLCSUTL",219,0)
 F  S HLI=$O(^HLMA(HLIENS,"MSH",HLI)) Q:'HLI  S HLCNT=HLCNT+1,(HLZ,@HLREST@(HLCNT))=$G(^(HLI,0))
"RTN","HLCSUTL",220,0)
 S:HLZ'="" HLCNT=HLCNT+1,@HLREST@(HLCNT)=""
"RTN","HLCSUTL",221,0)
 ;get body
"RTN","HLCSUTL",222,0)
 S HLI=0 F  S HLI=$O(^HL(772,HLIEN,"IN",HLI)) Q:'HLI  S HLCNT=HLCNT+1,@HLREST@(HLCNT)=$G(^(HLI,0))
"RTN","HLCSUTL",223,0)
 Q 1
"RTN","HLDIE")
0^1^B70092394^B47013227
"RTN","HLDIE",1,0)
HLDIE ;CIOFO-O/LJA - Direct 772 & 773 Sets ; 11/03/2008 14:33
"RTN","HLDIE",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109,122,142**;Oct 13,1995;Build 17
"RTN","HLDIE",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLDIE",4,0)
 Q
"RTN","HLDIE",5,0)
 ;
"RTN","HLDIE",6,0)
 ; Rules: if any of these rules is broken, FILE^DIE is called instead
"RTN","HLDIE",7,0)
 ;
"RTN","HLDIE",8,0)
 ;         * Can't edit files other than 772,773
"RTN","HLDIE",9,0)
 ;         * Don't pass IENS value with multiples IENs.  You can only
"RTN","HLDIE",10,0)
 ;             edit one IEN at a time!
"RTN","HLDIE",11,0)
 ;         * Only flag "S" is honored.  Flag "K" is ignored. Other
"RTN","HLDIE",12,0)
 ;             flags result in FILE^DIE being called.
"RTN","HLDIE",13,0)
 ;         * Can't edit ^HLMA(IEN,90) data.
"RTN","HLDIE",14,0)
 ;         * Can't edit ^HLMA(IEN,91) data.
"RTN","HLDIE",15,0)
 ;         * Can't edit ^HL(772,IEN,"IN") data (field #200, MESSAGE TEXT)
"RTN","HLDIE",16,0)
 ;         * No checking of data performed!  (Data format MUST be OK.)
"RTN","HLDIE",17,0)
 ;         * No locking of records in files 772 or 773. (Locks on queues.)
"RTN","HLDIE",18,0)
 ;
"RTN","HLDIE",19,0)
FILE(FLAGS,ROOT,ERR,SUB,RTN) ; FILE^DIE functional equivalent...
"RTN","HLDIE",20,0)
 ; This call has similar parameters to FILE^DIE, but changes data
"RTN","HLDIE",21,0)
 ; using hard sets.  The first two parameters of this API are the
"RTN","HLDIE",22,0)
 ; same as FILE^DIE.  So, if any file other than 772 or 773 is being
"RTN","HLDIE",23,0)
 ; edited, this API just passes on the FLAGS,ROOT,ERR parameters to
"RTN","HLDIE",24,0)
 ; FILE^DIE and quits.  If file 772 or 773 is being edited, the hard
"RTN","HLDIE",25,0)
 ; set code in HLDIE772 and HLDIE773 is called. 
"RTN","HLDIE",26,0)
 ;
"RTN","HLDIE",27,0)
 N DEBUG,FILE,HLEDITOR,LERR,IEN,X,XECMCODE
"RTN","HLDIE",28,0)
 ;
"RTN","HLDIE",29,0)
 S DT=$$NOW^XLFDT\1
"RTN","HLDIE",30,0)
 ;
"RTN","HLDIE",31,0)
 D BEGIN ; Debug call at beginning or process
"RTN","HLDIE",32,0)
 ;
"RTN","HLDIE",33,0)
 ; Check FILE, IEN, FIELDs passed, etc...
"RTN","HLDIE",34,0)
 I '$$CHECKS D  QUIT  ;->
"RTN","HLDIE",35,0)
 .
"RTN","HLDIE",36,0)
 .  S HLEDITOR="FILE^DIE"
"RTN","HLDIE",37,0)
 .
"RTN","HLDIE",38,0)
 .  ; Call FILEMAN...
"RTN","HLDIE",39,0)
 .  D FILE^DIE($G(FLAGS),$G(ROOT),$G(ERR))
"RTN","HLDIE",40,0)
 .
"RTN","HLDIE",41,0)
 .  ; Debug call made even with Fileman...
"RTN","HLDIE",42,0)
 .  D END
"RTN","HLDIE",43,0)
 ;
"RTN","HLDIE",44,0)
 S HLEDITOR="FILE^HLDIE"
"RTN","HLDIE",45,0)
 ;
"RTN","HLDIE",46,0)
 ; If this point is reached, file 772 or 773 is being edited, data
"RTN","HLDIE",47,0)
 ; in ROOT() has been checked, and data is being hard set...
"RTN","HLDIE",48,0)
 ;
"RTN","HLDIE",49,0)
 ;
"RTN","HLDIE",50,0)
 ; Make sure ERR is defined...
"RTN","HLDIE",51,0)
 I $G(ERR)']"" N HLERR S ERR="HLERR"
"RTN","HLDIE",52,0)
 ;
"RTN","HLDIE",53,0)
 ; All editing occurs in this call...
"RTN","HLDIE",54,0)
 D EDITALL(.ROOT,FILE,IEN)
"RTN","HLDIE",55,0)
 ;
"RTN","HLDIE",56,0)
 ; Store debug data if XTMP debug string set...
"RTN","HLDIE",57,0)
 D END
"RTN","HLDIE",58,0)
 ;
"RTN","HLDIE",59,0)
 ;check if ROOT needs to be retained
"RTN","HLDIE",60,0)
 I FLAGS'["S" K @ROOT,FLAGS
"RTN","HLDIE",61,0)
 ;
"RTN","HLDIE",62,0)
 Q
"RTN","HLDIE",63,0)
 ;
"RTN","HLDIE",64,0)
EDITALL(ROOT,FILE,IEN) ; Edit 772 or 773 by direct sets...
"RTN","HLDIE",65,0)
 ;
"RTN","HLDIE",66,0)
 ; FILE,IEN -- optional (parsed from ROOT())
"RTN","HLDIE",67,0)
 ;
"RTN","HLDIE",68,0)
 N ERRNO,FIELD,GBL,NODE,ROUTINE,TAG,VALUE,XRF
"RTN","HLDIE",69,0)
 ;
"RTN","HLDIE",70,0)
 S GBL=$$GBL(FILE,+IEN)
"RTN","HLDIE",71,0)
 ;
"RTN","HLDIE",72,0)
 ;check if .01="@" for deletion of record...
"RTN","HLDIE",73,0)
 I $G(@ROOT@(FILE,IEN,.01))="@" D  Q
"RTN","HLDIE",74,0)
 .I FILE=773 D DEL773^HLUOPT3(+IEN) Q
"RTN","HLDIE",75,0)
 .I FILE=772 D DEL772^HLUOPT3(+IEN)
"RTN","HLDIE",76,0)
 ;
"RTN","HLDIE",77,0)
 ; patch HL*1.6*122: MPI-client/server
"RTN","HLDIE",78,0)
 ; If no data in record passed in, log an error and quit...
"RTN","HLDIE",79,0)
 ; I '$D(@GBL) D  Q  ; Remember.  GBL contains IEN...
"RTN","HLDIE",80,0)
 N HLDGBL
"RTN","HLDIE",81,0)
 F  L +@GBL:10 Q:$T  H 1
"RTN","HLDIE",82,0)
 ; patch HL*1.6*142: MPI-client/server start
"RTN","HLDIE",83,0)
 N COUNT
"RTN","HLDIE",84,0)
 F COUNT=1:1:15 Q:$D(@GBL)  H COUNT
"RTN","HLDIE",85,0)
 ; patch HL*1.6*142: MPI-client/server end
"RTN","HLDIE",86,0)
 S HLDGBL=$D(@GBL)
"RTN","HLDIE",87,0)
 L -@GBL
"RTN","HLDIE",88,0)
 I 'HLDGBL D  Q  ; Remember.  GBL contains IEN...
"RTN","HLDIE",89,0)
 .  S ERRNO=$$ERRNO(601,"The entry does not exist.",FILE,2)
"RTN","HLDIE",90,0)
 .  S @ERR@("DIERR",+ERRNO,"PARAM","IENS")=IEN_$S(IEN'[",":",",1:"")
"RTN","HLDIE",91,0)
 ;
"RTN","HLDIE",92,0)
 ;
"RTN","HLDIE",93,0)
 ; What routine holds the file-specific field/xref set code?
"RTN","HLDIE",94,0)
 S ROUTINE=$S(FILE=772:"HLDIE772",FILE=773:"HLDIE773",1:"")
"RTN","HLDIE",95,0)
 ;
"RTN","HLDIE",96,0)
 ; Load NODEs...
"RTN","HLDIE",97,0)
 D GETNODES(FILE,+IEN,.NODE)
"RTN","HLDIE",98,0)
 ;
"RTN","HLDIE",99,0)
 ; When a field is edited, the NODE(1) is changed
"RTN","HLDIE",100,0)
 ;
"RTN","HLDIE",101,0)
 ; Edit NODE(1), adding new values, and set XRF(XREF) nodes...
"RTN","HLDIE",102,0)
 S FIELD=0
"RTN","HLDIE",103,0)
 F  S FIELD=$O(@ROOT@(FILE,IEN,FIELD)) Q:FIELD'>0  D
"RTN","HLDIE",104,0)
 .  ; VALUE = value passed in by process that is to be stored in file
"RTN","HLDIE",105,0)
 .  S VALUE=$G(@ROOT@(FILE,IEN,FIELD))
"RTN","HLDIE",106,0)
 .
"RTN","HLDIE",107,0)
 .  ; If field should be deleted, VALUE will equal @...
"RTN","HLDIE",108,0)
 .  I VALUE="@" S VALUE=""
"RTN","HLDIE",109,0)
 .
"RTN","HLDIE",110,0)
 .  ; Get and check tag...
"RTN","HLDIE",111,0)
 .  S TAG="F"_(FILE-770)_$TR(FIELD,".","")_U_ROUTINE
"RTN","HLDIE",112,0)
 .  S TAG(1)=$T(@TAG) I TAG(1)']"" D  QUIT  ;->
"RTN","HLDIE",113,0)
 .  .  S ERRNO=$$ERRNO(501,"No set logic for file #"_FILE_"'s field# "_FIELD,FILE,3)
"RTN","HLDIE",114,0)
 .  .  S @ERR@("DIERR",+ERRNO,"PARAM",1)=FIELD
"RTN","HLDIE",115,0)
 .  .  S @ERR@("DIERR",+ERRNO,"PARAM","FIELD")=FIELD
"RTN","HLDIE",116,0)
 .
"RTN","HLDIE",117,0)
 .  ; Call the subroutine below that is for the specific field...
"RTN","HLDIE",118,0)
 .  ; (No editing of xrefs or global data occurs in these calls.)
"RTN","HLDIE",119,0)
 .  D @("F"_(FILE-770)_$TR(FIELD,".","")_U_ROUTINE)
"RTN","HLDIE",120,0)
 ;
"RTN","HLDIE",121,0)
 ; If no data actually changed, quit...
"RTN","HLDIE",122,0)
 QUIT:'$D(NODE("CHG"))  ;->
"RTN","HLDIE",123,0)
 ;
"RTN","HLDIE",124,0)
 ; patch HL*1.6*142 start: MPI-client/server
"RTN","HLDIE",125,0)
 ; Store changes in the global now...
"RTN","HLDIE",126,0)
 D STORE(FILE,IEN,.NODE)
"RTN","HLDIE",127,0)
 ;
"RTN","HLDIE",128,0)
 ; patch HL*1.6*122: MPI-client/server
"RTN","HLDIE",129,0)
 I FILE=773 D
"RTN","HLDIE",130,0)
 . F  L +^HLMA(+IEN):10 Q:$T  H 1
"RTN","HLDIE",131,0)
 E  D
"RTN","HLDIE",132,0)
 . F  L +^HL(772,+IEN):10 Q:$T  H 1
"RTN","HLDIE",133,0)
 ;
"RTN","HLDIE",134,0)
 ; Set xrefs to correspond to the just-stored data...
"RTN","HLDIE",135,0)
 S XRF=""
"RTN","HLDIE",136,0)
 F  S XRF=$O(XRF(XRF)) Q:XRF']""  D
"RTN","HLDIE",137,0)
 .  D @("XRF"_XRF_U_ROUTINE)
"RTN","HLDIE",138,0)
 .  ; create x-ref: ^HLMA("AH-NEW")
"RTN","HLDIE",139,0)
 .  ; it is also defined in DD of field #2 (messsage ID)
"RTN","HLDIE",140,0)
 .  I (FILE=773),(XRF="AH") D
"RTN","HLDIE",141,0)
 ..  N HDR,FLD
"RTN","HLDIE",142,0)
 ..  F  L +^HLMA(+IEN,"MSH"):10 Q:$T  H 1
"RTN","HLDIE",143,0)
 ..  S HDR=$G(^HLMA(+IEN,"MSH",1,0))
"RTN","HLDIE",144,0)
 ..  L -^HLMA(+IEN,"MSH")
"RTN","HLDIE",145,0)
 ..  Q:HDR']""
"RTN","HLDIE",146,0)
 ..  F  L +^HLMA(+IEN,"MSH"):10 Q:$T  H 1
"RTN","HLDIE",147,0)
 ..  S HDR(2)=$G(^HLMA(+IEN,"MSH",2,0))
"RTN","HLDIE",148,0)
 ..  S:HDR(2)]"" HDR=HDR_HDR(2)
"RTN","HLDIE",149,0)
 ..  L -^HLMA(+IEN,"MSH")
"RTN","HLDIE",150,0)
 ..  S FLD=$E(HDR,4)
"RTN","HLDIE",151,0)
 ..  Q:FLD']""
"RTN","HLDIE",152,0)
 ..  S HDR=$P(HDR,FLD,3,6)
"RTN","HLDIE",153,0)
 ..  I HDR]"" D
"RTN","HLDIE",154,0)
 ...  S ^HLMA("AH-NEW",HDR,+$P($G(^HLMA(+IEN,0)),"^",2),+IEN)=""
"RTN","HLDIE",155,0)
 ...  S HL("HDR FLDS:3-6")=HDR
"RTN","HLDIE",156,0)
 ;
"RTN","HLDIE",157,0)
 ; patch HL*1.6*122: MPI-client/server
"RTN","HLDIE",158,0)
 I FILE=773 L -^HLMA(+IEN)
"RTN","HLDIE",159,0)
 E  L -^HL(772,+IEN)
"RTN","HLDIE",160,0)
 ; patch HL*1.6*142 end
"RTN","HLDIE",161,0)
 ;
"RTN","HLDIE",162,0)
 Q
"RTN","HLDIE",163,0)
 ;
"RTN","HLDIE",164,0)
GETNODES(FILE,IEN,NODE) ; Load pre-change data for each node in 
"RTN","HLDIE",165,0)
 ; NODE(node,0), and load node to be changed in NODE(node,1).
"RTN","HLDIE",166,0)
 ; GBL -- req
"RTN","HLDIE",167,0)
 ;
"RTN","HLDIE",168,0)
 ; patch HL*1.6*142 start: MPI-client/server 
"RTN","HLDIE",169,0)
 F  L +@GBL:10 Q:$T  H 1
"RTN","HLDIE",170,0)
 F NODE=0,1,2,"P","S" D
"RTN","HLDIE",171,0)
 .  ; After setting, NODE(NODE,0) will equal each other.
"RTN","HLDIE",172,0)
 .  ; However, after each edited field is processed, the pieces of
"RTN","HLDIE",173,0)
 .  ; data in NODE(NODE,1) will be changed.  The pre and post nodes
"RTN","HLDIE",174,0)
 .  ; then are of comparison value.
"RTN","HLDIE",175,0)
 .  S NODE(NODE,0)=$G(@GBL@(NODE)) ; Pre-change node
"RTN","HLDIE",176,0)
 .  ;
"RTN","HLDIE",177,0)
 .  ; for MPI-client/server environment:
"RTN","HLDIE",178,0)
 .  ; if it is going to update field #773,3 (Transmission type)
"RTN","HLDIE",179,0)
 .  ; field #773,2 (message ID) should be existed, otherwise,
"RTN","HLDIE",180,0)
 .  ; wait until it is available on this client node
"RTN","HLDIE",181,0)
 .  I FILE=773,$D(@ROOT@(3)),$P(NODE(NODE,0),"^",2)']"" D
"RTN","HLDIE",182,0)
 ..  N COUNT
"RTN","HLDIE",183,0)
 ..  F COUNT=1:1:15 Q:($P(NODE(NODE,0),"^",2)]"")  D  H COUNT
"RTN","HLDIE",184,0)
 ...  S NODE(NODE,0)=$G(@GBL@(NODE))
"RTN","HLDIE",185,0)
 .  S NODE(NODE,1)=NODE(NODE,0) ; Node that is changed
"RTN","HLDIE",186,0)
 L -@GBL
"RTN","HLDIE",187,0)
 ; patch HL*1.6*142 end 
"RTN","HLDIE",188,0)
 Q
"RTN","HLDIE",189,0)
 ;
"RTN","HLDIE",190,0)
STORE(FILE,IEN,NODE) ; Store changes in file...
"RTN","HLDIE",191,0)
 N DATA,ND
"RTN","HLDIE",192,0)
 ;
"RTN","HLDIE",193,0)
 ; Loop thru change nodes, get changed data, and store it...
"RTN","HLDIE",194,0)
 S ND=""
"RTN","HLDIE",195,0)
 F  S ND=$O(NODE("CHG",ND)) Q:ND']""  D
"RTN","HLDIE",196,0)
 .  S DATA=$G(NODE(ND,1))
"RTN","HLDIE",197,0)
 .  ; Even if no data no node, store it.  (Will be removed by purge.)
"RTN","HLDIE",198,0)
 .  ;
"RTN","HLDIE",199,0)
 .  ; patch HL*1.6*142: MPI-client/server start
"RTN","HLDIE",200,0)
 .  ; I FILE=772 S ^HL(772,+IEN,ND)=DATA
"RTN","HLDIE",201,0)
 .  I FILE=772 D
"RTN","HLDIE",202,0)
 ..  F  L +^HL(772,+IEN,ND):10 Q:$T  H 1
"RTN","HLDIE",203,0)
 ..  S ^HL(772,+IEN,ND)=DATA
"RTN","HLDIE",204,0)
 ..  L -^HL(772,+IEN,ND)
"RTN","HLDIE",205,0)
 .  ; I FILE=773 S ^HLMA(+IEN,ND)=DATA
"RTN","HLDIE",206,0)
 .  I FILE=773 D
"RTN","HLDIE",207,0)
 ..  F  L +^HLMA(+IEN,ND):10 Q:$T  H 1
"RTN","HLDIE",208,0)
 ..  S ^HLMA(+IEN,ND)=DATA
"RTN","HLDIE",209,0)
 ..  L -^HLMA(+IEN,ND)
"RTN","HLDIE",210,0)
 .  ; patch HL*1.6*142: MPI-client/server end
"RTN","HLDIE",211,0)
 ;
"RTN","HLDIE",212,0)
 QUIT
"RTN","HLDIE",213,0)
 ;
"RTN","HLDIE",214,0)
GBL(FILE,IEN) QUIT $S(FILE=772:"^HL(772,"_+IEN_")",1:"^HLMA("_+IEN_")")
"RTN","HLDIE",215,0)
 ;
"RTN","HLDIE",216,0)
CHKFLD(FILE,FIELD) ; Does passed-in field exist?
"RTN","HLDIE",217,0)
 ; Returns -- @ERR@(...) ->
"RTN","HLDIE",218,0)
 ;
"RTN","HLDIE",219,0)
 ; Quit if field exists...
"RTN","HLDIE",220,0)
 QUIT:$D(^DD(+FILE,+FIELD)) 1 ;->
"RTN","HLDIE",221,0)
 ;
"RTN","HLDIE",222,0)
 ; Field doesn't exist.  Log error...
"RTN","HLDIE",223,0)
 S ERRNO=$$ERRNO(501,"File #"_FILE_" does not contain a field "_FIELD_".",FILE,3)
"RTN","HLDIE",224,0)
 S @ERR@("DIERR",+ERRNO,"PARAM",1)=FIELD
"RTN","HLDIE",225,0)
 S @ERR@("DIERR",+ERRNO,"PARAM","FIELD")=FIELD
"RTN","HLDIE",226,0)
 ;
"RTN","HLDIE",227,0)
 Q ""
"RTN","HLDIE",228,0)
 ;
"RTN","HLDIE",229,0)
ERRNO(NUM,TXT,FILE,PNO) ; Return next ERROR number and create general data...
"RTN","HLDIE",230,0)
 N NO
"RTN","HLDIE",231,0)
 S NO=$G(@ERR@("DIERR"))+1,@ERR@("DIERR")=+NO_U_+NO
"RTN","HLDIE",232,0)
 S @ERR@("DIERR",NO)=NUM
"RTN","HLDIE",233,0)
 S @ERR@("DIERR",NO,"PARAM",0)=PNO
"RTN","HLDIE",234,0)
 S @ERR@("DIERR",NO,"PARAM","FILE")=FILE
"RTN","HLDIE",235,0)
 S @ERR@("DIERR",NO,"TEXT",1)=TXT
"RTN","HLDIE",236,0)
 S @ERR@("DIERR","E",NUM,NO)=""
"RTN","HLDIE",237,0)
 Q NO
"RTN","HLDIE",238,0)
 ;
"RTN","HLDIE",239,0)
GENLERR(ETXT) ; Store GENERAL (and fatal) error...
"RTN","HLDIE",240,0)
 ; ERR -- req
"RTN","HLDIE",241,0)
 N NO
"RTN","HLDIE",242,0)
 S NO=$G(@ERR@("DIERR"))+1,@ERR@("DIERR")=+NO_U_+NO
"RTN","HLDIE",243,0)
 S @ERR@("DIERR",NO)=999_U_ETXT ; Made up error number
"RTN","HLDIE",244,0)
 Q
"RTN","HLDIE",245,0)
 ;
"RTN","HLDIE",246,0)
CHECKS() ; Check ROOT() for file and validity of data...
"RTN","HLDIE",247,0)
 ; FLAGS, ROOT() -- req --> FILE,IEN
"RTN","HLDIE",248,0)
 N I,OK,FIELD
"RTN","HLDIE",249,0)
 ;
"RTN","HLDIE",250,0)
 ;check the file & ien
"RTN","HLDIE",251,0)
 S FILE=$O(@ROOT@(0))
"RTN","HLDIE",252,0)
 I FILE'=772,FILE'=773 D  QUIT "" ;->
"RTN","HLDIE",253,0)
 .  S IEN=$S(FILE:$O(@ROOT@(FILE,0)),1:0) ; Set for debugging
"RTN","HLDIE",254,0)
 ;
"RTN","HLDIE",255,0)
 ; ;shouldn't be more than 1 file!
"RTN","HLDIE",256,0)
 QUIT:$O(@ROOT@(FILE)) "" ;->
"RTN","HLDIE",257,0)
 ;
"RTN","HLDIE",258,0)
 ;check the ien structure, and that only ien passed...
"RTN","HLDIE",259,0)
 S IEN=$O(@ROOT@(FILE,0))
"RTN","HLDIE",260,0)
 ; Structure check...
"RTN","HLDIE",261,0)
 QUIT:$P(IEN,",")'=+IEN_"," "" ;->
"RTN","HLDIE",262,0)
 ; Is it numeric?
"RTN","HLDIE",263,0)
 QUIT:'(+IEN) "" ;->
"RTN","HLDIE",264,0)
 ; Has more than one IEN been passed?
"RTN","HLDIE",265,0)
 QUIT:($O(@ROOT@(FILE,IEN))'="") "" ;->
"RTN","HLDIE",266,0)
 ;
"RTN","HLDIE",267,0)
 ;check the flags.  Only K and S flags allowed...
"RTN","HLDIE",268,0)
 I $L(FLAGS) D  QUIT:'OK "" ;->
"RTN","HLDIE",269,0)
 .  S OK=1
"RTN","HLDIE",270,0)
 .  F I=0:1:$L(FLAGS) I $E(FLAGS,I)'="K",$E(FLAGS,I)'="S" S OK=0
"RTN","HLDIE",271,0)
 ;
"RTN","HLDIE",272,0)
 ; Check for existence of FIELD in FILE's DD & if an excluded field.
"RTN","HLDIE",273,0)
 ; (See rules for fields which cannot be updated by FILE^HLDIE.)
"RTN","HLDIE",274,0)
 S FIELD=0,OK=1
"RTN","HLDIE",275,0)
 F  S FIELD=$O(@ROOT@(FILE,IEN,FIELD)) Q:FIELD=""  D  Q:'OK
"RTN","HLDIE",276,0)
 .  I '$$CHKFLD(FILE,FIELD) S OK=0 Q
"RTN","HLDIE",277,0)
 .  I FILE=773,FIELD\1=90 S OK=0 Q
"RTN","HLDIE",278,0)
 .  I FILE=773,FIELD\1=91 S OK=0 Q
"RTN","HLDIE",279,0)
 .  I FILE=772,FIELD=200 S OK=0 Q
"RTN","HLDIE",280,0)
 ;
"RTN","HLDIE",281,0)
 ; If not OK to use FILE^HLDIE, skip any further testing...
"RTN","HLDIE",282,0)
 QUIT:'OK "" ;->
"RTN","HLDIE",283,0)
 ;
"RTN","HLDIE",284,0)
 ;                    *** WARNING ***
"RTN","HLDIE",285,0)
 ; The following check **MUST** be removed after FILE^HLDIE is working.
"RTN","HLDIE",286,0)
 ;
"RTN","HLDIE",287,0)
 ; Final check for whether FILE^HLDIE should be used...
"RTN","HLDIE",288,0)
 I $G(^XTMP("HLDIE-DEBUG","CALL"))]"" QUIT "" ;->
"RTN","HLDIE",289,0)
 ; If this node exists and follows null, FILE^DIE will be used.
"RTN","HLDIE",290,0)
 ; Otherwise, execution defaults to using FILE^HLDIE.
"RTN","HLDIE",291,0)
 ;
"RTN","HLDIE",292,0)
 Q OK
"RTN","HLDIE",293,0)
 ;
"RTN","HLDIE",294,0)
BEGIN ; Always call here before any ^HLDIE or ^DIE calls...
"RTN","HLDIE",295,0)
 D DEBUG(1)
"RTN","HLDIE",296,0)
 Q
"RTN","HLDIE",297,0)
 ;
"RTN","HLDIE",298,0)
END ; Always call here after all ^HLDIE or ^DIE actions...
"RTN","HLDIE",299,0)
 D DEBUG(2)
"RTN","HLDIE",300,0)
 Q
"RTN","HLDIE",301,0)
 ;
"RTN","HLDIE",302,0)
DEBUG(LOC) ; Debug presets and setup...
"RTN","HLDIE",303,0)
 ; Most variables created here should be left around.  These variables
"RTN","HLDIE",304,0)
 ; are newed above.
"RTN","HLDIE",305,0)
 N STORE
"RTN","HLDIE",306,0)
 ;
"RTN","HLDIE",307,0)
 S RTN=$G(RTN),SUB=$G(SUB)
"RTN","HLDIE",308,0)
 ;
"RTN","HLDIE",309,0)
 ; First-time (beginning) call setups...
"RTN","HLDIE",310,0)
 I LOC=1 D
"RTN","HLDIE",311,0)
 .  S RTN=$S(RTN]"":RTN,1:"HLDIE")_"~"_$S(RTN="HLDIE":"FILE",1:SUB)
"RTN","HLDIE",312,0)
 .  S DEBUG=$G(^XTMP("HLDIE-DEBUG","STATUS"))
"RTN","HLDIE",313,0)
 .  S XECMCODE=$P(DEBUG,U,3)
"RTN","HLDIE",314,0)
 ; DEBUG is always called at beginning (LOC=1) and end (LOC=2) or
"RTN","HLDIE",315,0)
 ; FILE^HLDIE.  So, set up variables only once, at beginning...
"RTN","HLDIE",316,0)
 ;
"RTN","HLDIE",317,0)
 ; Setup that is individual to each (1 or 2) call...
"RTN","HLDIE",318,0)
 S STORE=$P(DEBUG,U,LOC),STORE=$S(STORE=1:1,STORE=2:2,1:"")
"RTN","HLDIE",319,0)
 ; Some, All, or no data stored?
"RTN","HLDIE",320,0)
 ;
"RTN","HLDIE",321,0)
 ; If no STORE instructions, and no M code to specify STORE, quit...
"RTN","HLDIE",322,0)
 QUIT:'STORE&($G(XECMCODE)'=1)  ;->
"RTN","HLDIE",323,0)
 ;
"RTN","HLDIE",324,0)
 ; Call DEBUG to STORE data...
"RTN","HLDIE",325,0)
 D DEBUG^HLDIEDBG(RTN,LOC,STORE,XECMCODE)
"RTN","HLDIE",326,0)
 ;
"RTN","HLDIE",327,0)
 Q
"RTN","HLDIE",328,0)
 ;
"RTN","HLDIE",329,0)
EOR ;HLDIE - Direct 772 & 773 Sets ; 11/18/2003 11:17
"RTN","HLMA")
0^16^B53088927^B52398960
"RTN","HLMA",1,0)
HLMA ;AISC/SAW-Message Administration Module ;02/26/2009  15:42
"RTN","HLMA",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**19,43,58,63,66,82,91,109,115,133,132,122,140,142**;Oct 13, 1995;Build 17
"RTN","HLMA",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLMA",4,0)
GENERATE(HLEID,HLARYTYP,HLFORMAT,HLRESLT,HLMTIEN,HLP) ;
"RTN","HLMA",5,0)
 ;Entry point to generate a deferred message
"RTN","HLMA",6,0)
 ;
"RTN","HLMA",7,0)
 ;This is a subroutine call with parameter passing.  It returns a
"RTN","HLMA",8,0)
 ;value in the variable HLRESLT with 1 to 3 pieces separated by uparrows
"RTN","HLMA",9,0)
 ;as follows:  1st message ID^error code^error description
"RTN","HLMA",10,0)
 ;If no error occurs, only the first piece is returned equal to a unique
"RTN","HLMA",11,0)
 ;ID for the 1st message.  If message was sent to more than 1 subscriber
"RTN","HLMA",12,0)
 ;than the other message IDs will be in the array HLRESLT(n)=ID
"RTN","HLMA",13,0)
 ;Otherwise, three pieces are returned with the
"RTN","HLMA",14,0)
 ;first piece equal to the message ID, if one was assigned, otherwise 0
"RTN","HLMA",15,0)
 ;
"RTN","HLMA",16,0)
 ;Required Input Parameters
"RTN","HLMA",17,0)
 ;     HLEID = Name or IEN of event driver protocol in the Protocol file
"RTN","HLMA",18,0)
 ;  HLARYTYP = Array type.  One of the following codes:
"RTN","HLMA",19,0)
 ;               LM = local array containing a single message
"RTN","HLMA",20,0)
 ;               LB = local array containig a batch of messages
"RTN","HLMA",21,0)
 ;               GM = global array containing a single message
"RTN","HLMA",22,0)
 ;               GB = global array containing a batch of messages
"RTN","HLMA",23,0)
 ;  HLFORMAT = Format of array, 1 for pre-formatted in HL7 format,
"RTN","HLMA",24,0)
 ;               otherwise 0
"RTN","HLMA",25,0)
 ;NOTE:  The parameter HLRESLT must be passed by reference
"RTN","HLMA",26,0)
 ;   HLRESLT = The variable that will be returned to the calling
"RTN","HLMA",27,0)
 ;               application as descibed above
"RTN","HLMA",28,0)
 ;Optional Parameters
"RTN","HLMA",29,0)
 ;   HLMTIEN = IEN of entry in Message Text file where the message
"RTN","HLMA",30,0)
 ;               being generated is to be stored.  This parameter is
"RTN","HLMA",31,0)
 ;               only passed for a batch type message
"RTN","HLMA",32,0)
 ;NOTE:  The parameter HLP used for the following parameters must be
"RTN","HLMA",33,0)
 ;       passed by reference
"RTN","HLMA",34,0)
 ;  HLP("SECURITY") = A 1 to 40 character string
"RTN","HLMA",35,0)
 ;   HLP("CONTPTR") = Continuation pointer, a 1 to 180 character string
"RTN","HLMA",36,0)
 ; HLP("NAMESPACE") = Passed in by application namespace - HL*1.6*91
"RTN","HLMA",37,0)
 ; HLP("EXCLUDE SUBSCRIBER",<n=1,2,3...>)=<subscriber protocol ien> or
"RTN","HLMA",38,0)
 ;   <subscriber protocol name> - A list of protocols to dynamically
"RTN","HLMA",39,0)
 ;   drop from the event protocol's subscriber multiple.
"RTN","HLMA",40,0)
 ;
"RTN","HLMA",41,0)
 ;can't have link open when generating new message
"RTN","HLMA",42,0)
 N HLTCP,HLTCPO,HLPRIO,HLMIDAR
"RTN","HLMA",43,0)
 ; patch HL*1.6*142- to protect application who call this entry
"RTN","HLMA",44,0)
 N HLSUP
"RTN","HLMA",45,0)
 S HLPRIO="D"
"RTN","HLMA",46,0)
 S HLRESLT=""
"RTN","HLMA",47,0)
 ;Check for required parameters
"RTN","HLMA",48,0)
CONT ;
"RTN","HLMA",49,0)
 I $G(HLEID)']""!($G(HLARYTYP)']"")!($G(HLFORMAT)']"") D  G EXIT
"RTN","HLMA",50,0)
 . S HLRESLT="0^7^"_$G(^HL(771.7,7,0))_" at GENERATE^HLMA entry point"
"RTN","HLMA",51,0)
 I 'HLEID S HLEID=$O(^ORD(101,"B",HLEID,0)) I 'HLEID S HLRESLT="0^1^"_$G(^HL(771.7,1,0)) G EXIT
"RTN","HLMA",52,0)
 N HLRESLT1,HLRESLTA S (HLRESLTA,HLRESLT1)=""
"RTN","HLMA",53,0)
 I "GL"'[$E(HLARYTYP) S HLRESLT="0^4^"_$G(^HL(771.7,4,0)) G EXIT
"RTN","HLMA",54,0)
 I $L($G(HLP("SECURITY")))>40 S HLRESLT="0^6^"_$G(^HL(771.7,6,0)) G EXIT
"RTN","HLMA",55,0)
 I $L($G(HLP("CONTPTR")))>180 S HLRESLT="0^11^"_$G(^HL(771.7,11,0)) G EXIT
"RTN","HLMA",56,0)
 I $D(HLL("LINKS")) D  G:$G(HLRESLT)]"" EXIT
"RTN","HLMA",57,0)
 . N I,HLPNAM,HLPIEN,HLLNAM,HLLIEN
"RTN","HLMA",58,0)
 . S I=0
"RTN","HLMA",59,0)
 . F  S I=$O(HLL("LINKS",I)) Q:'I  D  Q:$G(HLRESLT)]""
"RTN","HLMA",60,0)
 . . S HLPNAM=$P(HLL("LINKS",I),U)
"RTN","HLMA",61,0)
 . . S HLPIEN=+$O(^ORD(101,"B",HLPNAM,0))
"RTN","HLMA",62,0)
 . . I $P($G(^ORD(101,HLPIEN,0)),U,4)'="S" S HLRESLT="0^15^Invalid Subscriber Protocol in HLL('LINKS'): "_HLL("LINKS",I) Q
"RTN","HLMA",63,0)
 . . S HLLNAM=$P(HLL("LINKS",I),U,2)
"RTN","HLMA",64,0)
 . . S HLLIEN=+$O(^HLCS(870,"B",HLLNAM,0))
"RTN","HLMA",65,0)
 . . I '$D(^HLCS(870,HLLIEN,0)) S HLRESLT="0^15^Invalid HL Node in HLL('LINKS'): "_HLL("LINKS",I) Q
"RTN","HLMA",66,0)
 ;Extract data from Protocol file
"RTN","HLMA",67,0)
 D EVENT^HLUTIL1(HLEID,"15,20,771",.HLN)
"RTN","HLMA",68,0)
 S HLENROU=$G(HLN(20)),HLEXROU=$G(HLN(15))
"RTN","HLMA",69,0)
 S HLP("GROUTINE")=$G(HLN(771)) K HLN I HLP("GROUTINE")']"",'HLFORMAT S HLRESLT="0^3^"_$G(^HL(771.7,3,0)) G EXIT
"RTN","HLMA",70,0)
 ;Create message ID and Message Text IEN if Message Text IEN not
"RTN","HLMA",71,0)
 ;previously created ('$G(HLMTIEN))
"RTN","HLMA",72,0)
 I '$G(HLMTIEN) D CREATE^HLTF(.HLMID,.HLMTIEN,.HLDT,.HLDT1)
"RTN","HLMA",73,0)
 ;Get message ID if Message Text IEN already created
"RTN","HLMA",74,0)
 I '$G(HLMID) D
"RTN","HLMA",75,0)
 .S HLDT=$G(^HL(772,HLMTIEN,0)),HLMID=$P(HLDT,"^",6),HLDT=+HLDT
"RTN","HLMA",76,0)
 .S HLDT1=$$HLDATE^HLFNC(HLDT)
"RTN","HLMA",77,0)
 S HLMIDAR=0,HLRESLT=HLMID,HLP("DT")=HLDT,HLP("DTM")=HLDT1
"RTN","HLMA",78,0)
 ;Execute entry action for event driver protocol
"RTN","HLMA",79,0)
 I HLENROU]"" X HLENROU
"RTN","HLMA",80,0)
 ;Invoke transaction processor
"RTN","HLMA",81,0)
 K HLDT,HLDT1,HLENROU
"RTN","HLMA",82,0)
 D GENERATE^HLTP(HLMID,HLMTIEN,HLEID,HLARYTYP,HLFORMAT,.HLRESLT1,.HLP)
"RTN","HLMA",83,0)
 ;HLMIDAR is array of message IDs, only set for broadcast messages
"RTN","HLMA",84,0)
 I HLMIDAR K HLMIDAR("N") M HLRESLT=HLMIDAR
"RTN","HLMA",85,0)
 S HLRESLT=HLRESLT_"^"_HLRESLT1
"RTN","HLMA",86,0)
 ;
"RTN","HLMA",87,0)
 ; patch HL*1.6*122
"RTN","HLMA",88,0)
 S HLRESLT("HLMID")=$G(HLMIDAR("HLMID"))
"RTN","HLMA",89,0)
 S HLRESLT("IEN773")=$G(HLMIDAR("IEN773"))
"RTN","HLMA",90,0)
 ;
"RTN","HLMA",91,0)
 ;Execute exit action for event driver protocol
"RTN","HLMA",92,0)
 I HLEXROU]"" X HLEXROU
"RTN","HLMA",93,0)
EXIT ;Update status if Message Text file entry has been created
"RTN","HLMA",94,0)
 K HLTCP
"RTN","HLMA",95,0)
 I $D(HLMTIEN) D STATUS^HLTF0(HLMTIEN,$S($P(HLRESLT,"^",2):4,1:3),$S($P(HLRESLT,"^",2):$P(HLRESLT,"^",2),1:""),$S($P(HLRESLT,"^",2):$P(HLRESLT,"^",3),1:""))
"RTN","HLMA",96,0)
 K HLDT,HLDT1,HLMID,HLRESLT1,HLENROU,HLEXROU
"RTN","HLMA",97,0)
 Q
"RTN","HLMA",98,0)
DIRECT(HLEID,HLARYTYP,HLFORMAT,HLRESLT,HLMTIENO,HLP) ;
"RTN","HLMA",99,0)
 ;Entry point to generate an immediate message, must be TCP Logical Link
"RTN","HLMA",100,0)
 ;Input:
"RTN","HLMA",101,0)
 ;  The same as GENERATE,with one additional subscript to the HLP input 
"RTN","HLMA",102,0)
 ;  array:
"RTN","HLMA",103,0)
 ; 
"RTN","HLMA",104,0)
 ;  HLP("OPEN TIMEOUT") (optional, pass by reference) a number between 
"RTN","HLMA",105,0)
 ;    1 and 120 that specifies how many seconds the DIRECT CONNECT should
"RTN","HLMA",106,0)
 ;    try to open a connection before failing.  It is killed upon 
"RTN","HLMA",107,0)
 ;    completion.
"RTN","HLMA",108,0)
 ; 
"RTN","HLMA",109,0)
 N HLTCP,HLTCPO,HLPRIO,HLSAN,HLN,HLMIDAR,HLMTIENR,ZMID,HLDIRECT
"RTN","HLMA",110,0)
 ; patch HL*1.6*140- to protect application who call this entry
"RTN","HLMA",111,0)
 N IO,IOF,ION,IOT,IOST,POP
"RTN","HLMA",112,0)
 S HLRESLT=""
"RTN","HLMA",113,0)
 ;HLMTIENO=ien passed in, batch message
"RTN","HLMA",114,0)
 S HLMTIEN=$G(HLMTIENO)
"RTN","HLMA",115,0)
 I $G(HLP("OPEN TIMEOUT")),((HLP("OPEN TIMEOUT")\1)'=+HLP("OPEN TIMEOUT"))!HLP("OPEN TIMEOUT")>120 Q "0^4^INVALID OPEN TIMEOUT PARAMETER"
"RTN","HLMA",116,0)
 I $G(HLP("OPEN TIMEOUT")) D
"RTN","HLMA",117,0)
 .S HLDIRECT("OPEN TIMEOUT")=HLP("OPEN TIMEOUT")
"RTN","HLMA",118,0)
 .K HLP("OPEN TIMEOUT")
"RTN","HLMA",119,0)
 K HL,HLMTIENO
"RTN","HLMA",120,0)
 D INIT^HLFNC2(HLEID,.HL)
"RTN","HLMA",121,0)
 I $G(HL) S HLRESLT="0^"_HL Q
"RTN","HLMA",122,0)
 S HLPRIO="I" D CONT
"RTN","HLMA",123,0)
 ;HLMTIENO=original msg. ien in file 772, HLMTIENR=response ien set in HLMA2
"RTN","HLMA",124,0)
 S HLMTIENO=HLMTIEN,HLMTIEN=$G(HLMTIENR)
"RTN","HLMA",125,0)
 ;Set special HL variables
"RTN","HLMA",126,0)
 S HLQUIT=0,HLNODE="",HLNEXT="D HLNEXT^HLCSUTL"
"RTN","HLMA",127,0)
 Q
"RTN","HLMA",128,0)
 ;
"RTN","HLMA",129,0)
CLOSE(LOGLINK) ;close connection that was open in tag DIRECT
"RTN","HLMA",130,0)
 Q
"RTN","HLMA",131,0)
PING ;ping another VAMC to test Link
"RTN","HLMA",132,0)
 ;set HLQUIET =1 to skip writes
"RTN","HLMA",133,0)
 ;look for HLTPUT to get turnaround time over network.
"RTN","HLMA",134,0)
 N DA,DIC,HLDP,HLDPNM,HLDPDM,HLCSOUT,HLDBSIZE,HLDREAD,HLOS,HLTCPADD,HLTCPCS,HLTCPLNK,HLTCPORT,HLTCPRET,HLCSFAIL,HLPARAM
"RTN","HLMA",135,0)
 N HCS,HCSCMD,HLCS,HCSDAT,HCSER,HCSEXIT,HCSTRACE,HLDT1,HLDRETR,HLRETRA,HLDBACK,HLDWAIT,HLTCPCS,INPUT,OUTPUT,POP,X,Y,HLX1,HLX2
"RTN","HLMA",136,0)
 S HLQUIET=$G(HLQUIET)
"RTN","HLMA",137,0)
 S HLCS="",HCSTRACE="C: ",POP=1,INPUT="INPUT",OUTPUT="OUTPUT"
"RTN","HLMA",138,0)
 S DIC="^HLCS(870,",DIC(0)="QEAMZ"
"RTN","HLMA",139,0)
 D ^DIC Q:Y<0
"RTN","HLMA",140,0)
 S HLDP=+Y,HLDPNM=Y(0,0),HLDPDM=$P($$PARAM^HLCS2,U,2)
"RTN","HLMA",141,0)
 ;I $P($G(^HLCS(870,HLDP,400)),U)="" W !,"Missing IP Address" Q
"RTN","HLMA",142,0)
 D SETUP^HLCSAC G:HLCS PINGQ
"RTN","HLMA",143,0)
 ; patch HL*1.6*122
"RTN","HLMA",144,0)
 G:$$DONTPING^HLMA4 PINGQ
"RTN","HLMA",145,0)
 ;PING header=MSH^PING^domain^PING^logical link^datetime
"RTN","HLMA",146,0)
 S INPUT(1)="MSH^PING^"_HLDPDM_"^PING^"_HLDPNM_"^"_$$HTE^XLFDT($H)
"RTN","HLMA",147,0)
 D OPEN^HLCSAC
"RTN","HLMA",148,0)
 I HLCS D DNS G:HLCS PINGQ
"RTN","HLMA",149,0)
 D
"RTN","HLMA",150,0)
 . N $ETRAP,$ESTACK S $ETRAP="D PINGERR^HLMA"
"RTN","HLMA",151,0)
 . ;non-standard HL7 header; start block,header,end block
"RTN","HLMA",152,0)
 . S HLX1=$H
"RTN","HLMA",153,0)
 . ;
"RTN","HLMA",154,0)
 . ; HL*1.6*122 start
"RTN","HLMA",155,0)
 . ; replace flush character '!' with @IOF (! or #)
"RTN","HLMA",156,0)
 . ; W $C(11)_INPUT(1)_$C(28)_$C(13),! ;HL*1.6*115, restored ! char
"RTN","HLMA",157,0)
 . ; patch HL*1.6*140, flush character- HLTCPLNK("IOF")
"RTN","HLMA",158,0)
 . ; W $C(11)_INPUT(1)_$C(28)_$C(13),@IOF
"RTN","HLMA",159,0)
 . W $C(11)_INPUT(1)_$C(28)_$C(13),@HLTCPLNK("IOF")
"RTN","HLMA",160,0)
 . ; HL*1.6*122 end
"RTN","HLMA",161,0)
 . ;
"RTN","HLMA",162,0)
 . ;read response
"RTN","HLMA",163,0)
 . R X:HLDREAD
"RTN","HLMA",164,0)
 . S HLX2=$H
"RTN","HLMA",165,0)
 . S X=$P(X,$C(28)),HLCS=$S(X=INPUT(1):"PING worked",X="":"No response",1:"Incorrect response")
"RTN","HLMA",166,0)
 . ;Get roundtrip time
"RTN","HLMA",167,0)
 . K HLTPUT I X]"" S HLTPUT=$$HDIFF^XLFDT(HLX2,HLX1,2)
"RTN","HLMA",168,0)
 D CLOSE^%ZISTCP
"RTN","HLMA",169,0)
PINGQ ;write back status and quit
"RTN","HLMA",170,0)
 I 'HLQUIET W !,HLCS,!
"RTN","HLMA",171,0)
 Q
"RTN","HLMA",172,0)
PINGERR ;process errors from PING
"RTN","HLMA",173,0)
 S $ETRAP="G UNWIND^%ZTER",HLCS="-1^Error"
"RTN","HLMA",174,0)
 ;I $ZE["READ" S HLCS="-1^Error during read"
"RTN","HLMA",175,0)
 ;I $ZE["WRITE" S HLCS="-1^Error during write"
"RTN","HLMA",176,0)
 ; HL*1.6*115, SACC compliance
"RTN","HLMA",177,0)
 I $$EC^%ZOSV["READ" S HLCS="-1^Error during read"
"RTN","HLMA",178,0)
 I $$EC^%ZOSV["WRITE" S HLCS="-1^Error during write"
"RTN","HLMA",179,0)
 G UNWIND^%ZTER
"RTN","HLMA",180,0)
DNS ;
"RTN","HLMA",181,0)
 ;openfail-try DNS lookup-Link must contain point to Domain Name
"RTN","HLMA",182,0)
 S POP=$G(POP)
"RTN","HLMA",183,0)
 S HLQUIET=$G(HLQUIET)
"RTN","HLMA",184,0)
 I 'HLQUIET W !,"Calling DNS"
"RTN","HLMA",185,0)
 N HLDOM,HLIP S HLCS=""
"RTN","HLMA",186,0)
 S HLDOM=$P(^HLCS(870,HLDP,0),U,7)
"RTN","HLMA",187,0)
 ; patch HL*1.6*122 start
"RTN","HLMA",188,0)
 S HLDOM("DNS")=$P($G(^HLCS(870,+$G(HLDP),0)),"^",8)
"RTN","HLMA",189,0)
 ; I 'HLDOM,'HLQUIET W !,"Domain Unknown" Q
"RTN","HLMA",190,0)
 I 'HLDOM,($L(HLDOM("DNS"),".")<3) D  Q
"RTN","HLMA",191,0)
 . I 'HLQUIET W !,"Domain Unknown"
"RTN","HLMA",192,0)
 . S HLCS="-1^Connection Fail"
"RTN","HLMA",193,0)
 ; patch HL*1.6*122 end
"RTN","HLMA",194,0)
 I HLDOM S HLDOM=$P(^DIC(4.2,HLDOM,0),U)
"RTN","HLMA",195,0)
 ; patch HL*1.6*122
"RTN","HLMA",196,0)
 ; I HLDOM]"" D  Q:'POP
"RTN","HLMA",197,0)
 I HLDOM]""!($L(HLDOM("DNS"),".")>2) D  Q:'POP
"RTN","HLMA",198,0)
 . I HLDOM["VA.GOV"&(HLDOM'[".MED.") S HLDOM=$P(HLDOM,".VA.GOV")_".MED.VA.GOV"
"RTN","HLMA",199,0)
 . I HLTCPORT=5000 S HLDOM="HL7."_HLDOM
"RTN","HLMA",200,0)
 . I HLTCPORT=5500 S HLDOM="MPI."_HLDOM
"RTN","HLMA",201,0)
 . ; patch HL*1.6*122
"RTN","HLMA",202,0)
 . I ($L(HLDOM("DNS"),".")>2) S HLDOM=HLDOM("DNS")
"RTN","HLMA",203,0)
 . I 'HLQUIET W !,"Domain, "_HLDOM
"RTN","HLMA",204,0)
 . I 'HLQUIET W !,"Port: ",HLTCPORT
"RTN","HLMA",205,0)
 . S HLIP=$$ADDRESS^XLFNSLK(HLDOM)
"RTN","HLMA",206,0)
 . I HLIP]"",'HLQUIET W !,"DNS Returned: ",HLIP
"RTN","HLMA",207,0)
 . I HLIP]"" D
"RTN","HLMA",208,0)
 . . ;If more than one IP returned, try each, cache successful open
"RTN","HLMA",209,0)
 . . N HLI,HLJ,HLIP1
"RTN","HLMA",210,0)
 . . F HLJ=1:1:$L(HLIP,",") D  Q:'POP
"RTN","HLMA",211,0)
 . . . S HLIP1=$P(HLIP,",",HLJ)
"RTN","HLMA",212,0)
 . . . F HLI=1:1:HLDRETR W:'HLQUIET !,"Trying ",HLIP1 D CALL^%ZISTCP(HLIP1,HLTCPORT,1) Q:'POP
"RTN","HLMA",213,0)
 . . . I 'POP S $P(^HLCS(870,HLDP,400),U)=HLIP1
"RTN","HLMA",214,0)
 . . . U IO
"RTN","HLMA",215,0)
 I POP S HLCS="-1^DNS Lookup Failed"
"RTN","HLMA3")
0^4^B51960807^B26373063
"RTN","HLMA3",1,0)
HLMA3 ;OIFO-O/RJH-API TO LOGICAL LINK FILE ;05/30/08  16:05
"RTN","HLMA3",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,142**;Oct 13, 1995;Build 17
"RTN","HLMA3",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLMA3",4,0)
 Q
"RTN","HLMA3",5,0)
 ;
"RTN","HLMA3",6,0)
IEDOMAIN() ;
"RTN","HLMA3",7,0)
 ; API for retrieving domain of site's local Interface Engine
"RTN","HLMA3",8,0)
 ; from logical link VA-VIE
"RTN","HLMA3",9,0)
 ; 
"RTN","HLMA3",10,0)
 ; no input
"RTN","HLMA3",11,0)
 ; output:
"RTN","HLMA3",12,0)
 ; return DNS domain if available, else return null string.
"RTN","HLMA3",13,0)
 ;
"RTN","HLMA3",14,0)
 N HLTEMP
"RTN","HLMA3",15,0)
 ; retrive data from DNS Domain field of file #870
"RTN","HLMA3",16,0)
 S HLTEMP("VA-VIE-IEN")=$O(^HLCS(870,"B","VA-VIE",0))
"RTN","HLMA3",17,0)
 S HLTEMP("DOMAIN")=$P($G(^HLCS(870,+$G(HLTEMP("VA-VIE-IEN")),0)),"^",8)
"RTN","HLMA3",18,0)
 Q HLTEMP("DOMAIN")
"RTN","HLMA3",19,0)
 ;
"RTN","HLMA3",20,0)
LINKAPI(LINK,DOMAIN,AUTOSTAR) ;
"RTN","HLMA3",21,0)
 ; API for updating fields, DNS Domain and Autostart, of logical link
"RTN","HLMA3",22,0)
 ; the API may only be applied to production account.
"RTN","HLMA3",23,0)
 ; inputs: 
"RTN","HLMA3",24,0)
 ; LINK -     1. ien of HL Logical Link file (#870), or 
"RTN","HLMA3",25,0)
 ;            2. name (field 'Node'- #.01) of HL Logical Link file
"RTN","HLMA3",26,0)
 ;               (#870)
"RTN","HLMA3",27,0)
 ; DOMAIN -   data for DNS domain field (field #.08)
"RTN","HLMA3",28,0)
 ; AUTOSTAR - data for Autostart field (field #4.5),
"RTN","HLMA3",29,0)
 ;            0 for Disabled, 1 for Enabled. 
"RTN","HLMA3",30,0)
 ;            Otherwise, data won't be updated
"RTN","HLMA3",31,0)
 ;
"RTN","HLMA3",32,0)
 ; output could be either of the following:
"RTN","HLMA3",33,0)
 ; 1^DOMAIN,AUTOSTART have been updated 
"RTN","HLMA3",34,0)
 ; 1^DOMAIN has been updated 
"RTN","HLMA3",35,0)
 ; 1^AUTOSTART has been updated 
"RTN","HLMA3",36,0)
 ; -1^none has been updated
"RTN","HLMA3",37,0)
 ; -1^the api may not be applied to non-production account 
"RTN","HLMA3",38,0)
 ;
"RTN","HLMA3",39,0)
 N HLTEMP,HLZ
"RTN","HLMA3",40,0)
 ;retrieve data from HL Communication Server Parameter file (#869.3)
"RTN","HLMA3",41,0)
 ; - Default Processing Id (#.03) 
"RTN","HLMA3",42,0)
 ;
"RTN","HLMA3",43,0)
 S HLTEMP("PARAM")=$$PARAM^HLCS2
"RTN","HLMA3",44,0)
 S HLTEMP("DEFAULT-PROCESSING-ID")=$P(HLTEMP("PARAM"),"^",3)
"RTN","HLMA3",45,0)
 ;
"RTN","HLMA3",46,0)
 ; quit if this is a non-production account
"RTN","HLMA3",47,0)
 Q:HLTEMP("DEFAULT-PROCESSING-ID")'="P" "-1^the api may not be applied to non-production account"
"RTN","HLMA3",48,0)
 ;
"RTN","HLMA3",49,0)
 ; get input data for link ien or name
"RTN","HLMA3",50,0)
 S HLTEMP("IEN")=$G(LINK)
"RTN","HLMA3",51,0)
 I 'HLTEMP("IEN")&($L(HLTEMP("IEN"))) S HLTEMP("IEN")=+$O(^HLCS(870,"B",HLTEMP("IEN"),0))
"RTN","HLMA3",52,0)
 ;
"RTN","HLMA3",53,0)
 ; quit if no ien
"RTN","HLMA3",54,0)
 Q:'HLTEMP("IEN") "-1^none has been updated"
"RTN","HLMA3",55,0)
 ;
"RTN","HLMA3",56,0)
 ; get input data for DNS domain field
"RTN","HLMA3",57,0)
 S HLTEMP("DOMAIN")=$G(DOMAIN)
"RTN","HLMA3",58,0)
 ;
"RTN","HLMA3",59,0)
 ; get IP address for the domain
"RTN","HLMA3",60,0)
 I $L(HLTEMP("DOMAIN")) S HLTEMP("IP")=$$ADDRESS^XLFNSLK(HLTEMP("DOMAIN"))
"RTN","HLMA3",61,0)
 ;
"RTN","HLMA3",62,0)
 ; invalid domain, set it to null
"RTN","HLMA3",63,0)
 I $L(HLTEMP("DOMAIN")),'$G(HLTEMP("IP")) S HLTEMP("DOMAIN")=""
"RTN","HLMA3",64,0)
 ;
"RTN","HLMA3",65,0)
 ; get input data for Autostart field
"RTN","HLMA3",66,0)
 S HLTEMP("AUTOSTART")=$G(AUTOSTAR)
"RTN","HLMA3",67,0)
 ;
"RTN","HLMA3",68,0)
 ; quit if invalid data for both fields
"RTN","HLMA3",69,0)
 Q:($L(HLTEMP("DOMAIN"),".")'>2)&'((HLTEMP("AUTOSTART")="0")!(HLTEMP("AUTOSTART")="1")) "-1^none has been updated"
"RTN","HLMA3",70,0)
 I $L(HLTEMP("DOMAIN"),".")>2 D
"RTN","HLMA3",71,0)
 . S HLZ(870,HLTEMP("IEN")_",",.08)=HLTEMP("DOMAIN")
"RTN","HLMA3",72,0)
 I (HLTEMP("AUTOSTART")="0")!(HLTEMP("AUTOSTART")="1") D
"RTN","HLMA3",73,0)
 . S HLZ(870,HLTEMP("IEN")_",",4.5)=HLTEMP("AUTOSTART")
"RTN","HLMA3",74,0)
 D FILE^DIE("S","HLZ","HLZ")
"RTN","HLMA3",75,0)
 ;
"RTN","HLMA3",76,0)
 ; both fields are updated
"RTN","HLMA3",77,0)
 Q:$D(HLZ(870,HLTEMP("IEN")_",",.08))&($D(HLZ(870,HLTEMP("IEN")_",",4.5))) "1^DOMAIN,AUTOSTART have been updated"
"RTN","HLMA3",78,0)
 ;
"RTN","HLMA3",79,0)
 ; only update DNS Domain field
"RTN","HLMA3",80,0)
 Q:$D(HLZ(870,HLTEMP("IEN")_",",.08)) "1^DOMAIN has been updated"
"RTN","HLMA3",81,0)
 ;
"RTN","HLMA3",82,0)
 ; only update Autostart field
"RTN","HLMA3",83,0)
 Q:$D(HLZ(870,HLTEMP("IEN")_",",4.5)) "1^AUTOSTART has been updated"
"RTN","HLMA3",84,0)
 ;
"RTN","HLMA3",85,0)
IP(DA,HLIP) ;
"RTN","HLMA3",86,0)
 ; 1. API to update field TCP/IP Address, #870,400.01.
"RTN","HLMA3",87,0)
 ; 2. called from input transform of #870,.08 DNS Domain to update
"RTN","HLMA3",88,0)
 ;    field TCP/IP Address, #870,400.01.
"RTN","HLMA3",89,0)
 ;
"RTN","HLMA3",90,0)
 ; input:
"RTN","HLMA3",91,0)
 ; DA -   1. ien of HL Logical Link file (#870), or 
"RTN","HLMA3",92,0)
 ;        2. name (field 'Node'- #.01) of HL Logical Link file (#870)
"RTN","HLMA3",93,0)
 ; HLIP - IP addresses
"RTN","HLMA3",94,0)
 ; 
"RTN","HLMA3",95,0)
 ; output:
"RTN","HLMA3",96,0)
 ; return IP address updated to the field if valid,
"RTN","HLMA3",97,0)
 ; else return null string.
"RTN","HLMA3",98,0)
 ;
"RTN","HLMA3",99,0)
 N HLZ,HLI,HLTEMP
"RTN","HLMA3",100,0)
 ; 
"RTN","HLMA3",101,0)
 ; get input data
"RTN","HLMA3",102,0)
 S DA=$G(DA)
"RTN","HLMA3",103,0)
 I 'DA&($L(DA)) S DA=+$O(^HLCS(870,"B",DA,0))
"RTN","HLMA3",104,0)
 ;
"RTN","HLMA3",105,0)
 ; invalid ien
"RTN","HLMA3",106,0)
 Q:'DA ""
"RTN","HLMA3",107,0)
 ;
"RTN","HLMA3",108,0)
 ; invalid ip
"RTN","HLMA3",109,0)
 Q:('HLIP) ""
"RTN","HLMA3",110,0)
 ;
"RTN","HLMA3",111,0)
 ; get port number
"RTN","HLMA3",112,0)
 S HLTEMP("PORT")=+$P($G(^HLCS(870,DA,400)),"^",2)
"RTN","HLMA3",113,0)
 ;
"RTN","HLMA3",114,0)
 ; invalid port
"RTN","HLMA3",115,0)
 Q:'HLTEMP("PORT") ""
"RTN","HLMA3",116,0)
 ;
"RTN","HLMA3",117,0)
 S HLTEMP("IP")=""
"RTN","HLMA3",118,0)
 S HLTEMP("IP-VALID")=0
"RTN","HLMA3",119,0)
 S HLTEMP("IP-COUNT")=$L($G(HLIP),",")
"RTN","HLMA3",120,0)
 F HLI=1:1:HLTEMP("IP-COUNT") D  Q:HLTEMP("IP-VALID")
"RTN","HLMA3",121,0)
 . S HLTEMP("IP")=$P(HLIP,",",HLI)
"RTN","HLMA3",122,0)
 . I '$G(HLTCPLNK("TIMEOUT")) S HLTCPLNK("TIMEOUT")=5
"RTN","HLMA3",123,0)
 . D CALL^%ZISTCP(HLTEMP("IP"),HLTEMP("PORT"),HLTCPLNK("TIMEOUT"))
"RTN","HLMA3",124,0)
 . I 'POP D
"RTN","HLMA3",125,0)
 .. D CLOSE^%ZISTCP
"RTN","HLMA3",126,0)
 .. S HLTEMP("IP-VALID")=HLTEMP("IP")
"RTN","HLMA3",127,0)
 ;
"RTN","HLMA3",128,0)
 ; invalid ip, return null
"RTN","HLMA3",129,0)
 Q:'HLTEMP("IP-VALID") ""
"RTN","HLMA3",130,0)
 ;
"RTN","HLMA3",131,0)
 ; valid data to update the field
"RTN","HLMA3",132,0)
 S HLZ(870,DA_",",400.01)=HLTEMP("IP-VALID")
"RTN","HLMA3",133,0)
 D FILE^DIE("E","HLZ","HLZ")
"RTN","HLMA3",134,0)
 ;
"RTN","HLMA3",135,0)
 ; return the valid ip
"RTN","HLMA3",136,0)
 Q HLTEMP("IP-VALID")
"RTN","HLMA3",137,0)
 ;
"RTN","HLMA3",138,0)
FACILITY(LINK,DELIMITR) ;
"RTN","HLMA3",139,0)
 ; API for retrieving the station number and domain fields of logical
"RTN","HLMA3",140,0)
 ; link (file #870) and to be usd for populating in field MSH-6 
"RTN","HLMA3",141,0)
 ; (receiving facility) of message header.
"RTN","HLMA3",142,0)
 ;
"RTN","HLMA3",143,0)
 ; output format: institution number<delimiter>domain<delimiter>DNS
"RTN","HLMA3",144,0)
 ;
"RTN","HLMA3",145,0)
 ; inputs:
"RTN","HLMA3",146,0)
 ; LINK -       1. ien of HL Logical Link file (#870), or
"RTN","HLMA3",147,0)
 ;              2. name (field 'Node'- #.01) of HL Logical Link file
"RTN","HLMA3",148,0)
 ;               (#870)
"RTN","HLMA3",149,0)
 ; DELIMITR -  such as "~", "^", etc.
"RTN","HLMA3",150,0)
 ;
"RTN","HLMA3",151,0)
 ; output:
"RTN","HLMA3",152,0)
 ;        1.  institution number<delimiter>domain<delimiter>DNS
"RTN","HLMA3",153,0)
 ;        2.  <null> if input data is invalid
"RTN","HLMA3",154,0)
 ;
"RTN","HLMA3",155,0)
 ; note: if the domain retrieved from DNS domain field with "HL7."
"RTN","HLMA3",156,0)
 ;       or "MPI." prefixed at the beginning of the domain, the
"RTN","HLMA3",157,0)
 ;       prifixed "HL7." or "MPI." will be removed, in order to
"RTN","HLMA3",158,0)
 ;       meet the current implementation of Vista HL7.  Current
"RTN","HLMA3",159,0)
 ;       VISTA HL7 domain is retrieved from MailMan domain field,
"RTN","HLMA3",160,0)
 ;       the "HL7." or "MPI." is not prefixed at the beginning of
"RTN","HLMA3",161,0)
 ;       the domain when it is populated in field MSH-6 (receiving
"RTN","HLMA3",162,0)
 ;       facility) of message header. 
"RTN","HLMA3",163,0)
 ;
"RTN","HLMA3",164,0)
 N HLLINK,HLCINS,HLCDOM
"RTN","HLMA3",165,0)
 ;
"RTN","HLMA3",166,0)
 ; get input data for link ien or name
"RTN","HLMA3",167,0)
 S HLLINK=$G(LINK)
"RTN","HLMA3",168,0)
 I 'HLLINK,HLLINK]"" D
"RTN","HLMA3",169,0)
 .S HLLINK=$O(^HLCS(870,"B",HLLINK,0))
"RTN","HLMA3",170,0)
 ;
"RTN","HLMA3",171,0)
 ; quit if no ien
"RTN","HLMA3",172,0)
 Q:'HLLINK ""
"RTN","HLMA3",173,0)
 ;
"RTN","HLMA3",174,0)
 ; get DELIMITR
"RTN","HLMA3",175,0)
 S DELIMITR=$G(DELIMITR)
"RTN","HLMA3",176,0)
 ;
"RTN","HLMA3",177,0)
 ; quit if invalid DELIMITR
"RTN","HLMA3",178,0)
 Q:$L(DELIMITR)'=1 ""
"RTN","HLMA3",179,0)
 ;
"RTN","HLMA3",180,0)
 ; retrive data from DNS Domain field of file #870
"RTN","HLMA3",181,0)
 S HLCDOM("DNS")=$P($G(^HLCS(870,+HLLINK,0)),"^",8)
"RTN","HLMA3",182,0)
 ;
"RTN","HLMA3",183,0)
 ; remove the first piece if the first piece is "HL7" or "MPI"
"RTN","HLMA3",184,0)
 I ($P(HLCDOM("DNS"),".")="HL7")!($P(HLCDOM("DNS"),".")="MPI") D
"RTN","HLMA3",185,0)
 . S HLCDOM("DNS")=$P(HLCDOM("DNS"),".",2,99)
"RTN","HLMA3",186,0)
 ;
"RTN","HLMA3",187,0)
 S (HLCINS,HLCDOM)=""
"RTN","HLMA3",188,0)
 S HLCINS=$P(^HLCS(870,HLLINK,0),U,2)
"RTN","HLMA3",189,0)
 S HLCDOM=$P(^HLCS(870,HLLINK,0),U,7)
"RTN","HLMA3",190,0)
 ;
"RTN","HLMA3",191,0)
 ; quit if no data in institution and domain fields
"RTN","HLMA3",192,0)
 Q:('HLCINS)&('HLCDOM)&('$L(HLCDOM("DNS"))) ""
"RTN","HLMA3",193,0)
 ;
"RTN","HLMA3",194,0)
 ; initialize result
"RTN","HLMA3",195,0)
 S HLLINK("RESULT")=""
"RTN","HLMA3",196,0)
 ;
"RTN","HLMA3",197,0)
 ; if instition ien exists
"RTN","HLMA3",198,0)
 I HLCINS D
"RTN","HLMA3",199,0)
 . S HLCINS=$P($G(^DIC(4,HLCINS,99)),U)
"RTN","HLMA3",200,0)
 . ;
"RTN","HLMA3",201,0)
 . ; if valid station number exists
"RTN","HLMA3",202,0)
 . I HLCINS D
"RTN","HLMA3",203,0)
 .. ; set station number to the first piece of the result
"RTN","HLMA3",204,0)
 .. S HLLINK("RESULT")=HLCINS
"RTN","HLMA3",205,0)
 ;
"RTN","HLMA3",206,0)
 ; if MailMan domain ien exists
"RTN","HLMA3",207,0)
 I HLCDOM D
"RTN","HLMA3",208,0)
 . ;get MailMan domain name
"RTN","HLMA3",209,0)
 . S HLCDOM=$P(^DIC(4.2,HLCDOM,0),U)
"RTN","HLMA3",210,0)
 ;
"RTN","HLMA3",211,0)
 ; DNS domain overides MailMan domain
"RTN","HLMA3",212,0)
 I ($L(HLCDOM("DNS"),".")>2) D
"RTN","HLMA3",213,0)
 . S HLCDOM=HLCDOM("DNS")
"RTN","HLMA3",214,0)
 ;
"RTN","HLMA3",215,0)
 ; set third piece as "DNS" if domain is valid
"RTN","HLMA3",216,0)
 I ($L(HLCDOM,".")>2) D
"RTN","HLMA3",217,0)
 . ; set domain to the 2nd and 3rd pieces of the result
"RTN","HLMA3",218,0)
 . S HLLINK("RESULT")=HLLINK("RESULT")_DELIMITR_HLCDOM_DELIMITR_"DNS"
"RTN","HLMA3",219,0)
 Q HLLINK("RESULT")
"RTN","HLMA3",220,0)
 ;
"RTN","HLMA3",221,0)
VIEDOMNM() ;
"RTN","HLMA3",222,0)
 ; API for generating the domain of site's local Interface Engine
"RTN","HLMA3",223,0)
 ; if it could be generated based on the VISN, Station number, and
"RTN","HLMA3",224,0)
 ; the site's multi-listener, named beginning with "VA".  It returns
"RTN","HLMA3",225,0)
 ; null string if this API is executed in 'test' account.
"RTN","HLMA3",226,0)
 ;
"RTN","HLMA3",227,0)
 ; The real DNS Domain of the VIE server should be the one registered
"RTN","HLMA3",228,0)
 ; in the DNS service.
"RTN","HLMA3",229,0)
 ; The Domain gernerated by this API should not be used if it is not
"RTN","HLMA3",230,0)
 ; the same one gegistered in DNS.
"RTN","HLMA3",231,0)
 ; 
"RTN","HLMA3",232,0)
 ; no input
"RTN","HLMA3",233,0)
 ; output:
"RTN","HLMA3",234,0)
 ; return DNS domain if available, else return null string.
"RTN","HLMA3",235,0)
 ;
"RTN","HLMA3",236,0)
 ;retrieve data from HL Communication Server Parameter file (#869.3)
"RTN","HLMA3",237,0)
 ; - Default Processing Id (#.03) 
"RTN","HLMA3",238,0)
 ; - Institution (#.04)
"RTN","HLMA3",239,0)
 ;
"RTN","HLMA3",240,0)
 N HLPARAM
"RTN","HLMA3",241,0)
 N HLSITE,INSIEN,NODEIEN,FLAG
"RTN","HLMA3",242,0)
 ;
"RTN","HLMA3",243,0)
 S HLPARAM=$$PARAM^HLCS2
"RTN","HLMA3",244,0)
 S HLSITE("DEFAULT-PROCESSING-ID")=$P(HLPARAM,"^",3)
"RTN","HLMA3",245,0)
 ;
"RTN","HLMA3",246,0)
 ; ien of "Institution" (#4) file
"RTN","HLMA3",247,0)
 S INSIEN=$P(HLPARAM,"^",4)
"RTN","HLMA3",248,0)
 ;
"RTN","HLMA3",249,0)
 ; if this is a production accout and found the ien in the
"RTN","HLMA3",250,0)
 ; "Institution" file
"RTN","HLMA3",251,0)
 I HLSITE("DEFAULT-PROCESSING-ID")="P",INSIEN D
"RTN","HLMA3",252,0)
 . S FLAG=0
"RTN","HLMA3",253,0)
 . S NODEIEN=0
"RTN","HLMA3",254,0)
 . F  D  Q:('NODEIEN)!(FLAG=1)
"RTN","HLMA3",255,0)
 .. ;
"RTN","HLMA3",256,0)
 .. ; find the node ien of file #870
"RTN","HLMA3",257,0)
 .. S NODEIEN=$O(^HLCS(870,"C",INSIEN,NODEIEN))
"RTN","HLMA3",258,0)
 .. Q:'NODEIEN
"RTN","HLMA3",259,0)
 .. ;
"RTN","HLMA3",260,0)
 .. ; check if multi-listener
"RTN","HLMA3",261,0)
 .. Q:'$D(^HLCS(870,"E","M",NODEIEN))
"RTN","HLMA3",262,0)
 .. ;
"RTN","HLMA3",263,0)
 .. ; get node name
"RTN","HLMA3",264,0)
 .. S HLSITE("NODE")=$P(^HLCS(870,NODEIEN,0),"^")
"RTN","HLMA3",265,0)
 .. ;
"RTN","HLMA3",266,0)
 .. ; check first 2 characters of node name
"RTN","HLMA3",267,0)
 .. Q:$E(HLSITE("NODE"),1,2)'["VA"
"RTN","HLMA3",268,0)
 .. ;
"RTN","HLMA3",269,0)
 .. ; chech the port number if it is 5000
"RTN","HLMA3",270,0)
 .. Q:$P(^HLCS(870,NODEIEN,400),"^",2)'=5000
"RTN","HLMA3",271,0)
 .. ;
"RTN","HLMA3",272,0)
 .. S FLAG=1
"RTN","HLMA3",273,0)
 . ;
"RTN","HLMA3",274,0)
 . Q:'FLAG
"RTN","HLMA3",275,0)
 . ;
"RTN","HLMA3",276,0)
 . ; get station number
"RTN","HLMA3",277,0)
 . S HLSITE("STATION")=$P($$NNT^XUAF4(INSIEN),"^",2)
"RTN","HLMA3",278,0)
 . ;
"RTN","HLMA3",279,0)
 . Q:'HLSITE("STATION")
"RTN","HLMA3",280,0)
 . ;
"RTN","HLMA3",281,0)
 . ; find the VISN number
"RTN","HLMA3",282,0)
 . D PARENT^XUAF4("HLSITE",HLSITE("STATION"),"VISN")
"RTN","HLMA3",283,0)
 . S HLSITE("VISN-IEN")=$O(HLSITE("P",0))
"RTN","HLMA3",284,0)
 . Q:'HLSITE("VISN-IEN")
"RTN","HLMA3",285,0)
 . ;
"RTN","HLMA3",286,0)
 . S HLSITE("VISN-NAME")=$G(HLSITE("P",+HLSITE("VISN-IEN")))
"RTN","HLMA3",287,0)
 . S HLSITE("VISN-NUMBER")=+$P(HLSITE("VISN-NAME")," ",2)
"RTN","HLMA3",288,0)
 . Q:'HLSITE("VISN-NUMBER")
"RTN","HLMA3",289,0)
 . ;
"RTN","HLMA3",290,0)
 . I $L(HLSITE("VISN-NUMBER"))=1 D
"RTN","HLMA3",291,0)
 .. S HLSITE("VISN-NUMBER")="0"_HLSITE("VISN-NUMBER")
"RTN","HLMA3",292,0)
 . S HLSITE("DOMAIN")="VHA"_$E(HLSITE("NODE"),3,5)_"VIEV1.V"_HLSITE("VISN-NUMBER")_".MED.VA.GOV"
"RTN","HLMA3",293,0)
 ;
"RTN","HLMA3",294,0)
 Q $G(HLSITE("DOMAIN"))
"RTN","HLMA3",295,0)
 ;
"RTN","HLP142")
0^^B63471190^n/a
"RTN","HLP142",1,0)
HLP142 ;OIFO-O/RJH - HL*1.6*142 POST-INSTALL ROUTINE ;03/16/2009 16:39
"RTN","HLP142",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**142**;OCT 13, 1995;Build 17
"RTN","HLP142",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLP142",4,0)
 ;
"RTN","HLP142",5,0)
 ; check "ORLANDO VAMC" entry in Institution file (#4),
"RTN","HLP142",6,0)
 ; and "ORLANDO.MED.VA.GOV" entry in Domain file (#4.2)
"RTN","HLP142",7,0)
 ;
"RTN","HLP142",8,0)
 N HLPARAM,HLSITE
"RTN","HLP142",9,0)
 ;
"RTN","HLP142",10,0)
 S HLPARAM=$$PARAM^HLCS2
"RTN","HLP142",11,0)
 S HLSITE("DEFAULT-PROCESSING-ID")=$P(HLPARAM,"^",3)
"RTN","HLP142",12,0)
 ;
"RTN","HLP142",13,0)
 I HLSITE("DEFAULT-PROCESSING-ID")="P" D
"RTN","HLP142",14,0)
 . D MES^XPDUTL("Checking environment ...")
"RTN","HLP142",15,0)
 . I '$O(^DIC(4,"D",675,0)) D
"RTN","HLP142",16,0)
 .. S XPDQUIT=2
"RTN","HLP142",17,0)
 .. D BMES^XPDUTL("'ORLANDO VAMC' entry with station number as 675 does not exist in Institution")
"RTN","HLP142",18,0)
 .. D MES^XPDUTL("file.")
"RTN","HLP142",19,0)
 . I '$O(^DIC(4.2,"B","ORLANDO.MED.VA.GOV",0)) D
"RTN","HLP142",20,0)
 .. S XPDQUIT=2
"RTN","HLP142",21,0)
 .. D BMES^XPDUTL("'ORLANDO.MED.VA.GOV' entry does not exist in Domain file, patch XM*999*172")
"RTN","HLP142",22,0)
 .. D MES^XPDUTL("must be installed first.")
"RTN","HLP142",23,0)
 . I $G(XPDQUIT) D BMES^XPDUTL("Aborting installation...")
"RTN","HLP142",24,0)
 Q
"RTN","HLP142",25,0)
 ;
"RTN","HLP142",26,0)
POST ; post install
"RTN","HLP142",27,0)
 ;
"RTN","HLP142",28,0)
 D POST1
"RTN","HLP142",29,0)
 D POST2
"RTN","HLP142",30,0)
 ; D ENDPST
"RTN","HLP142",31,0)
 Q
"RTN","HLP142",32,0)
 ;
"RTN","HLP142",33,0)
POST2 ;
"RTN","HLP142",34,0)
 ; deal with VAORL entry in file #870.
"RTN","HLP142",35,0)
 ; Is VAORL entry in the HL LOGICAL LINK (#870) file?
"RTN","HLP142",36,0)
 ; If yes, continue, If no, quit.
"RTN","HLP142",37,0)
 ;
"RTN","HLP142",38,0)
 ;find ien of VAORL
"RTN","HLP142",39,0)
 N HLLINK
"RTN","HLP142",40,0)
 S HLLINK=$$VAORL()
"RTN","HLP142",41,0)
 Q:'HLLINK
"RTN","HLP142",42,0)
 ;
"RTN","HLP142",43,0)
 ; check and update fields of VAORL
"RTN","HLP142",44,0)
 D UPDATE2
"RTN","HLP142",45,0)
 Q
"RTN","HLP142",46,0)
 ;
"RTN","HLP142",47,0)
VAORL() ;
"RTN","HLP142",48,0)
 ; for VA-VIE entry
"RTN","HLP142",49,0)
 ;
"RTN","HLP142",50,0)
 N HLLLK
"RTN","HLP142",51,0)
 S HLLLK=+$$FIND1^DIC(870,"","X","VAORL")
"RTN","HLP142",52,0)
 ;
"RTN","HLP142",53,0)
 ; if no VAORL entry, abort install
"RTN","HLP142",54,0)
 I HLLLK=0 D
"RTN","HLP142",55,0)
 . D BMES^XPDUTL(" 'VAORL' logical link failed to come in with this patch.")
"RTN","HLP142",56,0)
 . D MES^XPDUTL(" Log a Remedy ticket for assistance before proceeding.")
"RTN","HLP142",57,0)
 . S XPDABORT=1
"RTN","HLP142",58,0)
 ;
"RTN","HLP142",59,0)
 Q HLLLK
"RTN","HLP142",60,0)
 ;
"RTN","HLP142",61,0)
UPDATE2 ;
"RTN","HLP142",62,0)
 ;update the following fields for logical link, VAORL:
"RTN","HLP142",63,0)
 ; - DNS Domain (#.08)
"RTN","HLP142",64,0)
 ; - Autostart (#4.5)
"RTN","HLP142",65,0)
 ; - Institution (#.02)
"RTN","HLP142",66,0)
 ;
"RTN","HLP142",67,0)
 N HLDOM
"RTN","HLP142",68,0)
 N HLPARAM,HLSITE
"RTN","HLP142",69,0)
 N HLJ
"RTN","HLP142",70,0)
 N DIE,DR,X
"RTN","HLP142",71,0)
 ;
"RTN","HLP142",72,0)
 S HLDOM="HL7.ORLANDO.MED.VA.GOV"
"RTN","HLP142",73,0)
 S HLPARAM=$$PARAM^HLCS2
"RTN","HLP142",74,0)
 S HLSITE("DEFAULT-PROCESSING-ID")=$P(HLPARAM,"^",3)
"RTN","HLP142",75,0)
 S HLSITE("INSTITUTION IEN")=$P(HLPARAM,"^",4)
"RTN","HLP142",76,0)
 S HLSITE("STATION NUMBER")=$P(^DIC(4,HLSITE("INSTITUTION IEN"),99),"^")
"RTN","HLP142",77,0)
 ;
"RTN","HLP142",78,0)
 D BMES^XPDUTL(" Updating 'VAORL' logical link ...")
"RTN","HLP142",79,0)
 F  L +^HLCS(870,HLLINK):3 Q:$T  H 1
"RTN","HLP142",80,0)
 ; update AUTOSTART and DNS domain field if this is production
"RTN","HLP142",81,0)
 ; account, MAILMAN DOMAIN fields should be updated by KIDS.
"RTN","HLP142",82,0)
 ;
"RTN","HLP142",83,0)
 I HLSITE("DEFAULT-PROCESSING-ID")="P",(HLSITE("STATION NUMBER")'=675) D
"RTN","HLP142",84,0)
 . ; find ien of institution file (#4) with station number as 675
"RTN","HLP142",85,0)
 . N ORLIEN,OTHER
"RTN","HLP142",86,0)
 . S ORLIEN=$O(^DIC(4,"D",675,0))
"RTN","HLP142",87,0)
 . ; if the ien with station number as 675 is pointed to by
"RTN","HLP142",88,0)
 . ; other link, remove it.
"RTN","HLP142",89,0)
 . I ORLIEN S OTHER=$O(^HLCS(870,"C",ORLIEN,0))
"RTN","HLP142",90,0)
 . I ORLIEN,OTHER,(ORLIEN'=OTHER) D
"RTN","HLP142",91,0)
 .. K ^HLCS(870,"C",ORLIEN)
"RTN","HLP142",92,0)
 .. S $P(^HLCS(870,OTHER,0),"^",2)=""
"RTN","HLP142",93,0)
 . S DIE="^HLCS(870,",DA=HLLINK,DR="4.5///1;.02///^S X=ORLIEN"
"RTN","HLP142",94,0)
 . ;
"RTN","HLP142",95,0)
 . I ($L($P(^HLCS(870,HLLINK,0),"^",8),".")'>2) D
"RTN","HLP142",96,0)
 .. ; the API FILE^DIE does not implement input transform
"RTN","HLP142",97,0)
 .. ; for updating TCP/IP ADDRESS field
"RTN","HLP142",98,0)
 .. S DR=DR_";.08///^S X=HLDOM"
"RTN","HLP142",99,0)
 . D ^DIE K DIE,DA,DR
"RTN","HLP142",100,0)
 ;
"RTN","HLP142",101,0)
 ; ORLANDO VAMC site should have VAORL entry as multi-listener. 
"RTN","HLP142",102,0)
 I (HLSITE("STATION NUMBER")=675) D
"RTN","HLP142",103,0)
 . N IP
"RTN","HLP142",104,0)
 . ; remove data from AUTOSTART field
"RTN","HLP142",105,0)
 . S $P(^HLCS(870,HLLINK,0),"^",6)=""
"RTN","HLP142",106,0)
 . ; remove data from PERSISTENT field
"RTN","HLP142",107,0)
 . S $P(^HLCS(870,HLLINK,400),"^",4)=""
"RTN","HLP142",108,0)
 . ; remove data from EXCEED RE-TRANSMIT ACTION field
"RTN","HLP142",109,0)
 . S $P(^HLCS(870,HLLINK,200),"^",10)=""
"RTN","HLP142",110,0)
 . ; remove data from DNS DOMAIN field
"RTN","HLP142",111,0)
 . S $P(^HLCS(870,HLLINK,0),"^",8)=""
"RTN","HLP142",112,0)
 . K ^HLCS(870,"DNS","HL7.ORLANDO.MED.VA.GOV")
"RTN","HLP142",113,0)
 . K ^HLCS(870,"DNS2","HL7.ORLANDO.MED.VA.GOV")
"RTN","HLP142",114,0)
 . ; remove data from TCP/IP ADDRESS field
"RTN","HLP142",115,0)
 . S IP=$P(^HLCS(870,HLLINK,400),"^")
"RTN","HLP142",116,0)
 . I IP D
"RTN","HLP142",117,0)
 .. S $P(^HLCS(870,HLLINK,400),"^")=""
"RTN","HLP142",118,0)
 .. K ^HLCS(870,"IP",IP)
"RTN","HLP142",119,0)
 . ; check TCP/IP SERVICE TYPE
"RTN","HLP142",120,0)
 . I $P(^HLCS(870,HLLINK,400),"^",3)'="M" D
"RTN","HLP142",121,0)
 .. S $P(^HLCS(870,HLLINK,400),"^",3)="M"
"RTN","HLP142",122,0)
 .. K ^HLCS(870,"E","C",HLLINK)
"RTN","HLP142",123,0)
 .. S ^HLCS(870,"E","M",HLLINK)=""
"RTN","HLP142",124,0)
 . ;
"RTN","HLP142",125,0)
 . ; find ien of institution file (#4) with station number as 675
"RTN","HLP142",126,0)
 . N ORLIEN,OTHER
"RTN","HLP142",127,0)
 . S ORLIEN=$O(^DIC(4,"D",675,0))
"RTN","HLP142",128,0)
 . ; if the ien with station number as 675 is pointed to by
"RTN","HLP142",129,0)
 . ; other link, remove it.
"RTN","HLP142",130,0)
 . I ORLIEN S OTHER=$O(^HLCS(870,"C",ORLIEN,0))
"RTN","HLP142",131,0)
 . I ORLIEN,OTHER,(OTHER'=HLLINK) D
"RTN","HLP142",132,0)
 .. K ^HLCS(870,"C",ORLIEN)
"RTN","HLP142",133,0)
 .. S $P(^HLCS(870,OTHER,0),"^",2)=""
"RTN","HLP142",134,0)
 . ;
"RTN","HLP142",135,0)
 . ; update institution field
"RTN","HLP142",136,0)
 . I HLSITE("INSTITUTION IEN"),HLSITE("DEFAULT-PROCESSING-ID")="P" D
"RTN","HLP142",137,0)
 .. I '$D(^HLCS(870,"C",HLSITE("INSTITUTION IEN"),HLLINK)) D
"RTN","HLP142",138,0)
 ... S ^HLCS(870,"C",HLSITE("INSTITUTION IEN"),HLLINK)=""
"RTN","HLP142",139,0)
 ... S $P(^HLCS(870,HLLINK,0),"^",2)=HLSITE("INSTITUTION IEN")
"RTN","HLP142",140,0)
 . ;
"RTN","HLP142",141,0)
 . ; check TEST account of ORLANDO
"RTN","HLP142",142,0)
 . I HLSITE("DEFAULT-PROCESSING-ID")'="P" D
"RTN","HLP142",143,0)
 .. I $P(^HLCS(870,HLLINK,400),"^",2)=5000 D
"RTN","HLP142",144,0)
 ... S $P(^HLCS(870,HLLINK,400),"^",2)=5025
"RTN","HLP142",145,0)
 .. I $P(^HLCS(870,HLLINK,400),"^",8)=5001 D
"RTN","HLP142",146,0)
 ... S $P(^HLCS(870,HLLINK,400),"^",8)=5026
"RTN","HLP142",147,0)
 ;
"RTN","HLP142",148,0)
 L -^HLCS(870,HLLINK)
"RTN","HLP142",149,0)
 ;
"RTN","HLP142",150,0)
ENDPST2 ;
"RTN","HLP142",151,0)
 ; no update of DNS domain field for non-production account
"RTN","HLP142",152,0)
 ;
"RTN","HLP142",153,0)
 I HLSITE("DEFAULT-PROCESSING-ID")'="P",(HLSITE("STATION NUMBER")'=675) D
"RTN","HLP142",154,0)
 . D MES^XPDUTL("")
"RTN","HLP142",155,0)
 . D MES^XPDUTL(" Because this is not a production account, the 'MAILMAN DOMAIN', 'DNS DOMAIN'")
"RTN","HLP142",156,0)
 . D MES^XPDUTL(", 'TCP/IP ADDRESS' and 'AUTOSTART' fields won't be updated.")
"RTN","HLP142",157,0)
 Q
"RTN","HLP142",158,0)
 ;
"RTN","HLP142",159,0)
POST1 ;
"RTN","HLP142",160,0)
 ; update data fields for local I.E. entry, VA-VIE.
"RTN","HLP142",161,0)
 ;
"RTN","HLP142",162,0)
 ; Is VA-VIE entry in the HL LOGICAL LINK (#870) file?
"RTN","HLP142",163,0)
 ; If yes, continue, If no, quit.
"RTN","HLP142",164,0)
 ;
"RTN","HLP142",165,0)
 ;find ien of VA-VIE
"RTN","HLP142",166,0)
 N HLLINK
"RTN","HLP142",167,0)
 S HLLINK=$$VAVIE()
"RTN","HLP142",168,0)
 Q:'HLLINK
"RTN","HLP142",169,0)
 ;
"RTN","HLP142",170,0)
 ; get domain of VIE server of this site
"RTN","HLP142",171,0)
 N HLDOM
"RTN","HLP142",172,0)
 S HLDOM=$$VIEDOMNM^HLMA3()
"RTN","HLP142",173,0)
 ;
"RTN","HLP142",174,0)
 ; update DNS Domain field of VA-VIE
"RTN","HLP142",175,0)
 D UPDATE
"RTN","HLP142",176,0)
 D OPTION
"RTN","HLP142",177,0)
 Q
"RTN","HLP142",178,0)
 ;
"RTN","HLP142",179,0)
OPTION ;
"RTN","HLP142",180,0)
 ; Changes the "SYNONYM" from "FM" to "FL" for item, "HL FILER 
"RTN","HLP142",181,0)
 ; MONITOR" [HL FILER MONITOR],in option "Filer and Link Management
"RTN","HLP142",182,0)
 ; Options" [HL MENU FILER LINK MGT]
"RTN","HLP142",183,0)
 ;
"RTN","HLP142",184,0)
 N DIC,X,DA,DR,DIE
"RTN","HLP142",185,0)
 S DIC="^DIC(19,",DIC(0)="X",X="HL FILER MONITOR"
"RTN","HLP142",186,0)
 D ^DIC
"RTN","HLP142",187,0)
 S DA("SUB")=+Y
"RTN","HLP142",188,0)
 S X="HL MENU FILER LINK MGT"
"RTN","HLP142",189,0)
 D ^DIC
"RTN","HLP142",190,0)
 S DA(1)=+Y
"RTN","HLP142",191,0)
 S DA=$O(^DIC(19,DA(1),10,"B",DA("SUB"),0))
"RTN","HLP142",192,0)
 S DIE="^DIC(19,"_DA(1)_",10,",DR="2///FL"
"RTN","HLP142",193,0)
 D ^DIE
"RTN","HLP142",194,0)
 Q
"RTN","HLP142",195,0)
VAVIE() ;
"RTN","HLP142",196,0)
 ; for VA-VIE entry
"RTN","HLP142",197,0)
 ;
"RTN","HLP142",198,0)
 N HLLLK
"RTN","HLP142",199,0)
 S HLLLK=+$$FIND1^DIC(870,"","X","VA-VIE")
"RTN","HLP142",200,0)
 ;
"RTN","HLP142",201,0)
 ; if no VA-VIE entry, abort install
"RTN","HLP142",202,0)
 I HLLLK=0 D
"RTN","HLP142",203,0)
 . D BMES^XPDUTL(" 'VA-VIE' logical link failed to come in with this patch.")
"RTN","HLP142",204,0)
 . D MES^XPDUTL(" Log a Remedy ticket for assistance before proceeding.")
"RTN","HLP142",205,0)
 . S XPDABORT=1
"RTN","HLP142",206,0)
 ;
"RTN","HLP142",207,0)
 Q HLLLK
"RTN","HLP142",208,0)
 ;
"RTN","HLP142",209,0)
UPDATE ;
"RTN","HLP142",210,0)
 ;update the following fields for logical link, VA-VIE:
"RTN","HLP142",211,0)
 ; - DNS Domain (#.08)
"RTN","HLP142",212,0)
 ; - Autostart (#4.5)
"RTN","HLP142",213,0)
 ;
"RTN","HLP142",214,0)
 N HLPARAM,HLSITE
"RTN","HLP142",215,0)
 N HLJ
"RTN","HLP142",216,0)
 N DIE,DR,X
"RTN","HLP142",217,0)
 ;
"RTN","HLP142",218,0)
 S HLPARAM=$$PARAM^HLCS2
"RTN","HLP142",219,0)
 S HLSITE("DEFAULT-PROCESSING-ID")=$P(HLPARAM,"^",3)
"RTN","HLP142",220,0)
 ;
"RTN","HLP142",221,0)
 D BMES^XPDUTL(" Updating 'VA-VIE' logical link ...")
"RTN","HLP142",222,0)
 F  L +^HLCS(870,HLLINK):3 Q:$T  H 1
"RTN","HLP142",223,0)
 ; update DNS domain field if this is production account
"RTN","HLP142",224,0)
 ; I HLSITE("DEFAULT-PROCESSING-ID")="P",$D(HLDOM) D
"RTN","HLP142",225,0)
 I HLSITE("DEFAULT-PROCESSING-ID")="P" D
"RTN","HLP142",226,0)
 . S DIE="^HLCS(870,",DA=HLLINK,DR="4.5///1"
"RTN","HLP142",227,0)
 . I $D(HLDOM),($L($P(^HLCS(870,HLLINK,0),"^",8),".")'>2) D
"RTN","HLP142",228,0)
 .. ; S HLJ(870,HLLINK_",",4.5)=1
"RTN","HLP142",229,0)
 .. ; S HLJ(870,HLLINK_",",.08)=HLDOM
"RTN","HLP142",230,0)
 .. ; the API FILE^DIE does not implement input transform
"RTN","HLP142",231,0)
 .. ; for updating TCP/IP ADDRESS field
"RTN","HLP142",232,0)
 .. ; D FILE^DIE("","HLJ")
"RTN","HLP142",233,0)
 .. S DR=DR_";.08///^S X=HLDOM"
"RTN","HLP142",234,0)
 . D ^DIE K DIE,DA,DR
"RTN","HLP142",235,0)
 ;
"RTN","HLP142",236,0)
 L -^HLCS(870,HLLINK)
"RTN","HLP142",237,0)
 ;
"RTN","HLP142",238,0)
 ; check the updated data of DNS domain field for production account
"RTN","HLP142",239,0)
 I HLSITE("DEFAULT-PROCESSING-ID")="P" D
"RTN","HLP142",240,0)
 . I $L($P(^HLCS(870,HLLINK,0),"^",8),".")'>2 D
"RTN","HLP142",241,0)
 .. D MES^XPDUTL("")
"RTN","HLP142",242,0)
 .. D MES^XPDUTL(" Failed to update the DNS Domain field for logical link VA-VIE.")
"RTN","HLP142",243,0)
 .. D MES^XPDUTL(" In order to make the link 'VA-VIE' work, data need to be entered in fields")
"RTN","HLP142",244,0)
 .. D MES^XPDUTL(" 'DNS DOMAIN'(field #.08) and/or 'TCP/IP ADDRESS'(field #400.01).")
"RTN","HLP142",245,0)
 ; no update of DNS domain field for non-production account
"RTN","HLP142",246,0)
ENDPST1 ;
"RTN","HLP142",247,0)
 I HLSITE("DEFAULT-PROCESSING-ID")'="P" D
"RTN","HLP142",248,0)
 . D MES^XPDUTL("")
"RTN","HLP142",249,0)
 . D MES^XPDUTL(" Because this is not a production account, the 'DNS DOMAIN', 'TCP/IP ADDRESS'")
"RTN","HLP142",250,0)
 . D MES^XPDUTL(" and 'AUTOSTART' fields won't be updated.")
"RTN","HLP142",251,0)
 Q
"RTN","HLP142",252,0)
 ;
"RTN","HLP142",253,0)
ENDPST ; quit
"RTN","HLP142",254,0)
 D BMES^XPDUTL(" Execution of post-install routine has been completed.")
"RTN","HLP142",255,0)
 Q
"RTN","HLP142",256,0)
 ;
"RTN","HLTF")
0^15^B24387774^B22809391
"RTN","HLTF",1,0)
HLTF ;AISC/SAW,JRP-Create/Process Message Text File Entries ;10/01/2008  14:05
"RTN","HLTF",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**1,19,43,55,109,120,122,142**;Oct 13, 1995;Build 17
"RTN","HLTF",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLTF",4,0)
 ;
"RTN","HLTF",5,0)
 Q
"RTN","HLTF",6,0)
 ;
"RTN","HLTF",7,0)
FILE ;Create Entries in files 772 and 773 for Version 1.5 Interface Only
"RTN","HLTF",8,0)
 D CREATE(,.HLDA,.HLDT,.HLDT1)
"RTN","HLTF",9,0)
 Q
"RTN","HLTF",10,0)
CREATE(HLMID,MTIEN,HLDT,HLDT1) ;Create entries in Message Text (#772)
"RTN","HLTF",11,0)
 ;
"RTN","HLTF",12,0)
 ;Input  : HLMID = Variable in which value of message ID will be
"RTN","HLTF",13,0)
 ;                 returned (pass by reference)
"RTN","HLTF",14,0)
 ;         MTIEN = Variable in which IEN of Message Text file entry
"RTN","HLTF",15,0)
 ;                 will be returned (pass by reference)
"RTN","HLTF",16,0)
 ;         HLDT = Variable in which current date/time in FM internal
"RTN","HLTF",17,0)
 ;                format will be returned (pass by reference)
"RTN","HLTF",18,0)
 ;         HLDT1 = Variable in which current date/time in HL7 format
"RTN","HLTF",19,0)
 ;                 will be returned (pass by reference)
"RTN","HLTF",20,0)
 ;
"RTN","HLTF",21,0)
 ;Output : See above
"RTN","HLTF",22,0)
 ;
"RTN","HLTF",23,0)
 ;Notes  : If HLDT has a value [upon entry], the created entries will
"RTN","HLTF",24,0)
 ;         be given that value for their date/time (value of .01)
"RTN","HLTF",25,0)
 ;       : Current date/time used if HLDT is not passed or invalid
"RTN","HLTF",26,0)
 ;
"RTN","HLTF",27,0)
 ;Make entry in Message Administration file
"RTN","HLTF",28,0)
 N Y
"RTN","HLTF",29,0)
 S HLDT=$G(HLDT)
"RTN","HLTF",30,0)
 D MT(.HLDT)
"RTN","HLTF",31,0)
 S Y=$$CHNGMID(MTIEN,.HLMID),HLDT1=$$HLDATE^HLFNC(HLDT)
"RTN","HLTF",32,0)
 Q
"RTN","HLTF",33,0)
TCP(HLMID,MTIEN,HLDT) ;create new message in 772 & 773 entries
"RTN","HLTF",34,0)
 ;used for incoming messages and outgoing responses
"RTN","HLTF",35,0)
 ;Input  : HLMID = Variable in which value of message ID will be
"RTN","HLTF",36,0)
 ;                 returned (pass by reference)
"RTN","HLTF",37,0)
 ;         MTIEN = Variable in which IEN of file 773 entry
"RTN","HLTF",38,0)
 ;                 will be returned (pass by reference)
"RTN","HLTF",39,0)
 ;         HLDT = Variable in which current date/time in FM internal
"RTN","HLTF",40,0)
 ;                format will be returned (pass by reference)
"RTN","HLTF",41,0)
 ;
"RTN","HLTF",42,0)
 S HLDT=$G(HLDT),HLMID=$G(HLMID)
"RTN","HLTF",43,0)
 D MT(.HLDT)
"RTN","HLTF",44,0)
 S MTIEN=$$MA(MTIEN,.HLMID)
"RTN","HLTF",45,0)
 Q
"RTN","HLTF",46,0)
 ;
"RTN","HLTF",47,0)
MT(HLX) ;Create entry in Message Text file (#772)
"RTN","HLTF",48,0)
 ;
"RTN","HLTF",49,0)
 ;Input  : HLX = Date/time entry in file should be given (value of .01)
"RTN","HLTF",50,0)
 ;               Defaults to current date/time
"RTN","HLTF",51,0)
 ;
"RTN","HLTF",52,0)
 ;Output : HLDT = Date/time of created entry (value of .01)
"RTN","HLTF",53,0)
 ;       : HLDT1 = HLDT in HL7 format
"RTN","HLTF",54,0)
 ;
"RTN","HLTF",55,0)
 ;Notes  : HLX must be in FileMan format (default value used if not)
"RTN","HLTF",56,0)
 ;       : HLDT will be in FileMan format
"RTN","HLTF",57,0)
 ;       : MTIEN is ien in file 772
"RTN","HLTF",58,0)
 ;
"RTN","HLTF",59,0)
 ;Check for input
"RTN","HLTF",60,0)
 S HLX=$G(HLX)
"RTN","HLTF",61,0)
 ;Declare variables
"RTN","HLTF",62,0)
 N DIC,DD,DO,HLCNT,HLJ,X,Y
"RTN","HLTF",63,0)
 F HLCNT=0:1 D  Q:Y>0  H HLCNT
"RTN","HLTF",64,0)
 . I (HLX'?7N.1".".6N) S HLX=$$NOW^XLFDT
"RTN","HLTF",65,0)
 . S DIC="^HL(772,",DIC(0)="L",(HLDT,X)=HLX
"RTN","HLTF",66,0)
 . S Y=$$STUB772(X) ; This call substituted for D FILE^DICN by HL*1.6*109
"RTN","HLTF",67,0)
 . ;Entry not created - try again
"RTN","HLTF",68,0)
 . I Y<0 S HLX="" Q
"RTN","HLTF",69,0)
 . S MTIEN=+Y
"RTN","HLTF",70,0)
 ;***If we didn't get a record in 772, need to do something
"RTN","HLTF",71,0)
 I Y<0 Q
"RTN","HLTF",72,0)
 S HLDT1=$$HLDATE^HLFNC(HLDT)
"RTN","HLTF",73,0)
 Q
"RTN","HLTF",74,0)
 ;add to Message Admin file #773
"RTN","HLTF",75,0)
MA(X,HLMID) ;X=ien in file 772, HLMID=msg. id (passed by ref.)
"RTN","HLTF",76,0)
 ;return ien in file 773
"RTN","HLTF",77,0)
 ;
"RTN","HLTF",78,0)
 ; patch HL*1.6*122: MPI-client/server start
"RTN","HLTF",79,0)
 F  L +^HL(772,+$G(X)):10 Q:$T  H 1
"RTN","HLTF",80,0)
 ; patch HL*1.6*142: MPI-client/server start
"RTN","HLTF",81,0)
 N COUNT,FLAG
"RTN","HLTF",82,0)
 S FLAG=0
"RTN","HLTF",83,0)
 F COUNT=1:1:15 D  Q:FLAG  H COUNT
"RTN","HLTF",84,0)
 . Q:'($D(^HL(772,X,0))#2)
"RTN","HLTF",85,0)
 . Q:($G(^HL(772,X,0))']"")
"RTN","HLTF",86,0)
 . S FLAG=1
"RTN","HLTF",87,0)
 ; patch HL*1.6*142: MPI-client/server end
"RTN","HLTF",88,0)
 Q:'$G(^HL(772,X,0)) 0
"RTN","HLTF",89,0)
 L -^HL(772,+$G(X))
"RTN","HLTF",90,0)
 ; patch HL*1.6*122: MPI-client/server end
"RTN","HLTF",91,0)
 ;
"RTN","HLTF",92,0)
 N DA,DD,DO,DIC,DIE,DR,HLDA,HLCNT,HLJ,Y
"RTN","HLTF",93,0)
 S DIC="^HLMA(",DIC(0)="L"
"RTN","HLTF",94,0)
 F HLCNT=0:1 D  Q:Y>0  H HLCNT
"RTN","HLTF",95,0)
 . S Y=$$STUB773(X) ; This call substituted for D FILE^DICN by HL*1.6*109
"RTN","HLTF",96,0)
 ;***If we didn't get a record in 773, need to do something
"RTN","HLTF",97,0)
 I Y<0 Q 0
"RTN","HLTF",98,0)
 S HLDA=+Y,HLMID=$$MAID(HLDA,$G(HLMID))
"RTN","HLTF",99,0)
 Q HLDA
"RTN","HLTF",100,0)
 ;
"RTN","HLTF",101,0)
MAID(Y,HLMID) ;Determine message ID (if needed) & store message ID
"RTN","HLTF",102,0)
 ;Y=ien in 773, HLMID=id,  Output message id
"RTN","HLTF",103,0)
 N HLJ
"RTN","HLTF",104,0)
 ;need to have id contain institution number to make unique
"RTN","HLTF",105,0)
 S:$G(HLMID)="" HLMID=+$P($$PARAM^HLCS2,U,6)_Y
"RTN","HLTF",106,0)
 S HLJ(773,Y_",",2)=HLMID
"RTN","HLTF",107,0)
 D FILE^HLDIE("","HLJ","","MAID","HLTF") ;HL*1.6*109
"RTN","HLTF",108,0)
 Q HLMID
"RTN","HLTF",109,0)
 ;
"RTN","HLTF",110,0)
CHNGMID(PTRMT,NEWID) ;Change message ID for entry in Message Text file
"RTN","HLTF",111,0)
 ;Input  : PTRMT - Pointer to entry in Message Text file (#772)
"RTN","HLTF",112,0)
 ;         NEWID - New message ID
"RTN","HLTF",113,0)
 ;Output : 0 = Success
"RTN","HLTF",114,0)
 ;         -1^ErrorText = Error/Bad input
"RTN","HLTF",115,0)
 ;
"RTN","HLTF",116,0)
 ;Check input
"RTN","HLTF",117,0)
 S PTRMT=+$G(PTRMT)
"RTN","HLTF",118,0)
 S NEWID=$G(NEWID)
"RTN","HLTF",119,0)
 Q:('$D(^HL(772,PTRMT,0))) "-1^Did not pass valid pointer to Message Text file (#772)"
"RTN","HLTF",120,0)
 N HLJ
"RTN","HLTF",121,0)
 I $G(NEWID)="" S NEWID=+$P($$PARAM^HLCS2,U,6)_PTRMT
"RTN","HLTF",122,0)
 S HLJ(772,PTRMT_",",6)=NEWID
"RTN","HLTF",123,0)
 D FILE^HLDIE("","HLJ","","CHNGMID","HLTF") ; HL*1.6*109
"RTN","HLTF",124,0)
 Q 0
"RTN","HLTF",125,0)
 ;
"RTN","HLTF",126,0)
OUT(HLDA,HLMID,HLMTN) ;File Data in Message Text File for Outgoing Message
"RTN","HLTF",127,0)
 ;Version 1.5 Interface Only
"RTN","HLTF",128,0)
 ;
"RTN","HLTF",129,0)
 ; patch HL*1.6*122: HLTF routine splitted, moves sub-routines,
"RTN","HLTF",130,0)
 ; OUT, IN, and ACK to HLTF2 routine.
"RTN","HLTF",131,0)
 ;
"RTN","HLTF",132,0)
 D OUT^HLTF2($G(HLDA),$G(HLMID),$G(HLMTN))
"RTN","HLTF",133,0)
 Q
"RTN","HLTF",134,0)
 ;
"RTN","HLTF",135,0)
IN(HLMTN,HLMID,HLTIME) ;File Data in Message Text File for Incoming Message
"RTN","HLTF",136,0)
 ;Version 1.5 Interface Only
"RTN","HLTF",137,0)
 ;
"RTN","HLTF",138,0)
 ; patch HL*1.6*122: HLTF routine splitted, moves sub-routines,
"RTN","HLTF",139,0)
 ; OUT, IN, and ACK to HLTF2 routine.
"RTN","HLTF",140,0)
 ;
"RTN","HLTF",141,0)
 D IN^HLTF2($G(HLMTN),$G(HLMID),$G(HLTIME))
"RTN","HLTF",142,0)
 Q
"RTN","HLTF",143,0)
 ;
"RTN","HLTF",144,0)
ACK(HLMSA,HLIO,HLDA) ;Process 'ACK' Message Type - Version 1.5 Interface Only
"RTN","HLTF",145,0)
 ;
"RTN","HLTF",146,0)
 ; patch HL*1.6*122: HLTF routine splitted, moves sub-routines,
"RTN","HLTF",147,0)
 ; OUT, IN, and ACK to HLTF2 routine.
"RTN","HLTF",148,0)
 ;
"RTN","HLTF",149,0)
 D ACK^HLTF2($G(HLMSA),$G(HLIO),$G(HLDA))
"RTN","HLTF",150,0)
 Q
"RTN","HLTF",151,0)
 ;
"RTN","HLTF",152,0)
STUB772(FLD01,OS) ;
"RTN","HLTF",153,0)
 ;This function creates a new stub record in file 772. The Stub record may consist of only the 0 node with a value of "^". If a value is passed in for the .01 field it will be included in the 0 node and its "B" x-ref set.
"RTN","HLTF",154,0)
 ;Inputs:
"RTN","HLTF",155,0)
 ;  OS (optional), the value of ^%ZOSF("OS")
"RTN","HLTF",156,0)
 ;  FLD01 (optional), the value for the .01 field
"RTN","HLTF",157,0)
 ;Output - the function returns the ien of the newly created record
"RTN","HLTF",158,0)
 ;
"RTN","HLTF",159,0)
 N IEN
"RTN","HLTF",160,0)
 I '$L($G(OS)) N OS S OS=$G(^%ZOSF("OS"))
"RTN","HLTF",161,0)
 ;
"RTN","HLTF",162,0)
 I OS'["DSM",OS'["OpenM" D
"RTN","HLTF",163,0)
 .F  L +^HLCS(869.3,1,772):10 S IEN=+$G(^HLCS(869.3,1,772))+1,^HLCS(869.3,1,772)=IEN S:$D(^HL(772,IEN)) IEN=0,^HLCS(869.3,1,772)=($O(^HL(772,":"),-1)\1) L -^HLCS(869.3,1,772) Q:IEN
"RTN","HLTF",164,0)
 E  D
"RTN","HLTF",165,0)
 .F  S IEN=$I(^HLCS(869.3,1,772),1) S:$D(^HL(772,IEN)) IEN=0,^HLCS(869.3,1,772)=($O(^HL(772,":"),-1)\1) Q:IEN
"RTN","HLTF",166,0)
 ;
"RTN","HLTF",167,0)
 ; patch HL*1.6*122: MPI-client/server start
"RTN","HLTF",168,0)
 F  L +^HL(772,IEN):10 Q:$T  H 1
"RTN","HLTF",169,0)
 S ^HL(772,IEN,0)=$G(FLD01)_"^"
"RTN","HLTF",170,0)
 I $L($G(FLD01)) S ^HL(772,"B",FLD01,IEN)=""
"RTN","HLTF",171,0)
 L -^HL(772,IEN)
"RTN","HLTF",172,0)
 ; patch HL*1.6*122: MPI-client/server end
"RTN","HLTF",173,0)
 ;
"RTN","HLTF",174,0)
 Q IEN
"RTN","HLTF",175,0)
 ;
"RTN","HLTF",176,0)
STUB773(FLD01,OS) ;
"RTN","HLTF",177,0)
 ;This function creates a new stub record in file 772. The Stub record may consist of only the 0 node with a value of "^". If a value is passed in for the .01 field it will be included in the 0 node and its "B" x-ref set.
"RTN","HLTF",178,0)
 ;Inputs:
"RTN","HLTF",179,0)
 ;  OS (optional), the value of ^%ZOSF("OS")
"RTN","HLTF",180,0)
 ;  FLD01 (optional), the value for the .01 field
"RTN","HLTF",181,0)
 ;Output - the function returns the ien of the newly created record
"RTN","HLTF",182,0)
 ;
"RTN","HLTF",183,0)
 N IEN
"RTN","HLTF",184,0)
 I '$L($G(OS)) N OS S OS=$G(^%ZOSF("OS"))
"RTN","HLTF",185,0)
 ;
"RTN","HLTF",186,0)
 I OS'["DSM",OS'["OpenM" D
"RTN","HLTF",187,0)
 .F  L +^HLCS(869.3,1,773):10 S IEN=+$G(^HLCS(869.3,1,773))+1,^HLCS(869.3,1,773)=IEN S:$D(^HLMA(IEN)) IEN=0,^HLCS(869.3,1,773)=($O(^HLMA(":"),-1)\1) L -^HLCS(869.3,1,773) Q:IEN
"RTN","HLTF",188,0)
 E  D
"RTN","HLTF",189,0)
 .F  S IEN=$I(^HLCS(869.3,1,773),1) S:$D(^HLMA(IEN)) IEN=0,^HLCS(869.3,1,773)=($O(^HLMA(":"),-1)\1) Q:IEN
"RTN","HLTF",190,0)
 ;
"RTN","HLTF",191,0)
 ; patch HL*1.6*122: MPI-client/server start
"RTN","HLTF",192,0)
 F  L +^HLMA(IEN):10 Q:$T  H 1
"RTN","HLTF",193,0)
 S ^HLMA(IEN,0)=$G(FLD01)_"^"
"RTN","HLTF",194,0)
 I $L($G(FLD01)) S ^HLMA("B",FLD01,IEN)=""
"RTN","HLTF",195,0)
 L -^HLMA(IEN)
"RTN","HLTF",196,0)
 ; patch HL*1.6*122: MPI-client/server end
"RTN","HLTF",197,0)
 ;
"RTN","HLTF",198,0)
 Q IEN
"RTN","HLTP3")
0^2^B126319348^B75311331
"RTN","HLTP3",1,0)
HLTP3 ;SFIRMFO/RSD - Transaction Processor for TCP ;09/30/2008  11:09
"RTN","HLTP3",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**19,43,57,58,59,66,69,109,115,108,116,117,125,120,133,122,140,142**;Oct 13, 1995;Build 17
"RTN","HLTP3",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLTP3",4,0)
 ;
"RTN","HLTP3",5,0)
 Q
"RTN","HLTP3",6,0)
NEW(X) ;process new msg. ien in 773^ien in 772
"RTN","HLTP3",7,0)
 ;HLMTIENS=ien in #773; HLMTIEN=ien in #772
"RTN","HLTP3",8,0)
 ;HLHDRO=original header;  HLHDR=response header
"RTN","HLTP3",9,0)
 ;set error trap
"RTN","HLTP3",10,0)
 N $ETRAP,$ESTACK S $ETRAP="D ERROR^HLTP3"
"RTN","HLTP3",11,0)
 N HL,HLEID,HLEIDS,HLERR,HLHDR,HLHDRO,HLMTIEN,HLMTIENS,HLJ,HLMSA,HLQUIT,HLNODE,HLNEXT,HLRESLTA,HLDONE1,HLASTRSP,HLRESLT
"RTN","HLTP3",12,0)
 S HLRESLT=""
"RTN","HLTP3",13,0)
 D INIT^HLTP3A
"RTN","HLTP3",14,0)
 ;error with header, return commit/app reject
"RTN","HLTP3",15,0)
 I $G(HLRESLT) D  Q
"RTN","HLTP3",16,0)
 . ;set status & unlock record
"RTN","HLTP3",17,0)
 . D STATUS^HLTF0(HLMTIENS,4,,,1),EXIT
"RTN","HLTP3",18,0)
 . ;quit if no commit or app ack
"RTN","HLTP3",19,0)
 . I $G(HL("ACAT"))="NE",$G(HL("APAT"))="NE" Q
"RTN","HLTP3",20,0)
 . S X=$S($G(HL("ACAT"))="AL":"CR",1:"AR")
"RTN","HLTP3",21,0)
 . ;HLTCP=ien of acknowledgment msg. from ACK^HLTP4
"RTN","HLTP3",22,0)
 . D ACK^HLTP4(X,$P(HLRESLT,U,2)) Q:'$G(HLTCP)
"RTN","HLTP3",23,0)
 . ;write ack back
"RTN","HLTP3",24,0)
 . S X=$$WRITE^HLCSTCP2(HLTCP)
"RTN","HLTP3",25,0)
 . ;update counter to sent
"RTN","HLTP3",26,0)
 . D LLCNT^HLCSTCP(HLDP,4)
"RTN","HLTP3",27,0)
 . ;update status of ack
"RTN","HLTP3",28,0)
 . D STATUS^HLTF0(HLTCP,3,,,1)
"RTN","HLTP3",29,0)
 ;
"RTN","HLTP3",30,0)
 ;check for duplicate msg., use rec. app and msg. id x-ref
"RTN","HLTP3",31,0)
 ; patch HL*1.6*142 start
"RTN","HLTP3",32,0)
 ; HL("HDR FLDS:3-6") extracted from field 3 to field 6 of header
"RTN","HLTP3",33,0)
 ; defined in HLDIE routine
"RTN","HLTP3",34,0)
 ; I $G(HL("MID"))]"",$G(HL("RAP")) S X=$O(^HLMA("AH",HL("RAP"),HL("MID"),0)) D  Q:'$D(HLMTIENS)
"RTN","HLTP3",35,0)
 I ($G(HL("MID"))]""),($G(HL("HDR FLDS:3-6"))]"") D  Q:'$D(HLMTIENS)
"RTN","HLTP3",36,0)
 . S X=$O(^HLMA("AH-NEW",HL("HDR FLDS:3-6"),HL("MID"),0))
"RTN","HLTP3",37,0)
 . ; patch HL*1.6*142 end
"RTN","HLTP3",38,0)
 . ;HLASTMSG=last ien received during this connection
"RTN","HLTP3",39,0)
 . ;if no duplicate, save msg. ien and quit
"RTN","HLTP3",40,0)
 . I X=HLMTIENS!'X S HLASTMSG=HLMTIENS Q
"RTN","HLTP3",41,0)
 . N MSH,OIENS
"RTN","HLTP3",42,0)
 . S (OIENS,Y)=X D  S Y=HLMTIENS D
"RTN","HLTP3",43,0)
 .. ;combine MSH into single string
"RTN","HLTP3",44,0)
 .. S MSH(Y)="",I=0 F  S I=$O(^HLMA(Y,"MSH",I)) Q:'I  S MSH(Y)=MSH(Y)_$G(^(I,0))
"RTN","HLTP3",45,0)
 .; patch 117 & 125, check if identical
"RTN","HLTP3",46,0)
 .I MSH(HLMTIENS)'=MSH(OIENS) S HLASTMSG=HLMTIENS Q
"RTN","HLTP3",47,0)
 .;
"RTN","HLTP3",48,0)
 . ;msg is duplicate, set status
"RTN","HLTP3",49,0)
 . D STATUS^HLTF0(HLMTIENS,4,109,"Duplicate with ien "_OIENS,1),EXIT
"RTN","HLTP3",50,0)
 . ;msg was resent, ignore it.
"RTN","HLTP3",51,0)
 . I HLASTMSG=HLMTIENS K HLMTIENS Q
"RTN","HLTP3",52,0)
 . ;find original response and send back
"RTN","HLTP3",53,0)
 . S HLASTRSP=$O(^HLMA("AF",OIENS,OIENS))
"RTN","HLTP3",54,0)
 . ; patch HL*1.6*142 start
"RTN","HLTP3",55,0)
 . ; the original msg may need to be updated again if 1st time
"RTN","HLTP3",56,0)
 . ; update failed
"RTN","HLTP3",57,0)
 . S HLASTMSG("OIENS")=OIENS
"RTN","HLTP3",58,0)
 . ;
"RTN","HLTP3",59,0)
 . ; the original message and its commit ACK were purged, OIENS is
"RTN","HLTP3",60,0)
 . ; duplicate and needs to create its own commit ACK (happened
"RTN","HLTP3",61,0)
 . ; between MPI and VIE in 9/2008), the OIENS will be processed
"RTN","HLTP3",62,0)
 . ; by the application routine again.
"RTN","HLTP3",63,0)
 . I $G(HL("ACAT"))="AL",'$G(HL("ACK")),'HLASTRSP D
"RTN","HLTP3",64,0)
 .. N HLTCP,HLMTIENS
"RTN","HLTP3",65,0)
 .. S HLMTIENS=OIENS
"RTN","HLTP3",66,0)
 .. D ACK^HLTP4("CA")
"RTN","HLTP3",67,0)
 .. D LLCNT^HLCSTCP(HLDP,3,1) ; decreament and will be added later
"RTN","HLTP3",68,0)
 .. S HLASTRSP=HLTCP
"RTN","HLTP3",69,0)
 . ; patch HL*1.6*142 end
"RTN","HLTP3",70,0)
 ;
"RTN","HLTP3",71,0)
 ;Quit if this is ack to ack
"RTN","HLTP3",72,0)
 I $G(HL("ACK")) D  Q
"RTN","HLTP3",73,0)
 . ;Update status of original ack message
"RTN","HLTP3",74,0)
 . D STATUS^HLTF0(HL("MTIENS"),3,,,1),STATUS^HLTF0(HLMTIENS,3,,,1)
"RTN","HLTP3",75,0)
 . ;unlock record
"RTN","HLTP3",76,0)
 . D EXIT
"RTN","HLTP3",77,0)
 ;
"RTN","HLTP3",78,0)
 ; enhance ack., send commit, quit if not an ack, msg will be 
"RTN","HLTP3",79,0)
 ; processed by filer
"RTN","HLTP3",80,0)
 I $G(HL("ACAT"))="AL" D  Q:'$G(HL("MTIENS"))
"RTN","HLTP3",81,0)
 . ;msg is a resend, HLASTRSP=ien of original response (commit ACK)
"RTN","HLTP3",82,0)
 .I $G(HLASTRSP) D
"RTN","HLTP3",83,0)
 ..S HLTCP=HLASTRSP
"RTN","HLTP3",84,0)
 ..D LLCNT^HLCSTCP(HLDP,3)
"RTN","HLTP3",85,0)
 . E  D  Q:'$G(HLTCP)
"RTN","HLTP3",86,0)
 ..D ACK^HLTP4("CA") ;**109** LLCNT^HLCSTCP(HLDP,3) called in ACK^HLTP4
"RTN","HLTP3",87,0)
 . ;
"RTN","HLTP3",88,0)
 . ; write commit ACK (original commit ACK)
"RTN","HLTP3",89,0)
 . S X=$$WRITE^HLCSTCP2(HLTCP)
"RTN","HLTP3",90,0)
 . ; patch HL*1.6*142
"RTN","HLTP3",91,0)
 . ; D LLCNT^HLCSTCP(HLDP,4),STATUS^HLTF0(HLTCP,3,,,1):'$G(HLASTRSP)
"RTN","HLTP3",92,0)
 . D LLCNT^HLCSTCP(HLDP,4)
"RTN","HLTP3",93,0)
 . I '$G(HLASTRSP) D
"RTN","HLTP3",94,0)
 .. D STATUS^HLTF0(HLTCP,3,,,1)
"RTN","HLTP3",95,0)
 . S HLTCP=""
"RTN","HLTP3",96,0)
 . ;if not an ack, set status to awaiting processing **109** and put on in queue
"RTN","HLTP3",97,0)
 . I '$G(HL("MTIENS")),'$G(HLASTRSP) D STATUS^HLTF0(HLMTIENS,9),EXIT,SETINQUE^HLTP31
"RTN","HLTP3",98,0)
 . ;
"RTN","HLTP3",99,0)
 . ; patch HL*1.6*142 start
"RTN","HLTP3",100,0)
 . ;if the original msg failed to en-queue and update status
"RTN","HLTP3",101,0)
 . ; it may happen when COTS disconnect the listener during
"RTN","HLTP3",102,0)
 . ; writing the commit ACK
"RTN","HLTP3",103,0)
 . ; deal with a non-application ACK duplicate message
"RTN","HLTP3",104,0)
 . I '$G(HL("MTIENS")),$G(HLASTRSP) D
"RTN","HLTP3",105,0)
 .. N STATUS
"RTN","HLTP3",106,0)
 .. S STATUS=+$G(^HLMA(HLASTRSP,"P"))
"RTN","HLTP3",107,0)
 .. I STATUS,(STATUS'=3) D
"RTN","HLTP3",108,0)
 ... ; update the original messsage, ien=HLASTMSG("OIENS")
"RTN","HLTP3",109,0)
 ... D STATUS^HLTF0(HLASTMSG("OIENS"),9)
"RTN","HLTP3",110,0)
 ... D EXIT
"RTN","HLTP3",111,0)
 ... N HLMTIENS
"RTN","HLTP3",112,0)
 ... S HLMTIENS=HLASTMSG("OIENS")
"RTN","HLTP3",113,0)
 ... D SETINQUE^HLTP31
"RTN","HLTP3",114,0)
 ... D STATUS^HLTF0(HLASTRSP,3,,,1)
"RTN","HLTP3",115,0)
 . ; patch HL*1.6*142 end
"RTN","HLTP3",116,0)
 ;
"RTN","HLTP3",117,0)
 ;enhance ack., no commit & no app ack
"RTN","HLTP3",118,0)
 I $G(HL("ACAT"))="NE",$G(HL("APAT"))="NE" D  Q
"RTN","HLTP3",119,0)
 . ;set status to awaiting processing, **109** and put on in queue
"RTN","HLTP3",120,0)
 . I '$G(HLASTRSP) D STATUS^HLTF0(HLMTIENS,9),EXIT,SETINQUE^HLTP31
"RTN","HLTP3",121,0)
 ;
"RTN","HLTP3",122,0)
 ; patch HL*1.6*120 start
"RTN","HLTP3",123,0)
 ;resending old response, msg is a resend
"RTN","HLTP3",124,0)
 ; do not re-send duplicate when $G(HL("ACAT"))="AL"
"RTN","HLTP3",125,0)
 ; the following resend is for original mode application ACK
"RTN","HLTP3",126,0)
 I $G(HLASTRSP),$G(HL("ACAT"))'="AL" S HLTCP=HLASTRSP G ACK
"RTN","HLTP3",127,0)
 ; patch HL*1.6*120 end
"RTN","HLTP3",128,0)
 ;
"RTN","HLTP3",129,0)
 ; patch HL*1.6*142 start
"RTN","HLTP3",130,0)
 ; to handle duplicate when the original message encountered
"RTN","HLTP3",131,0)
 ; a write error of commit ACK
"RTN","HLTP3",132,0)
 ; quit if duplicate
"RTN","HLTP3",133,0)
 ; Q:$G(HLASTRSP)
"RTN","HLTP3",134,0)
 S HLASTRSP("FLAG")=0
"RTN","HLTP3",135,0)
 I $G(HLASTRSP),$G(HL("ACAT"))="AL" D
"RTN","HLTP3",136,0)
 . I +$G(^HLMA(+$G(HLASTRSP),"P")),(+$P($G(^HLMA(+$G(HLASTRSP),"P")),"^")'=3) D
"RTN","HLTP3",137,0)
 .. S HLASTRSP("FLAG")=1
"RTN","HLTP3",138,0)
 ; don't quit if this is duplicate application ACK msg with accept
"RTN","HLTP3",139,0)
 ; ACK type="AL", and its original commit ACK is not done.
"RTN","HLTP3",140,0)
 I $G(HLASTRSP),('HLASTRSP("FLAG")) Q
"RTN","HLTP3",141,0)
 ;
"RTN","HLTP3",142,0)
 ; if duplicate, change ien to orginal msg ien
"RTN","HLTP3",143,0)
 I $G(HLASTRSP) D
"RTN","HLTP3",144,0)
 . S HLMTIENS=+$G(HLASTMSG("OIENS"))
"RTN","HLTP3",145,0)
 . S HLMTIEN=+$G(^HLMA(HLMTIENS,0))
"RTN","HLTP3",146,0)
 ; patch HL*1.6*142 end
"RTN","HLTP3",147,0)
 ;
"RTN","HLTP3",148,0)
CONT ;continue processing an enhance ack msg. called from DEFACK
"RTN","HLTP3",149,0)
 ;Set special HL variables for processing rtn
"RTN","HLTP3",150,0)
 S HLQUIT=0,HLNODE="",HLNEXT="D HLNEXT^HLCSUTL"
"RTN","HLTP3",151,0)
 ;
"RTN","HLTP3",152,0)
 ; message is an acknowledgement, HLMSA=ack code^id^text
"RTN","HLTP3",153,0)
 I ($G(HLMSA)]"") D  Q
"RTN","HLTP3",154,0)
 . ;X=1 if ack ok, 0=reject of error
"RTN","HLTP3",155,0)
 . S X=$E(HLMSA,2)="A"
"RTN","HLTP3",156,0)
 . ;Update status of original message and remove it from the queue
"RTN","HLTP3",157,0)
 . D STATUS^HLTF0(HL("MTIENS"),$S(X:3,1:4),"",$S(X:"",1:$P(HLMSA,HL("FS"),3)),1)
"RTN","HLTP3",158,0)
 . ; patch HL*1.6*142
"RTN","HLTP3",159,0)
 . ; time: original message receives the application ACK
"RTN","HLTP3",160,0)
 . S $P(^HLMA(HL("MTIENS"),"S"),"^",5)=$$NOW^XLFDT
"RTN","HLTP3",161,0)
 . D DEQUE^HLCSREP($P($G(^HLMA(HL("MTIENS"),0)),"^",7),"O",HL("MTIENS"))
"RTN","HLTP3",162,0)
 . D
"RTN","HLTP3",163,0)
 .. N HLTCP ;variable to update status in file #772.
"RTN","HLTP3",164,0)
 ..;
"RTN","HLTP3",165,0)
 ..;**108**
"RTN","HLTP3",166,0)
 .. N TEMP
"RTN","HLTP3",167,0)
 .. S TEMP=HLMTIENS
"RTN","HLTP3",168,0)
 .. N HLMTIENS
"RTN","HLTP3",169,0)
 .. S HLMTIENS=TEMP
"RTN","HLTP3",170,0)
 ..;**END 108**
"RTN","HLTP3",171,0)
 ..;
"RTN","HLTP3",172,0)
 .. ; patch HL*1.6*142 start
"RTN","HLTP3",173,0)
 .. ; time: starts to process the incoming message
"RTN","HLTP3",174,0)
 .. S $P(^HLMA(HLMTIENS,"S"),"^",6)=$$NOW^XLFDT
"RTN","HLTP3",175,0)
 .. D PROCACK^HLTP2(HLMTIEN,HL("EID"),.HLRESLT,.HL)
"RTN","HLTP3",176,0)
 .. ; time: ends processing the incoming message
"RTN","HLTP3",177,0)
 .. S $P(^HLMA(HLMTIENS,"S"),"^",7)=$$NOW^XLFDT
"RTN","HLTP3",178,0)
 . ; if duplicate, and the original msg failed to
"RTN","HLTP3",179,0)
 . ; complete the processing
"RTN","HLTP3",180,0)
 . I $G(HLASTRSP) D STATUS^HLTF0(HLASTRSP,3,,,1)
"RTN","HLTP3",181,0)
 . ; patch HL*1.6*142 end
"RTN","HLTP3",182,0)
 . ;update status of incoming & unlock
"RTN","HLTP3",183,0)
 . D STATUS^HLTF0(HLMTIENS,$S($G(HLRESLT):4,1:3),$S($G(HLRESLT):+$G(HLRESLT),1:""),$S($G(HLRESLT):$P(HLRESLT,U,2),1:""),1),EXIT
"RTN","HLTP3",184,0)
 ;
"RTN","HLTP3",185,0)
 ;get entry action, exit action and processing routine
"RTN","HLTP3",186,0)
 K HLHDR,HLLD0,HLLD1,HLMSA
"RTN","HLTP3",187,0)
 I HL("EIDS")="",$G(HLEIDS)]"" S HL("EIDS")=HLEIDS ;**CIRN**
"RTN","HLTP3",188,0)
 D EVENT^HLUTIL1(HL("EIDS"),"15,20,771",.HLN)
"RTN","HLTP3",189,0)
 S HLENROU=$G(HLN(20)),HLEXROU=$G(HLN(15)),HLPROU=$G(HLN(771))
"RTN","HLTP3",190,0)
 ;quit if no processing routine,update status and quit
"RTN","HLTP3",191,0)
 I HLPROU']"" S HLRESLT="10^"_$G(^HL(771.7,10,0)) D STATUS^HLTF0(HLMTIENS,3,,,1),EXIT Q
"RTN","HLTP3",192,0)
 ;HLORNOD=subscriber protocol for Fileman auditing, ien;global ref
"RTN","HLTP3",193,0)
 N HLORNODD S HLORNOD=HL("EIDS")_";ORD(101,"
"RTN","HLTP3",194,0)
 ;Execute entry action of client protocol
"RTN","HLTP3",195,0)
 X:HLENROU]"" HLENROU K HLENROU,HLDONE1
"RTN","HLTP3",196,0)
 ;
"RTN","HLTP3",197,0)
 ; patch HL*1.6*142 start
"RTN","HLTP3",198,0)
 ; time: starts to process the incoming message
"RTN","HLTP3",199,0)
 S $P(^HLMA(HLMTIENS,"S"),"^",6)=$$NOW^XLFDT
"RTN","HLTP3",200,0)
 ;Execute processing routine
"RTN","HLTP3",201,0)
 X HLPROU S HLRESLT=0 S:($D(HLERR)) HLRESLT="9^"_HLERR
"RTN","HLTP3",202,0)
 ; time: ends processing the incoming message
"RTN","HLTP3",203,0)
 S $P(^HLMA(HLMTIENS,"S"),"^",7)=$$NOW^XLFDT
"RTN","HLTP3",204,0)
 ; if duplicate, and the original msg failed to
"RTN","HLTP3",205,0)
 ; complete the processing
"RTN","HLTP3",206,0)
 I $G(HLASTRSP) D STATUS^HLTF0(HLASTRSP,3,,,1)
"RTN","HLTP3",207,0)
 ; patch HL*1.6*142 end
"RTN","HLTP3",208,0)
 ;update status of incoming to complete & unlock
"RTN","HLTP3",209,0)
 D STATUS^HLTF0(HLMTIENS,$S(HLRESLT:4,1:3),$S(HLRESLT:+HLRESLT,1:""),$S(HLRESLT:$P(HLRESLT,U,2),1:""),1,$S($G(HLERR("SKIP_EVENT"))=1:1,1:0)),EXIT
"RTN","HLTP3",210,0)
 ;HLTCPO=link open, HLTCP=ien of ack msg. from GENACK
"RTN","HLTP3",211,0)
ACK I $G(HLTCPO),$G(HLTCP) D  Q
"RTN","HLTP3",212,0)
 . D LLCNT^HLCSTCP(HLDP,3)
"RTN","HLTP3",213,0)
 . ;write ack back over open tcp link
"RTN","HLTP3",214,0)
 . S X=$$WRITE^HLCSTCP2(HLTCP)
"RTN","HLTP3",215,0)
 . ;update status of ack to complete
"RTN","HLTP3",216,0)
 . D:'$G(HLASTRSP) STATUS^HLTF0(HLTCP,3,,,1)
"RTN","HLTP3",217,0)
 . D LLCNT^HLCSTCP(HLDP,4)
"RTN","HLTP3",218,0)
 Q
"RTN","HLTP3",219,0)
 ;
"RTN","HLTP3",220,0)
DEFACK(HLDP,X) ;process the deferred application ack, called from HLCSIN
"RTN","HLTP3",221,0)
 ;HLDP=logical link, X=ien in file 773
"RTN","HLTP3",222,0)
 ;
"RTN","HLTP3",223,0)
 ; patch HL*1.6*120 start
"RTN","HLTP3",224,0)
 ; clean non-Kernel variables
"RTN","HLTP3",225,0)
 D
"RTN","HLTP3",226,0)
 . ; protect variables defined in STARTIN^HLCSIN
"RTN","HLTP3",227,0)
 . N HLFLG,HLEXIT,HLPTRFLR
"RTN","HLTP3",228,0)
 . ; protect variables defined in DEFACK^HLCSIN
"RTN","HLTP3",229,0)
 . N HLXX,HLD0,HLPCT
"RTN","HLTP3",230,0)
 . ; protect input parameters of this sub-routine
"RTN","HLTP3",231,0)
 . N HLDP,X
"RTN","HLTP3",232,0)
 . D KILL^XUSCLEAN
"RTN","HLTP3",233,0)
 ; patch HL*1.6*120 end
"RTN","HLTP3",234,0)
 ;
"RTN","HLTP3",235,0)
 ;set error trap
"RTN","HLTP3",236,0)
 N $ETRAP,$ESTACK S $ETRAP="D ERROR^HLTP3"
"RTN","HLTP3",237,0)
 N HLERR     ;patch HL*1.6*109
"RTN","HLTP3",238,0)
 Q:'$G(HLDP)!'$G(X)  Q:'$G(^HLMA(X,0))
"RTN","HLTP3",239,0)
 Q:'$D(^HLMA("AC","I",HLDP,X))
"RTN","HLTP3",240,0)
 ;
"RTN","HLTP3",241,0)
 N HL,HLA,HLD0,HLEID,HLEIDS,HLHDR,HLHDRO,HLMTIEN,HLMTIENS,HLJ,HLMSA,HLN,HLQUIT,HLNODE,HLNEXT,HLRESLT,HLRESLTA,HLTCP,HLXX,Z,HLDONE1
"RTN","HLTP3",242,0)
 S HLMTIENS=X,X=^HLMA(HLMTIENS,0),HLMTIEN=+$P(X,U),HL("MID")=$P(X,U,2),HL("MTIENS")=$P(X,U,10),HL("LL")=$P(X,U,7),HLTCP="",HL("Q")=""""""
"RTN","HLTP3",243,0)
 S HL("EIDS")=$P(X,U,8),HL("SAP")=$P(X,U,11),HL("RAP")=$P(X,U,12),HL("MTP")=$P(X,U,13),HL("ETP")=$P(X,U,14)
"RTN","HLTP3",244,0)
 S:$P(X,U,15) HL("MTP_ETP")=$P(X,U,15)
"RTN","HLTP3",245,0)
 S:HL("SAP") HL("SAN")=$P($G(^HL(771,HL("SAP"),0)),U) S:HL("RAP") HL("RAN")=$P($G(^HL(771,HL("RAP"),0)),U)
"RTN","HLTP3",246,0)
 S:HL("MTP") HL("MTN")=$P($G(^HL(771.2,HL("MTP"),0)),U) S:HL("ETP") HL("ETN")=$P($G(^HL(779.001,HL("ETP"),0)),U)
"RTN","HLTP3",247,0)
 S:$G(HL("MTP_ETP")) HL("MTN_ETN")=$P($G(^HL(779.005,HL("MTP_ETP"),0)),U)
"RTN","HLTP3",248,0)
 S HL("EID")=$P($G(^HL(772,HLMTIEN,0)),U,10)
"RTN","HLTP3",249,0)
 M HLHDRO=^HLMA(HLMTIENS,"MSH")
"RTN","HLTP3",250,0)
 ; if no header quit
"RTN","HLTP3",251,0)
 Q:'$O(HLHDRO(0))
"RTN","HLTP3",252,0)
 ;
"RTN","HLTP3",253,0)
 S HL("FS")=$E(HLHDRO(1,0),4),HL("ECH")=$$P^HLTPCK2(.HLHDRO,2),HL("SFN")=$$P^HLTPCK2(.HLHDRO,4),HL("RFN")=$$P^HLTPCK2(.HLHDRO,6),HL("DTM")=$$P^HLTPCK2(.HLHDRO,7)
"RTN","HLTP3",254,0)
 ;
"RTN","HLTP3",255,0)
 ; quit if ien of #772 is not defined
"RTN","HLTP3",256,0)
 Q:'HLMTIEN
"RTN","HLTP3",257,0)
 ; quit if field separator is not defined
"RTN","HLTP3",258,0)
 Q:HL("FS")=""
"RTN","HLTP3",259,0)
 ;
"RTN","HLTP3",260,0)
 S X=$$P^HLTPCK2(.HLHDRO,1)
"RTN","HLTP3",261,0)
 ;
"RTN","HLTP3",262,0)
 ; patch HL*1.6*120 start
"RTN","HLTP3",263,0)
 I X="MSH" D
"RTN","HLTP3",264,0)
 . S HL("PID")=$$P^HLTPCK2(.HLHDRO,11),HL("VER")=$$P^HLTPCK2(.HLHDRO,12),HL("APAT")=$$P^HLTPCK2(.HLHDRO,16),HL("CC")=$$P^HLTPCK2(.HLHDRO,17)
"RTN","HLTP3",265,0)
 . ;
"RTN","HLTP3",266,0)
 . ; 2nd component is Processing mode
"RTN","HLTP3",267,0)
 . S HL("PMOD")=$P(HL("PID"),$E(HL("ECH"),1),2)
"RTN","HLTP3",268,0)
 . ; first component is Processing id
"RTN","HLTP3",269,0)
 . S HL("PID")=$P(HL("PID"),$E(HL("ECH"),1))
"RTN","HLTP3",270,0)
 ;
"RTN","HLTP3",271,0)
 I X'="MSH" D
"RTN","HLTP3",272,0)
 . S X=$$P^HLTPCK2(.HLHDRO,9),Z=$E(HL("ECH")),HL("PID")=$P(X,Z,2),HL("VER")=$P(X,Z,4)
"RTN","HLTP3",273,0)
 . ;
"RTN","HLTP3",274,0)
 . ; original code incorrectly treats repetition separator as
"RTN","HLTP3",275,0)
 . ; subcomponent separator
"RTN","HLTP3",276,0)
 . I $E(HL("ECH"),2)]"",X[$E(HL("ECH"),2) D
"RTN","HLTP3",277,0)
 .. S HL("SUB-COMPONENT")=$E(HL("ECH"),2)
"RTN","HLTP3",278,0)
 . ; if subcomponent separator is correctly applied
"RTN","HLTP3",279,0)
 . I $E(HL("ECH"),4)]"",X[$E(HL("ECH"),4) D
"RTN","HLTP3",280,0)
 .. S HL("SUB-COMPONENT")=$E(HL("ECH"),4)
"RTN","HLTP3",281,0)
 . ;
"RTN","HLTP3",282,0)
 . I $D(HL("SUB-COMPONENT")),HL("PID")[HL("SUB-COMPONENT") D
"RTN","HLTP3",283,0)
 .. ; 2nd sub-component is Processing mode
"RTN","HLTP3",284,0)
 .. S HL("PMOD")=$P(HL("PID"),HL("SUB-COMPONENT"),2)
"RTN","HLTP3",285,0)
 .. ; first sub-component is Processing id
"RTN","HLTP3",286,0)
 .. S HL("PID")=$P(HL("PID"),HL("SUB-COMPONENT"))
"RTN","HLTP3",287,0)
 . ; patch HL*1.6*120 end
"RTN","HLTP3",288,0)
 . ;
"RTN","HLTP3",289,0)
 . Q:$$P^HLTPCK2(.HLHDRO,10)=""
"RTN","HLTP3",290,0)
 . ;HLMSA=ack code^id^text
"RTN","HLTP3",291,0)
 . S HLMSA=$P($$P^HLTPCK2(.HLHDRO,10),$E(HL("ECH")),1),$P(HLMSA,HL("FS"),2)=$$P^HLTPCK2(.HLHDRO,12),$P(HLMSA,HL("FS"),3)=$P($$P^HLTPCK2(.HLHDRO,10),$E(HL("ECH")),2),HL("MSAID")=$P(HLMSA,HL("FS"),2)
"RTN","HLTP3",292,0)
 ;
"RTN","HLTP3",293,0)
 ; quit if this is a commit ack
"RTN","HLTP3",294,0)
 I $P($G(^HL(772,HLMTIEN,"IN",1,0)),HL("FS"),1)="MSA",$E($P($G(^HL(772,HLMTIEN,"IN",1,0)),HL("FS"),2))="C" Q
"RTN","HLTP3",295,0)
 ;
"RTN","HLTP3",296,0)
 ;**  HL*1.6*117 **
"RTN","HLTP3",297,0)
 K HLL("SET FOR APP ACK"),HLL("LINKS")
"RTN","HLTP3",298,0)
 ;
"RTN","HLTP3",299,0)
 D CONT
"RTN","HLTP3",300,0)
 Q
"RTN","HLTP3",301,0)
 ;
"RTN","HLTP3",302,0)
MSA(Y) ;Y=ien in 772, returns MSA segment
"RTN","HLTP3",303,0)
 ;ack code^msg being ack id^text
"RTN","HLTP3",304,0)
 ; patch HL*1.6*122
"RTN","HLTP3",305,0)
 ; for HL7 v2.5 and beyond with MSA as 3rd segment
"RTN","HLTP3",306,0)
 N X,SUBIEN,DATA,DONE
"RTN","HLTP3",307,0)
 S X=$G(^HL(772,Y,"IN",1,0)),X=$S($E(X,1,3)="MSA":$E(X,5,999),1:"")
"RTN","HLTP3",308,0)
 Q:X]"" X
"RTN","HLTP3",309,0)
 ;
"RTN","HLTP3",310,0)
 S DONE=0
"RTN","HLTP3",311,0)
 S SUBIEN=1
"RTN","HLTP3",312,0)
 F  S SUBIEN=$O(^HL(772,Y,"IN",SUBIEN)) Q:'SUBIEN  D  Q:DONE
"RTN","HLTP3",313,0)
 . S DATA=$G(^HL(772,Y,"IN",SUBIEN,0)) I DATA="" D
"RTN","HLTP3",314,0)
 .. S DONE=1
"RTN","HLTP3",315,0)
 .. S SUBIEN=$O(^HL(772,Y,"IN",SUBIEN)) Q:'SUBIEN
"RTN","HLTP3",316,0)
 .. S X=$G(^HL(772,Y,"IN",SUBIEN,0)),X=$S($E(X,1,3)="MSA":$E(X,5,999),1:"")
"RTN","HLTP3",317,0)
 ; patch HL*1.6*122 end
"RTN","HLTP3",318,0)
 ;
"RTN","HLTP3",319,0)
 Q X
"RTN","HLTP3",320,0)
 ;
"RTN","HLTP3",321,0)
ERROR ;error trap
"RTN","HLTP3",322,0)
 D ^%ZTER
"RTN","HLTP3",323,0)
 I $G(HLMTIENS),$D(^HLMA(HLMTIENS,0)) D STATUS^HLTF0(HLMTIENS,4,,,1),EXIT
"RTN","HLTP3",324,0)
 ; release locks created by inbound filer
"RTN","HLTP3",325,0)
 ; patch HL*1.6*140
"RTN","HLTP3",326,0)
 ; L -^HLMA("AC","I",+$G(HLXX))
"RTN","HLTP3",327,0)
 L -^HLMA("IN-FILER","AC","I",+$G(HLXX))
"RTN","HLTP3",328,0)
 G UNWIND^%ZTER
"RTN","HLTP3",329,0)
 ;
"RTN","HLTP3",330,0)
 ;
"RTN","HLTP3",331,0)
EXIT ;unlock
"RTN","HLTP3",332,0)
 I $G(HLMTIENS) L -^HLMA(HLMTIENS)
"RTN","HLTP3",333,0)
 Q
"RTN","HLTP3",334,0)
 ;
"RTN","HLTP3",335,0)
ONAC(IEN773) ;
"RTN","HLTP3",336,0)
 ;Returns 1 if the message is on the "AC","I" xref
"RTN","HLTP3",337,0)
 ;Returns 0 otherwise
"RTN","HLTP3",338,0)
 ;
"RTN","HLTP3",339,0)
 N LINK
"RTN","HLTP3",340,0)
 S LINK=$P($G(^HLMA(IEN773,0)),"^",17)
"RTN","HLTP3",341,0)
 Q:'LINK 0
"RTN","HLTP3",342,0)
 Q $D(^HLMA("AC","I",LINK,IEN773))
"RTN","HLTP3A")
0^9^B2797877^B2301375
"RTN","HLTP3A",1,0)
HLTP3A ;SFIRMFO/RSD - Transaction Processor for TCP- INIT ;10/31/2008  11:01
"RTN","HLTP3A",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109,142**;Oct 13, 1995;Build 17
"RTN","HLTP3A",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLTP3A",4,0)
 ;
"RTN","HLTP3A",5,0)
 ;split from hltp3
"RTN","HLTP3A",6,0)
 Q
"RTN","HLTP3A",7,0)
INIT ;initialize variables, get MSA & header, returns HLRESLT if error
"RTN","HLTP3A",8,0)
 N HLJ
"RTN","HLTP3A",9,0)
 ;
"RTN","HLTP3A",10,0)
 K HLRESLT,HL
"RTN","HLTP3A",11,0)
 S HLMTIENS=+X,HLMTIEN=+$P(X,U,2),HLMSA=$$MSA^HLTP3(HLMTIEN)
"RTN","HLTP3A",12,0)
 ;
"RTN","HLTP3A",13,0)
 ;get header and validate
"RTN","HLTP3A",14,0)
 ; patch HL*1.6*142: locking code for MPI-client/server
"RTN","HLTP3A",15,0)
 F  L +^HLMA(HLMTIENS,"MSH"):10 Q:$T  H 1
"RTN","HLTP3A",16,0)
 F COUNT=1:1:15 Q:$G(^HLMA(HLMTIENS,"MSH",1,0))]""  H COUNT
"RTN","HLTP3A",17,0)
 M HLHDRO=^HLMA(HLMTIENS,"MSH")
"RTN","HLTP3A",18,0)
 L -^HLMA(HLMTIENS,"MSH")
"RTN","HLTP3A",19,0)
 ;HLMSA is by ref., for a batch msg HLMSA will be setup in HLTPCK2
"RTN","HLTP3A",20,0)
 D CHK^HLTPCK2(.HLHDRO,.HL,.HLMSA)
"RTN","HLTP3A",21,0)
 ;Update Message Administration file #773, for incoming message
"RTN","HLTP3A",22,0)
 ;3=trans type, 20=status
"RTN","HLTP3A",23,0)
 K HLJ
"RTN","HLTP3A",24,0)
 S X="HLJ(773,"""_HLMTIENS_","")",@X@(3)="I",@X@(20)=9
"RTN","HLTP3A",25,0)
 ;HL=error #^error text, 21=date process, 22=error msg, 23=error type
"RTN","HLTP3A",26,0)
 S:$G(HL) @X@(20)=4,@X@(21)=$$NOW^XLFDT,@X@(22)=$P(HL,U,2),@X@(23)=+HL
"RTN","HLTP3A",27,0)
 ;8=protocol, 13=sending app
"RTN","HLTP3A",28,0)
 S:$G(HL("EIDS")) @X@(8)=HL("EIDS") S:$G(HL("SAP")) @X@(13)=HL("SAP")
"RTN","HLTP3A",29,0)
 ;14=receiving app, 12=acknowledgement to
"RTN","HLTP3A",30,0)
 S:$G(HL("RAP")) @X@(14)=HL("RAP") S:$G(HL("MTIENS")) @X@(12)=HL("MTIENS")
"RTN","HLTP3A",31,0)
 ;6=initial message, 7=logical link
"RTN","HLTP3A",32,0)
 S:$G(HLTCPI) @X@(6)=HLTCPI S @X@(7)=HLDP
"RTN","HLTP3A",33,0)
 ;
"RTN","HLTP3A",34,0)
 ;15=message type, 16=event type
"RTN","HLTP3A",35,0)
 S:$G(HL("MTP")) @X@(15)=HL("MTP") S:$G(HL("ETP")) @X@(16)=HL("ETP")
"RTN","HLTP3A",36,0)
 ;HL*1.6*109 S:$G(HL("MTP_ETP")) @X@(17)=HL("MTP_ETP")
"RTN","HLTP3A",37,0)
 D FILE^HLDIE("","HLJ","","INIT-1","HLTP3A") ;HL*1.6*109
"RTN","HLTP3A",38,0)
 ;Update Message Text file #772
"RTN","HLTP3A",39,0)
 ;4=trans type
"RTN","HLTP3A",40,0)
 K HLJ S X="HLJ(772,"""_HLMTIEN_","")",@X@(4)="I"
"RTN","HLTP3A",41,0)
 ;10=event protocol
"RTN","HLTP3A",42,0)
 S:$G(HL("EID")) @X@(10)=HL("EID")
"RTN","HLTP3A",43,0)
 D FILE^HLDIE("","HLJ","","INIT-2","HLTP3A") ; HL*1.6*109
"RTN","HLTP3A",44,0)
 ;set HLRESLT to error
"RTN","HLTP3A",45,0)
 S:HL'="" HLRESLT=HL
"RTN","HLTP3A",46,0)
 Q
"RTN","HLTP4")
0^10^B46055553^B45154182
"RTN","HLTP4",1,0)
HLTP4 ;SFIRMFO/RSD - Transaction Processor for TCP ;06/24/2008  10:47
"RTN","HLTP4",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**19,57,59,91,109,116,117,125,120,142**;Oct 13, 1995;Build 17
"RTN","HLTP4",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLTP4",4,0)
GENACK ;called from HLMA1
"RTN","HLTP4",5,0)
 ;Entry point to generate an acknowledgement message
"RTN","HLTP4",6,0)
 ;for TCP
"RTN","HLTP4",7,0)
 ;INPUT:
"RTN","HLTP4",8,0)
 ;   HLMTIENS=original msg. ien #773
"RTN","HLTP4",9,0)
 ;   HLEID=original msg. event protocol
"RTN","HLTP4",10,0)
 ;   HLEIDS=original msg. subscriber protocol
"RTN","HLTP4",11,0)
 ;   HLMTIENA=ien of ack in 772, for batch only
"RTN","HLTP4",12,0)
 ;   Note:  if the HLP(...) array exists, it will be "honored" by
"RTN","HLTP4",13,0)
 ;          UPDATE^HLTF0 below. This includes the HLP("NAMESPACE")
"RTN","HLTP4",14,0)
 ;          variable. - HL*1.6*91
"RTN","HLTP4",15,0)
 ;
"RTN","HLTP4",16,0)
 ;OUTPUT: HLTCP=ien of response
"RTN","HLTP4",17,0)
 N HLDT,HLDT1,HLQ,HLOGLINK,HLMIDA,HLMTIEN,HLREC,HLSAN,HLTYPE,X
"RTN","HLTP4",18,0)
 ;Extract data from original message and store in separate variables
"RTN","HLTP4",19,0)
 ;reverse sending and receiving application from original msg.
"RTN","HLTP4",20,0)
 S X=$G(^HLMA(HLMTIENS,0)),HLREC=$P(X,U,11),HLSAN=$P(X,U,12),HLOGLINK=$G(HLTCPO)
"RTN","HLTP4",21,0)
 ;HLMTIENA defined, create msg in 773
"RTN","HLTP4",22,0)
 I $G(HLMTIENA) S HLDT=+$G(^HL(772,HLMTIENA,0)),HLMTIENA=$$MA^HLTF(HLMTIENA,.HLMIDA)
"RTN","HLTP4",23,0)
 ;create message in 772 & 773, HLMTIENA=new msg ien #773
"RTN","HLTP4",24,0)
 I '$G(HLMTIENA) D TCP^HLTF(.HLMIDA,.HLMTIENA,.HLDT)
"RTN","HLTP4",25,0)
 ;
"RTN","HLTP4",26,0)
 ;**109**
"RTN","HLTP4",27,0)
 ;lock new record
"RTN","HLTP4",28,0)
 ;F  L +^HLMA(HLMTIENA):1 Q:$T  H 1
"RTN","HLTP4",29,0)
 ;
"RTN","HLTP4",30,0)
 ;HLMTIEN=ien in 772
"RTN","HLTP4",31,0)
 S HLTCP=HLMTIENA,HLMTIEN=+^HLMA(HLMTIENA,0),HLDT1=$$HLDATE^HLFNC(HLDT),(HLTYPE,HLP("MSGTYPE"))=$E(HLARYTYP,2)
"RTN","HLTP4",32,0)
 ;
"RTN","HLTP4",33,0)
 ;**** HL*1.6*116 ****
"RTN","HLTP4",34,0)
 ;no open link, check dynamic routing of ack
"RTN","HLTP4",35,0)
 S X=$G(^ORD(101,HLEIDS,770)),HLP("MTYPE")=$P(X,U,11),HLP("EVENT")=$P(X,U,4)
"RTN","HLTP4",36,0)
 ;
"RTN","HLTP4",37,0)
 ; patch HL*1.6*125- change from $G to $D
"RTN","HLTP4",38,0)
 I '$D(HLL("SET FOR APP ACK")) D  Q:'HLOGLINK
"RTN","HLTP4",39,0)
 .K HLL("LINKS")
"RTN","HLTP4",40,0)
 .I 'HLOGLINK D
"RTN","HLTP4",41,0)
 .. S HLOGLINK=$P(X,U,7)
"RTN","HLTP4",42,0)
 .. Q:HLOGLINK
"RTN","HLTP4",43,0)
 .. N DOMAIN,SFAC,MSH,FS,CS,HLI,INST
"RTN","HLTP4",44,0)
 .. S MSH=$G(^HLMA(HLMTIENS,"MSH",1,0))
"RTN","HLTP4",45,0)
 .. Q:'$L(MSH)
"RTN","HLTP4",46,0)
 .. S FS=$E(MSH,4)
"RTN","HLTP4",47,0)
 .. Q:'$L(FS)
"RTN","HLTP4",48,0)
 .. S CS=$E(MSH,5)
"RTN","HLTP4",49,0)
 .. Q:'$L(CS)
"RTN","HLTP4",50,0)
 .. S DOMAIN=$P($P(MSH,FS,4),CS,2)
"RTN","HLTP4",51,0)
 .. ;
"RTN","HLTP4",52,0)
 .. ; patch HL*1.6*120 start
"RTN","HLTP4",53,0)
 .. ; assume the format is <domain>:<port #>
"RTN","HLTP4",54,0)
 .. I DOMAIN[":" S HLP("PORT")=$P(DOMAIN,":",2)
"RTN","HLTP4",55,0)
 .. S DOMAIN=$P(DOMAIN,":")
"RTN","HLTP4",56,0)
 .. S HLP("DNS-DOMAIN")=DOMAIN
"RTN","HLTP4",57,0)
 .. ;
"RTN","HLTP4",58,0)
 .. ; if first piece of domain is "HL7." or "MPI.", remove it
"RTN","HLTP4",59,0)
 .. I ($E(DOMAIN,1,4)="HL7.")!($E(DOMAIN,1,4)="MPI.") D
"RTN","HLTP4",60,0)
 ... S DOMAIN=$P(DOMAIN,".",2,99)
"RTN","HLTP4",61,0)
 .. ;
"RTN","HLTP4",62,0)
 .. ; lookup Mailman domain
"RTN","HLTP4",63,0)
 .. I $L(DOMAIN) D
"RTN","HLTP4",64,0)
 ... D LINK^HLUTIL3(DOMAIN,.HLI,"D")
"RTN","HLTP4",65,0)
 ... S HLOGLINK=$O(HLI(0))
"RTN","HLTP4",66,0)
 .. Q:HLOGLINK
"RTN","HLTP4",67,0)
 .. S INST=$P($P(MSH,FS,4),CS,1)
"RTN","HLTP4",68,0)
 .. I $L(INST) D
"RTN","HLTP4",69,0)
 .. .D LINK^HLUTIL3(INST,.HLI,"I")
"RTN","HLTP4",70,0)
 ... S HLOGLINK=$O(HLI(0))
"RTN","HLTP4",71,0)
 .. Q:HLOGLINK
"RTN","HLTP4",72,0)
 .. ;
"RTN","HLTP4",73,0)
 .. ; check DNS domain and ip address
"RTN","HLTP4",74,0)
 .. I $L(HLP("DNS-DOMAIN")) D
"RTN","HLTP4",75,0)
 ... ;
"RTN","HLTP4",76,0)
 ... ; match DNS domain
"RTN","HLTP4",77,0)
 ... I $D(^HLCS(870,"DNS",HLP("DNS-DOMAIN"))) D
"RTN","HLTP4",78,0)
 .... S HLOGLINK=+$O(^HLCS(870,"DNS",HLP("DNS-DOMAIN"),0))
"RTN","HLTP4",79,0)
 ... Q:HLOGLINK
"RTN","HLTP4",80,0)
 ... ;
"RTN","HLTP4",81,0)
 ... I $D(^HLCS(870,"DNS",$$UP^XLFSTR(HLP("DNS-DOMAIN")))) D
"RTN","HLTP4",82,0)
 .... S HLOGLINK=+$O(^HLCS(870,"DNS",$$UP^XLFSTR(HLP("DNS-DOMAIN")),0))
"RTN","HLTP4",83,0)
 ... Q:HLOGLINK
"RTN","HLTP4",84,0)
 ... ;
"RTN","HLTP4",85,0)
 ... I $D(^HLCS(870,"DNS",$$LOW^XLFSTR(HLP("DNS-DOMAIN")))) D
"RTN","HLTP4",86,0)
 .... S HLOGLINK=+$O(^HLCS(870,"DNS",$$LOW^XLFSTR(HLP("DNS-DOMAIN")),0))
"RTN","HLTP4",87,0)
 ... Q:HLOGLINK
"RTN","HLTP4",88,0)
 ... ;
"RTN","HLTP4",89,0)
 ... ; match ip address
"RTN","HLTP4",90,0)
 ... I $D(^HLCS(870,"IP",HLP("DNS-DOMAIN"))) D
"RTN","HLTP4",91,0)
 .... S HLOGLINK=+$O(^HLCS(870,"IP",HLP("DNS-DOMAIN"),0))
"RTN","HLTP4",92,0)
 .. ;
"RTN","HLTP4",93,0)
 ; patch HL*1.6*116 and patch HL*1.6*120 end
"RTN","HLTP4",94,0)
 ;
"RTN","HLTP4",95,0)
 ;** HL*1.6*117 **
"RTN","HLTP4",96,0)
 ; patch HL*1.6*125- change from $G to $D
"RTN","HLTP4",97,0)
 I $D(HLL("SET FOR APP ACK")) D  Q:'HLOGLINK
"RTN","HLTP4",98,0)
 .N I
"RTN","HLTP4",99,0)
 .S I=$O(HLL("LINKS",0))
"RTN","HLTP4",100,0)
 .I 'I S HLOGLINK="" Q
"RTN","HLTP4",101,0)
 .S HLOGLINK=$P(HLL("LINKS",I),"^",2) Q:HLOGLINK=""
"RTN","HLTP4",102,0)
 .I +HLOGLINK'=HLOGLINK S HLOGLINK=$O(^HLCS(870,"B",HLOGLINK,0))
"RTN","HLTP4",103,0)
 ;**END HL*1.6*117 **
"RTN","HLTP4",104,0)
 ;
"RTN","HLTP4",105,0)
 S:$P(X,U,5) HLP("MTYPE_EVENT")=$P(X,U,5)
"RTN","HLTP4",106,0)
 ;HLTCPI=initial message
"RTN","HLTP4",107,0)
 S:$G(HLTCPI) HLP("HLTCPI")=HLTCPI
"RTN","HLTP4",108,0)
 ;Update zero node of Message Admin file #773
"RTN","HLTP4",109,0)
 D UPDATE^HLTF0(HLTCP,,"O",HLEIDS,HLREC,HLSAN,"I",HLMTIENS,HLOGLINK,.HLP)
"RTN","HLTP4",110,0)
 ;
"RTN","HLTP4",111,0)
 ;Update status to Being Generated
"RTN","HLTP4",112,0)
 D STATUS^HLTF0(HLTCP,8)
"RTN","HLTP4",113,0)
 ;
"RTN","HLTP4",114,0)
 ;**109**
"RTN","HLTP4",115,0)
 ;tcp link is open, don't need x-ref, msg will be sent over link
"RTN","HLTP4",116,0)
 ;I $G(HLTCPO) K ^HLMA("AC","O",HLOGLINK,HLTCP)
"RTN","HLTP4",117,0)
 ;
"RTN","HLTP4",118,0)
 ;update zero node of Message Text file #772
"RTN","HLTP4",119,0)
 D
"RTN","HLTP4",120,0)
 . N HLTCP D UPDATE^HLTF0(HLMTIEN,,"O",HLEID)
"RTN","HLTP4",121,0)
 ;
"RTN","HLTP4",122,0)
 ;Execute entry action for subscriber protocol
"RTN","HLTP4",123,0)
 I HLENROU]"" X HLENROU
"RTN","HLTP4",124,0)
 S HLQ=""""
"RTN","HLTP4",125,0)
 ;Check that local/global array exists and store in Message Text file
"RTN","HLTP4",126,0)
 ; if pre-compiled
"RTN","HLTP4",127,0)
 I HLFORMAT D  I (+$G(HLRESLTA)) D STATUS^HLTF0(HLMTIENA,4,+HLRESLTA) G ERR
"RTN","HLTP4",128,0)
 . I $E(HLARYTYP)="G" D
"RTN","HLTP4",129,0)
 .. I $O(^TMP("HLA",$J,0))']"" S HLRESLTA="8^"_$G(^HL(771.7,8,0)) Q
"RTN","HLTP4",130,0)
 .. D MERGE^HLTF1("G",HLMTIEN,"HLA")
"RTN","HLTP4",131,0)
 . I $E(HLARYTYP)="L" D
"RTN","HLTP4",132,0)
 .. I $O(HLA("HLA",0))']"" S HLRESLTA="8^"_$G(^HL(771.7,8,0)) Q
"RTN","HLTP4",133,0)
 .. D MERGE^HLTF1("L",HLMTIEN,"HLA")
"RTN","HLTP4",134,0)
 ;If array is not pre-compiled, call message generation routine
"RTN","HLTP4",135,0)
 I 'HLFORMAT N HLERR D  I $D(HLERR) S HLRESLTA="9^"_HLERR D STATUS^HLTF0(HLMTIENA,4,9,HLERR) G ERR
"RTN","HLTP4",136,0)
 .S HLP("GROUTINE")=HLP("GROUTINE")_"("_HLMIDA_","_HLMTIENA_","_HLQ_HLARYTYP_HLQ_","_HLSAN_","_$P($G(^HL(771.2,$P(HLN(770),"^",3),0)),"^")_","_$P($G(^HL(779.001,$P(HLN(770),"^",4),0)),"^")_","_HLQ_$TR($P(HLN(770),"^",6),"id","ID")_HLQ_")"
"RTN","HLTP4",137,0)
 .X HLP("GROUTINE")
"RTN","HLTP4",138,0)
 ;
"RTN","HLTP4",139,0)
 ;create header for message in 773
"RTN","HLTP4",140,0)
 I (HLTYPE="M") D HEADER^HLCSHDR1(HLTCP,HLREC,.HLRESLT)
"RTN","HLTP4",141,0)
 I (HLTYPE'="M") D BHSHDR^HLCSHDR1(HLTCP,HLREC,.HLRESLT)
"RTN","HLTP4",142,0)
 ;if error set status to ERROR DURING TRANSMISSION
"RTN","HLTP4",143,0)
 I ($G(HLRESLT)'="") D STATUS^HLTF0(HLTCP,4,12,HLRESLT) G ERR
"RTN","HLTP4",144,0)
 ;set header, HLHDR in 773
"RTN","HLTP4",145,0)
 K HLQ S X=HLTCP_",",HLQ(773,X,200)="HLHDR"
"RTN","HLTP4",146,0)
 D FILE^HLDIE("","HLQ","","GENACK","HLTP4") ;HL*1.6*109
"RTN","HLTP4",147,0)
 ;D FILE^DIE("","HLQ")
"RTN","HLTP4",148,0)
 ;update status of 773 to PENDING TRANSMISSION
"RTN","HLTP4",149,0)
 D STATUS^HLTF0(HLTCP,1)
"RTN","HLTP4",150,0)
 ;Execute exit action for subscriber protocol
"RTN","HLTP4",151,0)
 X:HLEXROU]"" HLEXROU
"RTN","HLTP4",152,0)
 ;
"RTN","HLTP4",153,0)
 ;**109**
"RTN","HLTP4",154,0)
 ;tcp link is NOT open, need x-ref
"RTN","HLTP4",155,0)
 I '$G(HLTCPO) D ENQUE^HLCSREP(HLOGLINK,"O",HLTCP)
"RTN","HLTP4",156,0)
 ;
"RTN","HLTP4",157,0)
EXIT ;**109**
"RTN","HLTP4",158,0)
 ;L -^HLMA(HLMTIENA)
"RTN","HLTP4",159,0)
 Q
"RTN","HLTP4",160,0)
ERR D EXIT S HLTCP=""
"RTN","HLTP4",161,0)
 S:$G(HLRESLT) HLRESLTA=$G(HLRESLTA)_"^"_HLRESLT
"RTN","HLTP4",162,0)
 Q
"RTN","HLTP4",163,0)
ACK(HLTACK,HLMG) ;build response based on original msg header
"RTN","HLTP4",164,0)
 ;for Bi-directional TCP
"RTN","HLTP4",165,0)
 ;INPUT:
"RTN","HLTP4",166,0)
 ;   HLTACK=type of ack. CA,CR, or AR
"RTN","HLTP4",167,0)
 ;   HLMG=text for MSA segment
"RTN","HLTP4",168,0)
 ;   HLMTIENS=original msg. ien #773
"RTN","HLTP4",169,0)
 ;   HL(array) from original header
"RTN","HLTP4",170,0)
 ;RETURNS:  HLTCP=ien of response msg. in 773
"RTN","HLTP4",171,0)
 N HLDT,HLDT1,HLQ,HLFS,HLHDR,HLMIDA,HLMTIEN,HLMTIENA,HLP,HLREC,HLSAN,X
"RTN","HLTP4",172,0)
 ;quit if we don't have enough to make a msg.
"RTN","HLTP4",173,0)
 I $G(HL("ECH"))=""!($G(HL("FS"))="")!($G(HL("TYPE"))="") Q
"RTN","HLTP4",174,0)
 ;Extract data from original message and store in separate variables
"RTN","HLTP4",175,0)
 ;reverse sending and receiving application from original msg.
"RTN","HLTP4",176,0)
 S HLFS=HL("FS"),HLREC=$G(HL("SAN")),HLSAN=$G(HL("RAN"))
"RTN","HLTP4",177,0)
 ;create message in 772 & 773, HLMTIENA=new msg ien #773
"RTN","HLTP4",178,0)
 D TCP^HLTF(.HLMIDA,.HLMTIENA,.HLDT)
"RTN","HLTP4",179,0)
 ;lock new record
"RTN","HLTP4",180,0)
 ;**109**
"RTN","HLTP4",181,0)
 ;F  L +^HLMA(HLMTIENA):1 Q:$T  H 1
"RTN","HLTP4",182,0)
 ;
"RTN","HLTP4",183,0)
 ;HLMTIEN=ien in 772
"RTN","HLTP4",184,0)
 S HLTCP=HLMTIENA,HLMTIEN=+^HLMA(HLMTIENA,0),HLDT1=$$FMTHL7^XLFDT(HLDT)
"RTN","HLTP4",185,0)
 ;get 'msgtype'=B or M, message type and event type
"RTN","HLTP4",186,0)
 S HLP("MSGTYPE")=$E(HL("TYPE")),HLP("MTYPE")=$G(HL("MTP")),HLP("EVENT")=$G(HL("ETP")),HLP("HLTCPI")=HLMTIENS
"RTN","HLTP4",187,0)
 S:$G(HL("MTP_ETP")) HLP("MTYPE_EVENT")=$G(HL("MTP_ETP"))
"RTN","HLTP4",188,0)
 ; HL*1.6*117 start
"RTN","HLTP4",189,0)
 ; change the order of when updates are done on file 773
"RTN","HLTP4",190,0)
 ;Update zero node of Message Admin file #773
"RTN","HLTP4",191,0)
 ;D UPDATE^HLTF0(HLTCP,,"O",,HLREC,HLSAN,"I",HLMTIENS,HLDP,.HLP)
"RTN","HLTP4",192,0)
 ;
"RTN","HLTP4",193,0)
 ;don't need x-ref, msg will be sent back over open tcp link
"RTN","HLTP4",194,0)
 ;**109**
"RTN","HLTP4",195,0)
 ;D LLCNT^HLCSTCP(HLDP,3)
"RTN","HLTP4",196,0)
 ;K ^HLMA("AC","O",HLDP,HLTCP)
"RTN","HLTP4",197,0)
 ;
"RTN","HLTP4",198,0)
 ;Update status to Being Generated
"RTN","HLTP4",199,0)
 ;D STATUS^HLTF0(HLTCP,8)
"RTN","HLTP4",200,0)
 ; HL*1.6*117 end
"RTN","HLTP4",201,0)
 ;update zero node of Message Text file #772
"RTN","HLTP4",202,0)
 D
"RTN","HLTP4",203,0)
 . N HLTCP D UPDATE^HLTF0(HLMTIEN,,"O")
"RTN","HLTP4",204,0)
 ;
"RTN","HLTP4",205,0)
 ;build MSA segment
"RTN","HLTP4",206,0)
 K HLA
"RTN","HLTP4",207,0)
 S HLA("HLS",1)="MSA"_HLFS_HLTACK_HLFS_$G(HL("MID"))
"RTN","HLTP4",208,0)
 S:$G(HLMG)]"" HLA("HLS",1)=HLA("HLS",1)_HLFS_HLMG
"RTN","HLTP4",209,0)
 ;update file 772 with msg text
"RTN","HLTP4",210,0)
 D MERGE^HLTF1("L",HLMTIEN,"HLS")
"RTN","HLTP4",211,0)
 D HDR
"RTN","HLTP4",212,0)
 ;update file 773 with msg header
"RTN","HLTP4",213,0)
 K HLQ S HLQ(773,HLTCP_",",200)="HLHDR"
"RTN","HLTP4",214,0)
 D FILE^HLDIE("","HLQ","","ACK","HLTP4") ; HL*1.6*109
"RTN","HLTP4",215,0)
 ;D FILE^DIE("","HLQ")
"RTN","HLTP4",216,0)
 ; HL*1.6*117 start
"RTN","HLTP4",217,0)
 ; finally commit updates to 773 that will affect behavior of messaging
"RTN","HLTP4",218,0)
 ;Update status to Being Generated
"RTN","HLTP4",219,0)
 D STATUS^HLTF0(HLTCP,8)
"RTN","HLTP4",220,0)
 ;Update zero node of Message Admin file #773
"RTN","HLTP4",221,0)
 ; patch HL*1.6*142
"RTN","HLTP4",222,0)
 ; update ien of sending application (from HL("RAP") of the incoming msg),
"RTN","HLTP4",223,0)
 ; ien of receiving application (from HL("SAP") of the incoming msg),
"RTN","HLTP4",224,0)
 ; and subscriber protocol
"RTN","HLTP4",225,0)
 ; D UPDATE^HLTF0(HLTCP,,"O",,HLREC,HLSAN,"I",HLMTIENS,HLDP,.HLP)
"RTN","HLTP4",226,0)
 D UPDATE^HLTF0(HLTCP,,"O",$G(HL("EIDS")),$G(HL("SAP")),$G(HL("RAP")),"I",HLMTIENS,HLDP,.HLP)
"RTN","HLTP4",227,0)
 ; update message sent count
"RTN","HLTP4",228,0)
 D LLCNT^HLCSTCP(HLDP,3)
"RTN","HLTP4",229,0)
 ; HL*1.6*117 end
"RTN","HLTP4",230,0)
 G EXIT
"RTN","HLTP4",231,0)
 ;
"RTN","HLTP4",232,0)
HDR ; build header for commit ack
"RTN","HLTP4",233,0)
 K HLHDR
"RTN","HLTP4",234,0)
 S HLHDR(1)=HL("TYPE")_HLFS_HL("ECH")_HLFS_HLSAN_HLFS_$G(HL("RFN"))_HLFS_HLREC_HLFS_$G(HL("SFN"))_HLFS_HLDT1_HLFS_HLFS
"RTN","HLTP4",235,0)
 I HLP("MSGTYPE")="M" S HLHDR(1)=HLHDR(1)_"ACK"_HLFS_HLMIDA_HLFS_$G(HL("PID"))_HLFS_$G(HL("VER")) Q
"RTN","HLTP4",236,0)
 ;batch
"RTN","HLTP4",237,0)
 S X=$E(HL("ECH"))
"RTN","HLTP4",238,0)
 S HLHDR(1)=HLHDR(1)_X_$G(HL("PID"))_X_"ACK"_HLFS_HLTACK_HLFS_HLMIDA_HLFS_$G(HL("MID"))
"RTN","HLTP4",239,0)
 Q
"RTN","HLTPCK2A")
0^11^B29587641^B28058257
"RTN","HLTPCK2A",1,0)
HLTPCK2A ;SF/RSD - Message Header Validation (Con't) ;09/24/2008 17:11
"RTN","HLTPCK2A",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**19,57,59,66,108,120,133,142**;Oct 13, 1995;Build 17
"RTN","HLTPCK2A",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLTPCK2A",4,0)
 S ERR=""
"RTN","HLTPCK2A",5,0)
 S HLPARAM=$$PARAM^HLCS2,HLDOM=$P(HLPARAM,U,2),HLINSTN=$P(HLPARAM,U,6)
"RTN","HLTPCK2A",6,0)
MT ;Validate message type
"RTN","HLTPCK2A",7,0)
 I (ARY("MTN")="") S:(ERR="") ERR="Invalid Message Type" Q
"RTN","HLTPCK2A",8,0)
 S ARY("MTP")=0
"RTN","HLTPCK2A",9,0)
 S:(ARY("MTN")'="") ARY("MTP")=+$O(^HL(771.2,"B",ARY("MTN"),0))
"RTN","HLTPCK2A",10,0)
 I ('ARY("MTP")) S:(ERR="") ERR="Invalid Message Type" Q
"RTN","HLTPCK2A",11,0)
 ;
"RTN","HLTPCK2A",12,0)
AT ;Determine if message is an acknowledgement type
"RTN","HLTPCK2A",13,0)
 I (("ACK,ADR,MCF,MFK,MFR,ORF,ORR,RRA,RRD,RRE,RRG,TBR"[ARY("MTN"))&($G(MSA)="")) S:(ERR="") ERR="MSA Segment Missing" Q
"RTN","HLTPCK2A",14,0)
 ;commit ack, quit
"RTN","HLTPCK2A",15,0)
 ; patch HL*1.6*142
"RTN","HLTPCK2A",16,0)
 ; in order to get data for ien of sending application,
"RTN","HLTPCK2A",17,0)
 ; receiving application, and subscriber protocol.
"RTN","HLTPCK2A",18,0)
 ; I $E($G(MSA))="C" D  Q
"RTN","HLTPCK2A",19,0)
 I $E($G(MSA))="C" D
"RTN","HLTPCK2A",20,0)
 . ;find original msg.
"RTN","HLTPCK2A",21,0)
 . S ARY("MSAID")=$P(MSA,FS,2),ARY("MTIENS")=0
"RTN","HLTPCK2A",22,0)
 . I ARY("MSAID")="" S:(ERR="") ERR="Invalid Message Control ID in MSA Segment - No Message ID " Q
"RTN","HLTPCK2A",23,0)
 . F  S ARY("MTIENS")=+$O(^HLMA("C",ARY("MSAID"),ARY("MTIENS"))) Q:'ARY("MTIENS")!($P($G(^HLMA(ARY("MTIENS"),0)),U,3)="O")
"RTN","HLTPCK2A",24,0)
 . I 'ARY("MTIENS") S:(ERR="") ERR="Invalid Message Control ID in MSA Segment - No message IEN in ""C"" x-ref" Q
"RTN","HLTPCK2A",25,0)
 . Q
"RTN","HLTPCK2A",26,0)
AAT ;Validate accept ack type and application ack type
"RTN","HLTPCK2A",27,0)
 I ($G(ARY("ACAT"))'="") I ("AL,NE,ER,SU"'[ARY("ACAT")) S:(ERR="") ERR="Invalid accept ack type" Q
"RTN","HLTPCK2A",28,0)
 I ($G(ARY("APAT"))'="") I ("AL,NE,ER,SU"'[ARY("APAT")) S:(ERR="") ERR="Invalid application ack type" Q
"RTN","HLTPCK2A",29,0)
 ;
"RTN","HLTPCK2A",30,0)
 ;
"RTN","HLTPCK2A",31,0)
RA ;Validate receiving application
"RTN","HLTPCK2A",32,0)
 I (ARY("RAN")']"") S:(ERR="") ERR="Invalid Receiving Application" Q
"RTN","HLTPCK2A",33,0)
 S ARY("RAP")=0
"RTN","HLTPCK2A",34,0)
 S:ARY("RAN")]"" ARY("RAP")=+$O(^HL(771,"B",$E(ARY("RAN"),1,30),0))
"RTN","HLTPCK2A",35,0)
 I 'ARY("RAP"),ARY("RAN")'="" D
"RTN","HLTPCK2A",36,0)
 .S X=$$UPPER^HLFNC(ARY("RAN"))
"RTN","HLTPCK2A",37,0)
 .S ARY("RAP")=+$O(^HL(771,"B",$E(ARY("RAN"),1,30),0))
"RTN","HLTPCK2A",38,0)
 ;
"RTN","HLTPCK2A",39,0)
 ; patch HL*1.6*120 start
"RTN","HLTPCK2A",40,0)
 I ($L(ARY("RAN"),ECH(1))>1) D
"RTN","HLTPCK2A",41,0)
 . S ARY("RAN-SUB1")=$P(ARY("RAN"),ECH(1))
"RTN","HLTPCK2A",42,0)
 . S ARY("RAN-SUB2")=$P(ARY("RAN"),ECH(1),2)
"RTN","HLTPCK2A",43,0)
 . S ARY("RAN-SUB3")=$P(ARY("RAN"),ECH(1),3)
"RTN","HLTPCK2A",44,0)
 . I 'ARY("RAP"),ARY("RAN-SUB1")]"" D
"RTN","HLTPCK2A",45,0)
 .. S ARY("RAP")=+$O(^HL(771,"B",$E(ARY("RAN-SUB1"),1,30),0))
"RTN","HLTPCK2A",46,0)
 . I ARY("RAN-SUB1")[ECH(3) D
"RTN","HLTPCK2A",47,0)
 .. S ARY("RAN-SUB1-DEESCAPE")=$$DEESCAPE(ARY("RAN-SUB1"))
"RTN","HLTPCK2A",48,0)
 . I ARY("RAN-SUB2")[ECH(3) D
"RTN","HLTPCK2A",49,0)
 .. S ARY("RAN-SUB2-DEESCAPE")=$$DEESCAPE(ARY("RAN-SUB2"))
"RTN","HLTPCK2A",50,0)
 . I ARY("RAN-SUB3")[ECH(3) D
"RTN","HLTPCK2A",51,0)
 .. S ARY("RAN-SUB3-DEESCAPE")=$$DEESCAPE(ARY("RAN-SUB3"))
"RTN","HLTPCK2A",52,0)
 . I 'ARY("RAP"),$G(ARY("RAN-SUB1-DEESCAPE"))]"" D
"RTN","HLTPCK2A",53,0)
 .. S ARY("RAP")=+$O(^HL(771,"B",$E(ARY("RAN-SUB1-DEESCAPE"),1,30),0))
"RTN","HLTPCK2A",54,0)
 I ARY("RAN")[ECH(3) D
"RTN","HLTPCK2A",55,0)
 . S ARY("RAN-DEESCAPE")=$$DEESCAPE(ARY("RAN"))
"RTN","HLTPCK2A",56,0)
 I 'ARY("RAP"),$G(ARY("RAN-DEESCAPE"))]"" D
"RTN","HLTPCK2A",57,0)
 . S ARY("RAP")=+$O(^HL(771,"B",$E(ARY("RAN-DEESCAPE"),1,30),0))
"RTN","HLTPCK2A",58,0)
 ; patch HL*1.6*120 end
"RTN","HLTPCK2A",59,0)
 ;
"RTN","HLTPCK2A",60,0)
 I ('ARY("RAP")) S:(ERR="") ERR="Invalid Receiving Application" Q
"RTN","HLTPCK2A",61,0)
 S X2=$G(^HL(771,ARY("RAP"),0))
"RTN","HLTPCK2A",62,0)
 I (X2="") S:(ERR="") ERR="Invalid Receiving Application" Q
"RTN","HLTPCK2A",63,0)
 I ($P(X2,"^",2)'="a") S:(ERR="") ERR="Receiving Application is Inactive" Q
"RTN","HLTPCK2A",64,0)
 ;
"RTN","HLTPCK2A",65,0)
SA ;Validate sending application
"RTN","HLTPCK2A",66,0)
 I (ARY("SAN")']"") S:(ERR="") ERR="Invalid Sending Application" Q
"RTN","HLTPCK2A",67,0)
 S ARY("SAP")=0
"RTN","HLTPCK2A",68,0)
 S:(ARY("SAN")]"") ARY("SAP")=+$O(^HL(771,"B",$E(ARY("SAN"),1,30),0))
"RTN","HLTPCK2A",69,0)
 I (('ARY("SAP"))&(ARY("SAN")'="")) D
"RTN","HLTPCK2A",70,0)
 .S X=$$UPPER^HLFNC(ARY("SAN"))
"RTN","HLTPCK2A",71,0)
 .S ARY("SAP")=+$O(^HL(771,"B",$E(ARY("SAN"),1,30),0))
"RTN","HLTPCK2A",72,0)
 ;
"RTN","HLTPCK2A",73,0)
 ; patch HL*1.6*120 start
"RTN","HLTPCK2A",74,0)
 I ($L(ARY("SAN"),ECH(1))>1) D
"RTN","HLTPCK2A",75,0)
 . S ARY("SAN-SUB1")=$P(ARY("SAN"),ECH(1))
"RTN","HLTPCK2A",76,0)
 . S ARY("SAN-SUB2")=$P(ARY("SAN"),ECH(1),2)
"RTN","HLTPCK2A",77,0)
 . S ARY("SAN-SUB3")=$P(ARY("SAN"),ECH(1),3)
"RTN","HLTPCK2A",78,0)
 . I 'ARY("SAP"),ARY("SAN-SUB1")]"" D
"RTN","HLTPCK2A",79,0)
 .. S ARY("SAP")=+$O(^HL(771,"B",$E(ARY("SAN-SUB1"),1,30),0))
"RTN","HLTPCK2A",80,0)
 . I ARY("SAN-SUB1")[ECH(3) D
"RTN","HLTPCK2A",81,0)
 .. S ARY("SAN-SUB1-DEESCAPE")=$$DEESCAPE(ARY("SAN-SUB1"))
"RTN","HLTPCK2A",82,0)
 . I ARY("SAN-SUB2")[ECH(3) D
"RTN","HLTPCK2A",83,0)
 .. S ARY("SAN-SUB2-DEESCAPE")=$$DEESCAPE(ARY("SAN-SUB2"))
"RTN","HLTPCK2A",84,0)
 . I ARY("SAN-SUB3")[ECH(3) D
"RTN","HLTPCK2A",85,0)
 .. S ARY("SAN-SUB3-DEESCAPE")=$$DEESCAPE(ARY("SAN-SUB3"))
"RTN","HLTPCK2A",86,0)
 . I 'ARY("SAP"),$G(ARY("SAN-SUB1-DEESCAPE"))]"" D
"RTN","HLTPCK2A",87,0)
 .. S ARY("SAP")=+$O(^HL(771,"B",$E(ARY("SAN-SUB1-DEESCAPE"),1,30),0))
"RTN","HLTPCK2A",88,0)
 I ARY("SAN")[ECH(3) D
"RTN","HLTPCK2A",89,0)
 . S ARY("SAN-DEESCAPE")=$$DEESCAPE(ARY("SAN"))
"RTN","HLTPCK2A",90,0)
 I 'ARY("SAP"),$G(ARY("SAN-DEESCAPE"))]"" D
"RTN","HLTPCK2A",91,0)
 . S ARY("SAP")=+$O(^HL(771,"B",$E(ARY("SAN-DEESCAPE"),1,30),0))
"RTN","HLTPCK2A",92,0)
 ; patch HL*1.6*120 end
"RTN","HLTPCK2A",93,0)
 ;
"RTN","HLTPCK2A",94,0)
 I ('ARY("SAP")) S:(ERR="") ERR="Invalid Sending Application" Q
"RTN","HLTPCK2A",95,0)
 ;
"RTN","HLTPCK2A",96,0)
VN ;Validate version number
"RTN","HLTPCK2A",97,0)
 ; patch HL*1.6*142
"RTN","HLTPCK2A",98,0)
 ; do not check version number of commit ACK because the batch commit ACK
"RTN","HLTPCK2A",99,0)
 ; does not have version number in it.
"RTN","HLTPCK2A",100,0)
 I $E($G(MSA))="C" G ET
"RTN","HLTPCK2A",101,0)
 ;
"RTN","HLTPCK2A",102,0)
 I (ARY("VER")="") S:(ERR="") ERR="Missing HL7 Version" Q
"RTN","HLTPCK2A",103,0)
 S X=0
"RTN","HLTPCK2A",104,0)
 S:(ARY("VER")'="") X=+$O(^HL(771.5,"B",ARY("VER"),0))
"RTN","HLTPCK2A",105,0)
 S ARY("VEP")=X
"RTN","HLTPCK2A",106,0)
 I ('X) S:(ERR="") ERR="Invalid HL7 Version" Q
"RTN","HLTPCK2A",107,0)
 ;I (X'=$P($G(HLN(770)),"^",10)) S:(ERR="") ERR="Invalid HL7 Version for Receiving Application" Q
"RTN","HLTPCK2A",108,0)
 ;
"RTN","HLTPCK2A",109,0)
ET ;Event Type Checks
"RTN","HLTPCK2A",110,0)
 ;
"RTN","HLTPCK2A",111,0)
 ;I ARY("ETN")="",ARY("VER")>2.1,$G(MSA)'="" D
"RTN","HLTPCK2A",112,0)
 ;. ;N Z,ZEP,ZP
"RTN","HLTPCK2A",113,0)
 ;. ;S Z=0 I $P(MSA,FS,2)]"" S Z=+$O(^HLMA("C",$P(MSA,FS,2),0))
"RTN","HLTPCK2A",114,0)
 ;. ;I '$G(^HLMA(Z,0)) S:(ERR="") ERR="Original Outgoing Message not found" Q
"RTN","HLTPCK2A",115,0)
 ;. ;S ZEP=$P(^HLMA(Z,0),U,8)
"RTN","HLTPCK2A",116,0)
 ;. ;I 'ZEP S:(ERR="") ERR="Event Protocol pointer (field #773,8) missing" Q
"RTN","HLTPCK2A",117,0)
 ;. ;S ZP=$G(^ORD(101,ZEP,770)),ARY("ETN")=$P($G(^HL(779.001,+$P(ZP,U,4),0)),U)
"RTN","HLTPCK2A",118,0)
 ;
"RTN","HLTPCK2A",119,0)
 ;Validate event type
"RTN","HLTPCK2A",120,0)
 I (ARY("ETN")=""),ARY("VER")>2.1,$G(MSA)="" S ERR="Event Type Required" Q
"RTN","HLTPCK2A",121,0)
 S ARY("ETP")=0
"RTN","HLTPCK2A",122,0)
 S:(ARY("ETN")'="") ARY("ETP")=+$O(^HL(779.001,"B",ARY("ETN"),0))
"RTN","HLTPCK2A",123,0)
 I $G(MSA)="",ARY("VER")>2.1,('ARY("ETP")) S ERR="Invalid Event Type" Q
"RTN","HLTPCK2A",124,0)
 ;
"RTN","HLTPCK2A",125,0)
 D ^HLTPCK2B
"RTN","HLTPCK2A",126,0)
 Q
"RTN","HLTPCK2A",127,0)
DEESCAPE(INPUT) ;
"RTN","HLTPCK2A",128,0)
 ; patch HL*1.6*120 - de-escape delimiters
"RTN","HLTPCK2A",129,0)
 ; (assuming "\" is the escape character):
"RTN","HLTPCK2A",130,0)
 ; - field separator (de-escape from \F\)
"RTN","HLTPCK2A",131,0)
 ; - component separator (de-escape from \S\)
"RTN","HLTPCK2A",132,0)
 ; - repetition separator (de-escape from \R\)
"RTN","HLTPCK2A",133,0)
 ; - escape character (de-escape from \E\)
"RTN","HLTPCK2A",134,0)
 ; - subcomponent separator (de-escape from \T\)
"RTN","HLTPCK2A",135,0)
 ; \F\ will be de-escaped only if the length of FS is 1.
"RTN","HLTPCK2A",136,0)
 ;
"RTN","HLTPCK2A",137,0)
 ; input:
"RTN","HLTPCK2A",138,0)
 ; INPUT - input string to be de-escaped
"RTN","HLTPCK2A",139,0)
 ; FS - field separator
"RTN","HLTPCK2A",140,0)
 ; ECH - encoding characters
"RTN","HLTPCK2A",141,0)
 ; 
"RTN","HLTPCK2A",142,0)
 ; output: de-escaped string
"RTN","HLTPCK2A",143,0)
 ;
"RTN","HLTPCK2A",144,0)
 N HLDATA,HLESCAPE,HLI,HLCHAR,HLCHAR23,HLEN,HLOUT
"RTN","HLTPCK2A",145,0)
 S HLDATA=$G(INPUT)
"RTN","HLTPCK2A",146,0)
 Q:HLDATA']"" HLDATA
"RTN","HLTPCK2A",147,0)
 ;
"RTN","HLTPCK2A",148,0)
 ; patch HL*1.6*133
"RTN","HLTPCK2A",149,0)
 Q:$L($G(ECH))<3 HLDATA
"RTN","HLTPCK2A",150,0)
 ;
"RTN","HLTPCK2A",151,0)
 S ECH(1)=$E(ECH,1)
"RTN","HLTPCK2A",152,0)
 S ECH(2)=$E(ECH,2)
"RTN","HLTPCK2A",153,0)
 S ECH(3)=$E(ECH,3)
"RTN","HLTPCK2A",154,0)
 S ECH(4)=$E(ECH,4)
"RTN","HLTPCK2A",155,0)
 ;
"RTN","HLTPCK2A",156,0)
 S HLEN=$L(HLDATA)
"RTN","HLTPCK2A",157,0)
 S HLOUT=""
"RTN","HLTPCK2A",158,0)
 F HLI=1:1:HLEN D
"RTN","HLTPCK2A",159,0)
 . S HLCHAR=$E(HLDATA,HLI)
"RTN","HLTPCK2A",160,0)
 . I HLCHAR=ECH(3) D
"RTN","HLTPCK2A",161,0)
 . S HLCHAR23=$E(HLDATA,HLI+1,HLI+2)
"RTN","HLTPCK2A",162,0)
 . I $L($G(FS))=1,(HLCHAR23=("F"_ECH(3))) D  Q
"RTN","HLTPCK2A",163,0)
 .. S HLOUT=HLOUT_FS
"RTN","HLTPCK2A",164,0)
 .. S HLI=HLI+2
"RTN","HLTPCK2A",165,0)
 . I HLCHAR23=("S"_ECH(3)) D  Q
"RTN","HLTPCK2A",166,0)
 .. S HLOUT=HLOUT_ECH(1)
"RTN","HLTPCK2A",167,0)
 .. S HLI=HLI+2
"RTN","HLTPCK2A",168,0)
 . I HLCHAR23=("R"_ECH(3)) D  Q
"RTN","HLTPCK2A",169,0)
 .. S HLOUT=HLOUT_ECH(2)
"RTN","HLTPCK2A",170,0)
 .. S HLI=HLI+2
"RTN","HLTPCK2A",171,0)
 . I HLCHAR23=("E"_ECH(3)) D  Q
"RTN","HLTPCK2A",172,0)
 .. S HLOUT=HLOUT_ECH(3)
"RTN","HLTPCK2A",173,0)
 .. S HLI=HLI+2
"RTN","HLTPCK2A",174,0)
 . I $L($G(ECH))>3,(HLCHAR23=("T"_ECH(3))) D  Q
"RTN","HLTPCK2A",175,0)
 .. S HLOUT=HLOUT_ECH(4)
"RTN","HLTPCK2A",176,0)
 .. S HLI=HLI+2
"RTN","HLTPCK2A",177,0)
 . S HLOUT=HLOUT_HLCHAR
"RTN","HLTPCK2A",178,0)
 ;
"RTN","HLTPCK2A",179,0)
 Q HLOUT
"RTN","HLUOPT3")
0^3^B6856566^B5260875
"RTN","HLUOPT3",1,0)
HLUOPT3 ;CIOFO-O/LJA - Delete 772, 773 Entries w/Direct Kills ;05/15/2008 16:16
"RTN","HLUOPT3",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109,142**;Oct 13, 1995;Build 17
"RTN","HLUOPT3",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLUOPT3",4,0)
 ;
"RTN","HLUOPT3",5,0)
 ;
"RTN","HLUOPT3",6,0)
 ; WARNING!  No locking used in DEL772 and DEL773.  You MUST already
"RTN","HLUOPT3",7,0)
 ;           have the entry lock before calling here, (or be willing to
"RTN","HLUOPT3",8,0)
 ;           accept the consequences.)
"RTN","HLUOPT3",9,0)
 ;
"RTN","HLUOPT3",10,0)
 ; WARNING!  DEL772 and DEL773 does NOT update piece 4 (number entries)
"RTN","HLUOPT3",11,0)
 ;           of the file's zero node.  Be sure to do this elsewhere.
"RTN","HLUOPT3",12,0)
 ;
"RTN","HLUOPT3",13,0)
 ;
"RTN","HLUOPT3",14,0)
DEL772(IEN772) ; Delete 772 entry using kill commands...  (See WARNINGS above)
"RTN","HLUOPT3",15,0)
 N D0,D2,DP,IEN773,P01,P03,P06,P08,P11,PP1,P22
"RTN","HLUOPT3",16,0)
 ;
"RTN","HLUOPT3",17,0)
 ; Does 773 entry exist?
"RTN","HLUOPT3",18,0)
 S IEN773=$O(^HLMA("B",IEN772,0))
"RTN","HLUOPT3",19,0)
 I IEN773,'$D(^HLMA(+IEN773,0)) D
"RTN","HLUOPT3",20,0)
 .  KILL ^HLMA("B",IEN772,IEN773)
"RTN","HLUOPT3",21,0)
 .  S IEN773=""
"RTN","HLUOPT3",22,0)
 QUIT:IEN773  ;->
"RTN","HLUOPT3",23,0)
 ;
"RTN","HLUOPT3",24,0)
 ; Every field value must be set so as not to be null!!!
"RTN","HLUOPT3",25,0)
 ;
"RTN","HLUOPT3",26,0)
 ; Get 0 node data and pieces...
"RTN","HLUOPT3",27,0)
 S D0=$G(^HL(772,+IEN772,0))
"RTN","HLUOPT3",28,0)
 S P01=+$P(D0,U),P03=+$P(D0,U,3)
"RTN","HLUOPT3",29,0)
 S P06=$P(D0,U,6),P06=$S(P06]"":P06,1:" ")
"RTN","HLUOPT3",30,0)
 S P08=+$P(D0,U,8),P011=+$P(D0,U,11)
"RTN","HLUOPT3",31,0)
 ;
"RTN","HLUOPT3",32,0)
 ;Get 2 node data and piece
"RTN","HLUOPT3",33,0)
 S D2=$G(^HL(772,+IEN772,2))
"RTN","HLUOPT3",34,0)
 S P22=+$P(D2,U,2)
"RTN","HLUOPT3",35,0)
 ;
"RTN","HLUOPT3",36,0)
 ; Get P node data and piece...
"RTN","HLUOPT3",37,0)
 S DP=$G(^HL(772,+IEN772,"P"))
"RTN","HLUOPT3",38,0)
 S PP1=+$P(DP,U)
"RTN","HLUOPT3",39,0)
 ;
"RTN","HLUOPT3",40,0)
 ; Kill xrefs...
"RTN","HLUOPT3",41,0)
 KILL ^HL(772,"A-XMIT-OUT",P011,IEN772)
"RTN","HLUOPT3",42,0)
 KILL ^HL(772,"AC","I",P03,IEN772)
"RTN","HLUOPT3",43,0)
 KILL ^HL(772,"AC","O",P03,IEN772)
"RTN","HLUOPT3",44,0)
 KILL ^HL(772,"AF",PP1,IEN772)
"RTN","HLUOPT3",45,0)
 KILL ^HL(772,"AH",P03,P06,IEN772)
"RTN","HLUOPT3",46,0)
 KILL ^HL(772,"AI",P08,IEN772)
"RTN","HLUOPT3",47,0)
 KILL ^HL(772,"B",P01,IEN772)
"RTN","HLUOPT3",48,0)
 KILL ^HL(772,"C",P06,IEN772)
"RTN","HLUOPT3",49,0)
 KILL ^HLMA("AI",P22,772,IEN772)
"RTN","HLUOPT3",50,0)
 ;
"RTN","HLUOPT3",51,0)
 ; Remove data...
"RTN","HLUOPT3",52,0)
 KILL ^HL(772,IEN772)
"RTN","HLUOPT3",53,0)
 ;
"RTN","HLUOPT3",54,0)
 QUIT
"RTN","HLUOPT3",55,0)
 ;
"RTN","HLUOPT3",56,0)
DEL773(IEN773) ; Delete 773 entry using kill commands...  (See WARNINGS above)
"RTN","HLUOPT3",57,0)
 N D0,D2,DP,DS,P01,P02,P07,P06,P012,PP1,PS1,P22
"RTN","HLUOPT3",58,0)
 ;
"RTN","HLUOPT3",59,0)
 ; Every field value must be set so as not to be null!!!
"RTN","HLUOPT3",60,0)
 ;
"RTN","HLUOPT3",61,0)
 ; Get 0 node data and pieces...
"RTN","HLUOPT3",62,0)
 S D0=$G(^HLMA(IEN773,0))
"RTN","HLUOPT3",63,0)
 S P01=+$P(D0,U),P02=$P(D0,U,2),P02=$S(P02]"":P02,1:" ")
"RTN","HLUOPT3",64,0)
 S P07=+$P(D0,U,7),P06=+$P(D0,U,6),P012=+$P(D0,U,12)
"RTN","HLUOPT3",65,0)
 ;
"RTN","HLUOPT3",66,0)
 ;
"RTN","HLUOPT3",67,0)
 ;Get 2 node data and piece
"RTN","HLUOPT3",68,0)
 S D2=$G(^HLMA(IEN773,2))
"RTN","HLUOPT3",69,0)
 S P22=+$P(D2,U,2)
"RTN","HLUOPT3",70,0)
 ;
"RTN","HLUOPT3",71,0)
 ; Get P node data and piece...
"RTN","HLUOPT3",72,0)
 S DP=$G(^HLMA(IEN773,"P"))
"RTN","HLUOPT3",73,0)
 S PP1=+DP
"RTN","HLUOPT3",74,0)
 ;
"RTN","HLUOPT3",75,0)
 ; Get S node data and piece...
"RTN","HLUOPT3",76,0)
 S DS=$G(^HLMA(IEN773,"S"))
"RTN","HLUOPT3",77,0)
 S PS1=+DS
"RTN","HLUOPT3",78,0)
 ;
"RTN","HLUOPT3",79,0)
 ; Kill xrefs...
"RTN","HLUOPT3",80,0)
 KILL ^HLMA("AC","I",P07,IEN773)
"RTN","HLUOPT3",81,0)
 KILL ^HLMA("AC","O",P07,IEN773)
"RTN","HLUOPT3",82,0)
 KILL ^HLMA("AD",PS1,IEN773)
"RTN","HLUOPT3",83,0)
 KILL ^HLMA("AF",P06,IEN773)
"RTN","HLUOPT3",84,0)
 KILL ^HLMA("AG",PP1,IEN773)
"RTN","HLUOPT3",85,0)
 KILL ^HLMA("AH",P012,P02,IEN773)
"RTN","HLUOPT3",86,0)
 KILL ^HLMA("B",P01,IEN773)
"RTN","HLUOPT3",87,0)
 KILL ^HLMA("C",P02,IEN773)
"RTN","HLUOPT3",88,0)
 KILL ^HLMA("AI",P22,773,IEN773)
"RTN","HLUOPT3",89,0)
 ;
"RTN","HLUOPT3",90,0)
 ; patch HL*1.6*142 start
"RTN","HLUOPT3",91,0)
 N HDR,FLD
"RTN","HLUOPT3",92,0)
 S HDR=$G(^HLMA(IEN773,"MSH",1,0))
"RTN","HLUOPT3",93,0)
 I HDR]"" D
"RTN","HLUOPT3",94,0)
 . I $G(^HLMA(IEN773,"MSH",2,0))]"" D
"RTN","HLUOPT3",95,0)
 .. S HDR=HDR_$G(^HLMA(IEN773,"MSH",2,0))
"RTN","HLUOPT3",96,0)
 . S FLD=$E(HDR,4)
"RTN","HLUOPT3",97,0)
 . I FLD]"" D
"RTN","HLUOPT3",98,0)
 .. S HDR=$P(HDR,FLD,3,6)
"RTN","HLUOPT3",99,0)
 .. K:HDR]"" ^HLMA("AH-NEW",HDR,P02,IEN773)
"RTN","HLUOPT3",100,0)
 ; patch HL*1.6*142 end
"RTN","HLUOPT3",101,0)
 ;
"RTN","HLUOPT3",102,0)
 ; Remove data...
"RTN","HLUOPT3",103,0)
 KILL ^HLMA(IEN773)
"RTN","HLUOPT3",104,0)
 ;
"RTN","HLUOPT3",105,0)
 QUIT
"RTN","HLUOPT3",106,0)
 ;
"RTN","HLUOPT3",107,0)
EOR ;HLUOPT3 - Delete 772, 773 Entries w/Direct Kills ;12/30/02 15:15
"RTN","HLUTIL")
0^5^B15676217^B15417895
"RTN","HLUTIL",1,0)
HLUTIL ;SFISC/RJH- Utilities for HL7 TCP    ;06/03/2008  11:20
"RTN","HLUTIL",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**36,19,57,64,66,109,142**;Oct 13, 1995;Build 17
"RTN","HLUTIL",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLUTIL",4,0)
 Q
"RTN","HLUTIL",5,0)
 ;For TCP only
"RTN","HLUTIL",6,0)
MSGSTAT(X) ;message status
"RTN","HLUTIL",7,0)
 ;input value:   X = message id
"RTN","HLUTIL",8,0)
 ;return value: status^status updated^error msg.^error type pointer^
"RTN","HLUTIL",9,0)
 ;queue position or # of retries^# open failed^ack timeout
"RTN","HLUTIL",10,0)
 ;      status:
"RTN","HLUTIL",11,0)
 ;               0 = message doesn't exist
"RTN","HLUTIL",12,0)
 ;               1 = waiting in queue
"RTN","HLUTIL",13,0)
 ;             1.5 = opening connection
"RTN","HLUTIL",14,0)
 ;             1.7 = awaiting response, # of retries
"RTN","HLUTIL",15,0)
 ;               2 = awaiting application ack
"RTN","HLUTIL",16,0)
 ;               3 = successfully completed
"RTN","HLUTIL",17,0)
 ;               4 = error
"RTN","HLUTIL",18,0)
 ;               8 = being generated
"RTN","HLUTIL",19,0)
 ;               9 = awaiting processing
"RTN","HLUTIL",20,0)
 Q:$G(X)']"" 0
"RTN","HLUTIL",21,0)
 N C,I,L,Y,Z
"RTN","HLUTIL",22,0)
 S Y=$O(^HLMA("C",X,0)) Q:'Y 0
"RTN","HLUTIL",23,0)
 ;lock node to flush disk buffers
"RTN","HLUTIL",24,0)
 L +^HLMA(Y,"P"):3 S Z=$G(^HLMA(Y,"P"))
"RTN","HLUTIL",25,0)
 S:'Z Z=0
"RTN","HLUTIL",26,0)
 ;if pending, get queue position
"RTN","HLUTIL",27,0)
 I +Z=1 D
"RTN","HLUTIL",28,0)
 . ;get Logical Link, if msg. not in x-ref, then it is being sent
"RTN","HLUTIL",29,0)
 . S L=+$P(^HLMA(Y,0),U,7) Q:'$D(^HLMA("AC","O",L,Y))
"RTN","HLUTIL",30,0)
 . ;find position in queue, if greater than 2 - use 2
"RTN","HLUTIL",31,0)
 . S I=Y F C=1:1:2 S I=$O(^HLMA("AC","O",L,I),-1) Q:'I
"RTN","HLUTIL",32,0)
 . S $P(Z,U,5)=C
"RTN","HLUTIL",33,0)
 L -^HLMA(Y,"P")
"RTN","HLUTIL",34,0)
 Q Z
"RTN","HLUTIL",35,0)
 ;
"RTN","HLUTIL",36,0)
MSGACT(X,HLIENACT) ;outgoing message action
"RTN","HLUTIL",37,0)
 ;input value:   X = message id
"RTN","HLUTIL",38,0)
 ;               HLIENACT = 1-cancel; 2-requeue
"RTN","HLUTIL",39,0)
 ;return value:  1 = action sucessful
"RTN","HLUTIL",40,0)
 ;               0 = action failed
"RTN","HLUTIL",41,0)
 Q:$G(X)']"" 0
"RTN","HLUTIL",42,0)
 N HLIEN,HLIEN0,HLSTAT,HLTCP,Y,LINK
"RTN","HLUTIL",43,0)
 S HLIEN=+$O(^HLMA("C",X,0)) Q:'HLIEN 0
"RTN","HLUTIL",44,0)
 S HLIEN0=$G(^HLMA(HLIEN,0)) Q:'HLIEN0 0
"RTN","HLUTIL",45,0)
 ;must be outgoing
"RTN","HLUTIL",46,0)
 Q:$P(HLIEN0,U,3)'="O" 0
"RTN","HLUTIL",47,0)
 F Y=1:1:3 L +^HLMA(HLIEN,"P"):1 Q:$T  H 1
"RTN","HLUTIL",48,0)
 E  Q 0
"RTN","HLUTIL",49,0)
 ;
"RTN","HLUTIL",50,0)
 ;**109**
"RTN","HLUTIL",51,0)
 S LINK=$P($G(^HLMA(HLIEN,0)),"^",7)
"RTN","HLUTIL",52,0)
 ;
"RTN","HLUTIL",53,0)
 S HLSTAT=1
"RTN","HLUTIL",54,0)
 ;cancel
"RTN","HLUTIL",55,0)
 I HLIENACT=1 D
"RTN","HLUTIL",56,0)
 . ;HLTCP is set so that file 773 is updated
"RTN","HLUTIL",57,0)
 . S HLTCP=""
"RTN","HLUTIL",58,0)
 . D STATUS^HLTF0(HLIEN,3,,"Cancelled by application",1)
"RTN","HLUTIL",59,0)
 .;
"RTN","HLUTIL",60,0)
 .;**109**
"RTN","HLUTIL",61,0)
 . D DEQUE^HLCSREP(LINK,"O",HLIEN)
"RTN","HLUTIL",62,0)
 .;
"RTN","HLUTIL",63,0)
 ;requeue
"RTN","HLUTIL",64,0)
 I HLIENACT=2 D
"RTN","HLUTIL",65,0)
 . N DA,DIK,HLJ
"RTN","HLUTIL",66,0)
 . ;check for type=outgoing and logical link, need for "AC" x-ref
"RTN","HLUTIL",67,0)
 . I $P(HLIEN0,U,3)'="O"!('$P(HLIEN0,U,7)) S HLSTAT=0 Q
"RTN","HLUTIL",68,0)
 . ;set status=pend transmission
"RTN","HLUTIL",69,0)
 . S Y=$NA(HLJ(773,HLIEN_",")),@Y@(20)=1
"RTN","HLUTIL",70,0)
 . ;delete status update, error msg, error type, date processed
"RTN","HLUTIL",71,0)
 . S (@Y@(21),@Y@(22),@Y@(23),@Y@(100))="@"
"RTN","HLUTIL",72,0)
 . D FILE^HLDIE("","HLJ","","MSGACT","HLUTIL") ; HL*1.6*109
"RTN","HLUTIL",73,0)
 . ;**109**
"RTN","HLUTIL",74,0)
 . ;need to set "AC" x-ref
"RTN","HLUTIL",75,0)
 .; S DA=HLIEN,DIK="^HLMA(",DIK(1)="7^AC"
"RTN","HLUTIL",76,0)
 .; D EN1^DIK
"RTN","HLUTIL",77,0)
 .;
"RTN","HLUTIL",78,0)
 .;**109**
"RTN","HLUTIL",79,0)
 . D ENQUE^HLCSREP(LINK,"O",HLIEN)
"RTN","HLUTIL",80,0)
 ;
"RTN","HLUTIL",81,0)
 L -^HLMA(HLIEN,"P")
"RTN","HLUTIL",82,0)
 Q HLSTAT
"RTN","HLUTIL",83,0)
 ;
"RTN","HLUTIL",84,0)
CHKLL(X) ;check setup of Logical Link
"RTN","HLUTIL",85,0)
 ;input value:   X = institution number or name
"RTN","HLUTIL",86,0)
 ;return value:  1 = setup OK
"RTN","HLUTIL",87,0)
 ;               0 = LL setup incorrect
"RTN","HLUTIL",88,0)
 N HLF,HLRESLT
"RTN","HLUTIL",89,0)
 S HLF=$S(X:"I",1:"")
"RTN","HLUTIL",90,0)
 D LINK^HLUTIL3(X,.HLRESLT,HLF)
"RTN","HLUTIL",91,0)
 S X=+$O(HLRESLT(0)) Q:'X 0
"RTN","HLUTIL",92,0)
 Q $$LLOK^HLCSLM(X)
"RTN","HLUTIL",93,0)
 ;
"RTN","HLUTIL",94,0)
DONTPURG() ; set the DONT PURGE field to 1 in order to prevent the message
"RTN","HLUTIL",95,0)
 ; from purging.
"RTN","HLUTIL",96,0)
 ; return value :  1 for successfully set the field
"RTN","HLUTIL",97,0)
 ;                -1 for failure
"RTN","HLUTIL",98,0)
 Q $$SETPURG(1)
"RTN","HLUTIL",99,0)
 ;
"RTN","HLUTIL",100,0)
TOPURG() ; clear the DONT PURGE field to allow the message to be purged.
"RTN","HLUTIL",101,0)
 ; return value :  0 for successfully clear the field
"RTN","HLUTIL",102,0)
 ;                -1 for failure
"RTN","HLUTIL",103,0)
 Q $$SETPURG(0)
"RTN","HLUTIL",104,0)
 ;
"RTN","HLUTIL",105,0)
SETPURG(STATUS) ; to set or to clear the DONT PURGE field
"RTN","HLUTIL",106,0)
 ; HLMTIENS = ien in file 773 for this message
"RTN","HLUTIL",107,0)
 ; input: 1 to set the DONT PURGE field
"RTN","HLUTIL",108,0)
 ;        0 to clear the DONT PURGE field.
"RTN","HLUTIL",109,0)
 ; return value: 1 means successfully set the DONT PURGE field
"RTN","HLUTIL",110,0)
 ;               0 means successfully clear the DONT PURGE field
"RTN","HLUTIL",111,0)
 ;              -1 means fail to set or to clear the field
"RTN","HLUTIL",112,0)
 I (STATUS'=1),(STATUS'=0) Q -1
"RTN","HLUTIL",113,0)
 I '$D(^HLMA(+$G(HLMTIENS),0)) Q -1
"RTN","HLUTIL",114,0)
 ;
"RTN","HLUTIL",115,0)
 L +^HLMA(HLMTIENS):30
"RTN","HLUTIL",116,0)
 E  Q -1
"RTN","HLUTIL",117,0)
 S $P(^HLMA(HLMTIENS,2),U)=STATUS
"RTN","HLUTIL",118,0)
 L -^HLMA(HLMTIENS)
"RTN","HLUTIL",119,0)
 Q STATUS
"RTN","HLUTIL",120,0)
 ;
"RTN","HLUTIL",121,0)
REPROC(IEN,RTN) ; reprocessing message
"RTN","HLUTIL",122,0)
 ; IEN- the message IEN in file 773
"RTN","HLUTIL",123,0)
 ; RTN- the routine, to be Xecuted for processing the message
"RTN","HLUTIL",124,0)
 ; return value:  0 for success, -1 for failure
"RTN","HLUTIL",125,0)
 N HLMTIEN,HLMTIENS,HLNEXT,HLNODE,HLQUIT,HLERR,HLRESLT,HLTCP
"RTN","HLUTIL",126,0)
 N HL,HDR,FS,ECH,HLMSA,X,X1,X2
"RTN","HLUTIL",127,0)
 S HLQUIT=0,HLNODE="",HLNEXT="D HLNEXT^HLCSUTL"
"RTN","HLUTIL",128,0)
 I '$D(^HLMA(+$G(IEN),0)) Q -1
"RTN","HLUTIL",129,0)
 ;
"RTN","HLUTIL",130,0)
 ; patch HL*1.6*142
"RTN","HLUTIL",131,0)
 ; I $G(RTN)'["" Q -1
"RTN","HLUTIL",132,0)
 I $G(RTN)']"" Q -1
"RTN","HLUTIL",133,0)
 ;
"RTN","HLUTIL",134,0)
 S (HLMTIENS,HLTCP)=+IEN,HLMTIEN=+^HLMA(HLMTIENS,0),HLMSA=$$MSA^HLTP3(HLMTIEN)
"RTN","HLUTIL",135,0)
 M HDR=^HLMA(HLMTIENS,"MSH")
"RTN","HLUTIL",136,0)
 D CHK^HLTPCK2(.HDR,.HL,.HLMSA)
"RTN","HLUTIL",137,0)
 Q:HL'="" -1
"RTN","HLUTIL",138,0)
 ;
"RTN","HLUTIL",139,0)
 I RTN["D " X RTN
"RTN","HLUTIL",140,0)
 I RTN'["D " D
"RTN","HLUTIL",141,0)
 . I RTN["^" X "D "_RTN
"RTN","HLUTIL",142,0)
 . I RTN'["^" X "D ^"_RTN
"RTN","HLUTIL",143,0)
 S HLRESLT=0 S:($D(HLERR)) HLRESLT="9^"_$G(^HL(771.7,9,0))
"RTN","HLUTIL",144,0)
 ; update the status
"RTN","HLUTIL",145,0)
 D STATUS^HLTF0(HLMTIENS,$S(HLRESLT:4,1:3),$S(HLRESLT:+HLRESLT,1:""),$S($D(HLERR):HLERR,HLRESLT:$P(HLRESLT,"^",2),1:""),1)
"RTN","HLUTIL",146,0)
 Q 0
"RTN","HLUTIL4")
0^7^B24031445^n/a
"RTN","HLUTIL4",1,0)
HLUTIL4 ;OIFO-O/RJH-Don't Purge & Reprocessing for HLLP & MAILMAN  ;09/02/2008  16:54
"RTN","HLUTIL4",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**142**;Oct 13, 1995;Build 17
"RTN","HLUTIL4",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLUTIL4",4,0)
 ; Don't purge and reprocessing functions for HLLP and MailMan
"RTN","HLUTIL4",5,0)
 ; messages only
"RTN","HLUTIL4",6,0)
 Q
"RTN","HLUTIL4",7,0)
 ;
"RTN","HLUTIL4",8,0)
NOPURG() ; for HLLP and MailMan messages only
"RTN","HLUTIL4",9,0)
 ; set the DON'T PURGE field to 1 in order to prevent the message
"RTN","HLUTIL4",10,0)
 ; from purging.
"RTN","HLUTIL4",11,0)
 ; at least one of the variables, HLMTIEN and HLMTIENS, must be defined
"RTN","HLUTIL4",12,0)
 ; HLMTIEN- parent message IEN of file #772
"RTN","HLUTIL4",13,0)
 ; HLMTIENS- child message IEN of file #772
"RTN","HLUTIL4",14,0)
 ; return value :  1 for successfully set the field
"RTN","HLUTIL4",15,0)
 ;                -1 for failure
"RTN","HLUTIL4",16,0)
 ;
"RTN","HLUTIL4",17,0)
 N FLAG
"RTN","HLUTIL4",18,0)
 S FLAG=$$SETPFLAG(1)
"RTN","HLUTIL4",19,0)
 Q FLAG
"RTN","HLUTIL4",20,0)
 ;
"RTN","HLUTIL4",21,0)
PURG() ; for HLLP and MailMan messages only
"RTN","HLUTIL4",22,0)
 ; clear the DON'T PURGE field to allow the message to be purged.
"RTN","HLUTIL4",23,0)
 ; at least one of the variables, HLMTIEN and HLMTIENS, must be defined
"RTN","HLUTIL4",24,0)
 ; HLMTIEN- parent message IEN of file #772
"RTN","HLUTIL4",25,0)
 ; HLMTIENS- child message IEN of file #772
"RTN","HLUTIL4",26,0)
 ; return value :  0 for successfully clear the field
"RTN","HLUTIL4",27,0)
 ;                -1 for failure
"RTN","HLUTIL4",28,0)
 ;
"RTN","HLUTIL4",29,0)
 N FLAG
"RTN","HLUTIL4",30,0)
 S FLAG=$$SETPFLAG(0)
"RTN","HLUTIL4",31,0)
 Q FLAG
"RTN","HLUTIL4",32,0)
 ;
"RTN","HLUTIL4",33,0)
SETPFLAG(STATUS) ; for HLLP and MailMan messages only
"RTN","HLUTIL4",34,0)
 ; to set or to clear the DONT PURGE field
"RTN","HLUTIL4",35,0)
 ; at least one of the variables, HLMTIEN and HLMTIENS, must be defined
"RTN","HLUTIL4",36,0)
 ; HLMTIEN- parent message IEN of file #772
"RTN","HLUTIL4",37,0)
 ; HLMTIENS- child message IEN of file #772
"RTN","HLUTIL4",38,0)
 ; input: 1 to set the DONT PURGE field
"RTN","HLUTIL4",39,0)
 ;        0 to clear the DONT PURGE field.
"RTN","HLUTIL4",40,0)
 ; return value: 1 means successfully set the DONT PURGE field
"RTN","HLUTIL4",41,0)
 ;               0 means successfully clear the DONT PURGE field
"RTN","HLUTIL4",42,0)
 ;              -1 means fail to set or to clear the field
"RTN","HLUTIL4",43,0)
 ;
"RTN","HLUTIL4",44,0)
 N FLAG
"RTN","HLUTIL4",45,0)
 S FLAG=""
"RTN","HLUTIL4",46,0)
 I (STATUS'=1),(STATUS'=0) Q -1
"RTN","HLUTIL4",47,0)
 I '$G(HLMTIEN),'$G(HLMTIENS) Q -1
"RTN","HLUTIL4",48,0)
 ;
"RTN","HLUTIL4",49,0)
 ; both HLMTIEN and HLMTIENS are defined
"RTN","HLUTIL4",50,0)
 I $G(HLMTIEN),$G(HLMTIENS) D
"RTN","HLUTIL4",51,0)
 . I '$D(^HL(772,HLMTIEN)) S FLAG=-1 Q
"RTN","HLUTIL4",52,0)
 . I '$D(^HL(772,HLMTIENS)) S FLAG=-1 Q
"RTN","HLUTIL4",53,0)
 . I (HLMTIEN'=$P(^HL(772,HLMTIENS,0),"^",8)) S FLAG=-1 Q
"RTN","HLUTIL4",54,0)
 . L +^HL(772,HLMTIEN):300
"RTN","HLUTIL4",55,0)
 . E  S FLAG=-1 Q
"RTN","HLUTIL4",56,0)
 . L +^HL(772,HLMTIENS):300
"RTN","HLUTIL4",57,0)
 . E  L -^HL(772,HLMTIEN) S FLAG=-1 Q
"RTN","HLUTIL4",58,0)
 . D SETVALUE
"RTN","HLUTIL4",59,0)
 . L -^HL(772,HLMTIENS)
"RTN","HLUTIL4",60,0)
 . L -^HL(772,HLMTIEN)
"RTN","HLUTIL4",61,0)
 . S FLAG=STATUS
"RTN","HLUTIL4",62,0)
 I (FLAG=-1)!(FLAG=STATUS) Q FLAG
"RTN","HLUTIL4",63,0)
 ;
"RTN","HLUTIL4",64,0)
 ; only HLMTIEN(parent message IEN) is defined
"RTN","HLUTIL4",65,0)
 I $G(HLMTIEN) D
"RTN","HLUTIL4",66,0)
 . I '$D(^HL(772,HLMTIEN)) S FLAG=-1 Q
"RTN","HLUTIL4",67,0)
 . I (HLMTIEN'=$P(^HL(772,HLMTIEN,0),"^",8)) S FLAG=-1 Q
"RTN","HLUTIL4",68,0)
 . L +^HL(772,HLMTIEN):300
"RTN","HLUTIL4",69,0)
 . E  S FLAG=-1 Q
"RTN","HLUTIL4",70,0)
 . D SETVALUE
"RTN","HLUTIL4",71,0)
 . L -^HL(772,HLMTIEN)
"RTN","HLUTIL4",72,0)
 . S FLAG=STATUS
"RTN","HLUTIL4",73,0)
 I (FLAG=-1)!(FLAG=STATUS) Q FLAG
"RTN","HLUTIL4",74,0)
 ;
"RTN","HLUTIL4",75,0)
 ; only HLMTIENS(child message IEN) is defined
"RTN","HLUTIL4",76,0)
 I $G(HLMTIENS) D
"RTN","HLUTIL4",77,0)
 . I '$D(^HL(772,HLMTIENS)) S FLAG=-1 Q
"RTN","HLUTIL4",78,0)
 . S HLMTIEN=$P(^HL(772,HLMTIENS,0),"^",8)
"RTN","HLUTIL4",79,0)
 . I 'HLMTIEN S FLAG=-1 Q
"RTN","HLUTIL4",80,0)
 . I '$D(^HL(772,HLMTIEN)) S FLAG=-1 Q
"RTN","HLUTIL4",81,0)
 . I (HLMTIEN'=$P(^HL(772,HLMTIEN,0),"^",8)) S FLAG=-1 Q
"RTN","HLUTIL4",82,0)
 . L +^HL(772,HLMTIEN):300
"RTN","HLUTIL4",83,0)
 . E  S FLAG=-1 Q
"RTN","HLUTIL4",84,0)
 . L +^HL(772,HLMTIENS):300
"RTN","HLUTIL4",85,0)
 . E  L -^HL(772,HLMTIEN) S FLAG=-1 Q
"RTN","HLUTIL4",86,0)
 . D SETVALUE
"RTN","HLUTIL4",87,0)
 . L -^HL(772,HLMTIENS)
"RTN","HLUTIL4",88,0)
 . L -^HL(772,HLMTIEN)
"RTN","HLUTIL4",89,0)
 . S FLAG=STATUS
"RTN","HLUTIL4",90,0)
 Q FLAG
"RTN","HLUTIL4",91,0)
 ;
"RTN","HLUTIL4",92,0)
SETVALUE ; set or clear the DONT PURGE field
"RTN","HLUTIL4",93,0)
 S ^HL(772,HLMTIEN,2)=STATUS
"RTN","HLUTIL4",94,0)
 I $G(HLMTIENS) S ^HL(772,HLMTIENS,2)=STATUS
"RTN","HLUTIL4",95,0)
 Q
"RTN","HLUTIL4",96,0)
 ;
"RTN","HLUTIL4",97,0)
PROC(IEN,RTN) ; reprocessing HLLP or MailMan message
"RTN","HLUTIL4",98,0)
 ; IEN- either the parent message IEN or the child message IEN
"RTN","HLUTIL4",99,0)
 ;  of file #772
"RTN","HLUTIL4",100,0)
 ; RTN- the routine, to be Xecuted for processing the message
"RTN","HLUTIL4",101,0)
 ;
"RTN","HLUTIL4",102,0)
 ; return value:
"RTN","HLUTIL4",103,0)
 ; "0^reprocessing is successful" for success.
"RTN","HLUTIL4",104,0)
 ; "-1^<error text>" for failure.
"RTN","HLUTIL4",105,0)
 ;
"RTN","HLUTIL4",106,0)
 N HLMTIEN,HLMTIENS,HLNEXT,HLNODE,HLQUIT,HLERR,HLRESLT
"RTN","HLUTIL4",107,0)
 N HL,HDR,HLMSA,X,X1
"RTN","HLUTIL4",108,0)
 N HLI,HLTMP,MSAFLAG
"RTN","HLUTIL4",109,0)
 ;
"RTN","HLUTIL4",110,0)
 Q:'$G(IEN) "-1^not a valid IEN"
"RTN","HLUTIL4",111,0)
 I $G(RTN)']"" Q "-1^reprocessing routine is misssing"
"RTN","HLUTIL4",112,0)
 ;
"RTN","HLUTIL4",113,0)
 S HLTMP=$G(^HL(772,IEN,0))
"RTN","HLUTIL4",114,0)
 I HLTMP']"" Q "-1^not a valid entry"
"RTN","HLUTIL4",115,0)
 I $P(HLTMP,"^",4)'="I" Q "-1^not an incoming message"
"RTN","HLUTIL4",116,0)
 ;
"RTN","HLUTIL4",117,0)
 ; get parent message ien
"RTN","HLUTIL4",118,0)
 S HLMTIEN=$P(HLTMP,"^",8)
"RTN","HLUTIL4",119,0)
 ;
"RTN","HLUTIL4",120,0)
 ; if IEN is child, define HLMTIENS as child IEN
"RTN","HLUTIL4",121,0)
 I HLMTIEN,(HLMTIEN'=IEN) S HLMTIENS=IEN
"RTN","HLUTIL4",122,0)
 ;
"RTN","HLUTIL4",123,0)
 ; if IEN is parent, find child ien, HLMTIENS
"RTN","HLUTIL4",124,0)
 I '$G(HLMTIENS) D
"RTN","HLUTIL4",125,0)
 . S HLMTIEN=IEN
"RTN","HLUTIL4",126,0)
 . S HLMTIENS=+$O(^HL(772,"AI",IEN,IEN))
"RTN","HLUTIL4",127,0)
 ;
"RTN","HLUTIL4",128,0)
 S HLMSA=""
"RTN","HLUTIL4",129,0)
 S MSAFLAG=0
"RTN","HLUTIL4",130,0)
 S X=0
"RTN","HLUTIL4",131,0)
 F HLI=1:1:6 S X=$O(^HL(772,HLMTIEN,"IN",X)) Q:(X'>0)!(MSAFLAG)  D
"RTN","HLUTIL4",132,0)
 . S X1=$G(^HL(772,HLMTIEN,"IN",X,0))
"RTN","HLUTIL4",133,0)
 . Q:"FHS,BHS,MSH,MSA"'[$E(X1,1,3)
"RTN","HLUTIL4",134,0)
 . ; If header segment, define HDR for header
"RTN","HLUTIL4",135,0)
 . I '$D(HDR),"FHS,BHS,MSH"[$E(X1,1,3) D  Q
"RTN","HLUTIL4",136,0)
 .. S HDR=X1
"RTN","HLUTIL4",137,0)
 . ; variable HLMSA is used to save the MSA segment data of MSH msg,
"RTN","HLUTIL4",138,0)
 . ; HLMSA is not for saving the MSA segment data of BHS msg
"RTN","HLUTIL4",139,0)
 . ; the MSA segment data of BHS msg will be set in CHK^HLTPCK1
"RTN","HLUTIL4",140,0)
 . I $E(X1,1,3)="MSA",$G(HLMSA)="",$E($G(HDR),1,3)="MSH" D
"RTN","HLUTIL4",141,0)
 .. S HLMSA=X1
"RTN","HLUTIL4",142,0)
 .. S MSAFLAG=1
"RTN","HLUTIL4",143,0)
 ;
"RTN","HLUTIL4",144,0)
 Q:'$D(HDR) "-1^missing message header segment"
"RTN","HLUTIL4",145,0)
 ;
"RTN","HLUTIL4",146,0)
 ;Validate message header
"RTN","HLUTIL4",147,0)
 D CHK^HLTPCK1(HDR,.HL,$S(HLMSA]"":$P(HLMSA,$E(HDR,4),2,4),1:""))
"RTN","HLUTIL4",148,0)
 ;
"RTN","HLUTIL4",149,0)
 I $G(HL)]"" Q "-1^"_HL
"RTN","HLUTIL4",150,0)
 ;
"RTN","HLUTIL4",151,0)
 S HLQUIT=0,HLNODE="",HLNEXT="D HLNEXT^HLCSUTL"
"RTN","HLUTIL4",152,0)
 ;
"RTN","HLUTIL4",153,0)
 I RTN["D " X RTN
"RTN","HLUTIL4",154,0)
 I RTN'["D " D
"RTN","HLUTIL4",155,0)
 . I RTN["^" X "D "_RTN
"RTN","HLUTIL4",156,0)
 . I RTN'["^" X "D ^"_RTN
"RTN","HLUTIL4",157,0)
 ;
"RTN","HLUTIL4",158,0)
 S HLRESLT=0
"RTN","HLUTIL4",159,0)
 S:($D(HLERR)) HLRESLT="9^"_$G(^HL(771.7,9,0))
"RTN","HLUTIL4",160,0)
 ;
"RTN","HLUTIL4",161,0)
 ; update the status of child message
"RTN","HLUTIL4",162,0)
 I $G(HLMTIENS) D
"RTN","HLUTIL4",163,0)
 . D STATUS^HLTF0(HLMTIENS,$S(HLRESLT:4,1:3),$S(HLRESLT:+HLRESLT,1:""),$S($D(HLERR):HLERR,HLRESLT:$P(HLRESLT,"^",2),1:""),,1)
"RTN","HLUTIL4",164,0)
 ;
"RTN","HLUTIL4",165,0)
 ; update the status of parent message
"RTN","HLUTIL4",166,0)
 D STATUS^HLTF0(HLMTIEN,$S(HLRESLT:4,1:3),$S(HLRESLT:+HLRESLT,1:""),$S(HLRESLT:$P(HLRESLT,"^",2),1:""),,1)
"RTN","HLUTIL4",167,0)
 ;
"RTN","HLUTIL4",168,0)
 Q "0^reprocessing is successful"
"RTN","HLUTIL4",169,0)
 ;
"VER")
8.0^22.0
"^DD",773,773,2,0)
MESSAGE ID^F^^0;2^K:$L(X)>60!($L(X)<1) X
"^DD",773,773,2,1,0)
^.1^^-1
"^DD",773,773,2,1,2,0)
773^AH^MUMPS
"^DD",773,773,2,1,2,1)
S:$P(^HLMA(DA,0),U,12) ^HLMA("AH",+$P(^(0),U,12),X,DA)=""
"^DD",773,773,2,1,2,2)
K:$P(^HLMA(DA,0),U,12) ^HLMA("AH",+$P(^(0),U,12),X,DA)
"^DD",773,773,2,1,2,3)
This x-reference is used in conjunction with the 'AG' x-ref on field 205
"^DD",773,773,2,1,2,"%D",0)
^^2^2^2980811^^^
"^DD",773,773,2,1,2,"%D",1,0)
This x-reference is used to look up the original message when processing
"^DD",773,773,2,1,2,"%D",2,0)
a response.
"^DD",773,773,2,1,2,"DT")
2980811
"^DD",773,773,2,3)
Answer must be 1-60 characters in length
"^DD",773,773,2,21,0)
^^1^1^2980414^^
"^DD",773,773,2,21,1,0)
This is an unique identifier associated with a message.
"^DD",773,773,2,"DT")
3080515
"^DD",773,773,100,0)
LAST DATE/TIME UPDATED^D^^S;1^S %DT="ESTXR" D ^%DT S X=Y K:Y<1 X
"^DD",773,773,100,1,0)
^.1^^-1
"^DD",773,773,100,1,1,0)
773^AD^MUMPS
"^DD",773,773,100,1,1,1)
S ^HLMA("AD",X,DA)="" N %,%1 S %=$G(^HLMA(DA,0)),%1=$P(%,U,3),%=$P(%,U,7) K:%1]""&% ^HLMA("AC",%1,%,DA)
"^DD",773,773,100,1,1,2)
K ^HLMA("AD",X,DA)
"^DD",773,773,100,1,1,3)
Required to determine if a message has been processed.
"^DD",773,773,100,1,1,"%D",0)
^.101^2^2^3031208^^^^
"^DD",773,773,100,1,1,"%D",1,0)
This cross-reference is used to remove messages from the 'AC' x-ref. after
"^DD",773,773,100,1,1,"%D",2,0)
they have been processed.  It also set the 'AD' x-ref for the date processed.
"^DD",773,773,100,1,1,"DT")
3031208
"^DD",773,773,100,1,2,0)
773^AF
"^DD",773,773,100,1,2,1)
S ^HLMA("AF",$E(X,1,30),DA)=""
"^DD",773,773,100,1,2,2)
K ^HLMA("AF",$E(X,1,30),DA)
"^DD",773,773,100,1,2,"DT")
2980811
"^DD",773,773,100,3)
The date and time this transmission was processed.
"^DD",773,773,100,21,0)
^^9^9^3090224^
"^DD",773,773,100,21,1,0)
For outgoing message:
"^DD",773,773,100,21,2,0)
  1. Date/time of its commit ACK received.
"^DD",773,773,100,21,3,0)
  2. Date/time of its application ACK message received (overwriting 
"^DD",773,773,100,21,4,0)
     #1).
"^DD",773,773,100,21,5,0)
 
"^DD",773,773,100,21,6,0)
And for incoming message:
"^DD",773,773,100,21,7,0)
  1. Date/time of the message received.
"^DD",773,773,100,21,8,0)
  2. Date/time of the message has been processed by the application 
"^DD",773,773,100,21,9,0)
     (overwriting #1).
"^DD",773,773,100,"DT")
3090224
"^DD",773,773,102,0)
TIME START TO SEND^D^^S;2^S %DT="ESTR" D ^%DT S X=Y K:X<1 X
"^DD",773,773,102,3)
(No range limit on date)
"^DD",773,773,102,21,0)
^^1^1^3090223^
"^DD",773,773,102,21,1,0)
This is the date/time the transmission of this outgoing message began.
"^DD",773,773,102,"DT")
3090223
"^DD",773,773,103,0)
TIME SENT^D^^S;3^S %DT="ESTR" D ^%DT S X=Y K:X<1 X
"^DD",773,773,103,3)
(No range limit on date)
"^DD",773,773,103,21,0)
^^1^1^3090223^
"^DD",773,773,103,21,1,0)
This is the date/time the transmission of this outgoing message finished.
"^DD",773,773,103,"DT")
3090223
"^DD",773,773,104,0)
TIME OF COMMIT/APP ACK^D^^S;4^S %DT="ESTR" D ^%DT S X=Y K:X<1 X
"^DD",773,773,104,3)
(No range limit on date)
"^DD",773,773,104,21,0)
^^2^2^3090223^
"^DD",773,773,104,21,1,0)
This is the date/time this message received the commit ACK, or application
"^DD",773,773,104,21,2,0)
ACK of original mode or direct connect transmission (API: DIRECT^HLMA).
"^DD",773,773,104,"DT")
3090223
"^DD",773,773,105,0)
TIME OF APPLICATION ACK^D^^S;5^S %DT="ESTR" D ^%DT S X=Y K:X<1 X
"^DD",773,773,105,3)
(No range limit on date)
"^DD",773,773,105,21,0)
^^1^1^3090223^
"^DD",773,773,105,21,1,0)
This is the date/time this message received the application ACK.
"^DD",773,773,105,"DT")
3090223
"^DD",773,773,106,0)
TIME START PROCESSING^D^^S;6^S %DT="ESTR" D ^%DT S X=Y K:X<1 X
"^DD",773,773,106,3)
(No range limit on date)
"^DD",773,773,106,21,0)
^^1^1^3090223^
"^DD",773,773,106,21,1,0)
This is the date/time the application began processing this message.
"^DD",773,773,106,"DT")
3090223
"^DD",773,773,107,0)
TIME PROCESSED^D^^S;7^S %DT="ESTR" D ^%DT S X=Y K:X<1 X
"^DD",773,773,107,3)
(No range limit on date)
"^DD",773,773,107,21,0)
^^1^1^3090223^
"^DD",773,773,107,21,1,0)
This is the date/time the application finished processing this message.
"^DD",773,773,107,"DT")
3090223
"BLD",1088,6)
^114
**END**
**END**
