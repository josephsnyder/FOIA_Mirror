Released HL*1.6*143 SEQ #116
Extracted from mail message
**KIDS**:HL*1.6*143^

**INSTALL NAME**
HL*1.6*143
"BLD",1272,0)
HL*1.6*143^HEALTH LEVEL SEVEN^0^3090619^y
"BLD",1272,1,0)
^^2^2^3090616^
"BLD",1272,1,1,0)
See the National Patch Module on Forum.
"BLD",1272,1,2,0)

"BLD",1272,4,0)
^9.64PA^^
"BLD",1272,6.3)
3
"BLD",1272,"ABPKG")
n
"BLD",1272,"INI")
PRE^HLOP143
"BLD",1272,"INID")
^^n
"BLD",1272,"KRN",0)
^9.67PA^9002226^21
"BLD",1272,"KRN",.4,0)
.4
"BLD",1272,"KRN",.401,0)
.401
"BLD",1272,"KRN",.402,0)
.402
"BLD",1272,"KRN",.403,0)
.403
"BLD",1272,"KRN",.5,0)
.5
"BLD",1272,"KRN",.84,0)
.84
"BLD",1272,"KRN",3.6,0)
3.6
"BLD",1272,"KRN",3.8,0)
3.8
"BLD",1272,"KRN",9.2,0)
9.2
"BLD",1272,"KRN",9.8,0)
9.8
"BLD",1272,"KRN",9.8,"NM",0)
^9.68A^8^8
"BLD",1272,"KRN",9.8,"NM",1,0)
HLOCLNT^^0^B86058650
"BLD",1272,"KRN",9.8,"NM",2,0)
HLOCLNT2^^0^B39313138
"BLD",1272,"KRN",9.8,"NM",3,0)
HLOMSG1^^0^B14540604
"BLD",1272,"KRN",9.8,"NM",4,0)
HLOQUE^^0^B97643227
"BLD",1272,"KRN",9.8,"NM",5,0)
HLOSRVR^^0^B84549527
"BLD",1272,"KRN",9.8,"NM",6,0)
HLOSRVR1^^0^B86996455
"BLD",1272,"KRN",9.8,"NM",7,0)
HLOPURGE^^0^B35133354
"BLD",1272,"KRN",9.8,"NM",8,0)
HLOUSR1^^0^B106022744
"BLD",1272,"KRN",9.8,"NM","B","HLOCLNT",1)

"BLD",1272,"KRN",9.8,"NM","B","HLOCLNT2",2)

"BLD",1272,"KRN",9.8,"NM","B","HLOMSG1",3)

"BLD",1272,"KRN",9.8,"NM","B","HLOPURGE",7)

"BLD",1272,"KRN",9.8,"NM","B","HLOQUE",4)

"BLD",1272,"KRN",9.8,"NM","B","HLOSRVR",5)

"BLD",1272,"KRN",9.8,"NM","B","HLOSRVR1",6)

"BLD",1272,"KRN",9.8,"NM","B","HLOUSR1",8)

"BLD",1272,"KRN",19,0)
19
"BLD",1272,"KRN",19.1,0)
19.1
"BLD",1272,"KRN",101,0)
101
"BLD",1272,"KRN",409.61,0)
409.61
"BLD",1272,"KRN",771,0)
771
"BLD",1272,"KRN",779.2,0)
779.2
"BLD",1272,"KRN",870,0)
870
"BLD",1272,"KRN",8989.51,0)
8989.51
"BLD",1272,"KRN",8989.52,0)
8989.52
"BLD",1272,"KRN",8994,0)
8994
"BLD",1272,"KRN",9002226,0)
9002226
"BLD",1272,"KRN","B",.4,.4)

"BLD",1272,"KRN","B",.401,.401)

"BLD",1272,"KRN","B",.402,.402)

"BLD",1272,"KRN","B",.403,.403)

"BLD",1272,"KRN","B",.5,.5)

"BLD",1272,"KRN","B",.84,.84)

"BLD",1272,"KRN","B",3.6,3.6)

"BLD",1272,"KRN","B",3.8,3.8)

"BLD",1272,"KRN","B",9.2,9.2)

"BLD",1272,"KRN","B",9.8,9.8)

"BLD",1272,"KRN","B",19,19)

"BLD",1272,"KRN","B",19.1,19.1)

"BLD",1272,"KRN","B",101,101)

"BLD",1272,"KRN","B",409.61,409.61)

"BLD",1272,"KRN","B",771,771)

"BLD",1272,"KRN","B",779.2,779.2)

"BLD",1272,"KRN","B",870,870)

"BLD",1272,"KRN","B",8989.51,8989.51)

"BLD",1272,"KRN","B",8989.52,8989.52)

"BLD",1272,"KRN","B",8994,8994)

"BLD",1272,"KRN","B",9002226,9002226)

"BLD",1272,"QUES",0)
^9.62^^
"BLD",1272,"REQB",0)
^9.611^1^1
"BLD",1272,"REQB",1,0)
HL*1.6*139^2
"BLD",1272,"REQB","B","HL*1.6*139",1)

"INI")
PRE^HLOP143
"MBREQ")
0
"PKG",9,-1)
1^1
"PKG",9,0)
HEALTH LEVEL SEVEN^HL^DHCP IMPLEMENTATION OF HEALTH LEVEL SEVEN^
"PKG",9,20,0)
^9.402P^^
"PKG",9,22,0)
^9.49I^1^1
"PKG",9,22,1,0)
1.6^2980130^2980130^6
"PKG",9,22,1,"PAH",1,0)
143^3090619
"PKG",9,22,1,"PAH",1,1,0)
^^2^2^3090619
"PKG",9,22,1,"PAH",1,1,1,0)
See the National Patch Module on Forum.
"PKG",9,22,1,"PAH",1,1,2,0)

"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
NO
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
NO
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
NO
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
9
"RTN","HLOCLNT")
0^1^B86058650^B75551909
"RTN","HLOCLNT",1,0)
HLOCLNT ;ALB/CJM- Client for sending messages - 10/4/94 1pm ;06/17/2009
"RTN","HLOCLNT",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,130,131,134,137,139,143**;Oct 13, 1995;Build 3
"RTN","HLOCLNT",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOCLNT",4,0)
 ;
"RTN","HLOCLNT",5,0)
 ;GET WORK function for the process running under the Process Manager
"RTN","HLOCLNT",6,0)
GETWORK(QUE) ;
"RTN","HLOCLNT",7,0)
 ;Input:
"RTN","HLOCLNT",8,0)
 ;  QUE - (pass by reference) These subscripts are used:
"RTN","HLOCLNT",9,0)
 ;    ("LINK")  - <link name>_":"_<port> last obtained
"RTN","HLOCLNT",10,0)
 ;    ("QUEUE") - name of the queue last obtained
"RTN","HLOCLNT",11,0)
 ;Output:
"RTN","HLOCLNT",12,0)
 ;  Function returns 1 if success, 0 if no more work
"RTN","HLOCLNT",13,0)
 ;  QUE -  updated to identify next queue of messages to process.
"RTN","HLOCLNT",14,0)
 ;    ("LINK") - <link name>_":"_<port>
"RTN","HLOCLNT",15,0)
 ;    ("QUEUE") - the named queue on the link
"RTN","HLOCLNT",16,0)
 ;    ("DOWN") - =1 means that the last OPEN attempt failed
"RTN","HLOCLNT",17,0)
 ;
"RTN","HLOCLNT",18,0)
 N LINK,QUEUE
"RTN","HLOCLNT",19,0)
 S LINK=$G(QUE("LINK")),QUEUE=$G(QUE("QUEUE"))
"RTN","HLOCLNT",20,0)
 I (LINK]""),(QUEUE]"") D
"RTN","HLOCLNT",21,0)
 .L -^HLB("QUEUE","OUT",LINK,QUEUE)
"RTN","HLOCLNT",22,0)
 .I $$IFSHUT^HLOTLNK($P(LINK,":")) S QUEUE="" Q
"RTN","HLOCLNT",23,0)
 .I '$$CNNCTD(LINK),$$FAILING(.LINK) S QUEUE="" Q
"RTN","HLOCLNT",24,0)
 .F  S QUEUE=$O(^HLB("QUEUE","OUT",LINK,QUEUE)) Q:(QUEUE="")  I '$$STOPPED^HLOQUE("OUT",QUEUE) L +^HLB("QUEUE","OUT",LINK,QUEUE):0  Q:$T
"RTN","HLOCLNT",25,0)
 I (LINK]""),(QUEUE="") D
"RTN","HLOCLNT",26,0)
 .F  S LINK=$O(^HLB("QUEUE","OUT",LINK)) Q:LINK=""  D  Q:$L(QUEUE)
"RTN","HLOCLNT",27,0)
 ..Q:$$IFSHUT^HLOTLNK($P(LINK,":"))
"RTN","HLOCLNT",28,0)
 ..I '$$CNNCTD(LINK),$$FAILING(.LINK) Q
"RTN","HLOCLNT",29,0)
 ..S QUEUE="" F  S QUEUE=$O(^HLB("QUEUE","OUT",LINK,QUEUE)) Q:(QUEUE="")  I '$$STOPPED^HLOQUE("OUT",QUEUE) L +^HLB("QUEUE","OUT",LINK,QUEUE):0 Q:$T
"RTN","HLOCLNT",30,0)
 I LINK="" D
"RTN","HLOCLNT",31,0)
 .F  S LINK=$O(^HLB("QUEUE","OUT",LINK)) Q:LINK=""  D  Q:$L(QUEUE)
"RTN","HLOCLNT",32,0)
 ..Q:$$IFSHUT^HLOTLNK($P(LINK,":"))
"RTN","HLOCLNT",33,0)
 ..I '$$CNNCTD(LINK),$$FAILING(.LINK) Q
"RTN","HLOCLNT",34,0)
 ..S QUEUE="" F  S QUEUE=$O(^HLB("QUEUE","OUT",LINK,QUEUE)) Q:(QUEUE="")  I '$$STOPPED^HLOQUE("OUT",QUEUE) L +^HLB("QUEUE","OUT",LINK,QUEUE):0 Q:$T
"RTN","HLOCLNT",35,0)
 S QUE("LINK")=LINK,QUE("QUEUE")=QUEUE,QUE("DOWN")=$G(LINK("DOWN"))
"RTN","HLOCLNT",36,0)
 Q:$L(QUEUE) 1
"RTN","HLOCLNT",37,0)
 D:$G(HLCSTATE("CONNECTED")) CLOSE^HLOT(.HLCSTATE)
"RTN","HLOCLNT",38,0)
 Q 0
"RTN","HLOCLNT",39,0)
 ;
"RTN","HLOCLNT",40,0)
FAILING(LINK) ;
"RTN","HLOCLNT",41,0)
 ;Returns 1 if the link has failed in the last 30 seconds, 0 otherwise
"RTN","HLOCLNT",42,0)
 ;Also returns LINK("DOWN")=1 if the link was failing > 30 seconds ago, not yet known if its up
"RTN","HLOCLNT",43,0)
 ;
"RTN","HLOCLNT",44,0)
 N LASTTIME,SET
"RTN","HLOCLNT",45,0)
 S LINK("DOWN")=0
"RTN","HLOCLNT",46,0)
 S LASTTIME=$G(^HLB("QUEUE","OUT",LINK))
"RTN","HLOCLNT",47,0)
 S SET=$S(LASTTIME]"":1,1:0)
"RTN","HLOCLNT",48,0)
 I SET D
"RTN","HLOCLNT",49,0)
 .I $$HDIFF^XLFDT($H,LASTTIME,2)>30 S ^HLB("QUEUE","OUT",LINK)="",SET=0,LINK("DOWN")=1
"RTN","HLOCLNT",50,0)
 I $D(^HLTMP("FAILING LINKS",LINK)) S LINK("DOWN")=1
"RTN","HLOCLNT",51,0)
 Q SET
"RTN","HLOCLNT",52,0)
 ;
"RTN","HLOCLNT",53,0)
LINKDOWN(HLCSTATE) ;
"RTN","HLOCLNT",54,0)
 N TO
"RTN","HLOCLNT",55,0)
 D:$G(HLCSTATE("CONNECTED")) CLOSE^HLOT(.HLCSTATE)
"RTN","HLOCLNT",56,0)
 I $D(HLCSTATE("LINK","NAME")),$D(HLCSTATE("LINK","PORT")) D
"RTN","HLOCLNT",57,0)
 .S TO=HLCSTATE("LINK","NAME")_":"_HLCSTATE("LINK","PORT")
"RTN","HLOCLNT",58,0)
 .S ^HLB("QUEUE","OUT",TO)=$H
"RTN","HLOCLNT",59,0)
 .S:'$D(^HLTMP("FAILING LINKS",TO)) ^HLTMP("FAILING LINKS",TO)=$H
"RTN","HLOCLNT",60,0)
 Q
"RTN","HLOCLNT",61,0)
 ;
"RTN","HLOCLNT",62,0)
ERROR ;error trap
"RTN","HLOCLNT",63,0)
ZB3 ;
"RTN","HLOCLNT",64,0)
 ;
"RTN","HLOCLNT",65,0)
 S $ETRAP="Q:$QUIT """" Q"
"RTN","HLOCLNT",66,0)
 ;
"RTN","HLOCLNT",67,0)
 N HOUR
"RTN","HLOCLNT",68,0)
 S HOUR=+$E($$NOW^XLFDT,1,10)
"RTN","HLOCLNT",69,0)
 S ^TMP("HL7 ERRORS",$J,HOUR,$P($ECODE,",",2))=$G(^TMP("HL7 ERRORS",$J,HOUR,$P($ECODE,",",2)))+1
"RTN","HLOCLNT",70,0)
 D END
"RTN","HLOCLNT",71,0)
 D LINKDOWN(.HLCSTATE)
"RTN","HLOCLNT",72,0)
 ;
"RTN","HLOCLNT",73,0)
 I ($ECODE["TOOMANYFILES")!($ECODE["EDITED") Q:$QUIT "" Q
"RTN","HLOCLNT",74,0)
 ;while debugging quit on all errors - this will return the process to the Process Manager error trap
"RTN","HLOCLNT",75,0)
 I $G(^HLTMP("LOG ALL ERRORS")) Q:$QUIT "" Q
"RTN","HLOCLNT",76,0)
 ;
"RTN","HLOCLNT",77,0)
 ;don't log some common errors
"RTN","HLOCLNT",78,0)
 I ($ECODE["READ")!($ECODE["NOTOPEN")!($ECODE["DEVNOTOPN")!($ECODE["WRITE")!($ECODE["OPENERR") D
"RTN","HLOCLNT",79,0)
 .;
"RTN","HLOCLNT",80,0)
 E  D
"RTN","HLOCLNT",81,0)
 .;but do log all the others
"RTN","HLOCLNT",82,0)
 .D ^%ZTER
"RTN","HLOCLNT",83,0)
 ;
"RTN","HLOCLNT",84,0)
 ;a lot of errors of the same type may indicate an endless loop
"RTN","HLOCLNT",85,0)
 ;return to the Process Manager error trap
"RTN","HLOCLNT",86,0)
 I ($G(^TMP("HL7 ERRORS",$J,HOUR,$P($ECODE,",",2)))>30) Q:$QUIT "" Q
"RTN","HLOCLNT",87,0)
 ;
"RTN","HLOCLNT",88,0)
 ;resume execution of the process manager executing the client
"RTN","HLOCLNT",89,0)
 D UNWIND^%ZTER
"RTN","HLOCLNT",90,0)
 Q
"RTN","HLOCLNT",91,0)
 ;
"RTN","HLOCLNT",92,0)
DOWORK(QUEUE) ;sends the messages on the queue
"RTN","HLOCLNT",93,0)
ZB0 N $ETRAP,$ESTACK S $ETRAP="G ERROR^HLOCLNT"
"RTN","HLOCLNT",94,0)
 N MSGIEN,DEQUE,SUCCESS,MSGCOUNT
"RTN","HLOCLNT",95,0)
 S DEQUE=0
"RTN","HLOCLNT",96,0)
 S SUCCESS=1
"RTN","HLOCLNT",97,0)
 ;
"RTN","HLOCLNT",98,0)
 I '$$CNNCTD(QUEUE("LINK")),'$$CONNECT^HLOCLNT1($P(QUEUE("LINK"),":"),$P(QUEUE("LINK"),":",2),30,.HLCSTATE) Q
"RTN","HLOCLNT",99,0)
 S (MSGCOUNT,MSGIEN)=0
"RTN","HLOCLNT",100,0)
 F  S MSGIEN=$O(^HLB("QUEUE","OUT",QUEUE("LINK"),QUEUE("QUEUE"),MSGIEN)) D  Q:'SUCCESS  Q:MSGCOUNT>1000  Q:$$STOPPED^HLOQUE("OUT",QUEUE("QUEUE"))  Q:$$IFSHUT^HLOTLNK($P(QUEUE("LINK"),":"))
"RTN","HLOCLNT",101,0)
 .S:'MSGIEN SUCCESS=0
"RTN","HLOCLNT",102,0)
ZB4 .;
"RTN","HLOCLNT",103,0)
 .Q:'SUCCESS
"RTN","HLOCLNT",104,0)
 .N UPDATE
"RTN","HLOCLNT",105,0)
 .S ^HLB(MSGIEN,"TRIES")=$G(^HLB(MSGIEN,"TRIES"))+1
"RTN","HLOCLNT",106,0)
 .S SUCCESS=0
"RTN","HLOCLNT",107,0)
 .S:$$TRANSMIT(.HLCSTATE,MSGIEN,.UPDATE) SUCCESS=1
"RTN","HLOCLNT",108,0)
 .Q:('SUCCESS)!('$D(UPDATE))
"RTN","HLOCLNT",109,0)
 .D DEQUE(.UPDATE)
"RTN","HLOCLNT",110,0)
 .S MSGCOUNT=MSGCOUNT+1
"RTN","HLOCLNT",111,0)
 .D:HLCSTATE("COUNTS")>4 SAVECNTS^HLOSTAT(.HLCSTATE)
"RTN","HLOCLNT",112,0)
 .;
"RTN","HLOCLNT",113,0)
 .;if the queue was on the down list, and not since shutdown, mark it as up, since a message has been successfully transmitted across it
"RTN","HLOCLNT",114,0)
 .I $G(QUEUE("DOWN"))!$$FAILING(QUEUE("LINK")),'$$IFSHUT^HLOTLNK(QUEUE("LINK")) S QUEUE("DOWN")=0,^HLB("QUEUE","OUT",QUEUE("LINK"))="" K ^HLTMP("FAILING LINKS",QUEUE("LINK"))
"RTN","HLOCLNT",115,0)
 ;
"RTN","HLOCLNT",116,0)
ZB5 ;
"RTN","HLOCLNT",117,0)
END D DEQUE()
"RTN","HLOCLNT",118,0)
 D SAVECNTS^HLOSTAT(.HLCSTATE)
"RTN","HLOCLNT",119,0)
 Q
"RTN","HLOCLNT",120,0)
CNNCTD(LINK) ;
"RTN","HLOCLNT",121,0)
 ;Connected to LINK?  HLCSTATE must be defined, LINK=<link name>:<port>
"RTN","HLOCLNT",122,0)
 ;
"RTN","HLOCLNT",123,0)
 I ($G(HLCSTATE("LINK","NAME"))=$P(LINK,":")),($G(HLCSTATE("LINK","PORT"))=$P(LINK,":",2)),$G(HLCSTATE("CONNECTED")) Q 1
"RTN","HLOCLNT",124,0)
 Q 0
"RTN","HLOCLNT",125,0)
 ;
"RTN","HLOCLNT",126,0)
DEQUE(UPDATE) ;
"RTN","HLOCLNT",127,0)
 ;**P143 START CJM
"RTN","HLOCLNT",128,0)
ZB25 ;
"RTN","HLOCLNT",129,0)
 ;**P143 END CJM
"RTN","HLOCLNT",130,0)
 I $D(UPDATE) S DEQUE=DEQUE+1,DEQUE(+UPDATE)=$P(UPDATE,"^",2,99) S:$G(UPDATE("MSA"))]"" DEQUE(+UPDATE,"MSA")=UPDATE("MSA") S:$G(UPDATE("ACTION"))]"" DEQUE(+UPDATE,"ACTION")=UPDATE("ACTION")
"RTN","HLOCLNT",131,0)
 I '$D(UPDATE)!(DEQUE>15) D
"RTN","HLOCLNT",132,0)
 .N MSGIEN S MSGIEN=0
"RTN","HLOCLNT",133,0)
 .F  S MSGIEN=$O(DEQUE(MSGIEN)) Q:'MSGIEN  D
"RTN","HLOCLNT",134,0)
 ..N NODE,TIME
"RTN","HLOCLNT",135,0)
 ..D DEQUE^HLOQUE(QUEUE("LINK"),QUEUE("QUEUE"),"OUT",MSGIEN)
"RTN","HLOCLNT",136,0)
 ..S TIME=$P(DEQUE(MSGIEN),"^")
"RTN","HLOCLNT",137,0)
 ..Q:'TIME
"RTN","HLOCLNT",138,0)
 ..S NODE=QUEUE("LINK")_"^"_QUEUE("QUEUE")_"^"_$P(DEQUE(MSGIEN),"^",2,99)
"RTN","HLOCLNT",139,0)
 ..S ^HLTMP("CLIENT UPDATES",$J,TIME,MSGIEN)=NODE
"RTN","HLOCLNT",140,0)
 ..S:$G(DEQUE(MSGIEN,"MSA"))]"" ^HLTMP("CLIENT UPDATES",$J,TIME,MSGIEN,"MSA")=DEQUE(MSGIEN,"MSA")
"RTN","HLOCLNT",141,0)
 ..S:$G(DEQUE(MSGIEN,"ACTION"))]"" ^HLTMP("CLIENT UPDATES",$J,TIME,MSGIEN,"ACTION")=DEQUE(MSGIEN,"ACTION")
"RTN","HLOCLNT",142,0)
 .K DEQUE S DEQUE=0
"RTN","HLOCLNT",143,0)
 Q
"RTN","HLOCLNT",144,0)
 ;
"RTN","HLOCLNT",145,0)
TRANSMIT(HLCSTATE,MSGIEN,UPDATE) ;
"RTN","HLOCLNT",146,0)
 ;Transmits a single message and if a commit ack was requested reads it.  Updates file 778 with the result.  Queues for the infiler the application accept action if one was requested.
"RTN","HLOCLNT",147,0)
 ;Input:
"RTN","HLOCLNT",148,0)
 ;   HLCSTATE (pass by reference)
"RTN","HLOCLNT",149,0)
 ;   MSGIEN - ien, file 778, of message to be transmitted
"RTN","HLOCLNT",150,0)
 ;Output:
"RTN","HLOCLNT",151,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOCLNT",152,0)
 ;  UPDATE - (pass by reference) to contain updates needed for message
"RTN","HLOCLNT",153,0)
 ;
"RTN","HLOCLNT",154,0)
 N HLMSTATE,MSA,HDR,SUCCESS
"RTN","HLOCLNT",155,0)
 ;
"RTN","HLOCLNT",156,0)
 S SUCCESS=0
"RTN","HLOCLNT",157,0)
 S HLCSTATE("ATTEMPT")=0
"RTN","HLOCLNT",158,0)
 ;
"RTN","HLOCLNT",159,0)
 ;start saving updates needed after the message is transmitted
"RTN","HLOCLNT",160,0)
 S UPDATE=MSGIEN
"RTN","HLOCLNT",161,0)
 Q:'$$GETMSG^HLOCLNT2(MSGIEN,.HLMSTATE) 1  ;returns 1 so the message will be removed from the queue
"RTN","HLOCLNT",162,0)
 I HLMSTATE("DT/TM"),HLMSTATE("STATUS","ACCEPTED")!(HLMSTATE("HDR","ACCEPT ACK TYPE")="NE") D  Q 1  ;the message was already transmitted
"RTN","HLOCLNT",163,0)
ZB20 .;**P143 START CJM
"RTN","HLOCLNT",164,0)
 .;**P143 END CJM
"RTN","HLOCLNT",165,0)
 ;
"RTN","HLOCLNT",166,0)
 ;**P143 START CJM
"RTN","HLOCLNT",167,0)
 I HLMSTATE("ACK BY")]"",HLMSTATE("STATUS")]"",$G(^HLB(MSGIEN,"TRIES"))>1 Q 1  ;The app ack was already returned, so don't keep transmitting
"RTN","HLOCLNT",168,0)
 ;**P143 END CJM
"RTN","HLOCLNT",169,0)
 ;
"RTN","HLOCLNT",170,0)
 S UPDATE=UPDATE_"^"_$$NOW^XLFDT
"RTN","HLOCLNT",171,0)
RETRY D
"RTN","HLOCLNT",172,0)
 .S HLCSTATE("ATTEMPT")=HLCSTATE("ATTEMPT")+1
"RTN","HLOCLNT",173,0)
 .I 'HLCSTATE("CONNECTED") D OPEN^HLOT(.HLCSTATE) Q:'HLCSTATE("CONNECTED")
"RTN","HLOCLNT",174,0)
 .;
"RTN","HLOCLNT",175,0)
 .;try to send the message
"RTN","HLOCLNT",176,0)
 .;
"RTN","HLOCLNT",177,0)
 .;
"RTN","HLOCLNT",178,0)
 .Q:'$$WRITEMSG^HLOCLNT1(.HLCSTATE,.HLMSTATE)
"RTN","HLOCLNT",179,0)
 .;does the message need an accept ack?
"RTN","HLOCLNT",180,0)
 .I HLMSTATE("HDR","ACCEPT ACK TYPE")="AL" D
"RTN","HLOCLNT",181,0)
 ..N FS
"RTN","HLOCLNT",182,0)
 ..Q:'$$READACK^HLOCLNT1(.HLCSTATE,.HDR,.MSA)
"RTN","HLOCLNT",183,0)
 ..;does the MSA refer to the correct control id?
"RTN","HLOCLNT",184,0)
 ..S FS=$E(HDR(1),4)
"RTN","HLOCLNT",185,0)
 ..I $P(MSA,FS,3)'=HLMSTATE("ID") D  Q
"RTN","HLOCLNT",186,0)
ZB21 ...;**P143 START CJM
"RTN","HLOCLNT",187,0)
 ...;**P43 END CJM
"RTN","HLOCLNT",188,0)
 ..N ACKID,ACKCODE
"RTN","HLOCLNT",189,0)
 ..S ACKCODE=$P(MSA,FS,2)
"RTN","HLOCLNT",190,0)
 ..S ACKID=$S($E(HDR(1),1,3)="MSH":$P(HDR(2),FS,5),1:$P(HDR(2),FS,6))
"RTN","HLOCLNT",191,0)
 ..S $P(UPDATE,"^",5)=1
"RTN","HLOCLNT",192,0)
 ..S UPDATE("MSA")=ACKID_"^"_MSA
"RTN","HLOCLNT",193,0)
 ..I '(ACKCODE="CA") D
"RTN","HLOCLNT",194,0)
 ...S $P(UPDATE,"^",3)="ER",$P(UPDATE,"^",4)=2
"RTN","HLOCLNT",195,0)
ZB22 ...;**P143 START CJM
"RTN","HLOCLNT",196,0)
 ...;**P143 END CJM
"RTN","HLOCLNT",197,0)
 ..I ACKCODE="CA",HLMSTATE("HDR","APP ACK TYPE")="NE" S $P(UPDATE,"^",3)="SU",$P(UPDATE,"^",4)=$S(HLMSTATE("BATCH"):"2",1:1)
"RTN","HLOCLNT",198,0)
 ..I ($P(UPDATE,"^",3)="ER") S $P(UPDATE,"^",6)=$P(HLMSTATE("HDR",1),FS,5) ;errors need the application for xref
"RTN","HLOCLNT",199,0)
 ..;
"RTN","HLOCLNT",200,0)
 ..;if it's from a sequence queue, timestamp the queue
"RTN","HLOCLNT",201,0)
 ..I $L($G(HLMSTATE("STATUS","SEQUENCE QUEUE"))) D
"RTN","HLOCLNT",202,0)
 ...L +^HLB("QUEUE","SEQUENCE",HLMSTATE("STATUS","SEQUENCE QUEUE")):200
"RTN","HLOCLNT",203,0)
 ...I $P($G(^HLB("QUEUE","SEQUENCE",HLMSTATE("STATUS","SEQUENCE QUEUE"))),"^")'=MSGIEN L -^HLB("QUEUE","SEQUENCE",HLMSTATE("STATUS","SEQUENCE QUEUE")) Q
"RTN","HLOCLNT",204,0)
 ...I ACKCODE="CA" D
"RTN","HLOCLNT",205,0)
 ....S $P(^HLB("QUEUE","SEQUENCE",HLMSTATE("STATUS","SEQUENCE QUEUE")),"^",2)=$$FMADD^XLFDT($P(UPDATE,"^",2),,,$$TIMEOUT^HLOAPP($$GETSAP^HLOCLNT2(MSGIEN))) L -^HLB("QUEUE","SEQUENCE",HLMSTATE("STATUS","SEQUENCE QUEUE"))
"RTN","HLOCLNT",206,0)
ZB23 ....;**P143 START CJM
"RTN","HLOCLNT",207,0)
 ....;**P143 END CJM
"RTN","HLOCLNT",208,0)
 ...;if the message wasn't accepted, need to notify without waiting
"RTN","HLOCLNT",209,0)
 ...S $P(^HLB("QUEUE","SEQUENCE",HLMSTATE("STATUS","SEQUENCE QUEUE")),"^",2)=$P(UPDATE,"^",2)
"RTN","HLOCLNT",210,0)
 ...L -^HLB("QUEUE","SEQUENCE",HLMSTATE("STATUS","SEQUENCE QUEUE"))
"RTN","HLOCLNT",211,0)
 ..;
"RTN","HLOCLNT",212,0)
 ..;does the app need notification of accept ack?
"RTN","HLOCLNT",213,0)
 ..S UPDATE("ACTION")=HLMSTATE("ACCEPT ACK RESPONSE")
"RTN","HLOCLNT",214,0)
 ..;
"RTN","HLOCLNT",215,0)
 ..S SUCCESS=1
"RTN","HLOCLNT",216,0)
 .E  D  ;accept ack wasn't requested
"RTN","HLOCLNT",217,0)
 ..S SUCCESS=1
"RTN","HLOCLNT",218,0)
 ..I HLMSTATE("HDR","APP ACK TYPE")="NE" S $P(UPDATE,"^",3)="SU",$P(UPDATE,"^",4)=$S(HLMSTATE("BATCH"):2,1:1)
"RTN","HLOCLNT",219,0)
 ;
"RTN","HLOCLNT",220,0)
 I 'SUCCESS,'HLCSTATE("CONNECTED"),(HLCSTATE("ATTEMPT")<2) G RETRY
"RTN","HLOCLNT",221,0)
 I SUCCESS D
"RTN","HLOCLNT",222,0)
 .D COUNT^HLOSTAT(.HLCSTATE,HLMSTATE("HDR","RECEIVING APPLICATION"),HLMSTATE("HDR","SENDING APPLICATION"),$S(HLMSTATE("BATCH"):"BATCH",1:HLMSTATE("HDR","MESSAGE TYPE")_"~"_HLMSTATE("HDR","EVENT")))
"RTN","HLOCLNT",223,0)
 .;if this is an ack to a message need to purge the original message, so store its ien with the purge date
"RTN","HLOCLNT",224,0)
 .S:$G(HLMSTATE("ACK TO IEN")) $P(UPDATE,"^",4)=$P(UPDATE,"^",4)_"-"_HLMSTATE("ACK TO IEN")
"RTN","HLOCLNT",225,0)
 I ('HLCSTATE("CONNECTED"))!('SUCCESS) D LINKDOWN(.HLCSTATE)
"RTN","HLOCLNT",226,0)
 Q SUCCESS
"RTN","HLOCLNT2")
0^2^B39313138^B38024848
"RTN","HLOCLNT2",1,0)
HLOCLNT2 ;ALB/CJM- Performs message updates for the client - 10/4/94 1pm ;06/16/2009
"RTN","HLOCLNT2",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,130,131,133,134,137,143**;Oct 13, 1995;Build 3
"RTN","HLOCLNT2",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOCLNT2",4,0)
 ;
"RTN","HLOCLNT2",5,0)
GETWORK(WORK) ;
"RTN","HLOCLNT2",6,0)
 ;
"RTN","HLOCLNT2",7,0)
 N OLD,DOLLARJ,SUCCESS,NOW
"RTN","HLOCLNT2",8,0)
 S SUCCESS=0
"RTN","HLOCLNT2",9,0)
 S NOW=$$NOW^XLFDT
"RTN","HLOCLNT2",10,0)
 S (OLD,DOLLARJ)=$G(WORK("DOLLARJ"))
"RTN","HLOCLNT2",11,0)
 F  S DOLLARJ=$O(^HLTMP("CLIENT UPDATES",DOLLARJ)) Q:DOLLARJ=""  D  Q:SUCCESS
"RTN","HLOCLNT2",12,0)
 .L +^HLTMP("CLIENT UPDATES",DOLLARJ):0
"RTN","HLOCLNT2",13,0)
 .Q:'$T
"RTN","HLOCLNT2",14,0)
 .N TIME S TIME=$O(^HLTMP("CLIENT UPDATES",DOLLARJ,""))
"RTN","HLOCLNT2",15,0)
 .I $$FMDIFF^XLFDT(NOW,TIME,2)<2 L -^HLTMP("CLIENT UPDATES",DOLLARJ) Q
"RTN","HLOCLNT2",16,0)
 .S SUCCESS=1
"RTN","HLOCLNT2",17,0)
 ;
"RTN","HLOCLNT2",18,0)
 I OLD'="",'SUCCESS F  S DOLLARJ=$O(^HLTMP("CLIENT UPDATES",DOLLARJ)) Q:DOLLARJ=""  Q:DOLLARJ>OLD  D  Q:SUCCESS
"RTN","HLOCLNT2",19,0)
 .L +^HLTMP("CLIENT UPDATES",DOLLARJ):0
"RTN","HLOCLNT2",20,0)
 .Q:'$T
"RTN","HLOCLNT2",21,0)
 .N TIME S TIME=$O(^HLTMP("CLIENT UPDATES",DOLLARJ,""))
"RTN","HLOCLNT2",22,0)
 .I $$FMDIFF^XLFDT(NOW,TIME,2)<2 L -^HLTMP("CLIENT UPDATES",DOLLARJ) Q
"RTN","HLOCLNT2",23,0)
 .S SUCCESS=1
"RTN","HLOCLNT2",24,0)
 S WORK("DOLLARJ")=DOLLARJ,WORK("NOW")=NOW
"RTN","HLOCLNT2",25,0)
 Q $S($L(WORK("DOLLARJ")):1,1:0)
"RTN","HLOCLNT2",26,0)
 ;
"RTN","HLOCLNT2",27,0)
DOWORK(WORK) ;
"RTN","HLOCLNT2",28,0)
 ;
"RTN","HLOCLNT2",29,0)
 N DOLLARJ,TIME,IEN,PARMS,SYSTEM
"RTN","HLOCLNT2",30,0)
 S TIME=""
"RTN","HLOCLNT2",31,0)
 S DOLLARJ=WORK("DOLLARJ")
"RTN","HLOCLNT2",32,0)
 D SYSPARMS^HLOSITE(.SYSTEM)
"RTN","HLOCLNT2",33,0)
 F  S TIME=$O(^HLTMP("CLIENT UPDATES",DOLLARJ,TIME)) Q:TIME=""  Q:$$FMDIFF^XLFDT(WORK("NOW"),TIME,2)<2  D
"RTN","HLOCLNT2",34,0)
 .S IEN=0
"RTN","HLOCLNT2",35,0)
 .F  S IEN=$O(^HLTMP("CLIENT UPDATES",DOLLARJ,TIME,IEN)) Q:'IEN  D
"RTN","HLOCLNT2",36,0)
 ..N NODE
"RTN","HLOCLNT2",37,0)
 ..S NODE=$G(^HLTMP("CLIENT UPDATES",DOLLARJ,TIME,IEN))
"RTN","HLOCLNT2",38,0)
 ..S PARMS("LINK")=$P(NODE,"^")
"RTN","HLOCLNT2",39,0)
 ..S PARMS("QUEUE")=$P(NODE,"^",2)
"RTN","HLOCLNT2",40,0)
 ..S PARMS("STATUS")=$P(NODE,"^",3)
"RTN","HLOCLNT2",41,0)
 ..S PARMS("PURGE TYPE")=$P(NODE,"^",4)
"RTN","HLOCLNT2",42,0)
 ..S PARMS("ACK TO IEN")=+$P($P(NODE,"^",4),"-",2)
"RTN","HLOCLNT2",43,0)
 ..S PARMS("ACCEPT ACK")=$P(NODE,"^",5)
"RTN","HLOCLNT2",44,0)
 ..S PARMS("RECEIVING APP")=$P(NODE,"^",6)
"RTN","HLOCLNT2",45,0)
 ..S:PARMS("RECEIVING APP")="" PARMS("RECEIVING APP")="UNKNOWN RECEIVING APPLICATION"
"RTN","HLOCLNT2",46,0)
 ..S PARMS("MSA")=$G(^HLTMP("CLIENT UPDATES",DOLLARJ,TIME,IEN,"MSA"))
"RTN","HLOCLNT2",47,0)
 ..S PARMS("ACTION")=$G(^HLTMP("CLIENT UPDATES",DOLLARJ,TIME,IEN,"ACTION"))
"RTN","HLOCLNT2",48,0)
 ..D UPDATE(IEN,TIME,.PARMS)
"RTN","HLOCLNT2",49,0)
 ..K ^HLTMP("CLIENT UPDATES",DOLLARJ,TIME,IEN)
"RTN","HLOCLNT2",50,0)
 L -^HLTMP("CLIENT UPDATES",DOLLARJ)
"RTN","HLOCLNT2",51,0)
 Q
"RTN","HLOCLNT2",52,0)
 ;
"RTN","HLOCLNT2",53,0)
UPDATE(MSGIEN,TIME,PARMS) ;
"RTN","HLOCLNT2",54,0)
 S:PARMS("STATUS")]"" $P(^HLB(MSGIEN,0),"^",20)=PARMS("STATUS")
"RTN","HLOCLNT2",55,0)
 I PARMS("STATUS")="ER" D
"RTN","HLOCLNT2",56,0)
 .S ^HLB("ERRORS",PARMS("RECEIVING APP"),TIME,MSGIEN_"^")=""
"RTN","HLOCLNT2",57,0)
 .D COUNT^HLOESTAT("OUT",PARMS("RECEIVING APP"),$$GETSAP(MSGIEN),$$GETMTYPE(MSGIEN))
"RTN","HLOCLNT2",58,0)
 S:PARMS("ACCEPT ACK") $P(^HLB(MSGIEN,0),"^",17)=PARMS("ACCEPT ACK")
"RTN","HLOCLNT2",59,0)
 S $P(^HLB(MSGIEN,0),"^",16)=TIME
"RTN","HLOCLNT2",60,0)
 S:PARMS("MSA")]"" ^HLB(MSGIEN,4)=TIME_"^"_PARMS("MSA")
"RTN","HLOCLNT2",61,0)
 I PARMS("PURGE TYPE"),PARMS("ACTION")="" D
"RTN","HLOCLNT2",62,0)
 .;don't set purge if going on the infiler - let infiler do it
"RTN","HLOCLNT2",63,0)
 .N PTIME
"RTN","HLOCLNT2",64,0)
 .S:(PARMS("PURGE TYPE")=2) PTIME=$$FMADD^XLFDT(TIME,SYSTEM("ERROR PURGE")) ;error purge is in days
"RTN","HLOCLNT2",65,0)
 .S:(PARMS("PURGE TYPE")'=2) PTIME=$$FMADD^XLFDT(TIME,,SYSTEM("NORMAL PURGE")) ;normal purge is in hours
"RTN","HLOCLNT2",66,0)
 .S $P(^HLB(MSGIEN,0),"^",9)=PTIME,^HLB("AD","OUT",PTIME,MSGIEN)=""
"RTN","HLOCLNT2",67,0)
 .I PARMS("ACK TO IEN"),$D(^HLB(PARMS("ACK TO IEN"),0)) S $P(^HLB(PARMS("ACK TO IEN"),0),"^",9)=PTIME,^HLB("AD","OUT",PTIME,PARMS("ACK TO IEN"))=""
"RTN","HLOCLNT2",68,0)
 D:PARMS("ACTION")]""
"RTN","HLOCLNT2",69,0)
 .N PURGE
"RTN","HLOCLNT2",70,0)
 .S PURGE=$S(PARMS("PURGE TYPE"):1,1:0)
"RTN","HLOCLNT2",71,0)
 .S:PARMS("ACK TO IEN") PURGE("ACKTOIEN")=PARMS("ACK TO IEN")
"RTN","HLOCLNT2",72,0)
 .D INQUE^HLOQUE(PARMS("LINK"),PARMS("QUEUE"),MSGIEN,PARMS("ACTION"),.PURGE)
"RTN","HLOCLNT2",73,0)
 Q
"RTN","HLOCLNT2",74,0)
 ;
"RTN","HLOCLNT2",75,0)
GETMSG(IEN,MSG) ;
"RTN","HLOCLNT2",76,0)
 ;
"RTN","HLOCLNT2",77,0)
 ;Description: given the message ien=MSGIEN (required), it returns the MSG array containing information about the message, defined below.
"RTN","HLOCLNT2",78,0)
 ;Input:
"RTN","HLOCLNT2",79,0)
 ;  IEN - the ien of the message in file 778
"RTN","HLOCLNT2",80,0)
 ;Output:
"RTN","HLOCLNT2",81,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOCLNT2",82,0)
 ;  MSG (pass by reference, required) These are the subscripts returned:
"RTN","HLOCLNT2",83,0)
 ;    "ACCEPT ACK RESPONSE" - if the sending app requested notification of the accept ack, this is the routine to perform
"RTN","HLOCLNT2",84,0)
 ;    "ACKTOIEN" - if this is an app ack to a message not in a batch, this is the ien of the original message
"RTN","HLOCLNT2",85,0)
 ;    "BATCH"  = 1 if this is a batch message, 0  if not
"RTN","HLOCLNT2",86,0)
 ;    "CURRENT MESSAGE" - defined only for batch messages -  a counterused during building and parsing messages to indicate the current message.  It will be set to 0 initially.
"RTN","HLOCLNT2",87,0)
 ;    "BODY" - ptr to file 778 which contains the body of the message.
"RTN","HLOCLNT2",88,0)
 ;    "LINE COUNT" -  a counter used during writing of the
"RTN","HLOCLNT2",89,0)
 ;     messages to indicate the current line. For
"RTN","HLOCLNT2",90,0)
 ;     batch messages where each message within the batch is stored
"RTN","HLOCLNT2",91,0)
 ;     separately, this field indicates the position within the current
"RTN","HLOCLNT2",92,0)
 ;     individual message
"RTN","HLOCLNT2",93,0)
 ;    "HDR" at these lower subscripts:
"RTN","HLOCLNT2",94,0)
 ;       1    - components 1-6
"RTN","HLOCLNT2",95,0)
 ;       2    - components 7-end
"RTN","HLOCLNT2",96,0)
 ;       "ACCEPT ACK TYPE" = "AL" or "NE"
"RTN","HLOCLNT2",97,0)
 ;       "APP ACK TYPE" = "AL" or "NE"
"RTN","HLOCLNT2",98,0)
 ;       "MESSAGE CONTROL ID" - defined if NOT batch
"RTN","HLOCLNT2",99,0)
 ;       "BATCH CONTROL ID" - defined if batch
"RTN","HLOCLNT2",100,0)
 ;
"RTN","HLOCLNT2",101,0)
 ;    "ID" - message id from the header
"RTN","HLOCLNT2",102,0)
 ;    "IEN" - ien, file 778
"RTN","HLOCLNT2",103,0)
 ;    "STATUS","SEQUENCE QUEUE")=name of the sequence queue (optional)
"RTN","HLOCLNT2",104,0)
 ;
"RTN","HLOCLNT2",105,0)
 K MSG
"RTN","HLOCLNT2",106,0)
 Q:'$G(IEN) 0
"RTN","HLOCLNT2",107,0)
 N NODE,FS,CS,REP,SUBCOMP,ESCAPE
"RTN","HLOCLNT2",108,0)
 S MSG("IEN")=IEN
"RTN","HLOCLNT2",109,0)
 S NODE=$G(^HLB(IEN,0))
"RTN","HLOCLNT2",110,0)
 S MSG("BODY")=$P(NODE,"^",2)
"RTN","HLOCLNT2",111,0)
 S MSG("ID")=$P(NODE,"^")
"RTN","HLOCLNT2",112,0)
 Q:'MSG("BODY") 0
"RTN","HLOCLNT2",113,0)
 ;
"RTN","HLOCLNT2",114,0)
 ;**P143 START CJM
"RTN","HLOCLNT2",115,0)
 S MSG("ACK BY")=$P(NODE,"^",7)
"RTN","HLOCLNT2",116,0)
 S MSG("STATUS")=$P(NODE,"^",20)
"RTN","HLOCLNT2",117,0)
 ;**P143 END CJM
"RTN","HLOCLNT2",118,0)
 ;
"RTN","HLOCLNT2",119,0)
 S MSG("STATUS","ACCEPTED")=$P(NODE,"^",17)
"RTN","HLOCLNT2",120,0)
 S MSG("DT/TM")=$P(NODE,"^",16)
"RTN","HLOCLNT2",121,0)
 S MSG("STATUS","QUEUE")=$P(NODE,"^",6)
"RTN","HLOCLNT2",122,0)
 I MSG("STATUS","QUEUE")="" S MSG("STATUS","QUEUE")="DEFAULT"
"RTN","HLOCLNT2",123,0)
 S MSG("ACCEPT ACK RESPONSE")=$P(NODE,"^",12,13)
"RTN","HLOCLNT2",124,0)
 I MSG("ACCEPT ACK RESPONSE")="^" S MSG("ACCEPT ACK RESPONSE")=""
"RTN","HLOCLNT2",125,0)
 ;
"RTN","HLOCLNT2",126,0)
 S MSG("BATCH")=+$P($G(^HLA(MSG("BODY"),0)),"^",2)
"RTN","HLOCLNT2",127,0)
 I MSG("BATCH") D
"RTN","HLOCLNT2",128,0)
 .S MSG("BATCH","CURRENT MESSAGE")=0
"RTN","HLOCLNT2",129,0)
 E  D
"RTN","HLOCLNT2",130,0)
 .N ACKTO
"RTN","HLOCLNT2",131,0)
 .S ACKTO=$P(NODE,"^",3)
"RTN","HLOCLNT2",132,0)
 .I ACKTO]"" S ACKTO=$$ACKTOIEN^HLOMSG1(MSG("ID"),ACKTO)
"RTN","HLOCLNT2",133,0)
 .I ACKTO,+ACKTO=ACKTO S MSG("ACK TO IEN")=ACKTO
"RTN","HLOCLNT2",134,0)
 S MSG("LINE COUNT")=0
"RTN","HLOCLNT2",135,0)
 S MSG("HDR",1)=$G(^HLB(IEN,1))
"RTN","HLOCLNT2",136,0)
 S MSG("HDR",2)=$G(^HLB(IEN,2))
"RTN","HLOCLNT2",137,0)
 S FS=$E(MSG("HDR",1),4)
"RTN","HLOCLNT2",138,0)
 S CS=$E(MSG("HDR",1),5)
"RTN","HLOCLNT2",139,0)
 S REP=$E(MSG("HDR",1),6)
"RTN","HLOCLNT2",140,0)
 S ESCAPE=$E(MSG("HDR",1),7)
"RTN","HLOCLNT2",141,0)
 S SUBCOMP=$E(MSG("HDR",1),8)
"RTN","HLOCLNT2",142,0)
 S MSG("HDR","FIELD SEPARATOR")=FS
"RTN","HLOCLNT2",143,0)
 S MSG("HDR","SENDING APPLICATION")=$$DESCAPE^HLOPRS1($P($P(MSG("HDR",1),FS,3),CS),FS,CS,SUBCOMP,REP,ESCAPE)
"RTN","HLOCLNT2",144,0)
 S MSG("HDR","RECEIVING APPLICATION")=$$DESCAPE^HLOPRS1($P($P(MSG("HDR",1),FS,5),CS),FS,CS,SUBCOMP,REP,ESCAPE)
"RTN","HLOCLNT2",145,0)
 I 'MSG("BATCH") D
"RTN","HLOCLNT2",146,0)
 .S MSG("HDR","MESSAGE TYPE")=$P($P(MSG("HDR",2),FS,4),CS)
"RTN","HLOCLNT2",147,0)
 .S MSG("HDR","EVENT")=$P($P(MSG("HDR",2),FS,4),CS,2)
"RTN","HLOCLNT2",148,0)
 .S MSG("HDR","ACCEPT ACK TYPE")=$E($P(MSG("HDR",2),FS,10),1,2)
"RTN","HLOCLNT2",149,0)
 .S MSG("HDR","APP ACK TYPE")=$E($P(MSG("HDR",2),FS,11),1,2)
"RTN","HLOCLNT2",150,0)
 .S MSG("HDR","MESSAGE CONTROL ID")=MSG("ID")
"RTN","HLOCLNT2",151,0)
 E  D
"RTN","HLOCLNT2",152,0)
 .S MSG("HDR","BATCH CONTROL ID")=MSG("ID")
"RTN","HLOCLNT2",153,0)
 .S MSG("HDR","ACCEPT ACK TYPE")=$E($P($P(MSG("HDR",2),FS,4),"ACCEPT ACK TYPE=",2),1,2)
"RTN","HLOCLNT2",154,0)
 .S MSG("HDR","APP ACK TYPE")=$E($P($P(MSG("HDR",2),FS,4),"APP ACK TYPE=",2),1,2)
"RTN","HLOCLNT2",155,0)
 S MSG("STATUS","SEQUENCE QUEUE")=$P($G(^HLB(IEN,5)),"^")
"RTN","HLOCLNT2",156,0)
 Q 1
"RTN","HLOCLNT2",157,0)
 ;
"RTN","HLOCLNT2",158,0)
GETMTYPE(MSGIEN) ;returns <message type>~<event> OR "BATCH"
"RTN","HLOCLNT2",159,0)
 Q:'$G(MSGIEN) "UNKNOWN"
"RTN","HLOCLNT2",160,0)
 N FS,CS,HDR1,HDR2
"RTN","HLOCLNT2",161,0)
 S HDR1=$G(^HLB(IEN,1))
"RTN","HLOCLNT2",162,0)
 I $E(HDR1,1,3)="BHS" Q "BATCH"
"RTN","HLOCLNT2",163,0)
 S HDR2=$G(^HLB(IEN,2))
"RTN","HLOCLNT2",164,0)
 S FS=$E(HDR1,4)
"RTN","HLOCLNT2",165,0)
 S CS=$E(HDR1,5)
"RTN","HLOCLNT2",166,0)
 Q $P($P(HDR2,FS,4),CS)_"~"_$P($P(HDR2,FS,4),CS,2)
"RTN","HLOCLNT2",167,0)
 ;
"RTN","HLOCLNT2",168,0)
GETEVENT(MSGIEN) ; returns event if not a batch message
"RTN","HLOCLNT2",169,0)
 Q:'$G(MSGIEN) ""
"RTN","HLOCLNT2",170,0)
 N FS,CS,HDR1,HDR2
"RTN","HLOCLNT2",171,0)
 S HDR1=$G(^HLB(MSGIEN,1))
"RTN","HLOCLNT2",172,0)
 I $E(HDR1,1,3)="BHS" Q ""
"RTN","HLOCLNT2",173,0)
 S HDR2=$G(^HLB(MSGIEN,2))
"RTN","HLOCLNT2",174,0)
 S FS=$E(HDR1,4)
"RTN","HLOCLNT2",175,0)
 S CS=$E(HDR1,5)
"RTN","HLOCLNT2",176,0)
 Q $P($P(HDR2,FS,4),CS,2)
"RTN","HLOCLNT2",177,0)
 ;
"RTN","HLOCLNT2",178,0)
GETSAP(MSGIEN) ;
"RTN","HLOCLNT2",179,0)
 ;
"RTN","HLOCLNT2",180,0)
 ;
"RTN","HLOCLNT2",181,0)
 Q:'$G(MSGIEN) "UNKNOWN"
"RTN","HLOCLNT2",182,0)
 N FS,CS,HDR1,REP,ESCAPE,SUBCOMP
"RTN","HLOCLNT2",183,0)
 S HDR1=$G(^HLB(MSGIEN,1))
"RTN","HLOCLNT2",184,0)
 S FS=$E(HDR1,4)
"RTN","HLOCLNT2",185,0)
 S CS=$E(HDR1,5)
"RTN","HLOCLNT2",186,0)
 S REP=$E(HDR1,6)
"RTN","HLOCLNT2",187,0)
 S ESCAPE=$E(HDR1,7)
"RTN","HLOCLNT2",188,0)
 S SUBCOMP=$E(HDR1,8)
"RTN","HLOCLNT2",189,0)
 Q $$DESCAPE^HLOPRS1($P($P(HDR1,FS,3),CS),FS,CS,SUBCOMP,REP,ESCAPE)
"RTN","HLOMSG1")
0^3^B14540604^B6084209
"RTN","HLOMSG1",1,0)
HLOMSG1 ;ALB/CJM-HL7 - APIs for files 777/778 (CONTINUED) ;06/19/2009
"RTN","HLOMSG1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,143**;Oct 13, 1995;Build 3
"RTN","HLOMSG1",3,0)
 ;
"RTN","HLOMSG1",4,0)
FINDMSG(MSGID,LIST) ;
"RTN","HLOMSG1",5,0)
 ;Given a message id, this function finds the file 778 entries having that message id.  The count is returned as the function value. If the message
"RTN","HLOMSG1",6,0)
 ;is within a batch, it might be in the subfile.  The list of found
"RTN","HLOMSG1",7,0)
 ;records is in the format LIST(1)=<IEN>^<SUBIEN>,LIST(2)=<IEN>^<SUBIEN>,
"RTN","HLOMSG1",8,0)
 ;etc., where SUBIEN="" if the message is not within a batch.
"RTN","HLOMSG1",9,0)
 ;
"RTN","HLOMSG1",10,0)
 N COUNT,MSG
"RTN","HLOMSG1",11,0)
 K LIST
"RTN","HLOMSG1",12,0)
 Q:$G(MSGID)="" 0
"RTN","HLOMSG1",13,0)
 S (MSG,COUNT)=0
"RTN","HLOMSG1",14,0)
 F  S MSG=$O(^HLB("B",MSGID,MSG)) Q:'MSG  S COUNT=COUNT+1,LIST(COUNT)=MSG
"RTN","HLOMSG1",15,0)
 S MSG=""
"RTN","HLOMSG1",16,0)
 F  S MSG=$O(^HLB("AE",MSGID,MSG)) Q:MSG=""  S COUNT=COUNT+1,LIST(COUNT)=MSG
"RTN","HLOMSG1",17,0)
 Q COUNT
"RTN","HLOMSG1",18,0)
 ;
"RTN","HLOMSG1",19,0)
ACKTOIEN(MSGID,ACKTO) ;
"RTN","HLOMSG1",20,0)
 ;finds the ien of the initial message
"RTN","HLOMSG1",21,0)
 ;Input:
"RTN","HLOMSG1",22,0)
 ;  MSGID - the msg id of the ack message
"RTN","HLOMSG1",23,0)
 ;  ACKTO - msgid of the original message
"RTN","HLOMSG1",24,0)
 ;Output: Function returns "" if not found, otherwise the IEN, or, if the message is in a batch, the <ien>^<subien>
"RTN","HLOMSG1",25,0)
 ;
"RTN","HLOMSG1",26,0)
 N LIST,RETURN,COUNT,IEN,SUBIEN
"RTN","HLOMSG1",27,0)
 S RETURN=""
"RTN","HLOMSG1",28,0)
 ;
"RTN","HLOMSG1",29,0)
 ;**P146 START CJM
"RTN","HLOMSG1",30,0)
 I $P(ACKTO," "),$P(ACKTO," ")=$P($G(^HLD(779.1,1,0)),"^",2) D
"RTN","HLOMSG1",31,0)
 .I '(ACKTO["-") D
"RTN","HLOMSG1",32,0)
 ..S IEN=$P(ACKTO," ",2)
"RTN","HLOMSG1",33,0)
 ..I IEN,$P($G(^HLB(IEN,0)),"^")=ACKTO,$P($G(^HLB(IEN,0)),"^",4)="O" S RETURN=IEN
"RTN","HLOMSG1",34,0)
 .E  D
"RTN","HLOMSG1",35,0)
 ..S IEN=$P(ACKTO," ",2)
"RTN","HLOMSG1",36,0)
 ..S SUBIEN=$P(IEN,"-",2)
"RTN","HLOMSG1",37,0)
 ..S IEN=+IEN
"RTN","HLOMSG1",38,0)
 ..I IEN,SUBIEN,$P($G(^HLB(IEN,3,SUBIEN,0)),"^",2)=ACKTO,$P($G(^HLB(IEN,0)),"^",4)="O" S RETURN=IEN_"^"_SUBIEN
"RTN","HLOMSG1",39,0)
 Q:RETURN RETURN
"RTN","HLOMSG1",40,0)
 ;
"RTN","HLOMSG1",41,0)
 S COUNT=$$FINDMSG(ACKTO,.LIST)
"RTN","HLOMSG1",42,0)
 I COUNT=1 D
"RTN","HLOMSG1",43,0)
 .S RETURN=$S($P(LIST(1),"^",2):LIST(1),1:+LIST(1))
"RTN","HLOMSG1",44,0)
 ;
"RTN","HLOMSG1",45,0)
 E  I COUNT=0 D
"RTN","HLOMSG1",46,0)
 .;no match found
"RTN","HLOMSG1",47,0)
 E  D
"RTN","HLOMSG1",48,0)
 .;more than one potential match
"RTN","HLOMSG1",49,0)
 .S COUNT=0
"RTN","HLOMSG1",50,0)
 .F  S COUNT=$O(LIST(COUNT)) Q:'COUNT  D  Q:RETURN
"RTN","HLOMSG1",51,0)
 ..S IEN=$P(LIST(COUNT),"^"),SUBIEN=$P(LIST(COUNT),"^",2)
"RTN","HLOMSG1",52,0)
 ..I 'SUBIEN D
"RTN","HLOMSG1",53,0)
 ...I $P($G(^HLB(IEN,0)),"^",7)=MSGID S RETURN=IEN
"RTN","HLOMSG1",54,0)
 ..E  D
"RTN","HLOMSG1",55,0)
 ...I $P($G(^HLB(IEN,3,SUBIEN,0)),"^",4)=MSGID S RETURN=IEN_"^"_SUBIEN
"RTN","HLOMSG1",56,0)
 .I 'RETURN S RETURN=$S($P(LIST(1),"^",2):LIST(1),1:+LIST(1))
"RTN","HLOMSG1",57,0)
 ;**P146 END CJM
"RTN","HLOMSG1",58,0)
 Q RETURN
"RTN","HLOMSG1",59,0)
 ;
"RTN","HLOMSG1",60,0)
 ;
"RTN","HLOMSG1",61,0)
ACKBYIEN(MSGID,ACKBY) ;
"RTN","HLOMSG1",62,0)
 ;finds the ien of the ack message
"RTN","HLOMSG1",63,0)
 ;Input:
"RTN","HLOMSG1",64,0)
 ;  MSGID - the msg id of the initial message
"RTN","HLOMSG1",65,0)
 ;  ACKBY - msgid of the ack message
"RTN","HLOMSG1",66,0)
 ;Output: Function returns "" if not found, otherwise the IEN, or, if the message is in a batch, the <ien>^<subien>
"RTN","HLOMSG1",67,0)
 ;
"RTN","HLOMSG1",68,0)
 N LIST,RETURN,COUNT,IEN,SUBIEN
"RTN","HLOMSG1",69,0)
 S RETURN=""
"RTN","HLOMSG1",70,0)
 ;
"RTN","HLOMSG1",71,0)
 ;**P146 START CJM
"RTN","HLOMSG1",72,0)
 I $P(ACKBY," "),$P(ACKBY," ")=$P($G(^HLD(779.1,1,0)),"^",2) D
"RTN","HLOMSG1",73,0)
 .I '(ACKBY["-") D
"RTN","HLOMSG1",74,0)
 ..S IEN=$P(ACKBY," ",2)
"RTN","HLOMSG1",75,0)
 ..I IEN,$P($G(^HLB(IEN,0)),"^")=ACKBY,$P($G(^HLB(IEN,0)),"^",4)="O" S RETURN=IEN
"RTN","HLOMSG1",76,0)
 .E  D
"RTN","HLOMSG1",77,0)
 ..S IEN=$P(ACKBY," ",2)
"RTN","HLOMSG1",78,0)
 ..S SUBIEN=$P(IEN,"-",2)
"RTN","HLOMSG1",79,0)
 ..S IEN=+IEN
"RTN","HLOMSG1",80,0)
 ..I IEN,SUBIEN,$P($G(^HLB(IEN,3,SUBIEN,0)),"^",2)=ACKBY,$P($G(^HLB(IEN,0)),"^",4)="O" S RETURN=IEN_"^"_SUBIEN
"RTN","HLOMSG1",81,0)
 Q:RETURN RETURN
"RTN","HLOMSG1",82,0)
 ;
"RTN","HLOMSG1",83,0)
 S COUNT=$$FINDMSG(ACKBY,.LIST)
"RTN","HLOMSG1",84,0)
 I COUNT=1 D
"RTN","HLOMSG1",85,0)
 .S RETURN=$S($P(LIST(1),"^",2):LIST(1),1:+LIST(1))
"RTN","HLOMSG1",86,0)
 ;
"RTN","HLOMSG1",87,0)
 E  I COUNT=0 D
"RTN","HLOMSG1",88,0)
 .;no match found
"RTN","HLOMSG1",89,0)
 E  D
"RTN","HLOMSG1",90,0)
 .;more than one potential match
"RTN","HLOMSG1",91,0)
 .S COUNT=0
"RTN","HLOMSG1",92,0)
 .F  S COUNT=$O(LIST(COUNT)) Q:'COUNT  D  Q:RETURN
"RTN","HLOMSG1",93,0)
 ..S IEN=$P(LIST(COUNT),"^"),SUBIEN=$P(LIST(COUNT),"^",2)
"RTN","HLOMSG1",94,0)
 ..I 'SUBIEN D
"RTN","HLOMSG1",95,0)
 ...I $P($G(^HLB(IEN,0)),"^",3)=MSGID S RETURN=IEN
"RTN","HLOMSG1",96,0)
 ..E  D
"RTN","HLOMSG1",97,0)
 ...I $P($G(^HLB(IEN,3,SUBIEN,0)),"^",3)=MSGID S RETURN=IEN_"^"_SUBIEN
"RTN","HLOMSG1",98,0)
 .I 'RETURN S RETURN=$S($P(LIST(1),"^",2):LIST(1),1:+LIST(1))
"RTN","HLOMSG1",99,0)
 ;**P146 END CJM
"RTN","HLOMSG1",100,0)
 ;
"RTN","HLOMSG1",101,0)
 Q RETURN
"RTN","HLOMSG1",102,0)
 ;
"RTN","HLOMSG1",103,0)
GETMSGB(MSG,SUBIEN,SUBMSG) ;
"RTN","HLOMSG1",104,0)
 ;gets a message from within a batch
"RTN","HLOMSG1",105,0)
 ;Input:
"RTN","HLOMSG1",106,0)
 ;  MSG (required, pass by reference) from $$GETMSG
"RTN","HLOMSG1",107,0)
 ;  SUBIEN - the subrecord #
"RTN","HLOMSG1",108,0)
 ;Output:
"RTN","HLOMSG1",109,0)
 ;  SUBMSG (pass by reference)  These subscripts are returned:
"RTN","HLOMSG1",110,0)
 ;    "ACK BY" - if this msg was app acked, the msg id if this msg that was app
"RTN","HLOMSG1",111,0)
 ;    "ACK TO" - if this msg is an app ack, the msg id of msg being acked
"RTN","HLOMSG1",112,0)
 ;    "EVENT" - HL7 Event
"RTN","HLOMSG1",113,0)
 ;    "HDR",1) - fields 1-6 of the header segment
"RTN","HLOMSG1",114,0)
 ;    "HDR",2) - fields 7-End of the header segment
"RTN","HLOMSG1",115,0)
 ;    "ID" - Message Control ID
"RTN","HLOMSG1",116,0)
 ;    "MESSAGE TYPE" - HL7 Message Type
"RTN","HLOMSG1",117,0)
 ;    "STATUS" - completion status for the individual message
"RTN","HLOMSG1",118,0)
 ;
"RTN","HLOMSG1",119,0)
 N NODE
"RTN","HLOMSG1",120,0)
 S NODE=$G(^HLB(MSG("IEN"),3,SUBIEN,0))
"RTN","HLOMSG1",121,0)
 S SUBMSG("ID")=$P(NODE,"^",2)
"RTN","HLOMSG1",122,0)
 S SUBMSG("ACK TO")=$P(NODE,"^",3)
"RTN","HLOMSG1",123,0)
 S SUBMSG("ACK BY")=$P(NODE,"^",4)
"RTN","HLOMSG1",124,0)
 S SUBMSG("STATUS")=$P(NODE,"^",5)
"RTN","HLOMSG1",125,0)
 S SUBMSG("HDR",1)=$G(^HLB(MSG("IEN"),3,SUBIEN,1)),SUBMSG("HDR",2)=$G(^(2))
"RTN","HLOMSG1",126,0)
 S NODE=$G(^HLA(MSG("BODY"),2,SUBIEN,0))
"RTN","HLOMSG1",127,0)
 S SUBMSG("MESSAGE TYPE")=$P(NODE,"^",2)
"RTN","HLOMSG1",128,0)
 S SUBMSG("EVENT")=$P(NODE,"^",3)
"RTN","HLOMSG1",129,0)
 Q
"RTN","HLOP143")
0^^B890949^n/a
"RTN","HLOP143",1,0)
HLOP143 ;ALB/CJM-Pre & Post install ;06/16/2009
"RTN","HLOP143",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**143**;Oct 13, 1995;Build 3
"RTN","HLOP143",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOP143",4,0)
 ;
"RTN","HLOP143",5,0)
PRE ;
"RTN","HLOP143",6,0)
 ;
"RTN","HLOP143",7,0)
 N WORK
"RTN","HLOP143",8,0)
 L +^HLTMP("PROCESS MANAGER"):0
"RTN","HLOP143",9,0)
 I '$T D ABORT Q
"RTN","HLOP143",10,0)
 D CHKDEAD^HLOPROC1(.WORK)
"RTN","HLOP143",11,0)
 I $O(^HLTMP("HL7 RUNNING PROCESSES",""))'="" D ABORT
"RTN","HLOP143",12,0)
 L -^HLTMP("PROCESS MANAGER")
"RTN","HLOP143",13,0)
 Q
"RTN","HLOP143",14,0)
ABORT ;
"RTN","HLOP143",15,0)
 S XPDABORT=1
"RTN","HLOP143",16,0)
 D BMES^XPDUTL("HLO processes are still running and prevent this installation from completing")
"RTN","HLOP143",17,0)
 Q
"RTN","HLOPURGE")
0^7^B35133354^B32879435
"RTN","HLOPURGE",1,0)
HLOPURGE ;IRMFO-ALB/CJM - Purging Old Messages;03/24/2004  14:43 ;06/17/2009
"RTN","HLOPURGE",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,134,136,137,139,143**;Oct 13, 1995;Build 3
"RTN","HLOPURGE",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOPURGE",4,0)
 ;
"RTN","HLOPURGE",5,0)
GETWORK(WORK) ;
"RTN","HLOPURGE",6,0)
 ;
"RTN","HLOPURGE",7,0)
 N OK
"RTN","HLOPURGE",8,0)
 S OK=0
"RTN","HLOPURGE",9,0)
 I $G(WORK)]"" L -HLPURGE(WORK)
"RTN","HLOPURGE",10,0)
 F WORK="IN","OUT","OLD778","OLD777" I '$G(WORK("DONE",WORK)) S WORK("DONE",WORK)=1 L +HLPURGE(WORK):0 S OK=$T Q:OK
"RTN","HLOPURGE",11,0)
 I 'OK K WORK("DONE") S WORK=""
"RTN","HLOPURGE",12,0)
 Q OK
"RTN","HLOPURGE",13,0)
 ;
"RTN","HLOPURGE",14,0)
DOWORK(WORK) ;
"RTN","HLOPURGE",15,0)
 I WORK="OLD778" D OLD778
"RTN","HLOPURGE",16,0)
 I WORK="OLD777" D OLD777
"RTN","HLOPURGE",17,0)
 I (WORK="IN")!(WORK="OUT") D
"RTN","HLOPURGE",18,0)
 .N TIME,NOW
"RTN","HLOPURGE",19,0)
 .S NOW=$$NOW^XLFDT
"RTN","HLOPURGE",20,0)
 .S TIME=0
"RTN","HLOPURGE",21,0)
 .F  S TIME=$O(^HLB("AD",WORK,TIME)) Q:TIME=""  Q:TIME>NOW  D
"RTN","HLOPURGE",22,0)
 ..N MSGIEN
"RTN","HLOPURGE",23,0)
 ..S MSGIEN=0
"RTN","HLOPURGE",24,0)
 ..F  S MSGIEN=$O(^HLB("AD",WORK,TIME,MSGIEN)) Q:'MSGIEN  D
"RTN","HLOPURGE",25,0)
 ...K ^HLB("AD",WORK,TIME,MSGIEN)
"RTN","HLOPURGE",26,0)
 ...D DELETE(MSGIEN)
"RTN","HLOPURGE",27,0)
 L -HLPURGE(WORK)
"RTN","HLOPURGE",28,0)
 Q
"RTN","HLOPURGE",29,0)
OLD778 ;
"RTN","HLOPURGE",30,0)
 N OLD,START,END,APP,TYPE,TODAY,PARMS
"RTN","HLOPURGE",31,0)
 S TODAY=$$DT^XLFDT
"RTN","HLOPURGE",32,0)
 S OLD=$$FMADD^XLFDT(TODAY,-$$OLDPURGE^HLOSITE)
"RTN","HLOPURGE",33,0)
 F START=0,100000000000,200000000000,300000000000 D
"RTN","HLOPURGE",34,0)
 .S END=(START+100000000000)-1
"RTN","HLOPURGE",35,0)
 .N MSGIEN,QUIT
"RTN","HLOPURGE",36,0)
 .S QUIT=0
"RTN","HLOPURGE",37,0)
 .S MSGIEN=START
"RTN","HLOPURGE",38,0)
 .F  S MSGIEN=$O(^HLB(MSGIEN)) Q:'MSGIEN  Q:(MSGIEN>END)  D  Q:QUIT
"RTN","HLOPURGE",39,0)
 ..N WHEN,BODY,NODE
"RTN","HLOPURGE",40,0)
 ..S NODE=$G(^HLB(MSGIEN,0))
"RTN","HLOPURGE",41,0)
 ..S WHEN=$P(NODE,"^",16)
"RTN","HLOPURGE",42,0)
 ..I WHEN,WHEN<OLD,$P(NODE,"^",9)<TODAY D DELETE(MSGIEN) Q
"RTN","HLOPURGE",43,0)
 ..I 'WHEN D
"RTN","HLOPURGE",44,0)
 ...S BODY=$P(NODE,"^",2)
"RTN","HLOPURGE",45,0)
 ...Q:'BODY
"RTN","HLOPURGE",46,0)
 ...S WHEN=+$G(^HLA(BODY,0))
"RTN","HLOPURGE",47,0)
 ...I WHEN,WHEN<OLD D  Q
"RTN","HLOPURGE",48,0)
 ....;I've seen messages sitting on outgoing queues forever, but it should never happen for incoming
"RTN","HLOPURGE",49,0)
 ....I $E($P(NODE,"^",4))="O",$P(NODE,"^",5)]"",$P(NODE,"^",6)]"" D
"RTN","HLOPURGE",50,0)
 .....N FROM
"RTN","HLOPURGE",51,0)
 .....S FROM=$P(NODE,"^",5)
"RTN","HLOPURGE",52,0)
 .....I $P(NODE,"^",8) S FROM=FROM_":"_$P(NODE,"^",8)
"RTN","HLOPURGE",53,0)
 .....Q:'$D(^HLB("QUEUE","OUT",FROM,$P(NODE,"^",6),MSGIEN))
"RTN","HLOPURGE",54,0)
 .....D DEQUE^HLOQUE(FROM,$P(NODE,"^",6),"OUT",MSGIEN)
"RTN","HLOPURGE",55,0)
 ....D DELETE(MSGIEN) Q
"RTN","HLOPURGE",56,0)
 ...;stop looking for old records?
"RTN","HLOPURGE",57,0)
 ...I WHEN,WHEN>OLD S QUIT=1
"RTN","HLOPURGE",58,0)
 ;
"RTN","HLOPURGE",59,0)
 ;also kill old errors left lying around
"RTN","HLOPURGE",60,0)
 D SYSPARMS^HLOSITE(.PARMS)
"RTN","HLOPURGE",61,0)
 S OLD=$$FMADD^XLFDT($$DT^XLFDT,-PARMS("ERROR PURGE"))
"RTN","HLOPURGE",62,0)
 S APP=""
"RTN","HLOPURGE",63,0)
 F  S APP=$O(^HLB("ERRORS",APP)) Q:APP=""  D
"RTN","HLOPURGE",64,0)
 .N TIME
"RTN","HLOPURGE",65,0)
 .S TIME=0
"RTN","HLOPURGE",66,0)
 .F  S TIME=$O(^HLB("ERRORS",APP,TIME)) Q:'TIME  Q:TIME>OLD  K ^HLB("ERRORS",APP,TIME)
"RTN","HLOPURGE",67,0)
 Q
"RTN","HLOPURGE",68,0)
OLD777 ;
"RTN","HLOPURGE",69,0)
 N OLD,TIME,TODAY
"RTN","HLOPURGE",70,0)
 S TODAY=$$DT^XLFDT
"RTN","HLOPURGE",71,0)
 S OLD=$$FMADD^XLFDT(TODAY,-$$OLDPURGE^HLOSITE)
"RTN","HLOPURGE",72,0)
 S TIME=0
"RTN","HLOPURGE",73,0)
 F  S TIME=$O(^HLA("B",TIME)) Q:'TIME  Q:TIME>OLD  D
"RTN","HLOPURGE",74,0)
 .N MSGIEN
"RTN","HLOPURGE",75,0)
 .S MSGIEN=0
"RTN","HLOPURGE",76,0)
 .F  S MSGIEN=$O(^HLA("B",TIME,MSGIEN)) Q:'MSGIEN  D
"RTN","HLOPURGE",77,0)
 ..N IEN778,STOP
"RTN","HLOPURGE",78,0)
 ..S (STOP,IEN778)=0
"RTN","HLOPURGE",79,0)
 ..F  S IEN778=$O(^HLB("C",MSGIEN,IEN778)) Q:'IEN778  D
"RTN","HLOPURGE",80,0)
 ...I $P($G(^HLB(IEN778,0)),"^",9)>TODAY S STOP=1 Q
"RTN","HLOPURGE",81,0)
 ...D DELETE(IEN778,1)
"RTN","HLOPURGE",82,0)
 ..K:'STOP ^HLB("C",MSGIEN),^HLA("B",TIME,MSGIEN),^HLA(MSGIEN)
"RTN","HLOPURGE",83,0)
 Q
"RTN","HLOPURGE",84,0)
 ;
"RTN","HLOPURGE",85,0)
DELETE(MSGIEN,FLAG) ;
"RTN","HLOPURGE",86,0)
 ;Input:
"RTN","HLOPURGE",87,0)
 ;  MSGIEN - IEN, file 778
"RTN","HLOPURGE",88,0)
 ;  FLAG - if $G(FLAG), will not delete the pointed to record in file 777
"RTN","HLOPURGE",89,0)
 N AC,SUBIEN,RAPP,SAPP,FS,CS,MSG
"RTN","HLOPURGE",90,0)
 I '$$GETMSG^HLOMSG(MSGIEN,.MSG) ;MSG is corrupted, but there sill may be nodes to delete
"RTN","HLOPURGE",91,0)
 S (RAPP,SAPP)=""
"RTN","HLOPURGE",92,0)
 D
"RTN","HLOPURGE",93,0)
 .; ** Begin HL*1.6*143 changes
"RTN","HLOPURGE",94,0)
 .;S FS=$E(MSG("HDR",1),4)
"RTN","HLOPURGE",95,0)
 .S FS=$E($G(MSG("HDR",1)),4)
"RTN","HLOPURGE",96,0)
 .;Q:FS=""
"RTN","HLOPURGE",97,0)
 .;S CS=$E($G(MSG("HDR",1)),5)
"RTN","HLOPURGE",98,0)
 .S CS=$E($G(MSG("HDR",1)),5)
"RTN","HLOPURGE",99,0)
 .; .S SAPP=$P($P(MSG("HDR",1),FS,3),CS)
"RTN","HLOPURGE",100,0)
 .S SAPP=$P($P($G(MSG("HDR",1)),FS,3),CS)
"RTN","HLOPURGE",101,0)
 .I SAPP="" S SAPP="UNKNOWN"
"RTN","HLOPURGE",102,0)
 .;.S RAPP=$P($P(MSG("HDR",1),FS,5),CS) 
"RTN","HLOPURGE",103,0)
 .S RAPP=$P($P($G(MSG("HDR",1)),FS,5),CS)
"RTN","HLOPURGE",104,0)
 .; ** End HL*1.6*143 changes
"RTN","HLOPURGE",105,0)
 .I RAPP="" S RAPP="UNKNOWN"
"RTN","HLOPURGE",106,0)
 ;
"RTN","HLOPURGE",107,0)
 I 'MSG("BATCH") D KSEARCH(.MSG,MSG("MESSAGE TYPE"),MSG("EVENT"),SAPP,RAPP,MSGIEN)
"RTN","HLOPURGE",108,0)
 ;if an error status,take care of the "ERRORS" x-ref
"RTN","HLOPURGE",109,0)
 I MSG("STATUS")'="",MSG("STATUS")'="SU",MSG("BODY") D
"RTN","HLOPURGE",110,0)
 .K ^HLB("ERRORS",RAPP,MSG("DT/TM CREATED"),MSGIEN)
"RTN","HLOPURGE",111,0)
 .I MSG("STATUS")="ER" D
"RTN","HLOPURGE",112,0)
 ..N SUB
"RTN","HLOPURGE",113,0)
 ..S SUB=MSGIEN_"^"
"RTN","HLOPURGE",114,0)
 ..K ^HLB("ERRORS",RAPP,MSG("DT/TM CREATED"),SUB)
"RTN","HLOPURGE",115,0)
 ..F  S SUB=$O(^HLB("ERRORS",RAPP,MSG("DT/TM CREATED"),SUB)) Q:SUB=""  Q:+SUB'=MSGIEN  K ^HLB("ERRORS",RAPP,MSG("DT/TM CREATED"),SUB)
"RTN","HLOPURGE",116,0)
 ;
"RTN","HLOPURGE",117,0)
 ;kill the whole-file xrefs for the message ien within a batch
"RTN","HLOPURGE",118,0)
 S SUBIEN=0
"RTN","HLOPURGE",119,0)
 F  S SUBIEN=$O(^HLB(MSGIEN,3,SUBIEN)) Q:'SUBIEN  D
"RTN","HLOPURGE",120,0)
 .N MSGID
"RTN","HLOPURGE",121,0)
 .I FS]"" D
"RTN","HLOPURGE",122,0)
 ..N VALUE,HDR2,MSGTYPE,EVENT
"RTN","HLOPURGE",123,0)
 ..S HDR2=$G(^HLB(MSGIEN,3,SUBIEN,2))
"RTN","HLOPURGE",124,0)
 ..S VALUE=$P(HDR2,FS,4)
"RTN","HLOPURGE",125,0)
 ..S MSGTYPE=$P(VALUE,CS)
"RTN","HLOPURGE",126,0)
 ..S EVENT=$P(VALUE,CS,2)
"RTN","HLOPURGE",127,0)
 ..D KSEARCH(.MSG,MSGTYPE,EVENT,SAPP,RAPP,MSGIEN_"^"_SUBIEN)
"RTN","HLOPURGE",128,0)
 .S MSGID=$P($G(^HLB(MSGIEN,3,SUBIEN,0)),"^",2)
"RTN","HLOPURGE",129,0)
 .I MSGID]"" K ^HLB("AE",MSGID,MSGIEN_"^"_SUBIEN)
"RTN","HLOPURGE",130,0)
 ;
"RTN","HLOPURGE",131,0)
 I MSG("DIRECTION")="IN" D
"RTN","HLOPURGE",132,0)
 .Q:FS=""
"RTN","HLOPURGE",133,0)
 .N VALUE,HDR
"RTN","HLOPURGE",134,0)
 .S HDR("SENDING APPLICATION")=$P(MSG("HDR",1),FS,3)
"RTN","HLOPURGE",135,0)
 .S VALUE=$P(MSG("HDR",1),FS,4)
"RTN","HLOPURGE",136,0)
 .S HDR("SENDING FACILITY",1)=$P(VALUE,CS)
"RTN","HLOPURGE",137,0)
 .S HDR("SENDING FACILITY",2)=$P(VALUE,CS,2)
"RTN","HLOPURGE",138,0)
 .S HDR("SENDING FACILITY",3)=$P(VALUE,CS,3)
"RTN","HLOPURGE",139,0)
 .S AC=$S(HDR("SENDING FACILITY",2)]"":HDR("SENDING FACILITY",2),1:HDR("SENDING FACILITY",1))_HDR("SENDING APPLICATION")_MSG("ID")
"RTN","HLOPURGE",140,0)
 K ^HLB(MSGIEN)
"RTN","HLOPURGE",141,0)
 I MSG("STATUS","PURGE"),MSG("DIRECTION")'="" K ^HLB("AD",MSG("DIRECTION"),MSG("STATUS","PURGE"),MSGIEN)
"RTN","HLOPURGE",142,0)
 K:(MSG("ID")]"") ^HLB("B",MSG("ID"),MSGIEN)
"RTN","HLOPURGE",143,0)
 I MSG("DIRECTION")="IN" D
"RTN","HLOPURGE",144,0)
 .K:($G(AC)]"") ^HLB("AC",AC,MSGIEN)
"RTN","HLOPURGE",145,0)
 .I MSG("BODY"),'$G(FLAG) D KILL777(MSG("BODY"))
"RTN","HLOPURGE",146,0)
 I MSG("DIRECTION")="OUT" D
"RTN","HLOPURGE",147,0)
 .K ^HLB("C",+MSG("BODY"),MSGIEN)
"RTN","HLOPURGE",148,0)
 .I '$G(FLAG),'$O(^HLB("C",+MSG("BODY"),0)) D KILL777(MSG("BODY"))
"RTN","HLOPURGE",149,0)
 Q
"RTN","HLOPURGE",150,0)
 ;
"RTN","HLOPURGE",151,0)
KILL777(BODY) ;
"RTN","HLOPURGE",152,0)
 Q:'$G(BODY)
"RTN","HLOPURGE",153,0)
 N TIME
"RTN","HLOPURGE",154,0)
 S TIME=$P($G(^HLA(BODY,0)),"^")
"RTN","HLOPURGE",155,0)
 K ^HLA(BODY)
"RTN","HLOPURGE",156,0)
 K:(TIME]"") ^HLA("B",TIME,BODY)
"RTN","HLOPURGE",157,0)
 Q
"RTN","HLOPURGE",158,0)
 ;
"RTN","HLOPURGE",159,0)
KSEARCH(MSG,MSGTYPE,EVENT,SAPP,RAPP,IEN) ;
"RTN","HLOPURGE",160,0)
 ;Kills the ^HLB("SEARCH") x-ref
"RTN","HLOPURGE",161,0)
 ;
"RTN","HLOPURGE",162,0)
 N APP
"RTN","HLOPURGE",163,0)
 S:MSGTYPE="" MSGTYPE="<none>"
"RTN","HLOPURGE",164,0)
 S:EVENT="" EVENT="<none>"
"RTN","HLOPURGE",165,0)
 Q:'MSG("DT/TM CREATED")
"RTN","HLOPURGE",166,0)
 I MSG("DIRECTION")'="IN",MSG("DIRECTION")'="OUT" Q
"RTN","HLOPURGE",167,0)
 S APP=$S(MSG("DIRECTION")="IN":RAPP,1:SAPP)
"RTN","HLOPURGE",168,0)
 Q:APP=""
"RTN","HLOPURGE",169,0)
 K ^HLB("SEARCH",MSG("DIRECTION"),MSG("DT/TM CREATED"),APP,MSGTYPE,EVENT,IEN)
"RTN","HLOPURGE",170,0)
 Q
"RTN","HLOQUE")
0^4^B97643227^B63465084
"RTN","HLOQUE",1,0)
HLOQUE ;ALB/CJM/OAK/PIJ/RBN- HL7 QUEUE MANAGEMENT - 10/4/94 1pm ;06/18/2009
"RTN","HLOQUE",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,132,134,137,138,143**;Oct 13, 1995;Build 3
"RTN","HLOQUE",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOQUE",4,0)
 ;
"RTN","HLOQUE",5,0)
INQUE(FROM,QNAME,IEN778,ACTION,PURGE) ;
"RTN","HLOQUE",6,0)
 ;Will place the message=IEN778 on the IN queue, incoming
"RTN","HLOQUE",7,0)
 ;Input:
"RTN","HLOQUE",8,0)
 ;  FROM - sending facility from message header.
"RTN","HLOQUE",9,0)
 ;         For actions other than incoming messages, its the specified link.
"RTN","HLOQUE",10,0)
 ;  QNAME - queue named by the application
"RTN","HLOQUE",11,0)
 ;  IEN778 = ien of the message in file 778
"RTN","HLOQUE",12,0)
 ;  ACTION - <tag^routine> that should be executed for the application
"RTN","HLOQUE",13,0)
 ;  PURGE (optional) - PURGE=1 indicates that the purge dt/tm needs to be set by the infiler
"RTN","HLOQUE",14,0)
 ;     If PURGE("ACKTOIEN") is set, it indicates that the purge dt/tm of
"RTN","HLOQUE",15,0)
 ;     the original message to this application ack also needs to be set.
"RTN","HLOQUE",16,0)
 ;Output: none
"RTN","HLOQUE",17,0)
 ;
"RTN","HLOQUE",18,0)
ZB36 I $G(FROM)="" S FROM="UNKNOWN"
"RTN","HLOQUE",19,0)
 I '$L($G(QNAME)) S QNAME="DEFAULT"
"RTN","HLOQUE",20,0)
 S ^HLB("QUEUE","IN",FROM,QNAME,IEN778)=ACTION_"^"_$G(PURGE)_"^"_$G(PURGE("ACKTOIEN"))
"RTN","HLOQUE",21,0)
 I $$INC^HLOSITE($NA(^HLC("QUEUECOUNT","IN",FROM,QNAME)))
"RTN","HLOQUE",22,0)
 Q
"RTN","HLOQUE",23,0)
 ;
"RTN","HLOQUE",24,0)
OUTQUE(LINKNAME,PORT,QNAME,IEN778) ;
"RTN","HLOQUE",25,0)
 ;Will place the message=IEN778 on the out-going queue
"RTN","HLOQUE",26,0)
 ;Input:
"RTN","HLOQUE",27,0)
 ;  LINKNAME = name of (.01) the logical link
"RTN","HLOQUE",28,0)
 ;  PORT (optional) the port to connect to
"RTN","HLOQUE",29,0)
 ;  QNAME - queue named by the application
"RTN","HLOQUE",30,0)
 ;  IEN778 = ien of the message in file 778
"RTN","HLOQUE",31,0)
 ;Output: none
"RTN","HLOQUE",32,0)
 ;
"RTN","HLOQUE",33,0)
 N SUB,FLG
"RTN","HLOQUE",34,0)
 S FLG=0
"RTN","HLOQUE",35,0)
 S SUB=LINKNAME
"RTN","HLOQUE",36,0)
 I PORT S SUB=SUB_":"_PORT
"RTN","HLOQUE",37,0)
 I '$L($G(QNAME)) S QNAME="DEFAULT"
"RTN","HLOQUE",38,0)
 ;***Start HL*1.6*138 PIJ
"RTN","HLOQUE",39,0)
 ;if recount in progress, give it up to 20 seconds to finish - if it takes longer than that the recount won't be exact, but a longer delay is unreasonable
"RTN","HLOQUE",40,0)
 I $$RCNT^HLOSITE L +RECOUNT("OUT",SUB,QNAME):20 S:$T FLG=1
"RTN","HLOQUE",41,0)
 ;***End HL*1.6*138 PIJ"
"RTN","HLOQUE",42,0)
 S ^HLB("QUEUE","OUT",SUB,QNAME,IEN778)=""
"RTN","HLOQUE",43,0)
 I $$INC^HLOSITE($NA(^HLC("QUEUECOUNT","OUT",SUB,QNAME)))
"RTN","HLOQUE",44,0)
 L:FLG -RECOUNT("OUT",SUB,QNAME)
"RTN","HLOQUE",45,0)
 Q
"RTN","HLOQUE",46,0)
 ;
"RTN","HLOQUE",47,0)
DEQUE(FROMORTO,QNAME,DIR,IEN778) ;
"RTN","HLOQUE",48,0)
 ;This routine will remove the message=IEN778 from its queue
"RTN","HLOQUE",49,0)
 ;Input:
"RTN","HLOQUE",50,0)
 ;  DIR = "IN" or "OUT", denoting the direction that the message is going in
"RTN","HLOQUE",51,0)
 ;  FROMORTO = for outgoing: the .01 field of the logical link
"RTN","HLOQUE",52,0)
 ;         for incoming: sending facility
"RTN","HLOQUE",53,0)
 ;  IEN778 = ien of the message in file 778
"RTN","HLOQUE",54,0)
 ;Output: none
"RTN","HLOQUE",55,0)
 ;
"RTN","HLOQUE",56,0)
 Q:(FROMORTO="")
"RTN","HLOQUE",57,0)
 I ($G(QNAME)="") S QNAME="DEFAULT"
"RTN","HLOQUE",58,0)
 D
"RTN","HLOQUE",59,0)
 .I $E(DIR)="I" S DIR="IN" Q
"RTN","HLOQUE",60,0)
 .I $E(DIR)="O" S DIR="OUT" Q
"RTN","HLOQUE",61,0)
 I DIR'="IN",DIR'="OUT" Q
"RTN","HLOQUE",62,0)
 Q:'$G(IEN778)
"RTN","HLOQUE",63,0)
 D:$D(^HLB("QUEUE",DIR,FROMORTO,QNAME,IEN778))
"RTN","HLOQUE",64,0)
 .K ^HLB("QUEUE",DIR,FROMORTO,QNAME,IEN778)
"RTN","HLOQUE",65,0)
 .;don't let the count become negative
"RTN","HLOQUE",66,0)
 .I $$INC^HLOSITE($NA(^HLC("QUEUECOUNT",DIR,FROMORTO,QNAME)),-1)<0,$$INC^HLOSITE($NA(^HLC("QUEUECOUNT",DIR,FROMORTO,QNAME)))
"RTN","HLOQUE",67,0)
 Q
"RTN","HLOQUE",68,0)
 ;
"RTN","HLOQUE",69,0)
STOPQUE(DIR,QUEUE) ;
"RTN","HLOQUE",70,0)
 ;This API is used to set a stop flag on a named queue.
"RTN","HLOQUE",71,0)
 ;DIR=<"IN" or "OUT">
"RTN","HLOQUE",72,0)
 ;QUEUE - the name of the queue to be stopped
"RTN","HLOQUE",73,0)
 ;
"RTN","HLOQUE",74,0)
 Q:$G(DIR)=""
"RTN","HLOQUE",75,0)
 Q:$G(QUEUE)=""
"RTN","HLOQUE",76,0)
 S ^HLTMP("STOPPED QUEUES",DIR,QUEUE)=1
"RTN","HLOQUE",77,0)
 Q
"RTN","HLOQUE",78,0)
STARTQUE(DIR,QUEUE) ;
"RTN","HLOQUE",79,0)
 ;This API is used to REMOVE the stop flag on a named queue.
"RTN","HLOQUE",80,0)
 ;DIR=<"IN" or "OUT">
"RTN","HLOQUE",81,0)
 ;QUEUE - the name of the queue to be stopped
"RTN","HLOQUE",82,0)
 ;
"RTN","HLOQUE",83,0)
 Q:$G(DIR)=""
"RTN","HLOQUE",84,0)
 Q:$G(QUEUE)=""
"RTN","HLOQUE",85,0)
 K ^HLTMP("STOPPED QUEUES",DIR,QUEUE)
"RTN","HLOQUE",86,0)
 Q
"RTN","HLOQUE",87,0)
STOPPED(DIR,QUEUE) ;
"RTN","HLOQUE",88,0)
 ;This API is used to DETERMINE if the stop flag on a named queue is set.
"RTN","HLOQUE",89,0)
 ;Input:
"RTN","HLOQUE",90,0)
 ;  DIR=<"IN" or "OUT">
"RTN","HLOQUE",91,0)
 ;  QUEUE - the name of the queue to be checked
"RTN","HLOQUE",92,0)
 ;Output:
"RTN","HLOQUE",93,0)
 ;  Function returns 1 if the queue is stopped, 0 otherwise
"RTN","HLOQUE",94,0)
 N RET
"RTN","HLOQUE",95,0)
 S RET=0
"RTN","HLOQUE",96,0)
 Q:$G(DIR)="" 0
"RTN","HLOQUE",97,0)
 Q:$G(QUEUE)="" 0
"RTN","HLOQUE",98,0)
 S:$G(^HLTMP("STOPPED QUEUES",DIR,QUEUE)) RET=1
"RTN","HLOQUE",99,0)
ZB0 Q RET
"RTN","HLOQUE",100,0)
 ;
"RTN","HLOQUE",101,0)
SQUE(SQUE,LINKNAME,PORT,QNAME,IEN778) ;
"RTN","HLOQUE",102,0)
 ;Will place the message=IEN778 on the sequencing queue. This is always done in the context of the application calling an HLO API to send a message.
"RTN","HLOQUE",103,0)
 ;Input:
"RTN","HLOQUE",104,0)
 ;  SQUE - name of the sequencing queue
"RTN","HLOQUE",105,0)
 ;  LINKNAME = name of (.01) the logical link
"RTN","HLOQUE",106,0)
 ;  PORT (optional) the port to connect to
"RTN","HLOQUE",107,0)
 ;  QNAME (optional) outgoing queue
"RTN","HLOQUE",108,0)
 ;  IEN778 = ien of the message in file 778
"RTN","HLOQUE",109,0)
 ;Output: 1 if placed on the outgoing queue, 0 if placed on the sequence queue
"RTN","HLOQUE",110,0)
 ;
"RTN","HLOQUE",111,0)
 N NEXT,MOVED,FLG
"RTN","HLOQUE",112,0)
 S (FLG,MOVED)=0
"RTN","HLOQUE",113,0)
 ;
"RTN","HLOQUE",114,0)
 ;keep a count of messages pending on sequence queues for the HLO System Monitor
"RTN","HLOQUE",115,0)
 ;
"RTN","HLOQUE",116,0)
 ;***Start HL*1.6*138 PIJ
"RTN","HLOQUE",117,0)
 ;if recount in progress, pause up to 20 seconds to finish - if it takes longer than that the recount won't be exact, but a longer delay is unreasonable
"RTN","HLOQUE",118,0)
 I $$RCNT^HLOSITE L +RECOUNT("SEQUENCE",SQUE):20 S:$T FLG=1
"RTN","HLOQUE",119,0)
 ;***End HL*1.6*138 PIJ
"RTN","HLOQUE",120,0)
 ;
"RTN","HLOQUE",121,0)
 ;** START 143 CJM
"RTN","HLOQUE",122,0)
 L +^HLB("QUEUE","SEQUENCE",SQUE):200
"RTN","HLOQUE",123,0)
 ;** END 143 CJM
"RTN","HLOQUE",124,0)
 ;
"RTN","HLOQUE",125,0)
 S NEXT=+$G(^HLB("QUEUE","SEQUENCE",SQUE))
"RTN","HLOQUE",126,0)
 I NEXT=IEN778 L -^HLB("QUEUE","SEQUENCE",SQUE) Q 0  ;already queued!
"RTN","HLOQUE",127,0)
 ;
"RTN","HLOQUE",128,0)
 ;increment the counter for all sequence queues
"RTN","HLOQUE",129,0)
 I $$INC^HLOSITE($NA(^HLC("QUEUECOUNT","SEQUENCE")))
"RTN","HLOQUE",130,0)
 ;
"RTN","HLOQUE",131,0)
 ;*** Start HL*1.6*138 CJM
"RTN","HLOQUE",132,0)
 ;also keep counter for the individual queue
"RTN","HLOQUE",133,0)
 I $$INC^HLOSITE($NA(^HLC("QUEUECOUNT","SEQUENCE",SQUE)))
"RTN","HLOQUE",134,0)
 ;*** End HL*1.6*138 CJM
"RTN","HLOQUE",135,0)
 ;
"RTN","HLOQUE",136,0)
 ;** START 143 CJM
"RTN","HLOQUE",137,0)
 ;L +^HLB("QUEUE","SEQUENCE",SQUE):200
"RTN","HLOQUE",138,0)
 ;** END 143 CJM
"RTN","HLOQUE",139,0)
 ;
"RTN","HLOQUE",140,0)
 ;if the sequence queue is empty and not waiting on a message, then the message can be put directly on the outgoing queue, bypassing the sequence queue
"RTN","HLOQUE",141,0)
 I '$O(^HLB("QUEUE","SEQUENCE",SQUE,0)),'NEXT D
"RTN","HLOQUE",142,0)
 .S ^HLB("QUEUE","SEQUENCE",SQUE)=IEN778 ;to mean something moved to outgoing but not yet transmitted
"RTN","HLOQUE",143,0)
 .D OUTQUE(.LINKNAME,.PORT,.QNAME,IEN778)
"RTN","HLOQUE",144,0)
 .S MOVED=1
"RTN","HLOQUE",145,0)
 E  D
"RTN","HLOQUE",146,0)
 .;Put the message on the sequence queue.
"RTN","HLOQUE",147,0)
 .S ^HLB("QUEUE","SEQUENCE",SQUE,IEN778)=""
"RTN","HLOQUE",148,0)
 .;
"RTN","HLOQUE",149,0)
 .;**P143 START CJM
"RTN","HLOQUE",150,0)
 .I 'NEXT,$$ADVANCE(SQUE,"")
"RTN","HLOQUE",151,0)
 .;**P143 END CJM
"RTN","HLOQUE",152,0)
 .;
"RTN","HLOQUE",153,0)
 L -^HLB("QUEUE","SEQUENCE",SQUE)
"RTN","HLOQUE",154,0)
 L:FLG -RECOUNT("SEQUENCE",SQUE)
"RTN","HLOQUE",155,0)
 Q MOVED
"RTN","HLOQUE",156,0)
 ;
"RTN","HLOQUE",157,0)
ADVANCE(SQUE,MSGIEN) ;
"RTN","HLOQUE",158,0)
 ;Will move the specified sequencing queue to the next message. 
"RTN","HLOQUE",159,0)
 ;Input:
"RTN","HLOQUE",160,0)
 ;  SQUE - name of the sequencing queue
"RTN","HLOQUE",161,0)
 ;  MSGIEN - the ien of the message upon which the sequence queue was waiting.  If it is NOT the correct ien, then the sequence queue will NOT be advance.
"RTN","HLOQUE",162,0)
 ;Output:
"RTN","HLOQUE",163,0)
 ;  Function - 1 if advanced, 0 if not
"RTN","HLOQUE",164,0)
 ;
"RTN","HLOQUE",165,0)
 N NODE,IEN778,LINKNAME,PORT,QNAME
"RTN","HLOQUE",166,0)
 Q:'$L($G(SQUE)) 0
"RTN","HLOQUE",167,0)
 ;
"RTN","HLOQUE",168,0)
 ;**P143 START CJM
"RTN","HLOQUE",169,0)
 ;Q:'$G(MSGIEN) 0
"RTN","HLOQUE",170,0)
 Q:'$D(MSGIEN) 0
"RTN","HLOQUE",171,0)
 ;**P143 END CJM
"RTN","HLOQUE",172,0)
 ;
"RTN","HLOQUE",173,0)
 L +^HLB("QUEUE","SEQUENCE",SQUE):200
"RTN","HLOQUE",174,0)
 ;
"RTN","HLOQUE",175,0)
 ;do not advance if the queue wasn't pending the message=MSGIEN
"RTN","HLOQUE",176,0)
 ;**P143 START CJM
"RTN","HLOQUE",177,0)
 ;I (MSGIEN'=$P($G(^HLB("QUEUE","SEQUENCE",SQUE)),"^")) L -^HLB("QUEUE","SEQUENCE",SQUE) Q 0
"RTN","HLOQUE",178,0)
 I ($G(MSGIEN)'=$P($G(^HLB("QUEUE","SEQUENCE",SQUE)),"^")) L -^HLB("QUEUE","SEQUENCE",SQUE) Q 0
"RTN","HLOQUE",179,0)
 ;**P143 END CJM
"RTN","HLOQUE",180,0)
 ;
"RTN","HLOQUE",181,0)
 ;decrement the count of messages pending on all sequence queues
"RTN","HLOQUE",182,0)
 I $$INC^HLOSITE($NA(^HLC("QUEUECOUNT","SEQUENCE")),-1)<0,$$INC^HLOSITE($NA(^HLC("QUEUECOUNT","SEQUENCE")))
"RTN","HLOQUE",183,0)
 ;
"RTN","HLOQUE",184,0)
 ;**Start HL*1.6*138 CJM
"RTN","HLOQUE",185,0)
 ;decrement the count of messages pending on this individual queue
"RTN","HLOQUE",186,0)
 I $$INC^HLOSITE($NA(^HLC("QUEUECOUNT","SEQUENCE",SQUE)),-1)<0,$$INC^HLOSITE($NA(^HLC("QUEUECOUNT","SEQUENCE",SQUE)))
"RTN","HLOQUE",187,0)
 ;**End HL*1.6*138 CJM
"RTN","HLOQUE",188,0)
 ;
"RTN","HLOQUE",189,0)
 S IEN778=0
"RTN","HLOQUE",190,0)
 ;look for the first message on the sequence que.  Make sure its valid, if not remove the invalid entry and keep looking.
"RTN","HLOQUE",191,0)
 F  S IEN778=$O(^HLB("QUEUE","SEQUENCE",SQUE,0)) Q:'IEN778  S NODE=$G(^HLB(IEN778,0)) Q:$L(NODE)  D
"RTN","HLOQUE",192,0)
 .;message does not exist! Remove from queue and try again.
"RTN","HLOQUE",193,0)
 .K ^HLB("QUEUE","SEQUENCE",SQUE,IEN778)
"RTN","HLOQUE",194,0)
 .I $$INC^HLOSITE($NA(^HLC("QUEUECOUNT","SEQUENCE")),-1)<0,$$INC^HLOSITE($NA(^HLC("QUEUECOUNT","SEQUENCE"))) ;decrement the count of messages pending sequence queues
"RTN","HLOQUE",195,0)
 .;**Start HL*1.6*138 CJM
"RTN","HLOQUE",196,0)
 .; also decrement the count of messages pending on this individual queue
"RTN","HLOQUE",197,0)
 .I $$INC^HLOSITE($NA(^HLC("QUEUECOUNT","SEQUENCE",SQUE)),-1)<0,$$INC^HLOSITE($NA(^HLC("QUEUECOUNT","SEQUENCE",SQUE)))
"RTN","HLOQUE",198,0)
 .;**End HL*1.6*138 CJM
"RTN","HLOQUE",199,0)
 ;
"RTN","HLOQUE",200,0)
 ;IEN778 is the next pending msg on this sequence queue
"RTN","HLOQUE",201,0)
 I IEN778 D
"RTN","HLOQUE",202,0)
 .;
"RTN","HLOQUE",203,0)
 .;parse out info needed to move to outgoing queue
"RTN","HLOQUE",204,0)
 .S LINKNAME=$P(NODE,"^",5),PORT=$P(NODE,"^",8),QNAME=$P(NODE,"^",6)
"RTN","HLOQUE",205,0)
 .;
"RTN","HLOQUE",206,0)
 .S ^HLB("QUEUE","SEQUENCE",SQUE)=IEN778 ;indicates this sequence queue is now waiting for msg=IEN778 before advancing.  The second pieces is the timer, but will not be set until the message=IEN778 is actually transmitted.
"RTN","HLOQUE",207,0)
 .K ^HLB("QUEUE","SEQUENCE",SQUE,IEN778) ;remove from sequence queue
"RTN","HLOQUE",208,0)
 .L -^HLB("QUEUE","SEQUENCE",SQUE)
"RTN","HLOQUE",209,0)
 .S $P(^HLB(IEN778,5),"^",2)=1
"RTN","HLOQUE",210,0)
 .D OUTQUE(.LINKNAME,$G(PORT),$G(QNAME),IEN778) ;move to outgoing queue
"RTN","HLOQUE",211,0)
 E  D
"RTN","HLOQUE",212,0)
 .K ^HLB("QUEUE","SEQUENCE",SQUE) ;this sequence queue is currently empty and not needed
"RTN","HLOQUE",213,0)
 .L -^HLB("QUEUE","SEQUENCE",SQUE)
"RTN","HLOQUE",214,0)
 Q 1
"RTN","HLOQUE",215,0)
 ;
"RTN","HLOQUE",216,0)
SEQCHK(WORK) ;functions under the HLO Process Manager
"RTN","HLOQUE",217,0)
 ;check sequence queues for timeout
"RTN","HLOQUE",218,0)
 N QUE,NOW
"RTN","HLOQUE",219,0)
 S NOW=$$NOW^XLFDT
"RTN","HLOQUE",220,0)
 S QUE=""
"RTN","HLOQUE",221,0)
 F  S QUE=$O(^HLB("QUEUE","SEQUENCE",QUE)) Q:QUE=""  D
"RTN","HLOQUE",222,0)
 .N NODE,MSGIEN,ACTION,NODE
"RTN","HLOQUE",223,0)
 .S NODE=$G(^HLB("QUEUE","SEQUENCE",QUE))
"RTN","HLOQUE",224,0)
 .Q:'$P(NODE,"^",2)
"RTN","HLOQUE",225,0)
 .Q:$P(NODE,"^",2)>NOW
"RTN","HLOQUE",226,0)
 .Q:$P(NODE,"^",3)
"RTN","HLOQUE",227,0)
 .L +^HLB("QUEUE","SEQUENCE",QUE):2
"RTN","HLOQUE",228,0)
 .;don't report if a lock wasn't obtained
"RTN","HLOQUE",229,0)
 .Q:'$T
"RTN","HLOQUE",230,0)
 .S NODE=$G(^HLB("QUEUE","SEQUENCE",QUE))
"RTN","HLOQUE",231,0)
 .I '$P(NODE,"^",2) L -^HLB("QUEUE","SEQUENCE",QUE) Q
"RTN","HLOQUE",232,0)
 .I ($P(NODE,"^",2)>NOW) L -^HLB("QUEUE","SEQUENCE",QUE) Q
"RTN","HLOQUE",233,0)
 .I $P(NODE,"^",3) L -^HLB("QUEUE","SEQUENCE",QUE) Q  ;exception already raised
"RTN","HLOQUE",234,0)
 .S MSGIEN=$P(NODE,"^")
"RTN","HLOQUE",235,0)
 .I 'MSGIEN L -^HLB("QUEUE","SEQUENCE",QUE) Q
"RTN","HLOQUE",236,0)
 .S ACTION=$$EXCEPT^HLOAPP($$GETSAP^HLOCLNT2(MSGIEN))
"RTN","HLOQUE",237,0)
 .S $P(^HLB(MSGIEN,5),"^",3)=1
"RTN","HLOQUE",238,0)
 .S $P(^HLB("QUEUE","SEQUENCE",QUE),"^",3)=1 ;indicates exception raised
"RTN","HLOQUE",239,0)
 .L -^HLB("QUEUE","SEQUENCE",QUE)
"RTN","HLOQUE",240,0)
 .D  ;call the application to take action
"RTN","HLOQUE",241,0)
 ..N HLMSGIEN,MCODE,DUZ,QUE,NOW
"RTN","HLOQUE",242,0)
 ..N $ETRAP,$ESTACK S $ETRAP="G ERROR^HLOQUE"
"RTN","HLOQUE",243,0)
 ..S HLMSGIEN=MSGIEN
"RTN","HLOQUE",244,0)
 ..S MCODE="D "_ACTION
"RTN","HLOQUE",245,0)
 ..N MSGIEN,X
"RTN","HLOQUE",246,0)
 ..D DUZ^XUP(.5)
"RTN","HLOQUE",247,0)
 ..X MCODE
"RTN","HLOQUE",248,0)
 ..;kill the apps variables
"RTN","HLOQUE",249,0)
 ..D
"RTN","HLOQUE",250,0)
 ...N ZTSK
"RTN","HLOQUE",251,0)
 ...D KILL^XUSCLEAN
"RTN","HLOQUE",252,0)
 Q
"RTN","HLOQUE",253,0)
ERROR ;error trap for application context
"RTN","HLOQUE",254,0)
 S $ETRAP="D UNWIND^%ZTER"
"RTN","HLOQUE",255,0)
 D ^%ZTER
"RTN","HLOQUE",256,0)
 S $ECODE=",UAPPLICATION ERROR,"
"RTN","HLOQUE",257,0)
 ;
"RTN","HLOQUE",258,0)
 ;kill the apps variables
"RTN","HLOQUE",259,0)
 D
"RTN","HLOQUE",260,0)
 .N ZTSK,MSGIEN,QUEUE
"RTN","HLOQUE",261,0)
 .D KILL^XUSCLEAN
"RTN","HLOQUE",262,0)
 ;
"RTN","HLOQUE",263,0)
 ;release all the locks the app may have set, except Taskman lock
"RTN","HLOQUE",264,0)
 L:$D(ZTSK) ^%ZTSCH("TASK",ZTSK):1
"RTN","HLOQUE",265,0)
 L:'$D(ZTSK)
"RTN","HLOQUE",266,0)
 ;reset HLO's lock
"RTN","HLOQUE",267,0)
 L +^HLTMP("HL7 RUNNING PROCESSES",$J):0
"RTN","HLOQUE",268,0)
 ;return to processing the next message on the queue
"RTN","HLOQUE",269,0)
 D UNWIND^%ZTER
"RTN","HLOQUE",270,0)
 Q
"RTN","HLOQUE",271,0)
 ;
"RTN","HLOQUE",272,0)
 ; *** start HL*1.6*143 -  RBN ***
"RTN","HLOQUE",273,0)
 ;
"RTN","HLOQUE",274,0)
 ; IMPLEMENTATION OF HL0 QUEUE COUNT SUMMARY
"RTN","HLOQUE",275,0)
 ;
"RTN","HLOQUE",276,0)
QUECNT(QUEARRAY) ;
"RTN","HLOQUE",277,0)
 ; 
"RTN","HLOQUE",278,0)
 ; DESC  : Functions eturns the total number of messages on all the queues and an the QUEARRAY
"RTN","HLOQUE",279,0)
 ;        
"RTN","HLOQUE",280,0)
 ; INPUT : QUEARRAY - the array, passed by reference, to contain the queue counts. 
"RTN","HLOQUE",281,0)
 ;               
"RTN","HLOQUE",282,0)
 ; OUTPUT : Filled array
"RTN","HLOQUE",283,0)
 ;               
"RTN","HLOQUE",284,0)
 ;               Format:
"RTN","HLOQUE",285,0)
 ;             
"RTN","HLOQUE",286,0)
 ;               QUE("TOTAL") = Total number of messages on all queues.
"RTN","HLOQUE",287,0)
 ;               QUE("OUT")   = Total number of outgoing messages.
"RTN","HLOQUE",288,0)
 ;               QUE("IN")    = Total number of incoming messages.
"RTN","HLOQUE",289,0)
 ;               QUE("SEQ")   = Total number of messages on sequence queues.
"RTN","HLOQUE",290,0)
 ;               QUE("IN",link_name,queue_name) = Number of messages on given link and queue.
"RTN","HLOQUE",291,0)
 ;               QUE("OUT",link_name,queue_name) = Number of messages on given link and queue.
"RTN","HLOQUE",292,0)
 ;               QUE("SEQ",queue_name) = Number of messages on given sequence queue.
"RTN","HLOQUE",293,0)
 ; 
"RTN","HLOQUE",294,0)
 ; There are four possible calls ("entry points") to this API:
"RTN","HLOQUE",295,0)
 ;   1. QUECNT - returns the referenced array with all of the above data.
"RTN","HLOQUE",296,0)
 ;   2. IN     - returns only the data related to the IN queues.
"RTN","HLOQUE",297,0)
 ;   3. OUT    - returns only the data related to the OUT queues.
"RTN","HLOQUE",298,0)
 ;   4. SEQ    - returns only the data related to the SEQUENCE queues.
"RTN","HLOQUE",299,0)
 ;   
"RTN","HLOQUE",300,0)
 N TOTAL,INCNT,OUTCNT,SEQCNT,LINK,QUE,FLG
"RTN","HLOQUE",301,0)
 S FLG=1
"RTN","HLOQUE",302,0)
 ; Get incomming counts
"RTN","HLOQUE",303,0)
 D IN(.QUEARRAY)
"RTN","HLOQUE",304,0)
 ; Get outgoing counts
"RTN","HLOQUE",305,0)
 D OUT(.QUEARRAY)
"RTN","HLOQUE",306,0)
 ; Get sequence counts
"RTN","HLOQUE",307,0)
 D SEQ(.QUEARRAY)
"RTN","HLOQUE",308,0)
 ;
"RTN","HLOQUE",309,0)
 ; Total messages on all queues
"RTN","HLOQUE",310,0)
 ; 
"RTN","HLOQUE",311,0)
 S QUEARRAY("TOTAL")=INCNT+OUTCNT+SEQCNT
"RTN","HLOQUE",312,0)
 Q QUEARRAY("TOTAL")
"RTN","HLOQUE",313,0)
 ;
"RTN","HLOQUE",314,0)
IN(QUEARRAY) ;
"RTN","HLOQUE",315,0)
 ; Count messages on incoming queues
"RTN","HLOQUE",316,0)
 ;
"RTN","HLOQUE",317,0)
 I '$G(FLG) N TOTAL,INCNT,OUTCNT,SEQCNT,LINK,QUE,FLG
"RTN","HLOQUE",318,0)
 S (LINK,QUE)=""
"RTN","HLOQUE",319,0)
 S INCNT=0
"RTN","HLOQUE",320,0)
 F  S LINK=$O(^HLC("QUEUECOUNT","IN",LINK)) Q:LINK=""  D
"RTN","HLOQUE",321,0)
 .  F  S QUE=$O(^HLC("QUEUECOUNT","IN",LINK,QUE)) Q:QUE=""  D
"RTN","HLOQUE",322,0)
 .  .  S INCNT=INCNT+^HLC("QUEUECOUNT","IN",LINK,QUE)
"RTN","HLOQUE",323,0)
 .  .  S QUEARRAY("IN",LINK,QUE)=^HLC("QUEUECOUNT","IN",LINK,QUE)
"RTN","HLOQUE",324,0)
 S QUEARRAY("IN")=INCNT
"RTN","HLOQUE",325,0)
 I '$G(FLG) Q INCNT
"RTN","HLOQUE",326,0)
 Q
"RTN","HLOQUE",327,0)
 ;
"RTN","HLOQUE",328,0)
OUT(QUEARRAY) ;
"RTN","HLOQUE",329,0)
 ; Count messages on outgoing queues
"RTN","HLOQUE",330,0)
 ;
"RTN","HLOQUE",331,0)
 I '$G(FLG) N TOTAL,INCNT,OUTCNT,SEQCNT,LINK,QUE,FLG
"RTN","HLOQUE",332,0)
 S (LINK,QUE)=""
"RTN","HLOQUE",333,0)
 S OUTCNT=0
"RTN","HLOQUE",334,0)
 F  S LINK=$O(^HLC("QUEUECOUNT","OUT",LINK)) Q:LINK=""  D
"RTN","HLOQUE",335,0)
 .  F  S QUE=$O(^HLC("QUEUECOUNT","OUT",LINK,QUE)) Q:QUE=""  D
"RTN","HLOQUE",336,0)
 .  .  S OUTCNT=OUTCNT+^HLC("QUEUECOUNT","OUT",LINK,QUE)
"RTN","HLOQUE",337,0)
 .  .  S QUEARRAY("OUT",LINK,QUE)=^HLC("QUEUECOUNT","OUT",LINK,QUE)
"RTN","HLOQUE",338,0)
 S QUEARRAY("OUT")=OUTCNT
"RTN","HLOQUE",339,0)
 I '$G(FLG) Q OUTCNT
"RTN","HLOQUE",340,0)
 Q
"RTN","HLOQUE",341,0)
 ;
"RTN","HLOQUE",342,0)
SEQ(QUEARRAY) ;
"RTN","HLOQUE",343,0)
 ; Count messages on sequence queues
"RTN","HLOQUE",344,0)
 ;
"RTN","HLOQUE",345,0)
 I '$G(FLG) N TOTAL,INCNT,OUTCNT,SEQCNT,LINK,QUE,FLG
"RTN","HLOQUE",346,0)
 S QUE=""
"RTN","HLOQUE",347,0)
 S SEQCNT=0
"RTN","HLOQUE",348,0)
 F  S QUE=$O(^HLC("QUEUECOUNT","SEQUENCE",QUE)) Q:QUE=""  D
"RTN","HLOQUE",349,0)
 .  S SEQCNT=SEQCNT+^HLC("QUEUECOUNT","SEQUENCE",QUE)
"RTN","HLOQUE",350,0)
 .  S QUEARRAY("SEQ",QUE)=^HLC("QUEUECOUNT","SEQUENCE",QUE)
"RTN","HLOQUE",351,0)
 S QUEARRAY("SEQ")=^HLC("QUEUECOUNT","SEQUENCE")
"RTN","HLOQUE",352,0)
 I '$G(FLG) Q QUEARRAY("SEQ")
"RTN","HLOQUE",353,0)
 Q
"RTN","HLOQUE",354,0)
 ;
"RTN","HLOQUE",355,0)
 ; *** End HL*1.6*143 -  RBN ***
"RTN","HLOSRVR")
0^5^B84549527^B77915377
"RTN","HLOSRVR",1,0)
HLOSRVR ;ALB/CJM/OAK/PIJ- Server for receiving messages - 10/4/94 1pm ;06/19/2009
"RTN","HLOSRVR",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,130,131,134,137,138,139,143**;Oct 13, 1995;Build 3
"RTN","HLOSRVR",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOSRVR",4,0)
 ;
"RTN","HLOSRVR",5,0)
GETWORK(WORK) ;
"RTN","HLOSRVR",6,0)
 ;GET WORK function for a single server or a Taskman multi-server
"RTN","HLOSRVR",7,0)
 N LINK
"RTN","HLOSRVR",8,0)
 I '$$CHKSTOP^HLOPROC,$G(WORK("LINK"))]"",$$GETLINK^HLOTLNK(WORK("LINK"),.LINK),+LINK("SERVER") S WORK("PORT")=LINK("PORT") Q 1
"RTN","HLOSRVR",9,0)
 Q 0
"RTN","HLOSRVR",10,0)
 ;
"RTN","HLOSRVR",11,0)
DOWORKS(WORK) ;
"RTN","HLOSRVR",12,0)
 ;DO WORK rtn for a single server (non-concurrent)
"RTN","HLOSRVR",13,0)
 N $ETRAP,$ESTACK
"RTN","HLOSRVR",14,0)
 S $ETRAP="G ERROR^HLOSRVR3"
"RTN","HLOSRVR",15,0)
 D SERVER(WORK("LINK"))
"RTN","HLOSRVR",16,0)
 Q
"RTN","HLOSRVR",17,0)
DOWORKM(WORK) ;
"RTN","HLOSRVR",18,0)
 ;DO WORK rtn for a Taskman multi-server (Cache systems only)
"RTN","HLOSRVR",19,0)
 D LISTEN^%ZISTCPS(WORK("PORT"),"SERVER^HLOSRVR("""_WORK("LINK")_""")")
"RTN","HLOSRVR",20,0)
 Q
"RTN","HLOSRVR",21,0)
 ;
"RTN","HLOSRVR",22,0)
VMS2(LINKNAME) ;called from a VMS TCP Service once a connection request has been received.  This entry point should be used only if an additional VMS TCPIP Services are being created for HLO.
"RTN","HLOSRVR",23,0)
 ;Input:
"RTN","HLOSRVR",24,0)
 ;   LINKNAME - only pass it in if an additional service is being created on a different port
"RTN","HLOSRVR",25,0)
 Q:'$L(LINKNAME)
"RTN","HLOSRVR",26,0)
 D VMS
"RTN","HLOSRVR",27,0)
 Q
"RTN","HLOSRVR",28,0)
 ;
"RTN","HLOSRVR",29,0)
VMS ;Called from VMS TCP Service once a connection request has been received. This entry point should be used only by the standard HLO service that runs on the standard HLO port.
"RTN","HLOSRVR",30,0)
 Q:$$CHKSTOP^HLOPROC
"RTN","HLOSRVR",31,0)
 D
"RTN","HLOSRVR",32,0)
 .Q:$L($G(LINKNAME))
"RTN","HLOSRVR",33,0)
 .;
"RTN","HLOSRVR",34,0)
 .N PROC,NODE
"RTN","HLOSRVR",35,0)
 .S PROC=$O(^HLD(779.3,"B","VMS TCP LISTENER",0))
"RTN","HLOSRVR",36,0)
 .I PROC S LINKNAME=$P($G(^HLD(779.3,PROC,0)),"^",14) Q:$L(LINKNAME)
"RTN","HLOSRVR",37,0)
 .S NODE=$G(^HLD(779.1,1,0)) I $P(NODE,"^",10) S LINKNAME=$P($G(^HLCS(870,$P(NODE,"^",10),0)),"^") Q:$L(LINKNAME) 
"RTN","HLOSRVR",38,0)
 .S LINKNAME="HLO DEFAULT LISTENER"
"RTN","HLOSRVR",39,0)
 ;
"RTN","HLOSRVR",40,0)
 D SERVER(LINKNAME,"SYS$NET")
"RTN","HLOSRVR",41,0)
 Q
"RTN","HLOSRVR",42,0)
 ;
"RTN","HLOSRVR",43,0)
SERVER(LINKNAME,LOGICAL) ; LINKNAME identifies the logical link, which describes the communication channel to be used
"RTN","HLOSRVR",44,0)
 ;;Start HL*1.6*138 PIJ
"RTN","HLOSRVR",45,0)
 ;;N $ETRAP,$ESTACK S $ETRAP="G ERROR^HLOSRVR1"
"RTN","HLOSRVR",46,0)
 N $ETRAP,$ESTACK S $ETRAP="G ERROR^HLOSRVR3"
"RTN","HLOSRVR",47,0)
 ;;End HL*1.6*138 PIJ
"RTN","HLOSRVR",48,0)
 N HLCSTATE,INQUE
"RTN","HLOSRVR",49,0)
 S INQUE=0
"RTN","HLOSRVR",50,0)
 ;
"RTN","HLOSRVR",51,0)
ZB1 ;
"RTN","HLOSRVR",52,0)
 I '$$CONNECT(.HLCSTATE,LINKNAME,.LOGICAL) Q
"RTN","HLOSRVR",53,0)
 K LINKNAME
"RTN","HLOSRVR",54,0)
 F  Q:'HLCSTATE("CONNECTED")  D  Q:$$CHKSTOP^HLOPROC
"RTN","HLOSRVR",55,0)
 .N HLMSTATE,SENT
"RTN","HLOSRVR",56,0)
 .;read msg and parse the hdr
"RTN","HLOSRVR",57,0)
 .;HLMSTATE("MSA",1) is set with type of ack to return
"RTN","HLOSRVR",58,0)
ZB2 .;
"RTN","HLOSRVR",59,0)
 .I $$READMSG^HLOSRVR1(.HLCSTATE,.HLMSTATE) D
"RTN","HLOSRVR",60,0)
 ..I (HLMSTATE("MSA",1)]"") S SENT=$$WRITEACK(.HLCSTATE,.HLMSTATE) D:HLMSTATE("IEN") SAVEACK(.HLMSTATE,SENT)
"RTN","HLOSRVR",61,0)
 ..;
"RTN","HLOSRVR",62,0)
 ..;** P143 START CJM **
"RTN","HLOSRVR",63,0)
 ..I HLMSTATE("ID")'="" L -HLO("MSGID",HLMSTATE("ID"))
"RTN","HLOSRVR",64,0)
 ..;** P143 END CJM **
"RTN","HLOSRVR",65,0)
 ..;
"RTN","HLOSRVR",66,0)
 ..D:HLMSTATE("IEN") UPDATE(.HLMSTATE,.HLCSTATE)
"RTN","HLOSRVR",67,0)
 ..D:HLCSTATE("COUNTS")>4 SAVECNTS^HLOSTAT(.HLCSTATE)
"RTN","HLOSRVR",68,0)
 ..I $G(HLMSTATE("ACK TO","IEN")),$L($G(HLMSTATE("ACK TO","SEQUENCE QUEUE"))) D ADVANCE^HLOQUE(HLMSTATE("ACK TO","SEQUENCE QUEUE"),+HLMSTATE("ACK TO","IEN"))
"RTN","HLOSRVR",69,0)
 .E  D
"RTN","HLOSRVR",70,0)
 ..;** P143 START CJM **
"RTN","HLOSRVR",71,0)
 ..I $G(HLMSTATE("ID"))'="" L -HLO("MSGID",HLMSTATE("ID"))
"RTN","HLOSRVR",72,0)
 ..;** P143 END CJM **
"RTN","HLOSRVR",73,0)
 ..D INQUE() H:HLCSTATE("CONNECTED") 1
"RTN","HLOSRVR",74,0)
ZB37 .;
"RTN","HLOSRVR",75,0)
 ;
"RTN","HLOSRVR",76,0)
END D CLOSE^HLOT(.HLCSTATE)
"RTN","HLOSRVR",77,0)
 D INQUE()
"RTN","HLOSRVR",78,0)
 D SAVECNTS^HLOSTAT(.HLCSTATE)
"RTN","HLOSRVR",79,0)
 Q
"RTN","HLOSRVR",80,0)
 ;
"RTN","HLOSRVR",81,0)
CONNECT(HLCSTATE,LINKNAME,LOGICAL) ;
"RTN","HLOSRVR",82,0)
 ;sets up HLCSTATE() and opens a server connection
"RTN","HLOSRVR",83,0)
 ;
"RTN","HLOSRVR",84,0)
 N LINK,NODE
"RTN","HLOSRVR",85,0)
 S HLCSTATE("CONNECTED")=0
"RTN","HLOSRVR",86,0)
 Q:'$$GETLINK^HLOTLNK(LINKNAME,.LINK) 0
"RTN","HLOSRVR",87,0)
ZB999 ; 
"RTN","HLOSRVR",88,0)
 Q:+LINK("SERVER")'=1 0
"RTN","HLOSRVR",89,0)
 S HLCSTATE("SERVER")=LINK("SERVER")
"RTN","HLOSRVR",90,0)
 M HLCSTATE("LINK")=LINK
"RTN","HLOSRVR",91,0)
 S HLCSTATE("READ TIMEOUT")=20
"RTN","HLOSRVR",92,0)
 S HLCSTATE("OPEN TIMEOUT")=30
"RTN","HLOSRVR",93,0)
 S HLCSTATE("READ")="" ;buffer for reads
"RTN","HLOSRVR",94,0)
 ;
"RTN","HLOSRVR",95,0)
 ;HLCSTATE("BUFFER",<seg>,<line>)  write buffer
"RTN","HLOSRVR",96,0)
 S HLCSTATE("BUFFER","BYTE COUNT")=0 ;count of bytes in buffer
"RTN","HLOSRVR",97,0)
 S HLCSTATE("BUFFER","SEGMENT COUNT")=0 ;count of segments in buffer
"RTN","HLOSRVR",98,0)
 ;
"RTN","HLOSRVR",99,0)
 S HLCSTATE("COUNTS")=0
"RTN","HLOSRVR",100,0)
 S HLCSTATE("MESSAGE STARTED")=0 ;start of message flag
"RTN","HLOSRVR",101,0)
 S HLCSTATE("MESSAGE ENDED")=0 ;end of message flag
"RTN","HLOSRVR",102,0)
 S NODE=^%ZOSF("OS")
"RTN","HLOSRVR",103,0)
 S HLCSTATE("SYSTEM","OS")=$S(NODE["DSM":"DSM",NODE["OpenM":"CACHE",NODE["G.TM":"G.TM",1:"")
"RTN","HLOSRVR",104,0)
 Q:HLCSTATE("SYSTEM","OS")="" 0
"RTN","HLOSRVR",105,0)
 D  ;get necessary system parameters
"RTN","HLOSRVR",106,0)
 .N SYS,SUB
"RTN","HLOSRVR",107,0)
 .D SYSPARMS^HLOSITE(.SYS)
"RTN","HLOSRVR",108,0)
 .F SUB="MAXSTRING","DOMAIN","STATION","PROCESSING ID","NORMAL PURGE","ERROR PURGE" S HLCSTATE("SYSTEM",SUB)=SYS(SUB)
"RTN","HLOSRVR",109,0)
 .S HLCSTATE("SYSTEM","BUFFER")=SYS("HL7 BUFFER")
"RTN","HLOSRVR",110,0)
 I HLCSTATE("LINK","LLP")="TCP" D
"RTN","HLOSRVR",111,0)
 .D OPEN^HLOTCP(.HLCSTATE,.LOGICAL)
"RTN","HLOSRVR",112,0)
 E  ;no other LLP implemented
"RTN","HLOSRVR",113,0)
 ;
"RTN","HLOSRVR",114,0)
 I 'HLCSTATE("CONNECTED") D
"RTN","HLOSRVR",115,0)
ZB24 .;
"RTN","HLOSRVR",116,0)
 Q HLCSTATE("CONNECTED")
"RTN","HLOSRVR",117,0)
 ;
"RTN","HLOSRVR",118,0)
INQUE(MSGIEN,PARMS) ;
"RTN","HLOSRVR",119,0)
 ;
"RTN","HLOSRVR",120,0)
 ;** do not implement the Pass Immediate parameter **
"RTN","HLOSRVR",121,0)
 ;INQUE(MSGIEN,PARMS,IMMEDIATE);
"RTN","HLOSRVR",122,0)
 ;
"RTN","HLOSRVR",123,0)
 ;puts received messages on the incoming queue and sets the B x-ref
"RTN","HLOSRVR",124,0)
 I $G(MSGIEN) S INQUE=INQUE+1 M INQUE(MSGIEN)=PARMS
"RTN","HLOSRVR",125,0)
 ;
"RTN","HLOSRVR",126,0)
 ;** do not implement the Pass Immediate parameter **
"RTN","HLOSRVR",127,0)
 ;I ('$G(MSGIEN))!(INQUE>20)!($G(IMMEDIATE)) S MSGIEN=0 D
"RTN","HLOSRVR",128,0)
 ;
"RTN","HLOSRVR",129,0)
 I ('$G(MSGIEN))!(INQUE>20) S MSGIEN=0 D
"RTN","HLOSRVR",130,0)
 .F  S MSGIEN=$O(INQUE(MSGIEN)) Q:'MSGIEN  D
"RTN","HLOSRVR",131,0)
 ..S ^HLB("B",INQUE(MSGIEN,"MSGID"),MSGIEN)=""
"RTN","HLOSRVR",132,0)
 ..S ^HLA("B",INQUE(MSGIEN,"DT/TM"),INQUE(MSGIEN,"BODY"))=""
"RTN","HLOSRVR",133,0)
 ..D:INQUE(MSGIEN,"PASS")
"RTN","HLOSRVR",134,0)
 ...N PURGE
"RTN","HLOSRVR",135,0)
 ...S PURGE=+$G(INQUE(MSGIEN,"PURGE"))
"RTN","HLOSRVR",136,0)
 ...S PURGE("ACKTOIEN")=$G(INQUE(MSGIEN,"ACKTOIEN"))
"RTN","HLOSRVR",137,0)
 ...D INQUE^HLOQUE(INQUE(MSGIEN,"FROM"),INQUE(MSGIEN,"QUEUE"),MSGIEN,INQUE(MSGIEN,"ACTION"),.PURGE)
"RTN","HLOSRVR",138,0)
 .K INQUE S INQUE=0
"RTN","HLOSRVR",139,0)
 Q
"RTN","HLOSRVR",140,0)
 ;
"RTN","HLOSRVR",141,0)
SAVEACK(HLMSTATE,SENT) ;
"RTN","HLOSRVR",142,0)
 ;Input:
"RTN","HLOSRVR",143,0)
 ;  SENT - flag = 1 if transmission of ack succeeded, 0 otherwise
"RTN","HLOSRVR",144,0)
 ;
"RTN","HLOSRVR",145,0)
 N NODE,I,XX
"RTN","HLOSRVR",146,0)
 S $P(NODE,"^")=HLMSTATE("MSA","DT/TM OF MESSAGE")
"RTN","HLOSRVR",147,0)
 S $P(NODE,"^",2)=HLMSTATE("MSA","MESSAGE CONTROL ID")
"RTN","HLOSRVR",148,0)
 S $P(NODE,"^",3)="MSA"
"RTN","HLOSRVR",149,0)
 F I=1:1:3 S NODE=NODE_"|"_$G(HLMSTATE("MSA",I))
"RTN","HLOSRVR",150,0)
 S ^HLB(HLMSTATE("IEN"),4)=NODE
"RTN","HLOSRVR",151,0)
 S:SENT $P(^HLB(HLMSTATE("IEN"),0),"^",$S($E(HLMSTATE("MSA",1))="A":18,1:17))=1
"RTN","HLOSRVR",152,0)
 Q
"RTN","HLOSRVR",153,0)
 ;
"RTN","HLOSRVR",154,0)
UPDATE(HLMSTATE,HLCSTATE) ;
"RTN","HLOSRVR",155,0)
 ;Updates status and purge date when appropriate
"RTN","HLOSRVR",156,0)
 ;Also, sets the "B" xrefs, files 777,778, and places message on the incoming queue
"RTN","HLOSRVR",157,0)
 ;
"RTN","HLOSRVR",158,0)
ZB40 N PARMS,PURGE,WAIT
"RTN","HLOSRVR",159,0)
 S PARMS("PASS")=0
"RTN","HLOSRVR",160,0)
 I HLMSTATE("STATUS","ACTION")]"",HLMSTATE("STATUS")'="ER" D
"RTN","HLOSRVR",161,0)
 .N IEN
"RTN","HLOSRVR",162,0)
 .S IEN=HLMSTATE("IEN")
"RTN","HLOSRVR",163,0)
 .S PARMS("PASS")=1,$P(^HLB(IEN,0),"^",6)=HLMSTATE("STATUS","QUEUE"),$P(^HLB(IEN,0),"^",10)=$P(HLMSTATE("STATUS","ACTION"),"^"),$P(^HLB(IEN,0),"^",11)=$P(HLMSTATE("STATUS","ACTION"),"^",2)
"RTN","HLOSRVR",164,0)
 D:'PARMS("PASS")  ;if not passing to the app, set the purge date
"RTN","HLOSRVR",165,0)
 .I HLMSTATE("STATUS")="" S HLMSTATE("STATUS")="SU"
"RTN","HLOSRVR",166,0)
 .S:HLMSTATE("BATCH") WAIT=HLCSTATE("SYSTEM","ERROR PURGE")
"RTN","HLOSRVR",167,0)
 .S:'HLMSTATE("BATCH") WAIT=$S(($G(HLMSTATE("ACK TO","STATUS"))="ER"):24*HLCSTATE("SYSTEM","ERROR PURGE"),HLMSTATE("STATUS")="ER":24*HLCSTATE("SYSTEM","ERROR PURGE"),1:HLCSTATE("SYSTEM","NORMAL PURGE"))
"RTN","HLOSRVR",168,0)
 .S PURGE=$$FMADD^XLFDT($$NOW^XLFDT,,WAIT)
"RTN","HLOSRVR",169,0)
 .S $P(^HLB(HLMSTATE("IEN"),0),"^",9)=PURGE
"RTN","HLOSRVR",170,0)
 .S ^HLB("AD","IN",PURGE,HLMSTATE("IEN"))=""
"RTN","HLOSRVR",171,0)
 .;if this is an app ack, purge the original message at the same time
"RTN","HLOSRVR",172,0)
 .I $G(HLMSTATE("ACK TO","IEN")),'HLMSTATE("BATCH") D
"RTN","HLOSRVR",173,0)
 ..S $P(^HLB(+HLMSTATE("ACK TO","IEN"),0),"^",9)=PURGE
"RTN","HLOSRVR",174,0)
 ..S ^HLB("AD","IN",PURGE,+HLMSTATE("ACK TO","IEN"))=""
"RTN","HLOSRVR",175,0)
 ;
"RTN","HLOSRVR",176,0)
 ;if not waiting for an application ack, set the status now even if passing to the app - but don't set the purge until the infiler passes the message
"RTN","HLOSRVR",177,0)
 I HLMSTATE("STATUS")="",($G(HLMSTATE("ACK TO","IEN"))!HLMSTATE("HDR","APP ACK TYPE")'="AL") S HLMSTATE("STATUS")="SU"
"RTN","HLOSRVR",178,0)
 I HLMSTATE("STATUS")'="" S $P(^HLB(HLMSTATE("IEN"),0),"^",20)=HLMSTATE("STATUS") S:$G(HLMSTATE("MSA",3))]"" $P(^HLB(HLMSTATE("IEN"),0),"^",21)=HLMSTATE("MSA",3) D:HLMSTATE("STATUS")'="SU"
"RTN","HLOSRVR",179,0)
 .N APP
"RTN","HLOSRVR",180,0)
 .S APP=HLMSTATE("HDR","RECEIVING APPLICATION") S:APP="" APP="UNKNOWN" S ^HLB("ERRORS",APP,HLMSTATE("DT/TM"),HLMSTATE("IEN"))=""
"RTN","HLOSRVR",181,0)
 .D COUNT^HLOESTAT("IN",$G(HLMSTATE("HDR","RECEIVING APPLICATION")),$G(HLMSTATE("HDR","SENDING APPLICATION")),$S(HLMSTATE("BATCH"):"BATCH",1:$G(HLMSTATE("HDR","MESSAGE TYPE"))),$G(HLMSTATE("HDR","EVENT")))
"RTN","HLOSRVR",182,0)
 ;
"RTN","HLOSRVR",183,0)
 ;set the necessary parms for passing the msg to the app via the infiler
"RTN","HLOSRVR",184,0)
 D:PARMS("PASS")
"RTN","HLOSRVR",185,0)
 .N I,FROM
"RTN","HLOSRVR",186,0)
 .S FROM=HLMSTATE("HDR","SENDING FACILITY",1)
"RTN","HLOSRVR",187,0)
 .I HLMSTATE("HDR","SENDING FACILITY",2)]"" S FROM=FROM_"~"_HLMSTATE("HDR","SENDING FACILITY",2)_"~"_HLMSTATE("HDR","SENDING FACILITY",3)
"RTN","HLOSRVR",188,0)
 .I FROM="" S FROM="UNKNOWN SENDING FACILITY"
"RTN","HLOSRVR",189,0)
 .S PARMS("FROM")=FROM,PARMS("QUEUE")=HLMSTATE("STATUS","QUEUE"),PARMS("ACTION")=HLMSTATE("STATUS","ACTION")
"RTN","HLOSRVR",190,0)
 .I HLMSTATE("STATUS")'="" S PARMS("PURGE")=$S(HLMSTATE("STATUS")="ER":2,$G(HLMSTATE("ACK TO","STATUS"))="ER":2,1:1)
"RTN","HLOSRVR",191,0)
 .S:$G(HLMSTATE("ACK TO","IEN")) PARMS("ACKTOIEN")=HLMSTATE("ACK TO","IEN") ;to insure that the infiler will know to set the purge date at the same time as the initial message
"RTN","HLOSRVR",192,0)
 ;
"RTN","HLOSRVR",193,0)
 S PARMS("BODY")=HLMSTATE("BODY")
"RTN","HLOSRVR",194,0)
 S PARMS("DT/TM")=HLMSTATE("DT/TM")
"RTN","HLOSRVR",195,0)
 S PARMS("MSGID")=HLMSTATE("ID")
"RTN","HLOSRVR",196,0)
 ;
"RTN","HLOSRVR",197,0)
 ;** do not implement the Pass Immediate parameter **
"RTN","HLOSRVR",198,0)
 ;D INQUE(HLMSTATE("IEN"),.PARMS,$G(HLMSTATE("STATUS","PASS IMMEDIATE")))
"RTN","HLOSRVR",199,0)
 ;
"RTN","HLOSRVR",200,0)
 D INQUE(HLMSTATE("IEN"),.PARMS)
"RTN","HLOSRVR",201,0)
 Q
"RTN","HLOSRVR",202,0)
 ;
"RTN","HLOSRVR",203,0)
WRITEACK(HLCSTATE,HLMSTATE) ;
"RTN","HLOSRVR",204,0)
 ;Sends an accept ack
"RTN","HLOSRVR",205,0)
 ;
"RTN","HLOSRVR",206,0)
 ;Input:
"RTN","HLOSRVR",207,0)
 ;  HLCSTATE (pass by reference) defines the communication channel
"RTN","HLOSRVR",208,0)
 ;  HLMSTATE (pass by reference) the message being acked
"RTN","HLOSRVR",209,0)
 ;     ("MSA",1) - value for MSA-1
"RTN","HLOSRVR",210,0)
 ;     ("MSA",2) - value for MSA-2
"RTN","HLOSRVR",211,0)
 ;     ("MSA",3) - value for MSA-3
"RTN","HLOSRVR",212,0)
 ;     ("HDR") - parsed values for the message being ack'd
"RTN","HLOSRVR",213,0)
 ;Output:
"RTN","HLOSRVR",214,0)
 ;  Function returns 1 if successful, 0 otherwise
"RTN","HLOSRVR",215,0)
 ;  HLMSTATE("MSA","MESSAGE CONTROL ID") - the msg id of the ack
"RTN","HLOSRVR",216,0)
 ;  HLMSTATE(,"MSA","DT/TM OF MESSAGE") - from the ack header
"RTN","HLOSRVR",217,0)
 ; 
"RTN","HLOSRVR",218,0)
 N HDR,SUB,FS,CS,MSA,ACKID,TIME
"RTN","HLOSRVR",219,0)
 ;Hard-code the delimiters, the standard requires that the receiving system accept the delimiters listed in the header
"RTN","HLOSRVR",220,0)
 S FS="|"
"RTN","HLOSRVR",221,0)
 S CS="^"
"RTN","HLOSRVR",222,0)
 S TIME=$$NOW^XLFDT
"RTN","HLOSRVR",223,0)
 S HLMSTATE("MSA","DT/TM OF MESSAGE")=TIME
"RTN","HLOSRVR",224,0)
 S ACKID=HLCSTATE("SYSTEM","STATION")_" "_$$NEWIEN^HLOF778A("OUT")
"RTN","HLOSRVR",225,0)
 S HLMSTATE("MSA","MESSAGE CONTROL ID")=ACKID
"RTN","HLOSRVR",226,0)
 ;
"RTN","HLOSRVR",227,0)
 S HDR(1)="MSH"_FS_"^~\&"_FS_HLMSTATE("HDR","RECEIVING APPLICATION")_FS_HLCSTATE("SYSTEM","STATION")_CS_HLCSTATE("SYSTEM","DOMAIN")_CS_"DNS"_FS
"RTN","HLOSRVR",228,0)
 S HDR(1)=HDR(1)_HLMSTATE("HDR","SENDING APPLICATION")_FS_HLMSTATE("HDR","SENDING FACILITY",1)_CS_HLMSTATE("HDR","SENDING FACILITY",2)_CS_HLMSTATE("HDR","SENDING FACILITY",3)
"RTN","HLOSRVR",229,0)
 ;
"RTN","HLOSRVR",230,0)
 S HDR(2)=FS_$$HLDATE^HLFNC(TIME,"TS")_FS_FS_"ACK"_FS_ACKID_FS_HLMSTATE("HDR","PROCESSING ID")_FS_"2.4"_FS_FS_FS_"NE"_FS_"NE"
"RTN","HLOSRVR",231,0)
 ;
"RTN","HLOSRVR",232,0)
 S MSA(1)="MSA"_FS
"RTN","HLOSRVR",233,0)
 F SUB=1:1:3 S MSA(1)=MSA(1)_HLMSTATE("MSA",SUB)_FS
"RTN","HLOSRVR",234,0)
 I $$WRITEHDR^HLOT(.HLCSTATE,.HDR),$$WRITESEG^HLOT(.HLCSTATE,.MSA),$$ENDMSG^HLOT(.HLCSTATE) S HLCSTATE("COUNTS","ACKS")=$G(HLCSTATE("COUNTS","ACKS"))+1 Q 1
"RTN","HLOSRVR",235,0)
 S HLMSTATE("MSA","DT/TM OF MESSAGE")=""
"RTN","HLOSRVR",236,0)
 Q 0
"RTN","HLOSRVR1")
0^6^B86996455^B79956205
"RTN","HLOSRVR1",1,0)
HLOSRVR1 ;IRMFO-ALB/CJM/OAK/PIJ - Reading messages, sending acks;03/24/2004  14:43 ;06/17/2009
"RTN","HLOSRVR1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,130,131,133,134,137,138,139,143**;Oct 13, 1995;Build 3
"RTN","HLOSRVR1",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOSRVR1",4,0)
 ;
"RTN","HLOSRVR1",5,0)
READMSG(HLCSTATE,HLMSTATE) ;
"RTN","HLOSRVR1",6,0)
 ;Reads a message.  The header is parsed. Does these checks:
"RTN","HLOSRVR1",7,0)
 ; 1) Duplicate?
"RTN","HLOSRVR1",8,0)
 ; 2) Wrong Receiving Facility?
"RTN","HLOSRVR1",9,0)
 ; 3) Can the Receiving App accept this message, based message type & event?
"RTN","HLOSRVR1",10,0)
 ; 4) Processing ID must match the receiving system
"RTN","HLOSRVR1",11,0)
 ; 5) Must have an ID
"RTN","HLOSRVR1",12,0)
 ; 6) Header must be BHS or MSH
"RTN","HLOSRVR1",13,0)
 ;
"RTN","HLOSRVR1",14,0)
 ;Output:
"RTN","HLOSRVR1",15,0)
 ;  Function returns 1 if the message was read fully, 0 otherwise
"RTN","HLOSRVR1",16,0)
 ;  HLMSTATE (pass by reference) the message.  It will include the fields for the return ack in HLMSTATE("MSA")
"RTN","HLOSRVR1",17,0)
 ;
"RTN","HLOSRVR1",18,0)
ZB28 N ACK,SEG,STORE,I
"RTN","HLOSRVR1",19,0)
 ;
"RTN","HLOSRVR1",20,0)
 S STORE=1
"RTN","HLOSRVR1",21,0)
 Q:'$$READHDR^HLOT(.HLCSTATE,.SEG) 0
"RTN","HLOSRVR1",22,0)
 D SPLITHDR(.SEG)
"RTN","HLOSRVR1",23,0)
 ;
"RTN","HLOSRVR1",24,0)
 ;parse the header, stop if unsuccessful because the server cannot know what to do next
"RTN","HLOSRVR1",25,0)
ZB34 I '$$PARSEHDR^HLOPRS(.SEG) D  Q 0
"RTN","HLOSRVR1",26,0)
ZB29 .;
"RTN","HLOSRVR1",27,0)
 .S HLCSTATE("MESSAGE ENDED")=0
"RTN","HLOSRVR1",28,0)
 .D CLOSE^HLOT(.HLCSTATE)
"RTN","HLOSRVR1",29,0)
 ;
"RTN","HLOSRVR1",30,0)
 ;** P143 START CJM**
"RTN","HLOSRVR1",31,0)
 S I=$S(SEG("SEGMENT TYPE")="MSH":$G(SEG("MESSAGE CONTROL ID")),1:$G(SEG("BATCH CONTROL ID")))
"RTN","HLOSRVR1",32,0)
 I I'="" L +HLO("MSGID",I):5 I '$T D  Q 0
"RTN","HLOSRVR1",33,0)
 .S HLCSTATE("MESSAGE ENDED")=0
"RTN","HLOSRVR1",34,0)
 .D CLOSE^HLOT(.HLCSTATE)
"RTN","HLOSRVR1",35,0)
 ;** P143 START CJM
"RTN","HLOSRVR1",36,0)
ZB38 ;
"RTN","HLOSRVR1",37,0)
 D NEWMSG^HLOSRVR2(.HLCSTATE,.HLMSTATE,.SEG)
"RTN","HLOSRVR1",38,0)
 I HLMSTATE("ID")="" D
"RTN","HLOSRVR1",39,0)
ZB30 .;
"RTN","HLOSRVR1",40,0)
 .S STORE=0
"RTN","HLOSRVR1",41,0)
 .I HLMSTATE("HDR","ACCEPT ACK TYPE")="AL" S HLMSTATE("MSA",1)="CE",HLMSTATE("MSA",3)="CONTROL ID MISSING"
"RTN","HLOSRVR1",42,0)
 I STORE,$$DUP(.HLMSTATE) S STORE=0
"RTN","HLOSRVR1",43,0)
 ;
"RTN","HLOSRVR1",44,0)
 ;if the message is not to be stored, just read it and discard the segments
"RTN","HLOSRVR1",45,0)
 I 'STORE D
"RTN","HLOSRVR1",46,0)
ZB32 .F  Q:'$$READSEG^HLOT(.HLCSTATE,.SEG)
"RTN","HLOSRVR1",47,0)
 ;
"RTN","HLOSRVR1",48,0)
 E  D
"RTN","HLOSRVR1",49,0)
ZB33 .N FS,NEWMSGID
"RTN","HLOSRVR1",50,0)
 .S NEWMSGID=""
"RTN","HLOSRVR1",51,0)
 .S FS=HLMSTATE("HDR","FIELD SEPARATOR")
"RTN","HLOSRVR1",52,0)
 .F  Q:'$$READSEG^HLOT(.HLCSTATE,.SEG)  D
"RTN","HLOSRVR1",53,0)
 ..N MSA,SEGTYPE,OLDMSGID,CODE,IEN,TEXT
"RTN","HLOSRVR1",54,0)
 ..S SEGTYPE=$E($E(SEG(1),1,3)_$E($G(SEG(2)),1,2),1,3)
"RTN","HLOSRVR1",55,0)
 ..I SEGTYPE="MSA" D
"RTN","HLOSRVR1",56,0)
 ...S MSA=SEG(1)_$G(SEG(2))_$G(SEG(3))
"RTN","HLOSRVR1",57,0)
 ...;; ** Start HL*1.6*138 PIJ **
"RTN","HLOSRVR1",58,0)
 ...;;S OLDMSGID=$P(MSA,FS,3),CODE=$P(MSA,FS,2),TEXT=$E($P(MSA,FS,4),1,30)
"RTN","HLOSRVR1",59,0)
 ...S OLDMSGID=$P(MSA,FS,3),CODE=$P(MSA,FS,2)
"RTN","HLOSRVR1",60,0)
 ...S TEXT=$$ESCAPE^HLOPBLD(.HLMSTATE,$P(MSA,FS,4,$L(MSA,"|")))
"RTN","HLOSRVR1",61,0)
 ...;; ** End HL*1.6*138 **
"RTN","HLOSRVR1",62,0)
 ...I $E(CODE,1)'="A" S SEGTYPE="" Q
"RTN","HLOSRVR1",63,0)
 ...;** P143 START CJM
"RTN","HLOSRVR1",64,0)
 ...;S:$P(OLDMSGID,"-")]"" IEN=$O(^HLB("B",$P(OLDMSGID,"-"),0))
"RTN","HLOSRVR1",65,0)
 ...;S:$G(IEN) IEN=IEN_"^"_$P(OLDMSGID,"-",2)
"RTN","HLOSRVR1",66,0)
 ...S IEN=$$ACKTOIEN^HLOMSG1("",OLDMSGID)
"RTN","HLOSRVR1",67,0)
 ...;** P143 END CJM
"RTN","HLOSRVR1",68,0)
 ..I 'HLMSTATE("BATCH") D
"RTN","HLOSRVR1",69,0)
 ...D:SEGTYPE="MSA"
"RTN","HLOSRVR1",70,0)
 ....S HLMSTATE("ACK TO")=OLDMSGID
"RTN","HLOSRVR1",71,0)
 ....S HLMSTATE("ACK TO","ACK BY")=HLMSTATE("ID")
"RTN","HLOSRVR1",72,0)
 ....S HLMSTATE("ACK TO","STATUS")=$S(CODE="AA":"SU",1:"ER")
"RTN","HLOSRVR1",73,0)
 ....I $G(IEN) D
"RTN","HLOSRVR1",74,0)
 .....S HLMSTATE("ACK TO","IEN")=IEN
"RTN","HLOSRVR1",75,0)
 .....S HLMSTATE("ACK TO","SEQUENCE QUEUE")=$P($G(^HLB(+IEN,5)),"^")
"RTN","HLOSRVR1",76,0)
 ....S HLMSTATE("ACK TO","ERROR TEXT")=TEXT
"RTN","HLOSRVR1",77,0)
 ...D ADDSEG^HLOMSG(.HLMSTATE,.SEG)
"RTN","HLOSRVR1",78,0)
 ..E  D  ;batch
"RTN","HLOSRVR1",79,0)
 ...I SEGTYPE="MSH" D
"RTN","HLOSRVR1",80,0)
 ....D SPLITHDR(.SEG)
"RTN","HLOSRVR1",81,0)
 ....S NEWMSGID=$P(SEG(2),FS,5)
"RTN","HLOSRVR1",82,0)
 ....D ADDMSG2^HLOMSG(.HLMSTATE,.SEG)
"RTN","HLOSRVR1",83,0)
 ...E  D  ;not MSH
"RTN","HLOSRVR1",84,0)
 ....D:SEGTYPE="MSA"
"RTN","HLOSRVR1",85,0)
 .....N SUBIEN S SUBIEN=HLMSTATE("BATCH","CURRENT MESSAGE")
"RTN","HLOSRVR1",86,0)
 .....S HLMSTATE("BATCH","ACK TO",SUBIEN)=OLDMSGID
"RTN","HLOSRVR1",87,0)
 .....S HLMSTATE("BATCH","ACK TO",SUBIEN,"ACK BY")=NEWMSGID
"RTN","HLOSRVR1",88,0)
 .....S HLMSTATE("BATCH","ACK TO",SUBIEN,"STATUS")=$S(CODE="AA":"SU",1:"ER")
"RTN","HLOSRVR1",89,0)
 .....S:$D(IEN) HLMSTATE("BATCH","ACK TO",SUBIEN,"IEN")=IEN
"RTN","HLOSRVR1",90,0)
 ....D ADDSEG^HLOMSG(.HLMSTATE,.SEG)
"RTN","HLOSRVR1",91,0)
 .I HLMSTATE("UNSTORED LINES"),HLCSTATE("MESSAGE ENDED"),$$SAVEMSG^HLOF778(.HLMSTATE)
"RTN","HLOSRVR1",92,0)
 ;
"RTN","HLOSRVR1",93,0)
 I STORE,'HLCSTATE("MESSAGE ENDED") D
"RTN","HLOSRVR1",94,0)
 .;reading failed, don't store
"RTN","HLOSRVR1",95,0)
 .D:HLMSTATE("IEN") DEL778(HLMSTATE("IEN")) D:HLMSTATE("BODY") DEL777(HLMSTATE("BODY"))
"RTN","HLOSRVR1",96,0)
 .S HLMSTATE("IEN")="",HLMSTATE("BODY")=""
"RTN","HLOSRVR1",97,0)
 E  D:STORE
"RTN","HLOSRVR1",98,0)
 .D CHECKMSG(.HLMSTATE)
"RTN","HLOSRVR1",99,0)
 .D ADDAC(.HLMSTATE) ;so future duplicates are detected
"RTN","HLOSRVR1",100,0)
 .D COUNT^HLOSTAT(.HLCSTATE,HLMSTATE("HDR","RECEIVING APPLICATION"),HLMSTATE("HDR","SENDING APPLICATION"),$S(HLMSTATE("BATCH"):"BATCH",1:HLMSTATE("HDR","MESSAGE TYPE")_"~"_HLMSTATE("HDR","EVENT")))
"RTN","HLOSRVR1",101,0)
 ;
"RTN","HLOSRVR1",102,0)
 D:'HLCSTATE("MESSAGE ENDED") CLOSE^HLOT(.HLCSTATE)
"RTN","HLOSRVR1",103,0)
 Q HLCSTATE("MESSAGE ENDED")
"RTN","HLOSRVR1",104,0)
 ;
"RTN","HLOSRVR1",105,0)
ADDAC(HLMSTATE) ;adds the AC xref for duplicates detection
"RTN","HLOSRVR1",106,0)
 ;
"RTN","HLOSRVR1",107,0)
 N FROM
"RTN","HLOSRVR1",108,0)
 S FROM=$S(HLMSTATE("HDR","SENDING FACILITY",2)]"":HLMSTATE("HDR","SENDING FACILITY",2),1:HLMSTATE("HDR","SENDING FACILITY",1))
"RTN","HLOSRVR1",109,0)
 S ^HLB("AC",FROM_HLMSTATE("HDR","SENDING APPLICATION")_HLMSTATE("ID"),HLMSTATE("IEN"))=""
"RTN","HLOSRVR1",110,0)
 Q
"RTN","HLOSRVR1",111,0)
 ;
"RTN","HLOSRVR1",112,0)
DUP(HLMSTATE) ;
"RTN","HLOSRVR1",113,0)
 ;Returns 1 if the message is a duplicate and its ack (if requested) is found, 0 otherwise
"RTN","HLOSRVR1",114,0)
 ;Input:
"RTN","HLOSRVR1",115,0)
 ; HLMSTATE (pass by reference) the message being read
"RTN","HLOSRVR1",116,0)
 ;Output:
"RTN","HLOSRVR1",117,0)
 ;  Function returns 1 if the message is a duplicate, 0 otherwise
"RTN","HLOSRVR1",118,0)
 ;  HLMSTATE (pass by reference) IF the message is a duplicate:
"RTN","HLOSRVR1",119,0)
 ;     returns the prior MSA segment in HLMSTATE("MSA")
"RTN","HLOSRVR1",120,0)
 ;
"RTN","HLOSRVR1",121,0)
 N IEN,FROM,DUP
"RTN","HLOSRVR1",122,0)
 S (IEN,DUP)=0
"RTN","HLOSRVR1",123,0)
 ;
"RTN","HLOSRVR1",124,0)
 ;no way to determine!  Bad header will be rejected
"RTN","HLOSRVR1",125,0)
 Q:(HLMSTATE("ID")="") 0
"RTN","HLOSRVR1",126,0)
 ;
"RTN","HLOSRVR1",127,0)
 S FROM=$S(HLMSTATE("HDR","SENDING FACILITY",2)]"":HLMSTATE("HDR","SENDING FACILITY",2),1:HLMSTATE("HDR","SENDING FACILITY",1))
"RTN","HLOSRVR1",128,0)
 F  S IEN=$O(^HLB("AC",FROM_HLMSTATE("HDR","SENDING APPLICATION")_HLMSTATE("ID"),IEN)) Q:'IEN  D  Q:DUP
"RTN","HLOSRVR1",129,0)
 .I HLMSTATE("HDR","ACCEPT ACK TYPE")="NE" S DUP=1 Q
"RTN","HLOSRVR1",130,0)
 .;need the MSA to return
"RTN","HLOSRVR1",131,0)
 .D  Q
"RTN","HLOSRVR1",132,0)
 ..N NODE
"RTN","HLOSRVR1",133,0)
 ..S NODE=$P($G(^HLB(IEN,4)),"^",3,10)
"RTN","HLOSRVR1",134,0)
 ..S HLMSTATE("MSA",1)=$P(NODE,"|",2)
"RTN","HLOSRVR1",135,0)
 ..Q:$L(HLMSTATE("MSA",1))'=2
"RTN","HLOSRVR1",136,0)
 ..S HLMSTATE("MSA",2)=$P(NODE,"|",3)
"RTN","HLOSRVR1",137,0)
 ..S HLMSTATE("MSA",3)=$P(NODE,"|",4,10)
"RTN","HLOSRVR1",138,0)
 ..S DUP=1
"RTN","HLOSRVR1",139,0)
 ;
"RTN","HLOSRVR1",140,0)
 Q DUP
"RTN","HLOSRVR1",141,0)
 ;
"RTN","HLOSRVR1",142,0)
CHECKMSG(HLMSTATE) ;
"RTN","HLOSRVR1",143,0)
 ;Checks the header & MSA segment, sets HLMSTATE("STATUS","ACTION") if the message needs to be passed, determines if completion status should be set
"RTN","HLOSRVR1",144,0)
 ;Input:
"RTN","HLOSRVR1",145,0)
 ;  HLMSTATE("HDR") - the parsed header segment
"RTN","HLOSRVR1",146,0)
 ;Output:
"RTN","HLOSRVR1",147,0)
 ;  HLMSTATE("STATUS")="ER" if an error is detected
"RTN","HLOSRVR1",148,0)
 ;  HLMSTATE("STATUS","QUEUE") queue to put the message on
"RTN","HLOSRVR1",149,0)
 ;  HLMSTATE("STATUS","ACTION")  <tag^rtn> that is the processing routine for the receiving application
"RTN","HLOSRVR1",150,0)
 ;  HLMSTATE("MSA") - MSA(1)=accept code to be returned, MSA(3)= error txt
"RTN","HLOSRVR1",151,0)
 ;
"RTN","HLOSRVR1",152,0)
 N WANTACK,PASS,ACTION,QUEUE,ERROR
"RTN","HLOSRVR1",153,0)
 M HDR=HLMSTATE("HDR")
"RTN","HLOSRVR1",154,0)
 S ERROR=0
"RTN","HLOSRVR1",155,0)
 I HDR("ACCEPT ACK TYPE")="NE",'HLMSTATE("ORIGINAL MODE") D
"RTN","HLOSRVR1",156,0)
 .S WANTACK=0
"RTN","HLOSRVR1",157,0)
 E  D
"RTN","HLOSRVR1",158,0)
 .S WANTACK=1
"RTN","HLOSRVR1",159,0)
 I HLMSTATE("ORIGINAL MODE") S HLMSTATE("MSA",1)="AE",HLMSTATE("MSA",3)="THIS INTERFACE DOES NOT IMPLEMENT ORIGINAL MODE APPLICATION ACKOWLEDGMENTS",HLMSTATE("STATUS")="ER" Q
"RTN","HLOSRVR1",160,0)
 I $G(HLMSTATE("ACK TO"))="" D  Q:ERROR
"RTN","HLOSRVR1",161,0)
 .;
"RTN","HLOSRVR1",162,0)
 .;** do not immplement the Pass Immediate parameter **
"RTN","HLOSRVR1",163,0)
 .;N IMMEDIATE
"RTN","HLOSRVR1",164,0)
 .;I '$$ACTION^HLOAPP(.HDR,.ACTION,.QUEUE,.IMMEDIATE) S ERROR=1 S:WANTACK HLMSTATE("MSA",1)="CR" S HLMSTATE("MSA",3)="RECEIVING APPLICATION NOT DEFINED",HLMSTATE("STATUS")="ER" Q
"RTN","HLOSRVR1",165,0)
 .;S HLMSTATE("STATUS","ACTION")=$G(ACTION),HLMSTATE("STATUS","QUEUE")=$G(QUEUE),HLMSTATE("STATUS","PASS IMMEDIATE")=$G(IMMEDIATE)
"RTN","HLOSRVR1",166,0)
 .;
"RTN","HLOSRVR1",167,0)
 .I '$$ACTION^HLOAPP(.HDR,.ACTION,.QUEUE) S ERROR=1 S:WANTACK HLMSTATE("MSA",1)="CR" S HLMSTATE("MSA",3)="RECEIVING APPLICATION NOT DEFINED",HLMSTATE("STATUS")="ER" Q
"RTN","HLOSRVR1",168,0)
 .S HLMSTATE("STATUS","ACTION")=$G(ACTION),HLMSTATE("STATUS","QUEUE")=$G(QUEUE)
"RTN","HLOSRVR1",169,0)
 E  D  Q:ERROR  ;this is an app ack
"RTN","HLOSRVR1",170,0)
 .;does the original message exist?
"RTN","HLOSRVR1",171,0)
 .;
"RTN","HLOSRVR1",172,0)
 .;** do not immplement the Pass Immediate parameter **
"RTN","HLOSRVR1",173,0)
 .;N NODE,IMMEDIATE
"RTN","HLOSRVR1",174,0)
 .;
"RTN","HLOSRVR1",175,0)
 .N NODE
"RTN","HLOSRVR1",176,0)
 .S:+$G(HLMSTATE("ACK TO","IEN")) NODE=$G(^HLB(+HLMSTATE("ACK TO","IEN"),0))
"RTN","HLOSRVR1",177,0)
 .I $G(NODE)="" S ERROR=1,HLMSTATE("STATUS")="ER",HLMSTATE("ACK TO","IEN")="" S:WANTACK HLMSTATE("MSA",1)="CE" S HLMSTATE("MSA",3)="INITIAL MESSAGE TO APPLICATION ACKNOWLEDGMENT NOT FOUND" Q
"RTN","HLOSRVR1",178,0)
 .I $P(NODE,"^",7)'="",$P(NODE,"^",7)'=HLMSTATE("ID") S ERROR=1,HLMSTATE("STATUS")="ER",HLMSTATE("ACK TO","IEN")="" S:WANTACK HLMSTATE("MSA",1)="CE" S HLMSTATE("MSA",3)="INITIAL MESSAGE WAS ALREADY ACKED" Q
"RTN","HLOSRVR1",179,0)
 .I ($P(NODE,"^",11)]"") S HLMSTATE("STATUS","ACTION")=$P(NODE,"^",10,11),HLMSTATE("STATUS","QUEUE")=$S($P(NODE,"^",6)]"":$P(NODE,"^",6),1:"DEFAULT")  Q
"RTN","HLOSRVR1",180,0)
 .;processing routine for the app ack wasn't found with the original message, look in the HLO Application Registry
"RTN","HLOSRVR1",181,0)
 .I HLMSTATE("HDR","MESSAGE TYPE")="ACK",HLMSTATE("HDR","EVENT")="" S HDR("EVENT")=$$GETEVENT^HLOCLNT2(+HLMSTATE("ACK TO","IEN"))
"RTN","HLOSRVR1",182,0)
 .;
"RTN","HLOSRVR1",183,0)
 .;** do not immplement the Pass Immediate parameter **
"RTN","HLOSRVR1",184,0)
 .;I $$ACTION^HLOAPP(.HDR,.ACTION,.QUEUE,.IMMEDIATE) S HLMSTATE("STATUS","ACTION")=$G(ACTION),HLMSTATE("STATUS","QUEUE")=$G(QUEUE),HLMSTATE("STATUS","PASS IMMEDIATE")=$G(IMMEDIATE)
"RTN","HLOSRVR1",185,0)
 .;
"RTN","HLOSRVR1",186,0)
 .I $$ACTION^HLOAPP(.HDR,.ACTION,.QUEUE) S HLMSTATE("STATUS","ACTION")=$G(ACTION),HLMSTATE("STATUS","QUEUE")=$G(QUEUE)
"RTN","HLOSRVR1",187,0)
 ;
"RTN","HLOSRVR1",188,0)
 I HDR("PROCESSING ID")'=HLCSTATE("SYSTEM","PROCESSING ID") S:WANTACK HLMSTATE("MSA",1)="CR" S HLMSTATE("STATUS")="ER",HLMSTATE("MSA",3)="SYSTEM PROCESSING ID="_HLCSTATE("SYSTEM","PROCESSING ID") Q
"RTN","HLOSRVR1",189,0)
 ;
"RTN","HLOSRVR1",190,0)
 ;wrong receiving facility?  This is hard to check if the sender is not VistA, because the HL7 standard permits different coding systems to be used. This check is only for DNS or station number.
"RTN","HLOSRVR1",191,0)
 S PASS=0
"RTN","HLOSRVR1",192,0)
 D
"RTN","HLOSRVR1",193,0)
 .;if its an ack to an existing message, don't check the receiving facility
"RTN","HLOSRVR1",194,0)
 .I $G(HLMSTATE("ACK TO"))]"" S PASS=1 Q
"RTN","HLOSRVR1",195,0)
 .I HDR("RECEIVING FACILITY",1)=HLCSTATE("SYSTEM","STATION") S PASS=1 Q
"RTN","HLOSRVR1",196,0)
 .I HDR("RECEIVING FACILITY",3)'="DNS" S PASS=1 Q
"RTN","HLOSRVR1",197,0)
 .I HDR("RECEIVING FACILITY",2)="" S PASS=1 Q
"RTN","HLOSRVR1",198,0)
 .I $P(HDR("RECEIVING FACILITY",2),":")[HLCSTATE("SYSTEM","DOMAIN") S PASS=1 Q
"RTN","HLOSRVR1",199,0)
 .I HLCSTATE("SYSTEM","DOMAIN")[$P(HDR("RECEIVING FACILITY",2),":") S PASS=1 Q
"RTN","HLOSRVR1",200,0)
 I 'PASS S HLMSTATE("STATUS")="ER",HLMSTATE("MSA",3)="RECEIVING FACILITY IS "_HLCSTATE("SYSTEM","DOMAIN") S:WANTACK HLMSTATE("MSA",1)="CE"
"RTN","HLOSRVR1",201,0)
 I PASS,WANTACK S HLMSTATE("MSA",1)="CA"
"RTN","HLOSRVR1",202,0)
 Q
"RTN","HLOSRVR1",203,0)
 ;
"RTN","HLOSRVR1",204,0)
DEL777(IEN777) ;delete a record from file 777 where the read did not complete
"RTN","HLOSRVR1",205,0)
 ;
"RTN","HLOSRVR1",206,0)
 K ^HLA(IEN777,0)
"RTN","HLOSRVR1",207,0)
 Q
"RTN","HLOSRVR1",208,0)
DEL778(IEN778) ;delete a record from file 778 where the read did not complete
"RTN","HLOSRVR1",209,0)
 ;
"RTN","HLOSRVR1",210,0)
 K ^HLB(IEN778,0)
"RTN","HLOSRVR1",211,0)
 Q
"RTN","HLOSRVR1",212,0)
 ;
"RTN","HLOSRVR1",213,0)
SPLITHDR(HDR) ;
"RTN","HLOSRVR1",214,0)
 ;splits hdr segment into two lines, first being just components 1-6
"RTN","HLOSRVR1",215,0)
 ;
"RTN","HLOSRVR1",216,0)
 N TEMP,FS
"RTN","HLOSRVR1",217,0)
 D SQUISH(.HDR)
"RTN","HLOSRVR1",218,0)
 S FS=$E($G(HDR(1)),4)
"RTN","HLOSRVR1",219,0)
 S TEMP(1)=$P($G(HDR(1)),FS,1,6)
"RTN","HLOSRVR1",220,0)
 S TEMP(2)=""
"RTN","HLOSRVR1",221,0)
 I $L(TEMP(1))<$L($G(HDR(1))) S TEMP(2)=FS_$P($G(HDR(1)),FS,7,20)
"RTN","HLOSRVR1",222,0)
 S HDR(2)=TEMP(2)_$G(HDR(2))
"RTN","HLOSRVR1",223,0)
 S HDR(1)=TEMP(1)
"RTN","HLOSRVR1",224,0)
 Q
"RTN","HLOSRVR1",225,0)
 ;
"RTN","HLOSRVR1",226,0)
SQUISH(SEG) ;
"RTN","HLOSRVR1",227,0)
 ;reformat the segment array into full lines
"RTN","HLOSRVR1",228,0)
 ;
"RTN","HLOSRVR1",229,0)
 ;nothing to do if less than 2 lines
"RTN","HLOSRVR1",230,0)
 Q:'$O(SEG(1))
"RTN","HLOSRVR1",231,0)
 ;
"RTN","HLOSRVR1",232,0)
 N A,I,J,K,MAX,COUNT,LEN
"RTN","HLOSRVR1",233,0)
 S MAX=$S($G(HLCSTATE("SYSTEM","MAXSTRING"))>256:HLCSTATE("SYSTEM","MAXSTRING"),1:256)
"RTN","HLOSRVR1",234,0)
 S (COUNT,I)=0,J=1
"RTN","HLOSRVR1",235,0)
 F  S I=$O(SEG(I)) Q:'I  D
"RTN","HLOSRVR1",236,0)
 .S LEN=$L(SEG(I))
"RTN","HLOSRVR1",237,0)
 .F K=1:1:LEN D
"RTN","HLOSRVR1",238,0)
 ..S A(J)=$G(A(J))_$E(SEG(I),K)
"RTN","HLOSRVR1",239,0)
 ..S COUNT=COUNT+1
"RTN","HLOSRVR1",240,0)
 ..I (COUNT>(MAX-1)) S COUNT=0,J=J+1
"RTN","HLOSRVR1",241,0)
 K SEG
"RTN","HLOSRVR1",242,0)
 M SEG=A
"RTN","HLOSRVR1",243,0)
 Q
"RTN","HLOUSR1")
0^8^B106022744^B105211577
"RTN","HLOUSR1",1,0)
HLOUSR1 ;ALB/CJM/OAK/PIJ -ListManager Screen for viewing messages;12 JUN 1997 10:00 am ;06/19/2009
"RTN","HLOUSR1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,134,137,138,143**;Oct 13, 1995;Build 3
"RTN","HLOUSR1",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOUSR1",4,0)
 ;
"RTN","HLOUSR1",5,0)
EN ;
"RTN","HLOUSR1",6,0)
 N MSGIEN,SEGS
"RTN","HLOUSR1",7,0)
 S MSGIEN=$$PICKMSG
"RTN","HLOUSR1",8,0)
 I 'MSGIEN S VALMBCK="R" Q
"RTN","HLOUSR1",9,0)
 D EN^VALM("HLO SINGLE MESSAGE DISPLAY")
"RTN","HLOUSR1",10,0)
 Q
"RTN","HLOUSR1",11,0)
 ;
"RTN","HLOUSR1",12,0)
HDR ;
"RTN","HLOUSR1",13,0)
 ;
"RTN","HLOUSR1",14,0)
 Q
"RTN","HLOUSR1",15,0)
 ;
"RTN","HLOUSR1",16,0)
BLANK ;
"RTN","HLOUSR1",17,0)
 S VALMCNT=0
"RTN","HLOUSR1",18,0)
 D EXIT
"RTN","HLOUSR1",19,0)
 Q
"RTN","HLOUSR1",20,0)
DISPLAY ;
"RTN","HLOUSR1",21,0)
 K @VALMAR
"RTN","HLOUSR1",22,0)
 S VALMBCK="R"
"RTN","HLOUSR1",23,0)
 N MSG
"RTN","HLOUSR1",24,0)
 S VALMBG=1
"RTN","HLOUSR1",25,0)
 Q:'MSGIEN
"RTN","HLOUSR1",26,0)
 D SHOWMSG($P(MSGIEN,"^"),$P(MSGIEN,"^",2))
"RTN","HLOUSR1",27,0)
 Q
"RTN","HLOUSR1",28,0)
 ;
"RTN","HLOUSR1",29,0)
PICKMSG(DEFAULT) ;
"RTN","HLOUSR1",30,0)
 ;ask the user to select a message & return its ien
"RTN","HLOUSR1",31,0)
 ;Input: DEFAULT (optional) message id to display to user as default
"RTN","HLOUSR1",32,0)
 N MSGIEN,DIR,COUNT,LIST
"RTN","HLOUSR1",33,0)
 D FULL^VALM1
"RTN","HLOUSR1",34,0)
 S DIR(0)="F3:30"
"RTN","HLOUSR1",35,0)
 S DIR("A")="Message ID"
"RTN","HLOUSR1",36,0)
 S:$L($G(DEFAULT)) DIR("B")=DEFAULT
"RTN","HLOUSR1",37,0)
 S DIR("?")="Enter the full Message Control ID or Batch Control ID of the message, or '^' to exit."
"RTN","HLOUSR1",38,0)
PICK D ^DIR
"RTN","HLOUSR1",39,0)
 I $D(DIRUT)!(Y="") Q 0
"RTN","HLOUSR1",40,0)
 I $G(@VALMAR@("INDEX",Y)) Q $G(@VALMAR@("INDEX",Y))
"RTN","HLOUSR1",41,0)
 S COUNT=$$FINDMSG^HLOMSG1(Y,.LIST)
"RTN","HLOUSR1",42,0)
 I COUNT="0" W !!,"That message can not be found! Try Again",! G PICK
"RTN","HLOUSR1",43,0)
 I COUNT=1 Q LIST(1)
"RTN","HLOUSR1",44,0)
 I COUNT>1 D
"RTN","HLOUSR1",45,0)
 .N ITEM
"RTN","HLOUSR1",46,0)
 .W !,"There is more than one message with that ID! You must choose one to display.",1
"RTN","HLOUSR1",47,0)
 .S ITEM=0
"RTN","HLOUSR1",48,0)
 .F  S ITEM=$O(LIST(ITEM)) Q:'ITEM  D
"RTN","HLOUSR1",49,0)
 ..N MSG
"RTN","HLOUSR1",50,0)
 ..Q:'$$GETMSG^HLOMSG(+LIST(ITEM),.MSG)
"RTN","HLOUSR1",51,0)
 ..W !,"[",ITEM,"]","  DT/TM: ",$$FMTE^XLFDT(MSG("DT/TM CREATED"),2),"   STATUS: ",MSG("STATUS")
"RTN","HLOUSR1",52,0)
 .S DIR(0)="NO^1:"_COUNT,DIR("A")="Choose",DIR("?")="Choose one message from the list"
"RTN","HLOUSR1",53,0)
 .D ^DIR
"RTN","HLOUSR1",54,0)
 .I Y S Y=LIST(Y)
"RTN","HLOUSR1",55,0)
 Q Y
"RTN","HLOUSR1",56,0)
 ;
"RTN","HLOUSR1",57,0)
HELP ;Help code
"RTN","HLOUSR1",58,0)
 S X="?" D DISP^XQORM1 W !!
"RTN","HLOUSR1",59,0)
 Q
"RTN","HLOUSR1",60,0)
 ;
"RTN","HLOUSR1",61,0)
EXIT ;Exit code
"RTN","HLOUSR1",62,0)
 D CLEAN^VALM10
"RTN","HLOUSR1",63,0)
 D CLEAR^VALM1
"RTN","HLOUSR1",64,0)
 S VALMBCK="R"
"RTN","HLOUSR1",65,0)
 ;
"RTN","HLOUSR1",66,0)
 Q
"RTN","HLOUSR1",67,0)
 ;
"RTN","HLOUSR1",68,0)
EXPND ;Expand code
"RTN","HLOUSR1",69,0)
 Q
"RTN","HLOUSR1",70,0)
 ;
"RTN","HLOUSR1",71,0)
CJ(STRING,LEN) ;
"RTN","HLOUSR1",72,0)
 Q $$CJ^XLFSTR(STRING,LEN)
"RTN","HLOUSR1",73,0)
LJ(STRING,LEN) ;
"RTN","HLOUSR1",74,0)
 Q $$LJ^XLFSTR(STRING,LEN)
"RTN","HLOUSR1",75,0)
SP(LEN,CHAR) ;
"RTN","HLOUSR1",76,0)
 ;return padding - " " is the default pad character
"RTN","HLOUSR1",77,0)
 N STR
"RTN","HLOUSR1",78,0)
 S:$G(CHAR)="" CHAR=" "
"RTN","HLOUSR1",79,0)
 S $P(STR,CHAR,LEN)=CHAR
"RTN","HLOUSR1",80,0)
 Q STR
"RTN","HLOUSR1",81,0)
 ;
"RTN","HLOUSR1",82,0)
SHOWMSG(MSGIEN,SUBIEN) ;
"RTN","HLOUSR1",83,0)
 ;Description:
"RTN","HLOUSR1",84,0)
 ;
"RTN","HLOUSR1",85,0)
 ;Input:
"RTN","HLOUSR1",86,0)
 ;Output:
"RTN","HLOUSR1",87,0)
 ;
"RTN","HLOUSR1",88,0)
 N MSG,I,TEMP,LINE,HDR,TRIES,STATUS
"RTN","HLOUSR1",89,0)
 S VALMCNT=0
"RTN","HLOUSR1",90,0)
 S SUBIEN=+$G(SUBIEN)
"RTN","HLOUSR1",91,0)
 I '$$GETMSG^HLOMSG(MSGIEN,.MSG) W !,"UNABLE TO DISPLAY THE MESSAGE",!! Q
"RTN","HLOUSR1",92,0)
 I SUBIEN S STATUS=MSG("STATUS") D GETMSGB^HLOMSG1(.MSG,SUBIEN,.MSG) I MSG("STATUS")="" S MSG("STATUS")=STATUS
"RTN","HLOUSR1",93,0)
 S HDR(1)=MSG("HDR",1),HDR(2)=MSG("HDR",2)
"RTN","HLOUSR1",94,0)
 I $$PARSEHDR^HLOPRS(.HDR)
"RTN","HLOUSR1",95,0)
 S I=0
"RTN","HLOUSR1",96,0)
 ;** administrative information **
"RTN","HLOUSR1",97,0)
 S @VALMAR@($$I,0)=$$CJ("Administrative Information",80)
"RTN","HLOUSR1",98,0)
 D CNTRL^VALM10(VALMCNT,26,30,IORVON,IORVOFF)
"RTN","HLOUSR1",99,0)
 ;; ***patch HL*1.6*138 start
"RTN","HLOUSR1",100,0)
 S LINE="MsgID: "_$$LJ(MSG("ID"),18) ;;
"RTN","HLOUSR1",101,0)
 S:MSG("ACK TO")]"" LINE=LINE_$$LJ(" Application Ack To:",26)_MSG("ACK TO") ;;
"RTN","HLOUSR1",102,0)
 S:MSG("ACK BY")]"" LINE=LINE_$$LJ(" Application Ack'd By:",26)_MSG("ACK BY") ;;
"RTN","HLOUSR1",103,0)
 S @VALMAR@($$I,0)=LINE ;;
"RTN","HLOUSR1",104,0)
 ;;
"RTN","HLOUSR1",105,0)
 S LINE=""
"RTN","HLOUSR1",106,0)
 S:MSG("DIRECTION")="OUT" TRIES=$G(^HLB(MSGIEN,"TRIES"))
"RTN","HLOUSR1",107,0)
 ;
"RTN","HLOUSR1",108,0)
 ;determine current status - as opposed to final status
"RTN","HLOUSR1",109,0)
 D
"RTN","HLOUSR1",110,0)
 .I MSG("STATUS")="SU" S MSG("STATUS")="SUCCESSFUL" Q
"RTN","HLOUSR1",111,0)
 .I MSG("STATUS")="ER" S MSG("STATUS")="ERROR" Q
"RTN","HLOUSR1",112,0)
 .I MSG("DIRECTION")="IN" D  Q
"RTN","HLOUSR1",113,0)
 ..I '$G(MSG("STATUS","APP HANDOFF")) S MSG("STATUS")="PENDING ON RECEIVING APPLICATION" Q
"RTN","HLOUSR1",114,0)
 .I MSG("DIRECTION")="OUT" D  Q
"RTN","HLOUSR1",115,0)
 ..I MSG("DT/TM")="" D  Q
"RTN","HLOUSR1",116,0)
 ...I $O(^HLB("QUEUE","OUT",MSG("STATUS","LINK NAME")_":"_MSG("STATUS","PORT"),MSG("STATUS","QUEUE"),0))=MSG("IEN") S MSG("STATUS")="TRANSMISSION IN PROGRESS" Q
"RTN","HLOUSR1",117,0)
 ...S MSG("STATUS")="PENDING ON OUTGOING QUEUE" Q
"RTN","HLOUSR1",118,0)
 ..I $G(HDR("APP ACK TYPE"))="AL",'$G(MSG("STATUS","APP ACK'D")),$G(MSG("ACK BY"))="" S MSG("STATUS")="TRANSMITTED, PENDING RECEIPT OF APPLICATION ACKNOWLEDGEMENT" Q
"RTN","HLOUSR1",119,0)
 ;; ***patch HL*1.6*138 end
"RTN","HLOUSR1",120,0)
 ;
"RTN","HLOUSR1",121,0)
 S LINE="Status: "_$$LJ(MSG("STATUS"),79)
"RTN","HLOUSR1",122,0)
 S @VALMAR@($$I,0)=LINE
"RTN","HLOUSR1",123,0)
 I MSG("STATUS","ERROR TEXT")]"" S @VALMAR@($$I,0)="Error: "_"** "_MSG("STATUS","ERROR TEXT")_" **"
"RTN","HLOUSR1",124,0)
 ;;**138 start cjm
"RTN","HLOUSR1",125,0)
 ;S @VALMAR@($$I,0)="Dir:   "_$$LJ($S(MSG("DIRECTION")="IN":"INCOMING",1:"OUTGOING"),10)_$$LJ("  Trans Dt/Tm: ",12)_$$FMTE^XLFDT(MSG("DT/TM"),2)_$$LJ("  Purge DT/TM: ",8)_$$FMTE^XLFDT(MSG("STATUS","PURGE"),2)
"RTN","HLOUSR1",126,0)
 S @VALMAR@($$I,0)="Direction: "_$$LJ($S(MSG("DIRECTION")="IN":"IN",1:"OUT"),4)_$$LJ("  TransDt/Tm"_$S($G(TRIES):"("_TRIES_"x): ",1:": "),12)_$$FMTE^XLFDT(MSG("DT/TM"),2)_$$LJ("  Purge DT/TM: ",8)_$$FMTE^XLFDT(MSG("STATUS","PURGE"),2)
"RTN","HLOUSR1",127,0)
 ;** 138 end cjm
"RTN","HLOUSR1",128,0)
 S @VALMAR@($$I,0)="Link:  "_$$LJ(MSG("STATUS","LINK NAME"),29)_"   "_$$LJ("Queue: ",13)_MSG("STATUS","QUEUE")
"RTN","HLOUSR1",129,0)
 I $L($G(MSG("STATUS","SEQUENCE QUEUE"))) D
"RTN","HLOUSR1",130,0)
 .S @VALMAR@($$I,0)="Sequence Queue: "_MSG("STATUS","SEQUENCE QUEUE")_"    Moved: "_$S(MSG("STATUS","MOVED TO OUT QUEUE"):"YES",1:"NO")
"RTN","HLOUSR1",131,0)
 I MSG("STATUS","ACCEPT ACK'D") D
"RTN","HLOUSR1",132,0)
 .S @VALMAR@($$I,0)="Accept Ack: "_$$LJ(MSG("STATUS","ACCEPT ACK ID"),26)_$$LJ(" DT/TM Ack'd: ",14)_$$FMTE^XLFDT(MSG("STATUS","ACCEPT ACK DT/TM"),2)
"RTN","HLOUSR1",133,0)
 .S @VALMAR@($$I,0)="   "_MSG("STATUS","ACCEPT ACK MSA")
"RTN","HLOUSR1",134,0)
 I MSG("DIRECTION")="IN" D
"RTN","HLOUSR1",135,0)
 .S LINE="App Response Rtn: "
"RTN","HLOUSR1",136,0)
 .;START HL*1.6*138 CJM
"RTN","HLOUSR1",137,0)
 .;I $L($G(MSG("STATUS","APP ACK RESPONSE"))) S LINE=$$LJ(LINE_MSG("STATUS","APP ACK RESPONSE"),38)_" Executed: "_$S(MSG("STATUS","APP HANDOFF"):"   YES",1:"   NO")
"RTN","HLOUSR1",138,0)
 .S LINE=$$LJ(LINE_$S($L($G(MSG("STATUS","ACTION"))):MSG("STATUS","ACTION"),1:"n/a"),38)_" Executed: "_$S('$L($G(MSG("STATUS","ACTION"))):"n/a",MSG("STATUS","APP HANDOFF"):"   YES",1:"   NO")
"RTN","HLOUSR1",139,0)
 .;;END HL*1.6*138 CJM
"RTN","HLOUSR1",140,0)
 .S @VALMAR@($$I,0)=LINE
"RTN","HLOUSR1",141,0)
 I MSG("DIRECTION")="OUT",(MSG("STATUS","APP ACK'D")!MSG("STATUS","ACCEPT ACK'D")) D
"RTN","HLOUSR1",142,0)
 .S LINE=""
"RTN","HLOUSR1",143,0)
 .I MSG("STATUS","ACCEPT ACK'D") D
"RTN","HLOUSR1",144,0)
 ..I MSG("STATUS","ACCEPT ACK RESPONSE")="" S MSG("STATUS","ACCEPT ACK RESPONSE")="n/a"
"RTN","HLOUSR1",145,0)
 ..S LINE="Accept Ack Rtn: "_MSG("STATUS","ACCEPT ACK RESPONSE")
"RTN","HLOUSR1",146,0)
 .S LINE=$$LJ(LINE,39)
"RTN","HLOUSR1",147,0)
 .I MSG("STATUS","APP ACK'D") D
"RTN","HLOUSR1",148,0)
 ..I MSG("STATUS","APP ACK RESPONSE")="" S MSG("STATUS","APP ACK RESPONSE")="n/a"
"RTN","HLOUSR1",149,0)
 ..S LINE=LINE_"App Ack Rtn: "_MSG("STATUS","APP ACK RESPONSE")
"RTN","HLOUSR1",150,0)
 .S @VALMAR@($$I,0)=LINE
"RTN","HLOUSR1",151,0)
 ;
"RTN","HLOUSR1",152,0)
 ;** the message text **
"RTN","HLOUSR1",153,0)
 S @VALMAR@($$I,0)=""
"RTN","HLOUSR1",154,0)
 I '$G(SUBIEN) D
"RTN","HLOUSR1",155,0)
 .S @VALMAR@($$I,0)=$$CJ("Message Text",80)
"RTN","HLOUSR1",156,0)
 .D CNTRL^VALM10(VALMCNT,33,16,IORVON,IORVOFF)
"RTN","HLOUSR1",157,0)
 E  D
"RTN","HLOUSR1",158,0)
 .S @VALMAR@($$I,0)=$$CJ("Individual Message Text (Batched)",80)
"RTN","HLOUSR1",159,0)
 .D CNTRL^VALM10(VALMCNT,23,35,IORVON,IORVOFF)
"RTN","HLOUSR1",160,0)
 ;; START 138
"RTN","HLOUSR1",161,0)
 ;D SHOWBODY(.MSG,$G(SUBIEN))
"RTN","HLOUSR1",162,0)
 D SHOWBODY(.MSG,$G(SUBIEN),.SEGS)
"RTN","HLOUSR1",163,0)
 ;; END 138
"RTN","HLOUSR1",164,0)
 ;
"RTN","HLOUSR1",165,0)
 ;** display its application acknowledgment **
"RTN","HLOUSR1",166,0)
 ;**P143 START CJM
"RTN","HLOUSR1",167,0)
 ;I MSG("ACK BY")]"",$$FINDMSG^HLOMSG1(MSG("ACK BY"),.TEMP)=1 S MSGIEN=TEMP(1) D
"RTN","HLOUSR1",168,0)
 I $G(MSG("ACK BY IEN")) S MSGIEN=MSG("ACK BY IEN") D
"RTN","HLOUSR1",169,0)
 .;**P143 END CJM
"RTN","HLOUSR1",170,0)
 .N MSG,STATUS
"RTN","HLOUSR1",171,0)
 .Q:'$$GETMSG^HLOMSG(+MSGIEN,.MSG)
"RTN","HLOUSR1",172,0)
 .I $P(MSGIEN,"^",2) S STATUS=MSG("STATUS") D GETMSGB^HLOMSG1(.MSG,SUBIEN,.MSG) I MSG("STATUS")="" S MSG("STATUS")=STATUS
"RTN","HLOUSR1",173,0)
 .S @VALMAR@($$I,0)=""
"RTN","HLOUSR1",174,0)
 .S @VALMAR@($$I,0)=$$CJ("Application Acknowledgment",80)
"RTN","HLOUSR1",175,0)
 .D CNTRL^VALM10(VALMCNT,26,30,IORVON,IORVOFF)
"RTN","HLOUSR1",176,0)
 .D SHOWBODY(.MSG,$P(MSGIEN,"^",2))
"RTN","HLOUSR1",177,0)
 ;
"RTN","HLOUSR1",178,0)
 ;** display the original message **
"RTN","HLOUSR1",179,0)
 ;**P143 START CJM
"RTN","HLOUSR1",180,0)
 ;I MSG("ACK TO")]"",$$FINDMSG^HLOMSG1(MSG("ACK TO"),.TEMP)=1 S MSGIEN=TEMP(1) D
"RTN","HLOUSR1",181,0)
 I $G(MSG("ACK TO IEN")) S MSGIEN=MSG("ACK TO IEN") D
"RTN","HLOUSR1",182,0)
 .;**P143 END CJM
"RTN","HLOUSR1",183,0)
 .N MSG
"RTN","HLOUSR1",184,0)
 .Q:'$$GETMSG^HLOMSG(+MSGIEN,.MSG)
"RTN","HLOUSR1",185,0)
 .I $P(MSGIEN,"^",2) S STATUS=MSG("STATUS") D GETMSGB^HLOMSG1(.MSG,SUBIEN,.MSG) I MSG("STATUS")="" S MSG("STATUS")=STATUS
"RTN","HLOUSR1",186,0)
 .S @VALMAR@($$I,0)=""
"RTN","HLOUSR1",187,0)
 .S @VALMAR@($$I,0)=$$CJ("Original Message",80)
"RTN","HLOUSR1",188,0)
 .D CNTRL^VALM10(VALMCNT,26,30,IORVON,IORVOFF)
"RTN","HLOUSR1",189,0)
 .D SHOWBODY(.MSG,$P(MSGIEN,"^",2))
"RTN","HLOUSR1",190,0)
 Q
"RTN","HLOUSR1",191,0)
 ;
"RTN","HLOUSR1",192,0)
SHOWBODY(MSG,SUBIEN,SEGS) ;
"RTN","HLOUSR1",193,0)
 N NODE,I,SEG,QUIT
"RTN","HLOUSR1",194,0)
 S QUIT=0
"RTN","HLOUSR1",195,0)
 S SEGS("ARY")=VALMAR
"RTN","HLOUSR1",196,0)
 S SEGS("TOP")=VALMCNT+1
"RTN","HLOUSR1",197,0)
 M SEG=MSG("HDR")
"RTN","HLOUSR1",198,0)
 D ADD(.SEG,.SEGS)
"RTN","HLOUSR1",199,0)
 S MSG("BATCH","CURRENT MESSAGE")=0
"RTN","HLOUSR1",200,0)
 I MSG("BATCH") D
"RTN","HLOUSR1",201,0)
 .I $G(SUBIEN) D  Q
"RTN","HLOUSR1",202,0)
 ..S MSG("BATCH","CURRENT MESSAGE")=SUBIEN
"RTN","HLOUSR1",203,0)
 ..F  Q:'$$HLNEXT^HLOMSG(.MSG,.SEG)  D ADD(.SEG,.SEGS)
"RTN","HLOUSR1",204,0)
 .S MSG("BATCH","CURRENT MESSAGE")=0
"RTN","HLOUSR1",205,0)
 .N LAST S LAST=0
"RTN","HLOUSR1",206,0)
 .F  Q:'$$NEXTMSG^HLOMSG(.MSG,.SEG)  D  Q:QUIT
"RTN","HLOUSR1",207,0)
 ..D ADD(.SEG,.SEGS)
"RTN","HLOUSR1",208,0)
 ..S LAST=MSG("BATCH","CURRENT MESSAGE")
"RTN","HLOUSR1",209,0)
 ..F  Q:'$$HLNEXT^HLOMSG(.MSG,.SEG)  D ADD(.SEG,.SEGS)
"RTN","HLOUSR1",210,0)
 .I MSG("DIRECTION")="OUT" K SEG S SEG(1)="BTS"_$E($G(MSG("HDR",1)),4)_LAST D ADD(.SEG,.SEGS)
"RTN","HLOUSR1",211,0)
 .;
"RTN","HLOUSR1",212,0)
 E  D
"RTN","HLOUSR1",213,0)
 .F  Q:'$$HLNEXT^HLOMSG(.MSG,.SEG)  D  Q:QUIT
"RTN","HLOUSR1",214,0)
 ..D ADD(.SEG,.SEGS)
"RTN","HLOUSR1",215,0)
 S SEGS("BOT")=VALMCNT
"RTN","HLOUSR1",216,0)
 Q
"RTN","HLOUSR1",217,0)
I() ;
"RTN","HLOUSR1",218,0)
 S VALMCNT=VALMCNT+1
"RTN","HLOUSR1",219,0)
 Q VALMCNT
"RTN","HLOUSR1",220,0)
ADD(SEG,SEGS) ;
"RTN","HLOUSR1",221,0)
 N QUIT,I,J,LINE
"RTN","HLOUSR1",222,0)
 S QUIT=0
"RTN","HLOUSR1",223,0)
 S SEGS=$G(SEGS)+1
"RTN","HLOUSR1",224,0)
 S (I,J)=1
"RTN","HLOUSR1",225,0)
 S LINE(1)=$E(SEG(1),1,80),SEG(1)=$E(SEG(1),81,9999)
"RTN","HLOUSR1",226,0)
 I SEG(1)="" K SEG(1)
"RTN","HLOUSR1",227,0)
 D SHIFT(.I,.J)
"RTN","HLOUSR1",228,0)
 S @VALMAR@($$I,0)=LINE(1)
"RTN","HLOUSR1",229,0)
 ;; START 138
"RTN","HLOUSR1",230,0)
 D CNTRL^VALM10(VALMCNT,1,3,IOINHI,IOINORM)
"RTN","HLOUSR1",231,0)
 ;;END 138
"RTN","HLOUSR1",232,0)
 S SEGS(SEGS)=VALMCNT
"RTN","HLOUSR1",233,0)
 S I=1
"RTN","HLOUSR1",234,0)
 F  S I=$O(LINE(I)) Q:'I  D
"RTN","HLOUSR1",235,0)
 .S @VALMAR@($$I,0)=LINE(I)
"RTN","HLOUSR1",236,0)
 .;;START 138
"RTN","HLOUSR1",237,0)
 .;D CNTRL^VALM10(VALMCNT,1,1,IORVON,IORVOFF)
"RTN","HLOUSR1",238,0)
 .;END 138
"RTN","HLOUSR1",239,0)
 Q
"RTN","HLOUSR1",240,0)
 ;
"RTN","HLOUSR1",241,0)
SHIFT(I,J) ;
"RTN","HLOUSR1",242,0)
 I '$D(SEG(I)) S I=$O(SEG(0)) Q:'I
"RTN","HLOUSR1",243,0)
 I $L(LINE(J))<80 D
"RTN","HLOUSR1",244,0)
 .N LEN
"RTN","HLOUSR1",245,0)
 .S LEN=$L(LINE(J))
"RTN","HLOUSR1",246,0)
 .S LINE(J)=LINE(J)_$E(SEG(I),1,80-LEN)
"RTN","HLOUSR1",247,0)
 .S SEG(I)=$E(SEG(I),81-LEN,9999)
"RTN","HLOUSR1",248,0)
 .I SEG(I)="" K SEG(I)
"RTN","HLOUSR1",249,0)
 E  D
"RTN","HLOUSR1",250,0)
 .S J=J+1
"RTN","HLOUSR1",251,0)
 .S LINE(J)=""
"RTN","HLOUSR1",252,0)
 D SHIFT(.I,.J)
"RTN","HLOUSR1",253,0)
 Q
"RTN","HLOUSR1",254,0)
 ;
"RTN","HLOUSR1",255,0)
SCRLMODE ;scroll mode
"RTN","HLOUSR1",256,0)
 Q:'$L(HLRFRSH)
"RTN","HLOUSR1",257,0)
 N QUIT,IOTM,IOBM,DX,DY,LINE,IOTM,IOBM
"RTN","HLOUSR1",258,0)
 W !!,IOINHI,"Hit any key to escape scroll mode...",IOINORM
"RTN","HLOUSR1",259,0)
 S IOTM=3,IOBM=23
"RTN","HLOUSR1",260,0)
 S QUIT=0
"RTN","HLOUSR1",261,0)
 S LINE=$S(VALMCNT<17:1,1:17)
"RTN","HLOUSR1",262,0)
 W @IOSTBM
"RTN","HLOUSR1",263,0)
 S DX=1,DY=$S(VALMCNT<17:VALMCNT+1,1:17) X IOXY
"RTN","HLOUSR1",264,0)
 F I=1:1 D  Q:QUIT
"RTN","HLOUSR1",265,0)
 .;every 10 seconds refresh the data
"RTN","HLOUSR1",266,0)
 .I I>42 D @HLRFRSH S I=0
"RTN","HLOUSR1",267,0)
 .I LINE+1>VALMCNT D
"RTN","HLOUSR1",268,0)
 ..S TEMP=$G(@VALMAR@(LINE,0))
"RTN","HLOUSR1",269,0)
 ..W !,IOUON,TEMP_$$SP(80-$L(TEMP)),IOUOFF
"RTN","HLOUSR1",270,0)
 .E  W !,$G(@VALMAR@(LINE,0))
"RTN","HLOUSR1",271,0)
 .S LINE=LINE+1
"RTN","HLOUSR1",272,0)
 .I LINE>VALMCNT S LINE=1
"RTN","HLOUSR1",273,0)
 .I (I=22)!(I=43) R *C:5 I $T S QUIT=1 Q
"RTN","HLOUSR1",274,0)
 S VALMBG=LINE-23 I VALMBG<0 S VALMBG=1
"RTN","HLOUSR1",275,0)
 S VALMBCK="R"
"RTN","HLOUSR1",276,0)
 Q
"RTN","HLOUSR1",277,0)
HLP ;
"RTN","HLOUSR1",278,0)
 Q
"RTN","HLOUSR1",279,0)
 ;
"RTN","HLOUSR1",280,0)
IFOPEN(LINK) ;
"RTN","HLOUSR1",281,0)
 ;returns 1 if the link can be opened, otherwise 0
"RTN","HLOUSR1",282,0)
 ;
"RTN","HLOUSR1",283,0)
 ;Inputs:
"RTN","HLOUSR1",284,0)
 ;  LINK - name of the link (required), optionally post-fixed with ":"_<port #>, will default to that defined for link
"RTN","HLOUSR1",285,0)
 ;
"RTN","HLOUSR1",286,0)
 N LINKNAME,LINKARY,POP,IO,IOF,IOST,OPEN,PORT
"RTN","HLOUSR1",287,0)
 S OPEN=0
"RTN","HLOUSR1",288,0)
 S LINKNAME=$P(LINK,":")
"RTN","HLOUSR1",289,0)
 S PORT=$P(LINK,":",2)
"RTN","HLOUSR1",290,0)
 Q:LINKNAME="" 0
"RTN","HLOUSR1",291,0)
 Q:'$$GETLINK^HLOTLNK(LINKNAME,.LINKARY) 0
"RTN","HLOUSR1",292,0)
 S:PORT LINKARY("PORT")=PORT
"RTN","HLOUSR1",293,0)
 Q:'$G(LINKARY("PORT")) 0
"RTN","HLOUSR1",294,0)
 I LINKARY("IP")="",LINKARY("DOMAIN")="",LINKARY("LLP")="TCP",LINKARY("SERVER") D
"RTN","HLOUSR1",295,0)
 .N DATA
"RTN","HLOUSR1",296,0)
 .S LINKARY("DOMAIN")=$P($G(^HLD(779.1,1,0)),"^")
"RTN","HLOUSR1",297,0)
 .Q:LINKARY("DOMAIN")=""
"RTN","HLOUSR1",298,0)
 .S DATA(.08)=LINKARY("DOMAIN")
"RTN","HLOUSR1",299,0)
 .Q:$$UPD^HLOASUB1(870,LINKARY("IEN"),.DATA)
"RTN","HLOUSR1",300,0)
 D:$G(LINKARY("IP"))'=""
"RTN","HLOUSR1",301,0)
 .D CALL^%ZISTCP(LINKARY("IP"),LINKARY("PORT"),15)
"RTN","HLOUSR1",302,0)
 .S OPEN='POP
"RTN","HLOUSR1",303,0)
 I 'OPEN,LINKARY("DOMAIN")'="",$G(^HLTMP("DNS LAST",LINKARY("IEN")))<$$DT^XLFDT D
"RTN","HLOUSR1",304,0)
 .N IP
"RTN","HLOUSR1",305,0)
 .S ^HLTMP("DNS LAST",LINKARY("IEN"))=$$DT^XLFDT
"RTN","HLOUSR1",306,0)
 .S IP=$$DNS^HLOTCP(LINKARY("DOMAIN"))
"RTN","HLOUSR1",307,0)
 .I IP'="",IP'=LINKARY("IP") D
"RTN","HLOUSR1",308,0)
 ..N DATA
"RTN","HLOUSR1",309,0)
 ..S DATA(400.01)=IP,LINKARY("IP")=IP
"RTN","HLOUSR1",310,0)
 ..Q:$$UPD^HLOASUB1(870,LINKARY("IEN"),.DATA)
"RTN","HLOUSR1",311,0)
 ..D CALL^%ZISTCP(LINKARY("IP"),LINKARY("PORT"),15)
"RTN","HLOUSR1",312,0)
 ..S OPEN='POP
"RTN","HLOUSR1",313,0)
 C:OPEN IO
"RTN","HLOUSR1",314,0)
 ;D CLOSE^%ZISTCP
"RTN","HLOUSR1",315,0)
 Q OPEN
"VER")
8.0^22.0
"BLD",1272,6)
^116
**END**
**END**
