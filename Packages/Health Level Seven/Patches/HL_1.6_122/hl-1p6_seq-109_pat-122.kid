Released HL*1.6*122 SEQ #109
Extracted from mail message
**KIDS**:HL*1.6*122^

**INSTALL NAME**
HL*1.6*122
"BLD",965,0)
HL*1.6*122^HEALTH LEVEL SEVEN^0^3071214^y
"BLD",965,4,0)
^9.64PA^773^4
"BLD",965,4,772,0)
772
"BLD",965,4,772,2,0)
^9.641^772^1
"BLD",965,4,772,2,772,0)
HL7 MESSAGE TEXT  (File-top level)
"BLD",965,4,772,2,772,1,0)
^9.6411^6^1
"BLD",965,4,772,2,772,1,6,0)
MESSAGE ID
"BLD",965,4,772,222)
y^n^p^^^^n^^n
"BLD",965,4,772,224)

"BLD",965,4,773,0)
773
"BLD",965,4,773,2,0)
^9.641^773^1
"BLD",965,4,773,2,773,0)
HL7 MESSAGE ADMINISTRATION  (File-top level)
"BLD",965,4,773,2,773,1,0)
^9.6411^2^1
"BLD",965,4,773,2,773,1,2,0)
MESSAGE ID
"BLD",965,4,773,222)
y^n^p^^^^n^^n
"BLD",965,4,773,224)

"BLD",965,4,869.3,0)
869.3
"BLD",965,4,869.3,222)
y^n^f^^^^n
"BLD",965,4,870,0)
870
"BLD",965,4,870,222)
y^n^f^^^^n^^n
"BLD",965,4,870,224)

"BLD",965,4,"APDD",772,772)

"BLD",965,4,"APDD",772,772,6)

"BLD",965,4,"APDD",773,773)

"BLD",965,4,"APDD",773,773,2)

"BLD",965,4,"B",772,772)

"BLD",965,4,"B",773,773)

"BLD",965,4,"B",869.3,869.3)

"BLD",965,4,"B",870,870)

"BLD",965,6.3)
14
"BLD",965,"INI")

"BLD",965,"INID")
^y^
"BLD",965,"INIT")
POST^HLPAT122
"BLD",965,"KRN",0)
^9.67PA^8989.52^19
"BLD",965,"KRN",.4,0)
.4
"BLD",965,"KRN",.401,0)
.401
"BLD",965,"KRN",.402,0)
.402
"BLD",965,"KRN",.403,0)
.403
"BLD",965,"KRN",.403,"NM",0)
^9.68A^1^1
"BLD",965,"KRN",.403,"NM",1,0)
HL7 LOGICAL LINK    FILE #870^870^0
"BLD",965,"KRN",.403,"NM","B","HL7 LOGICAL LINK    FILE #870",1)

"BLD",965,"KRN",.5,0)
.5
"BLD",965,"KRN",.84,0)
.84
"BLD",965,"KRN",3.6,0)
3.6
"BLD",965,"KRN",3.8,0)
3.8
"BLD",965,"KRN",9.2,0)
9.2
"BLD",965,"KRN",9.8,0)
9.8
"BLD",965,"KRN",9.8,"NM",0)
^9.68A^35^25
"BLD",965,"KRN",9.8,"NM",10,0)
HLMA^^0^B50301067
"BLD",965,"KRN",9.8,"NM",12,0)
HLMA4^^0^B23979433
"BLD",965,"KRN",9.8,"NM",13,0)
HLCS^^0^B35933605
"BLD",965,"KRN",9.8,"NM",14,0)
HLCS2^^0^B49434182
"BLD",965,"KRN",9.8,"NM",15,0)
HLCSGTM^^0^B2303330
"BLD",965,"KRN",9.8,"NM",16,0)
HLCSIN^^0^B34245145
"BLD",965,"KRN",9.8,"NM",17,0)
HLCSLNCH^^0^B46750262
"BLD",965,"KRN",9.8,"NM",18,0)
HLCSMON1^^0^B10975872
"BLD",965,"KRN",9.8,"NM",19,0)
HLCSTCP^^0^B46918121
"BLD",965,"KRN",9.8,"NM",20,0)
HLCSTCP1^^0^B70690150
"BLD",965,"KRN",9.8,"NM",21,0)
HLCSTCP2^^0^B68574650
"BLD",965,"KRN",9.8,"NM",22,0)
HLCSTCP3^^0^B12715740
"BLD",965,"KRN",9.8,"NM",23,0)
HLCSTCP4^^0^B39383548
"BLD",965,"KRN",9.8,"NM",24,0)
HLCSTCPA^^0^B6096093
"BLD",965,"KRN",9.8,"NM",25,0)
HLCSTERM^^0^B4335770
"BLD",965,"KRN",9.8,"NM",26,0)
HLTPCK2B^^0^B67329178
"BLD",965,"KRN",9.8,"NM",27,0)
HLTP3^^0^B75102682
"BLD",965,"KRN",9.8,"NM",28,0)
HLCSHDR4^^0^B78131935
"BLD",965,"KRN",9.8,"NM",29,0)
HLCSHDR1^^0^B59513881
"BLD",965,"KRN",9.8,"NM",30,0)
HLCSREP^^0^B2826311
"BLD",965,"KRN",9.8,"NM",31,0)
HLDIE^^0^B47013227
"BLD",965,"KRN",9.8,"NM",32,0)
HLTF^^0^B22809391
"BLD",965,"KRN",9.8,"NM",33,0)
HLTF1^^0^B25518513
"BLD",965,"KRN",9.8,"NM",34,0)
HLTF2^^0^B40999444
"BLD",965,"KRN",9.8,"NM",35,0)
HLCSMON^^0^B54162059
"BLD",965,"KRN",9.8,"NM","B","HLCS",13)

"BLD",965,"KRN",9.8,"NM","B","HLCS2",14)

"BLD",965,"KRN",9.8,"NM","B","HLCSGTM",15)

"BLD",965,"KRN",9.8,"NM","B","HLCSHDR1",29)

"BLD",965,"KRN",9.8,"NM","B","HLCSHDR4",28)

"BLD",965,"KRN",9.8,"NM","B","HLCSIN",16)

"BLD",965,"KRN",9.8,"NM","B","HLCSLNCH",17)

"BLD",965,"KRN",9.8,"NM","B","HLCSMON",35)

"BLD",965,"KRN",9.8,"NM","B","HLCSMON1",18)

"BLD",965,"KRN",9.8,"NM","B","HLCSREP",30)

"BLD",965,"KRN",9.8,"NM","B","HLCSTCP",19)

"BLD",965,"KRN",9.8,"NM","B","HLCSTCP1",20)

"BLD",965,"KRN",9.8,"NM","B","HLCSTCP2",21)

"BLD",965,"KRN",9.8,"NM","B","HLCSTCP3",22)

"BLD",965,"KRN",9.8,"NM","B","HLCSTCP4",23)

"BLD",965,"KRN",9.8,"NM","B","HLCSTCPA",24)

"BLD",965,"KRN",9.8,"NM","B","HLCSTERM",25)

"BLD",965,"KRN",9.8,"NM","B","HLDIE",31)

"BLD",965,"KRN",9.8,"NM","B","HLMA",10)

"BLD",965,"KRN",9.8,"NM","B","HLMA4",12)

"BLD",965,"KRN",9.8,"NM","B","HLTF",32)

"BLD",965,"KRN",9.8,"NM","B","HLTF1",33)

"BLD",965,"KRN",9.8,"NM","B","HLTF2",34)

"BLD",965,"KRN",9.8,"NM","B","HLTP3",27)

"BLD",965,"KRN",9.8,"NM","B","HLTPCK2B",26)

"BLD",965,"KRN",19,0)
19
"BLD",965,"KRN",19.1,0)
19.1
"BLD",965,"KRN",101,0)
101
"BLD",965,"KRN",409.61,0)
409.61
"BLD",965,"KRN",771,0)
771
"BLD",965,"KRN",870,0)
870
"BLD",965,"KRN",8989.51,0)
8989.51
"BLD",965,"KRN",8989.52,0)
8989.52
"BLD",965,"KRN",8994,0)
8994
"BLD",965,"KRN","B",.4,.4)

"BLD",965,"KRN","B",.401,.401)

"BLD",965,"KRN","B",.402,.402)

"BLD",965,"KRN","B",.403,.403)

"BLD",965,"KRN","B",.5,.5)

"BLD",965,"KRN","B",.84,.84)

"BLD",965,"KRN","B",3.6,3.6)

"BLD",965,"KRN","B",3.8,3.8)

"BLD",965,"KRN","B",9.2,9.2)

"BLD",965,"KRN","B",9.8,9.8)

"BLD",965,"KRN","B",19,19)

"BLD",965,"KRN","B",19.1,19.1)

"BLD",965,"KRN","B",101,101)

"BLD",965,"KRN","B",409.61,409.61)

"BLD",965,"KRN","B",771,771)

"BLD",965,"KRN","B",870,870)

"BLD",965,"KRN","B",8989.51,8989.51)

"BLD",965,"KRN","B",8989.52,8989.52)

"BLD",965,"KRN","B",8994,8994)

"BLD",965,"QDEF")
^^^^^^^^^^
"BLD",965,"QUES",0)
^9.62^^
"BLD",965,"REQB",0)
^9.611^2^2
"BLD",965,"REQB",1,0)
HL*1.6*132^2
"BLD",965,"REQB",2,0)
XU*8.0*275^2
"BLD",965,"REQB","B","HL*1.6*132",1)

"BLD",965,"REQB","B","XU*8.0*275",2)

"FIA",772)
HL7 MESSAGE TEXT
"FIA",772,0)
^HL(772,
"FIA",772,0,0)
772DI
"FIA",772,0,1)
y^n^p^^^^n^^n
"FIA",772,0,10)

"FIA",772,0,11)

"FIA",772,0,"RLRO")

"FIA",772,0,"VR")
1.6^HL
"FIA",772,772)
1
"FIA",772,772,6)

"FIA",773)
HL7 MESSAGE ADMINISTRATION
"FIA",773,0)
^HLMA(
"FIA",773,0,0)
773PI
"FIA",773,0,1)
y^n^p^^^^n^^n
"FIA",773,0,10)

"FIA",773,0,11)

"FIA",773,0,"RLRO")

"FIA",773,0,"VR")
1.6^HL
"FIA",773,773)
1
"FIA",773,773,2)

"FIA",869.3)
HL COMMUNICATION SERVER PARAMETERS
"FIA",869.3,0)
^HLCS(869.3,
"FIA",869.3,0,0)
869.3
"FIA",869.3,0,1)
y^n^f^^^^n
"FIA",869.3,0,10)

"FIA",869.3,0,11)

"FIA",869.3,0,"RLRO")

"FIA",869.3,0,"VR")
1.6^HL
"FIA",869.3,869.3)
0
"FIA",869.3,869.31)
0
"FIA",869.3,869.311)
0
"FIA",869.3,869.32)
0
"FIA",869.3,869.33)
0
"FIA",869.3,869.34)
0
"FIA",869.3,869.35)
0
"FIA",869.3,869.36)
0
"FIA",869.3,869.391)
0
"FIA",869.3,869.392)
0
"FIA",869.3,869.393)
0
"FIA",870)
HL LOGICAL LINK
"FIA",870,0)
^HLCS(870,
"FIA",870,0,0)
870
"FIA",870,0,1)
y^n^f^^^^n^^n
"FIA",870,0,10)

"FIA",870,0,11)

"FIA",870,0,"RLRO")

"FIA",870,0,"VR")
1.6^HL
"FIA",870,870)
0
"FIA",870,870.01)
0
"FIA",870,870.019)
0
"FIA",870,870.02)
0
"FIA",870,870.13)
0
"FIA",870,870.193)
0
"INIT")
POST^HLPAT122
"IX",772,772,"C",0)
772^C^This is a regular index of new-style cross-reference on the Message ID field^R^^F^IR^I^772^^^^^LS
"IX",772,772,"C",.1,0)
^^2^2^3070731^
"IX",772,772,"C",.1,1,0)
This cross reference allows a user to look up an HL7 message by its 
"IX",772,772,"C",.1,2,0)
unique message ID.
"IX",772,772,"C",1)
S ^HL(772,"C",$E(X,1,60),DA)=""
"IX",772,772,"C",2)
K ^HL(772,"C",$E(X,1,60),DA)
"IX",772,772,"C",2.5)
K ^HL(772,"C")
"IX",772,772,"C",11.1,0)
^.114IA^1^1
"IX",772,772,"C",11.1,1,0)
1^F^772^6^60^1^F
"IX",772,772,"C",11.1,1,3)

"IX",773,773,"C",0)
773^C^This is a regular index of new-style cross-reference on the Message ID field^R^^F^IR^I^773^^^^^LS
"IX",773,773,"C",.1,0)
^^2^2^3070731^
"IX",773,773,"C",.1,1,0)
This cross reference allows a user to look up an HL7 message by its 
"IX",773,773,"C",.1,2,0)
unique message ID.
"IX",773,773,"C",1)
S ^HLMA("C",$E(X,1,60),DA)=""
"IX",773,773,"C",2)
K ^HLMA("C",$E(X,1,60),DA)
"IX",773,773,"C",2.5)
K ^HLMA("C")
"IX",773,773,"C",11.1,0)
^.114IA^1^1
"IX",773,773,"C",11.1,1,0)
1^F^773^2^60^1^F
"IX",870,870,"AC",0)
870^AC^Sorts entries by <station number>,<link name>,<ien>^MU^^R^IR^I^870^^^^^S
"IX",870,870,"AC",1)
S ^HLCS(870,"AC",$S($L($P($G(^DIC(4,+X2(1),99)),"^")):$P($G(^DIC(4,+X2(1),99)),"^"),1:" "),X2(2),DA)=""
"IX",870,870,"AC",2)
K ^HLCS(870,"AC",$S($L($P($G(^DIC(4,+X1(1),99)),"^")):$P($G(^DIC(4,+X1(1),99)),"^"),1:" "),X1(2),DA)
"IX",870,870,"AC",2.5)
K ^HLCS(870,"AC")
"IX",870,870,"AC",11.1,0)
^.114IA^2^2
"IX",870,870,"AC",11.1,1,0)
1^F^870^.02^^1^F
"IX",870,870,"AC",11.1,1,1)

"IX",870,870,"AC",11.1,1,1.5)

"IX",870,870,"AC",11.1,1,3)

"IX",870,870,"AC",11.1,2,0)
2^F^870^.01^^^F
"IX",870,870,"AD",0)
870^AD^Used to find the link over which to send the application acknowledgment.^MU^^R^IR^I^870^^^^^A
"IX",870,870,"AD",1)
D SET1^HLOTLNK(X(1),X(3))
"IX",870,870,"AD",1.4)
S X=0 I X(4)="C",X(2),$P($G(^HLCS(869.1,X(2),0)),"^")="TCP" S X=1
"IX",870,870,"AD",2)
D KILL1^HLOTLNK(X(1),X(3))
"IX",870,870,"AD",2.4)
S X=0 I X(4)="C",X(2),$P($G(^HLCS(869.1,X(2),0)),"^")="TCP" S X=1
"IX",870,870,"AD",2.5)

"IX",870,870,"AD",11.1,0)
^.114IA^5^4
"IX",870,870,"AD",11.1,1,0)
1^F^870^.01^30^1^F
"IX",870,870,"AD",11.1,2,0)
2^F^870^2^^2^F
"IX",870,870,"AD",11.1,4,0)
3^F^870^.03^^3^F
"IX",870,870,"AD",11.1,5,0)
4^F^870^400.03^^4^F
"IX",870,870,"AD",11.1,5,3)

"IX",870,870,"AD1",0)
870^AD1^Used to find the link overwhich to send the application acknowledgment.^MU^^R^IR^I^870^^^^^A
"IX",870,870,"AD1",1)
D SET2^HLOTLNK(X(1),X(3))
"IX",870,870,"AD1",1.4)
S X=0 I X(4)="C",X(2),$P($G(^HLCS(869.1,X(2),0)),"^")="TCP" S X=1
"IX",870,870,"AD1",2)
D KILL2^HLOTLNK(X(1),X(3))
"IX",870,870,"AD1",2.4)
S X=0 I X(4)="C",X(2),$P($G(^HLCS(869.1,X(2),0)),"^")="TCP" S X=1
"IX",870,870,"AD1",2.5)

"IX",870,870,"AD1",11.1,0)
^.114IA^4^4
"IX",870,870,"AD1",11.1,1,0)
1^F^870^.01^^1^F
"IX",870,870,"AD1",11.1,2,0)
2^F^870^2^^2^F
"IX",870,870,"AD1",11.1,3,0)
3^F^870^.08^^3^F
"IX",870,870,"AD1",11.1,4,0)
4^F^870^400.03^^4^F
"IX",870,870,"AD2",0)
870^AD2^Used to find the link overwhich to send an application acknowledgment.^MU^^R^IR^I^870^^^^^A
"IX",870,870,"AD2",1)
D SET3^HLOTLNK(X(1),X(3))
"IX",870,870,"AD2",1.4)
S X=0 I X(2),$P($G(^HLCS(869.1,X(2),0)),"^")="HLLP" S X=1
"IX",870,870,"AD2",2)
D KILL3^HLOTLNK(X(1),X(3))
"IX",870,870,"AD2",2.4)
S X=0 I X(2),$P($G(^HLCS(869.1,X(2),0)),"^")="HLLP" S X=1
"IX",870,870,"AD2",2.5)
K ^HLCS(870,"AD","HLLP")
"IX",870,870,"AD2",11.1,0)
^.114IA^3^3
"IX",870,870,"AD2",11.1,1,0)
1^F^870^.01^^1^F
"IX",870,870,"AD2",11.1,2,0)
2^F^870^2^^2^F
"IX",870,870,"AD2",11.1,3,0)
3^F^870^200.01^^3^F
"IX",870,870,"DNS",0)
870^DNS^This is a regular index of new-style cross-reference on the DNS Domain field^R^^F^IR^I^870^^^^^LS
"IX",870,870,"DNS",1)
S ^HLCS(870,"DNS",$E(X,1,70),DA)=""
"IX",870,870,"DNS",2)
K ^HLCS(870,"DNS",$E(X,1,70),DA)
"IX",870,870,"DNS",2.5)
K ^HLCS(870,"DNS")
"IX",870,870,"DNS",11.1,0)
^.114IA^1^1
"IX",870,870,"DNS",11.1,1,0)
1^F^870^.08^70^1^F
"IX",870,870,"DNS",11.1,1,3)

"IX",870,870,"DNS2",0)
870^DNS2^Regular index of new-style x-ref on the DNS Domain and Node fields^R^^R^IR^I^870^^^^^LS
"IX",870,870,"DNS2",1)
S ^HLCS(870,"DNS2",$E(X(1),1,70),$E(X(2),1,30),DA)=""
"IX",870,870,"DNS2",2)
K ^HLCS(870,"DNS2",$E(X(1),1,70),$E(X(2),1,30),DA)
"IX",870,870,"DNS2",2.5)
K ^HLCS(870,"DNS2")
"IX",870,870,"DNS2",11.1,0)
^.114IA^2^2
"IX",870,870,"DNS2",11.1,1,0)
1^F^870^.08^70^1^F
"IX",870,870,"DNS2",11.1,1,3)

"IX",870,870,"DNS2",11.1,2,0)
2^F^870^.01^30^2^F
"IX",870,870,"DNS2",11.1,2,3)

"IX",870,870,"IEN772IN",0)
870^IEN772IN^IEN772 whole file cross reference^R^^F^IR^W^870.019^^^^^LS
"IX",870,870,"IEN772IN",1)
S ^HLCS(870,"IEN772IN",X,DA(1),DA)=""
"IX",870,870,"IEN772IN",2)
K ^HLCS(870,"IEN772IN",X,DA(1),DA)
"IX",870,870,"IEN772IN",2.5)
K ^HLCS(870,"IEN772IN")
"IX",870,870,"IEN772IN",11.1,0)
^.114IA^1^1
"IX",870,870,"IEN772IN",11.1,1,0)
1^F^870.019^9^^1^F
"IX",870,870,"IEN772IN",11.1,1,3)

"IX",870,870,"IEN772OUT",0)
870^IEN772OUT^IEN772 whole file cross reference^R^^F^IR^W^870.01^^^^^LS
"IX",870,870,"IEN772OUT",1)
S ^HLCS(870,"IEN772OUT",X,DA(1),DA)=""
"IX",870,870,"IEN772OUT",2)
K ^HLCS(870,"IEN772OUT",X,DA(1),DA)
"IX",870,870,"IEN772OUT",2.5)
K ^HLCS(870,"IEN772OUT")
"IX",870,870,"IEN772OUT",11.1,0)
^.114IA^1^1
"IX",870,870,"IEN772OUT",11.1,1,0)
1^F^870.01^6^^1^F
"IX",870,870,"IEN772OUT",11.1,1,3)

"IX",870,870,"IP",0)
870^IP^IP Address cross reference^R^^F^IR^I^870^^^^^LS
"IX",870,870,"IP",1)
S ^HLCS(870,"IP",$E(X,1,40),DA)=""
"IX",870,870,"IP",2)
K ^HLCS(870,"IP",$E(X,1,40),DA)
"IX",870,870,"IP",2.5)
K ^HLCS(870,"IP")
"IX",870,870,"IP",11.1,0)
^.114IA^1^1
"IX",870,870,"IP",11.1,1,0)
1^F^870^400.01^40^1^F
"IX",870,870,"IP",11.1,1,3)

"KRN",.403,30,-1)
0^1
"KRN",.403,30,0)
HL7 LOGICAL LINK^@^@^^2990706.1207^^^870^0^0^1
"KRN",.403,30,40,0)
^.4031I^5^5
"KRN",.403,30,40,1,0)
1^^1,1
"KRN",.403,30,40,1,1)
Page 1
"KRN",.403,30,40,1,40,0)
^.4032IP^144^2
"KRN",.403,30,40,1,40,143,0)
HL7 LL HEADER1^1^1,1^d
"KRN",.403,30,40,1,40,144,0)
HL7 LL BLK1^2^2,1^e
"KRN",.403,30,40,2,0)
3^^3,3^^^1^14,77
"KRN",.403,30,40,2,1)
Page 3
"KRN",.403,30,40,2,40,0)
^.4032IP^145^1
"KRN",.403,30,40,2,40,145,0)
HL7 LLP HLLP^1^1,2^e
"KRN",.403,30,40,2,40,145,1)

"KRN",.403,30,40,3,0)
5^^3,3^^^1^17,77
"KRN",.403,30,40,3,1)
Page 5
"KRN",.403,30,40,3,40,0)
^.4032IP^146^1
"KRN",.403,30,40,3,40,146,0)
HL7 LLP TCP^1^1,2^e
"KRN",.403,30,40,3,40,146,1)

"KRN",.403,30,40,4,0)
2^^3,3^^^1^7,77
"KRN",.403,30,40,4,1)
Page 2
"KRN",.403,30,40,4,40,0)
^.4032IP^147^1
"KRN",.403,30,40,4,40,147,0)
HL7 LLP MAIL^1^1,2^e
"KRN",.403,30,40,4,40,147,1)

"KRN",.403,30,40,5,0)
4^^3,3^^^1^14,77
"KRN",.403,30,40,5,1)
Page 4
"KRN",.403,30,40,5,40,0)
^.4032IP^148^1
"KRN",.403,30,40,5,40,148,0)
HL7 LLP X3.28^1^1,2^e
"KRN",.403,30,40,5,40,148,1)

"KRN",.404,143,0)
HL7 LL HEADER1^870^
"KRN",.404,143,40,0)
^.4044I^3^2
"KRN",.404,143,40,1,0)
1^HL7 LOGICAL LINK^1
"KRN",.404,143,40,1,2)
^^1,27
"KRN",.404,143,40,3,0)
3^--------------------------------------------------------------------------------^1
"KRN",.404,143,40,3,2)
^^2,1
"KRN",.404,144,0)
HL7 LL BLK1^870
"KRN",.404,144,40,0)
^.4044I^8^8
"KRN",.404,144,40,1,0)
1^NODE^3
"KRN",.404,144,40,1,1)
.01
"KRN",.404,144,40,1,2)
4,23^10^4,17
"KRN",.404,144,40,1,4)
1
"KRN",.404,144,40,2,0)
2^INSTITUTION^3
"KRN",.404,144,40,2,1)
.02
"KRN",.404,144,40,2,2)
6,23^30^6,10
"KRN",.404,144,40,3,0)
3^MAILMAN DOMAIN^3
"KRN",.404,144,40,3,1)
.03
"KRN",.404,144,40,3,2)
8,23^30^8,7
"KRN",.404,144,40,4,0)
6^LLP TYPE^3
"KRN",.404,144,40,4,1)
2
"KRN",.404,144,40,4,2)
14,23^30^14,13
"KRN",.404,144,40,4,4)
1
"KRN",.404,144,40,4,10)
S DDSSTACK="PAGE "_(1+X)
"KRN",.404,144,40,5,0)
4^AUTOSTART^3
"KRN",.404,144,40,5,1)
4.5
"KRN",.404,144,40,5,2)
10,23^8^10,12
"KRN",.404,144,40,6,0)
5^QUEUE SIZE^3
"KRN",.404,144,40,6,1)
21
"KRN",.404,144,40,6,2)
12,23^6^12,11
"KRN",.404,144,40,6,3)
10
"KRN",.404,144,40,7,0)
7^DNS DOMAIN^3
"KRN",.404,144,40,7,1)
.08
"KRN",.404,144,40,7,2)
16,23^30^16,11
"KRN",.404,144,40,8,0)
8^DESCRIPTION^3
"KRN",.404,144,40,8,1)
1
"KRN",.404,144,40,8,2)
4,67^1^4,54
"KRN",.404,145,0)
HL7 LLP HLLP^870
"KRN",.404,145,40,0)
^.4044I^11^10
"KRN",.404,145,40,1,0)
1^HLLP LOWER LEVEL PARAMETERS^1
"KRN",.404,145,40,1,2)
^^1,24
"KRN",.404,145,40,2,0)
2^^3
"KRN",.404,145,40,2,1)
.01
"KRN",.404,145,40,2,2)
2,24^30
"KRN",.404,145,40,2,4)
^^^1
"KRN",.404,145,40,4,0)
9^BLOCK SIZE^3
"KRN",.404,145,40,4,1)
200.03
"KRN",.404,145,40,4,2)
11,15^3^11,3
"KRN",.404,145,40,5,0)
3^HLLP DEVICE^3
"KRN",.404,145,40,5,1)
200.01
"KRN",.404,145,40,5,2)
5,15^30^5,2
"KRN",.404,145,40,6,0)
6^RE-TRANSMISION ATTEMPTS^3
"KRN",.404,145,40,6,1)
200.02
"KRN",.404,145,40,6,2)
7,70^2^7,45
"KRN",.404,145,40,7,0)
5^READ TIMEOUT^3
"KRN",.404,145,40,7,1)
200.04
"KRN",.404,145,40,7,2)
7,15^3^7,1
"KRN",.404,145,40,8,0)
7^ACK TIMEOUT^3
"KRN",.404,145,40,8,1)
200.05
"KRN",.404,145,40,8,2)
9,15^3^9,2
"KRN",.404,145,40,9,0)
8^LLP START BLOCK^3
"KRN",.404,145,40,9,1)
200.06
"KRN",.404,145,40,9,2)
9,70^2^9,53
"KRN",.404,145,40,10,0)
10^LLP END BLOCK^3
"KRN",.404,145,40,10,1)
200.07
"KRN",.404,145,40,10,2)
11,70^2^11,55
"KRN",.404,145,40,11,0)
4^PROTOCOL ID VERSION^3
"KRN",.404,145,40,11,1)
200.08
"KRN",.404,145,40,11,2)
5,70^3^5,49
"KRN",.404,146,0)
HL7 LLP TCP^870
"KRN",.404,146,40,0)
^.4044I^18^16
"KRN",.404,146,40,1,0)
1^TCP LOWER LEVEL PARAMETERS^1
"KRN",.404,146,40,1,2)
^^1,23
"KRN",.404,146,40,2,0)
2^^3
"KRN",.404,146,40,2,1)
.01
"KRN",.404,146,40,2,2)
2,23^30
"KRN",.404,146,40,2,4)
^^^1
"KRN",.404,146,40,4,0)
7^RE-TRANSMISION ATTEMPTS^3
"KRN",.404,146,40,4,1)
200.02
"KRN",.404,146,40,4,2)
9,64^2^9,39
"KRN",.404,146,40,5,0)
10^BLOCK SIZE^3
"KRN",.404,146,40,5,1)
200.03
"KRN",.404,146,40,5,2)
11,17^3^11,5
"KRN",.404,146,40,6,0)
8^READ TIMEOUT^3
"KRN",.404,146,40,6,1)
200.04
"KRN",.404,146,40,6,2)
10,17^3^10,3
"KRN",.404,146,40,7,0)
6^ACK TIMEOUT^3
"KRN",.404,146,40,7,1)
200.05
"KRN",.404,146,40,7,2)
9,17^3^9,4
"KRN",.404,146,40,8,0)
15^UNI-DIRECTIONAL WAIT^3
"KRN",.404,146,40,8,1)
200.09
"KRN",.404,146,40,8,2)
14,64^2^14,42
"KRN",.404,146,40,9,0)
4^TCP/IP ADDRESS^3
"KRN",.404,146,40,9,1)
400.01
"KRN",.404,146,40,9,2)
5,24^40^5,8
"KRN",.404,146,40,10,0)
5^TCP/IP PORT^3
"KRN",.404,146,40,10,1)
400.02
"KRN",.404,146,40,10,2)
6,24^5^6,11
"KRN",.404,146,40,11,0)
3^TCP/IP SERVICE TYPE^3
"KRN",.404,146,40,11,1)
400.03
"KRN",.404,146,40,11,2)
4,24^15^4,3
"KRN",.404,146,40,11,13)
I X'="C" F HLI=200.02,200.09,400.04,400.05 D UNED^DDSUTL(HLI,"","",1)
"KRN",.404,146,40,12,0)
13^PERSISTENT^3
"KRN",.404,146,40,12,1)
400.04
"KRN",.404,146,40,12,2)
13,64^3^13,52
"KRN",.404,146,40,13,0)
14^RETENTION^3
"KRN",.404,146,40,13,1)
400.05
"KRN",.404,146,40,13,2)
14,15^6^14,4
"KRN",.404,146,40,14,0)
12^STARTUP NODE^3
"KRN",.404,146,40,14,1)
400.06
"KRN",.404,146,40,14,2)
13,15^20^13,1
"KRN",.404,146,40,15,0)
9^EXCEED RE-TRANSMIT ACTION^3
"KRN",.404,146,40,15,1)
200.021
"KRN",.404,146,40,15,2)
10,64^10^10,37
"KRN",.404,146,40,15,4)
0
"KRN",.404,146,40,16,0)
11^SAY HELO^3
"KRN",.404,146,40,16,1)
400.07
"KRN",.404,146,40,16,2)
11,64^3^11,54
"KRN",.404,146,40,17,0)
5.1^TCP/IP PORT (OPTIMIZED)^3
"KRN",.404,146,40,17,1)
400.08
"KRN",.404,146,40,17,2)
7,36^5^7,11
"KRN",.404,146,40,18,0)
16^DIRECT CONNECT OPEN TIMEOUT^3
"KRN",.404,146,40,18,1)
.09
"KRN",.404,146,40,18,2)
12,64^2^12,35
"KRN",.404,147,0)
HL7 LLP MAIL^870
"KRN",.404,147,40,0)
^.4044I^5^3
"KRN",.404,147,40,1,0)
1^MAILMAN LOWER LEVEL PARAMETERS^1
"KRN",.404,147,40,1,2)
^^1,23
"KRN",.404,147,40,4,0)
2^MAIL GROUP^3
"KRN",.404,147,40,4,1)
100.01
"KRN",.404,147,40,4,2)
4,23^30^4,11
"KRN",.404,147,40,4,4)
0
"KRN",.404,147,40,5,0)
3^^3
"KRN",.404,147,40,5,1)
.01
"KRN",.404,147,40,5,2)
2,23^30
"KRN",.404,147,40,5,4)
^^^1
"KRN",.404,148,0)
HL7 LLP X3.28^870
"KRN",.404,148,40,0)
^.4044I^10^9
"KRN",.404,148,40,1,0)
1^X3.28 LOWER LEVEL PARAMETERS^1
"KRN",.404,148,40,1,2)
^^1,23
"KRN",.404,148,40,2,0)
2^^3
"KRN",.404,148,40,2,1)
.01
"KRN",.404,148,40,2,2)
2,23^30
"KRN",.404,148,40,2,4)
^^^1
"KRN",.404,148,40,4,0)
3^X3.28 DEVICE^3
"KRN",.404,148,40,4,1)
300.01
"KRN",.404,148,40,4,2)
5,24^30^5,10
"KRN",.404,148,40,5,0)
4^MAXIMUM MESSAGE SIZE^3
"KRN",.404,148,40,5,1)
300.02
"KRN",.404,148,40,5,2)
7,24^5^7,2
"KRN",.404,148,40,6,0)
5^MAXIMUM BLOCK SIZE^3
"KRN",.404,148,40,6,1)
300.03
"KRN",.404,148,40,6,2)
7,69^3^7,49
"KRN",.404,148,40,7,0)
6^TIMER A^3
"KRN",.404,148,40,7,1)
300.04
"KRN",.404,148,40,7,2)
9,24^2^9,15
"KRN",.404,148,40,8,0)
8^TIMER B^3
"KRN",.404,148,40,8,1)
300.05
"KRN",.404,148,40,8,2)
11,24^2^11,15
"KRN",.404,148,40,9,0)
7^TIMER D^3
"KRN",.404,148,40,9,1)
300.06
"KRN",.404,148,40,9,2)
9,69^2^9,60
"KRN",.404,148,40,10,0)
9^TIMER E^3
"KRN",.404,148,40,10,1)
300.07
"KRN",.404,148,40,10,2)
11,69^3^11,60
"MBREQ")
0
"ORD",8,.403)
.403;8;;;EDEOUT^DIFROMSO(.403,DA,"",XPDA);FPRE^DIFROMSI(.403,"",XPDA);EPRE^DIFROMSI(.403,DA,$E("N",$G(XPDNEW)),XPDA,"",OLDA);;EPOST^DIFROMSI(.403,DA,"",XPDA);DEL^DIFROMSK(.403,"",%)
"ORD",8,.403,0)
FORM
"PKG",9,-1)
1^1
"PKG",9,0)
HEALTH LEVEL SEVEN^HL^DHCP IMPLEMENTATION OF HEALTH LEVEL SEVEN^
"PKG",9,20,0)
^9.402P^^
"PKG",9,22,0)
^9.49I^1^1
"PKG",9,22,1,0)
1.6^2980130^2980130^6
"PKG",9,22,1,"PAH",1,0)
122^3071214^16
"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
NO
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
NO
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
NO
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
26
"RTN","HLCS")
0^13^B35933605^B32818553
"RTN","HLCS",1,0)
HLCS ;ALB/RJS,MTC,JRP - COMMUNICATIONS SERVER - ;10/04/2007  14:34
"RTN","HLCS",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**2,9,14,19,43,57,109,132,122**;Oct 13, 1995;Build 14
"RTN","HLCS",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLCS",4,0)
 ;
"RTN","HLCS",5,0)
 ;The SEND function is invoked by the transaction processor.
"RTN","HLCS",6,0)
 ;It's function is to $O through the ITEM multiple of the Event Driver
"RTN","HLCS",7,0)
 ;Protocol and create child entries in the Message Text file (#772)
"RTN","HLCS",8,0)
 ;for the message at HLMTIEN.  These child messages point back
"RTN","HLCS",9,0)
 ;to the parent message so that message text does not need to
"RTN","HLCS",10,0)
 ;be duplicated when a message is sent to multiple applications.
"RTN","HLCS",11,0)
 ;
"RTN","HLCS",12,0)
 ;The SENDACK function is also invoked by the transaction processor.
"RTN","HLCS",13,0)
 ;It's function is to create a child entry in the Message Text file
"RTN","HLCS",14,0)
 ;for the message at HLMTIENA and deliver the message to the
"RTN","HLCS",15,0)
 ;application the requested/sent information.
"RTN","HLCS",16,0)
 ;
"RTN","HLCS",17,0)
 ;For DHCP to DHCP messaging (i.e. internal to internal), an incoming
"RTN","HLCS",18,0)
 ;message is created in the Message Text file which is a duplication
"RTN","HLCS",19,0)
 ;of the outgoing message.  The incoming message is then processed by
"RTN","HLCS",20,0)
 ;calling the transaction processor.
"RTN","HLCS",21,0)
 ;
"RTN","HLCS",22,0)
 ;For DHCP to COTS messaging (i.e. internal to external), the message
"RTN","HLCS",23,0)
 ;is filed in the Message Text file with the Logical Link defined and
"RTN","HLCS",24,0)
 ;a status of PENDING TRANSMISSION.  These entries are picked up by
"RTN","HLCS",25,0)
 ;the background filer and transmitted to the appropriate COTS system.
"RTN","HLCS",26,0)
 ;
"RTN","HLCS",27,0)
SEND(HLMTIEN,HLEID,HLRESULT) ;Send an HL7 message
"RTN","HLCS",28,0)
 ;HLMTIEN=The IEN of the parent message in file # 772
"RTN","HLCS",29,0)
 ;HLEID=The IEN of the Event Driver protocol in file #101
"RTN","HLCS",30,0)
 ;HLRESULT=Variable for any error text (pass by reference)
"RTN","HLCS",31,0)
 ;
"RTN","HLCS",32,0)
 ;Declare variables
"RTN","HLCS",33,0)
 N HLARY,HLERROR,HLEIDS,HLCLIENT,HLOGLINK,HLMTIENS,HLMSGPTR
"RTN","HLCS",34,0)
 S HLERROR=""
"RTN","HLCS",35,0)
 ;Direct connect
"RTN","HLCS",36,0)
 I HLPRIO="I" D  Q
"RTN","HLCS",37,0)
 . D DC^HLMA2
"RTN","HLCS",38,0)
 . S HLRESULT=HLERROR
"RTN","HLCS",39,0)
 ;Get all subscribers to the message
"RTN","HLCS",40,0)
 D ITEM^HLUTIL2(HLEID,"PTR")
"RTN","HLCS",41,0)
 ;Quit if no subscribers (considered successful delivery)
"RTN","HLCS",42,0)
 G:($G(HLARY(0))'>0) EXIT
"RTN","HLCS",43,0)
 ;Deliver message to each subscriber
"RTN","HLCS",44,0)
 S HLEIDS=0
"RTN","HLCS",45,0)
 F  S HLEIDS=$O(HLARY(HLEIDS)) Q:(HLEIDS'>0)  D
"RTN","HLCS",46,0)
 .;
"RTN","HLCS",47,0)
 .;**132 excluded subscribers **
"RTN","HLCS",48,0)
 .N I,EXCLUDE
"RTN","HLCS",49,0)
 .S (EXCLUDE,I)=0
"RTN","HLCS",50,0)
 . ;
"RTN","HLCS",51,0)
 . ; patch HL*1.6*122
"RTN","HLCS",52,0)
 . ; F  S I=$O(HLP("EXCLUDE SUBSCRIBER",I)) Q:'I  I $G(HLP("EXCLUDE SUBSCRIBER",I))=HLEIDS S EXCLUDE=1 Q
"RTN","HLCS",53,0)
 . F  S I=$O(HLP("EXCLUDE SUBSCRIBER",I)) Q:'I  D  Q:EXCLUDE
"RTN","HLCS",54,0)
 .. N TEMP
"RTN","HLCS",55,0)
 .. S TEMP=HLP("EXCLUDE SUBSCRIBER",I)
"RTN","HLCS",56,0)
 .. I 'TEMP,TEMP]"" S TEMP=$O(^ORD(101,"B",TEMP,0))
"RTN","HLCS",57,0)
 .. I TEMP=HLEIDS S EXCLUDE=1
"RTN","HLCS",58,0)
 . ; patch HL*1.6*122
"RTN","HLCS",59,0)
 . ;
"RTN","HLCS",60,0)
 .Q:EXCLUDE
"RTN","HLCS",61,0)
 .;** 132 end **
"RTN","HLCS",62,0)
 .;
"RTN","HLCS",63,0)
 .;Get pointer to receiving application
"RTN","HLCS",64,0)
 .S HLCLIENT=+HLARY(HLEIDS),HL("EIDS")=HLEIDS,HLERROR=""
"RTN","HLCS",65,0)
 .Q:(HLCLIENT'>0)
"RTN","HLCS",66,0)
 .;Check and execute ROUTING LOGIC **CIRN**
"RTN","HLCS",67,0)
 .S HLX=$G(^ORD(101,HLEIDS,774))
"RTN","HLCS",68,0)
 .I HLX]"" D  Q
"RTN","HLCS",69,0)
 ..N HLQUIT,HLNODE,HLNEXT
"RTN","HLCS",70,0)
 ..S HLQUIT=0,HLNODE="",HLNEXT="D HLNEXT^HLCSUTL"
"RTN","HLCS",71,0)
 ..X HLX I $D(HLL("LINKS")) D FWD^HLCS2 K HLL ;**CIRN**
"RTN","HLCS",72,0)
 .;Get pointer to logical link
"RTN","HLCS",73,0)
 .S HLOGLINK=$P(HLARY(HLEIDS),"^",2)
"RTN","HLCS",74,0)
 .;Determine if receiving application is internal or external
"RTN","HLCS",75,0)
 .;  Logical link has a value for external applications
"RTN","HLCS",76,0)
 .;  Logical link is NULL for internal applications
"RTN","HLCS",77,0)
 .I (HLOGLINK) D COTS Q
"RTN","HLCS",78,0)
 .;Create 'incoming' message based on 'outgoing' message (internal)
"RTN","HLCS",79,0)
 .D DHCP(HLMTIEN,HLEIDS,HLCLIENT)
"RTN","HLCS",80,0)
 .Q:(HLERROR)
"RTN","HLCS",81,0)
 .;Process the 'incoming' message
"RTN","HLCS",82,0)
 .S HLERROR=""
"RTN","HLCS",83,0)
 .D PROCESS^HLTP0(HLMSGPTR,"DHCP","",.HLERROR)
"RTN","HLCS",84,0)
 .;Update Status of 'incoming' message to SUCCESSFULLY COMPLETED
"RTN","HLCS",85,0)
 .; or ERROR DURING TRANSMISSION
"RTN","HLCS",86,0)
 .D STATUS^HLTF0(HLMSGPTR,$S(HLERROR:4,1:3),$S(HLERROR:+HLERROR,1:""),$S(HLERROR:$P(HLERROR,"^",2),1:""),,$S($G(HLERR("SKIP_EVENT"))=1:1,1:0))
"RTN","HLCS",87,0)
 .I $D(HLL("LINKS")) D FWD^HLCS2 K HLL ;**CIRN**
"RTN","HLCS",88,0)
 D ADD^HLCS2 ;**CIRN**
"RTN","HLCS",89,0)
EXIT S HLRESULT=HLERROR
"RTN","HLCS",90,0)
 Q
"RTN","HLCS",91,0)
COTS ;Internal to external communication
"RTN","HLCS",92,0)
 ;Create child entry in Message Text file
"RTN","HLCS",93,0)
 N HLTCP,HLTCPI,HLTCPO
"RTN","HLCS",94,0)
 D SEND^HLMA2(HLEIDS,HLMTIEN,HLCLIENT,"D",.HLMTIENS,HLOGLINK)
"RTN","HLCS",95,0)
 I ((+HLMTIENS)'>0) S HLERROR=HLMTIENS Q
"RTN","HLCS",96,0)
 ;'Pass' message to background filer by setting status of child
"RTN","HLCS",97,0)
 ;  to PENDING TRANSMISSION
"RTN","HLCS",98,0)
 D STATUS^HLTF0(HLMTIENS,1)
"RTN","HLCS",99,0)
 Q
"RTN","HLCS",100,0)
DHCP(HLMTIEN,HLEIDS,HLCLIENT) ;Internal to internal communication
"RTN","HLCS",101,0)
 ;
"RTN","HLCS",102,0)
 ;Input  : HLMTIEN - Pointer to parent outgoing message (file #772)
"RTN","HLCS",103,0)
 ;         HLEIDS - Pointer to subscribing protocol (file #101)
"RTN","HLCS",104,0)
 ;         HLCLIENT - Pointer to receiving application (file # 771)
"RTN","HLCS",105,0)
 ;
"RTN","HLCS",106,0)
 ;Output : HLMTIENS - Pointer to child outgoing message (file #772)
"RTN","HLCS",107,0)
 ;         HLMSGPTR - Pointer to [parent] incoming message (file #772)
"RTN","HLCS",108,0)
 ;         HLERROR - ErrorCode ^ ErrorText
"RTN","HLCS",109,0)
 ;
"RTN","HLCS",110,0)
 ;Notes  : This module only copies the outgoing message into an incoming
"RTN","HLCS",111,0)
 ;         message.  Delivery of the message (i.e. processing of it)
"RTN","HLCS",112,0)
 ;         must be done by the calling application.
"RTN","HLCS",113,0)
 ;       : Message/batch header (MSH/BSH) is built and placed in the
"RTN","HLCS",114,0)
 ;         incoming message
"RTN","HLCS",115,0)
 ;       : HLMTIENS, HLMSGPTR, and HLERROR will be initialized
"RTN","HLCS",116,0)
 ;       : Existance and validity of input is assumed
"RTN","HLCS",117,0)
 ;
"RTN","HLCS",118,0)
 ;Declare variables
"RTN","HLCS",119,0)
 N MSGID,MSGDT,MSGDTH,HDR2BLD,TMP,HLHDR,BHSHDR
"RTN","HLCS",120,0)
 S HLERROR=""
"RTN","HLCS",121,0)
 S HLMTIENS=0
"RTN","HLCS",122,0)
 S HLMSGPTR=0
"RTN","HLCS",123,0)
 ;Create child entry in Message Text file
"RTN","HLCS",124,0)
 D SEND^HLMA2(HLEIDS,HLMTIEN,HLCLIENT,"D",.HLMTIENS)
"RTN","HLCS",125,0)
 I ((+HLMTIENS)'>0) S HLERROR=HLMTIENS Q
"RTN","HLCS",126,0)
 ;'Receive' message by making an incoming message
"RTN","HLCS",127,0)
 ;Determine type of header to build
"RTN","HLCS",128,0)
 S TMP=$G(^HL(772,HLMTIEN,0))
"RTN","HLCS",129,0)
 S HDR2BLD=$P(TMP,"^",14)
"RTN","HLCS",130,0)
 ;Build message header (MSH)
"RTN","HLCS",131,0)
 I (HDR2BLD="M") D  Q:(HLERROR)
"RTN","HLCS",132,0)
 .S TMP=""
"RTN","HLCS",133,0)
 .D HEADER^HLCSHDR(HLMTIENS,.TMP)
"RTN","HLCS",134,0)
 .Q:(TMP="")
"RTN","HLCS",135,0)
 .;Error building header
"RTN","HLCS",136,0)
 .S HLERROR="4^Unable to build message header => "_TMP
"RTN","HLCS",137,0)
 .D STATUS^HLTF0(HLMTIENS,4,0,$P(HLERROR,"^",2))
"RTN","HLCS",138,0)
 ;Build batch header (BHS or FHS)
"RTN","HLCS",139,0)
 I (HDR2BLD'="M") D  Q:(HLERROR)
"RTN","HLCS",140,0)
 .S TMP=""
"RTN","HLCS",141,0)
 .D BHSHDR^HLCSHDR(HLMTIENS)
"RTN","HLCS",142,0)
 .S:($E(HLHDR(1),1)="-") TMP=$P(HLHDR(1),"^",2)
"RTN","HLCS",143,0)
 .Q:(TMP="")
"RTN","HLCS",144,0)
 .;Error building header
"RTN","HLCS",145,0)
 .S HLERROR="4^Unable to build batch header => "_TMP
"RTN","HLCS",146,0)
 .D STATUS^HLTF0(HLMTIENS,4,0,$P(HLERROR,"^",2))
"RTN","HLCS",147,0)
 ;Create entry for 'incoming' message
"RTN","HLCS",148,0)
 D CREATE^HLTF(.MSGID,.HLMSGPTR,.MSGDT,.MSGDTH)
"RTN","HLCS",149,0)
 ;Move header and rest of message into 'incoming' message
"RTN","HLCS",150,0)
 I (HDR2BLD="M") D
"RTN","HLCS",151,0)
 .;Use MSH as header
"RTN","HLCS",152,0)
 .D MRGINT^HLTF1(HLMTIEN,HLMSGPTR,"HLHDR")
"RTN","HLCS",153,0)
 I (HDR2BLD'="M") D
"RTN","HLCS",154,0)
 .;Use BHS or FHS as header
"RTN","HLCS",155,0)
 .D MRGINT^HLTF1(HLMTIEN,HLMSGPTR,"BHSHDR")
"RTN","HLCS",156,0)
 ;Set status of outgoing message to AWAITING ACKNOWLEDGEMENT
"RTN","HLCS",157,0)
 D STATUS^HLTF0(HLMTIENS,$S($P(^HL(772,HLMTIEN,0),U,7):3,1:2))
"RTN","HLCS",158,0)
 ;Set status of 'incoming' message to AWAITING PROCESSING
"RTN","HLCS",159,0)
 D STATUS^HLTF0(HLMSGPTR,9)
"RTN","HLCS",160,0)
 Q
"RTN","HLCS",161,0)
SENDACK(HLMTIENA,HLEID,HLEIDS,HLRESULT) ;Send an HL7 acknowledgement/response
"RTN","HLCS",162,0)
 ;HLMTIENA=The IEN of the parent acknowledgment/response message in
"RTN","HLCS",163,0)
 ;         file # 772
"RTN","HLCS",164,0)
 ;HLEIDS=The IEN of the Subscribing protocol in file # 101
"RTN","HLCS",165,0)
 ;HLEID=The IEN of the Event Driver protocol in file #101
"RTN","HLCS",166,0)
 ;HLRESULT=Variable for any error text (pass by reference)
"RTN","HLCS",167,0)
 ;
"RTN","HLCS",168,0)
 N HLERROR,HLOGLINK,HLCLIENT,HLMTIENS,HLMSGPTR,HLCLNODE
"RTN","HLCS",169,0)
 I $G(HLMTIENA)=""!($G(HLEID)="")!($G(HLEIDS)="") S HLERROR="0^7^"_$G(^HL(771.7,7,0))_"at SENDACK^HLCS entry point" G EXIT2
"RTN","HLCS",170,0)
 S HLCLNODE=$G(^ORD(101,HLEID,770))
"RTN","HLCS",171,0)
 ;Get pointers to Logical Link & receiving application
"RTN","HLCS",172,0)
 S HLOGLINK=$P($G(^ORD(101,HLEIDS,770)),U,7)
"RTN","HLCS",173,0)
 ;Application needed to dynamically address the ACK (tcp/ip)
"RTN","HLCS",174,0)
 ;(set HLL("LINKS") array before calling GENACK)
"RTN","HLCS",175,0)
 I $D(HLL("LINKS")) D  Q:'HLOGLINK
"RTN","HLCS",176,0)
 .S HLOGLINK=$P(HLL("LINKS",1),"^",2) Q:HLOGLINK=""
"RTN","HLCS",177,0)
 .K HLL("LINKS")
"RTN","HLCS",178,0)
 .I +HLOGLINK'=HLOGLINK S HLOGLINK=$O(^HLCS(870,"B",HLOGLINK,0))
"RTN","HLCS",179,0)
 S HLCLIENT=$P(HLCLNODE,U,1)
"RTN","HLCS",180,0)
 Q:('HLCLIENT)
"RTN","HLCS",181,0)
 ;Determine if receiving application is internal or external
"RTN","HLCS",182,0)
 ;  Logical link has a value for external applications
"RTN","HLCS",183,0)
 ;  Logical link is NULL for internal applications
"RTN","HLCS",184,0)
 I (HLOGLINK) D COTSACK Q
"RTN","HLCS",185,0)
 ;Create 'incoming' message based on 'outgoing' message (internal)
"RTN","HLCS",186,0)
 D DHCP(HLMTIENA,HLEID,HLCLIENT)
"RTN","HLCS",187,0)
 ;Process the 'incoming' message
"RTN","HLCS",188,0)
 I (HLMSGPTR) D
"RTN","HLCS",189,0)
 .S HLERROR=""
"RTN","HLCS",190,0)
 .D PROCESS^HLTP0(HLMSGPTR,"DHCP","",.HLERROR)
"RTN","HLCS",191,0)
 ;Update Status of 'incoming' message to SUCCESSFULLY COMPLETED
"RTN","HLCS",192,0)
 ; or ERROR DURING TRANSMISSION
"RTN","HLCS",193,0)
 D STATUS^HLTF0(HLMSGPTR,$S(HLERROR:4,1:3),$S(HLERROR:+HLERROR,1:""),$S(HLERROR:$P(HLERROR,"^",2),1:""))
"RTN","HLCS",194,0)
EXIT2 ;
"RTN","HLCS",195,0)
 S HLRESULT=$G(HLERROR)
"RTN","HLCS",196,0)
 Q
"RTN","HLCS",197,0)
COTSACK ;Internal to external communication of acknowledgements/responses
"RTN","HLCS",198,0)
 ;Create child entry in Message Text file
"RTN","HLCS",199,0)
 D SEND^HLMA2(HLEID,HLMTIENA,HLCLIENT,"D",.HLMTIENS,HLOGLINK)
"RTN","HLCS",200,0)
 ;'Pass' message to background filer by setting status of child
"RTN","HLCS",201,0)
 ;  to PENDING TRANSMISSION
"RTN","HLCS",202,0)
 D STATUS^HLTF0(HLMTIENS,1)
"RTN","HLCS",203,0)
 Q
"RTN","HLCS2")
0^14^B49434182^B38051566
"RTN","HLCS2",1,0)
HLCS2 ;SF/JC - More Communication Server utilities ; 10/04/2007  14:31
"RTN","HLCS2",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**14,40,43,49,57,58,82,84,109,122**;Oct 13, 1995;Build 14
"RTN","HLCS2",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLCS2",4,0)
FWD ; Add supplemental clients from HLL("LINKS") to HLSUP array
"RTN","HLCS2",5,0)
 ;This enhancement also supports distribution of a message to
"RTN","HLCS2",6,0)
 ;the same client over multiple logical links.
"RTN","HLCS2",7,0)
 Q:'$D(HLL("LINKS"))
"RTN","HLCS2",8,0)
 N CNT,LNK,CLIAP
"RTN","HLCS2",9,0)
 S CNT=0,ROUTINE=1 F  S CNT=$O(HLL("LINKS",CNT)) Q:CNT<1  D
"RTN","HLCS2",10,0)
 . S PTR=$P(HLL("LINKS",CNT),"^"),LNK=$P(HLL("LINKS",CNT),"^",2)
"RTN","HLCS2",11,0)
 . Q:PTR=""  I +PTR<1 S PTR=$O(^ORD(101,"B",PTR,0)) Q:PTR<1
"RTN","HLCS2",12,0)
 . ;
"RTN","HLCS2",13,0)
 . ; patch HL*1.6*122: excluding subscribers defined in
"RTN","HLCS2",14,0)
 . ; HLP("EXCLUDE SUBSCRIBER",I) = ien of subscriber
"RTN","HLCS2",15,0)
 . N I,EXCLUDE
"RTN","HLCS2",16,0)
 . S (EXCLUDE,I)=0
"RTN","HLCS2",17,0)
 . F  S I=$O(HLP("EXCLUDE SUBSCRIBER",I)) Q:'I  D  Q:EXCLUDE
"RTN","HLCS2",18,0)
 .. N TEMP
"RTN","HLCS2",19,0)
 .. S TEMP=HLP("EXCLUDE SUBSCRIBER",I)
"RTN","HLCS2",20,0)
 .. I 'TEMP,TEMP]"" S TEMP=$O(^ORD(101,"B",TEMP,0))
"RTN","HLCS2",21,0)
 .. I TEMP=PTR S EXCLUDE=1
"RTN","HLCS2",22,0)
 . Q:EXCLUDE
"RTN","HLCS2",23,0)
 . ; 
"RTN","HLCS2",24,0)
 . Q:LNK=""  I +LNK<1 S LNK=$O(^HLCS(870,"B",LNK,0)) Q:LNK<1
"RTN","HLCS2",25,0)
 . Q:'$D(^HLCS(870,LNK))
"RTN","HLCS2",26,0)
 . S CLIAP=$$PTR^HLUTIL2(PTR)
"RTN","HLCS2",27,0)
 . ; patch HL*1.6*122: add the 3rd component as receiving facility
"RTN","HLCS2",28,0)
 . ; S HLSUP("S",PTR,+LNK)=CLIAP_$S(CLIAP<1:U_HLL("LINKS",CNT),1:"")
"RTN","HLCS2",29,0)
 . S HLSUP("S",PTR,+LNK)=CLIAP_U_$S(CLIAP<1:HLL("LINKS",CNT),1:$P(HLL("LINKS",CNT),"^",3))
"RTN","HLCS2",30,0)
 Q
"RTN","HLCS2",31,0)
ADD ;Deliver message to supplemental client list.
"RTN","HLCS2",32,0)
 ;Invoked by HLTP before and after processing normal clients
"RTN","HLCS2",33,0)
 ;Only processes remote links. Local clients must be subscribing
"RTN","HLCS2",34,0)
 ;protocols.
"RTN","HLCS2",35,0)
 Q:'$D(HLSUP("S"))
"RTN","HLCS2",36,0)
 N HLTCP,HLTCPI,HLTCPO,ZHLEIDS,ZLCLIENT,ZLOGLINK,ZMTIENS
"RTN","HLCS2",37,0)
 S ZHLEIDS=0 F  S ZHLEIDS=$O(HLSUP("S",ZHLEIDS)) Q:ZHLEIDS<1  D
"RTN","HLCS2",38,0)
 .S ZLOGLINK=0 F  S ZLOGLINK=$O(HLSUP("S",ZHLEIDS,ZLOGLINK)) Q:ZLOGLINK<1  D
"RTN","HLCS2",39,0)
 ..S ZLCLIENT=+HLSUP("S",ZHLEIDS,ZLOGLINK)
"RTN","HLCS2",40,0)
 ..I ZLCLIENT<1 S:$G(HLERROR)="" HLERROR="15^Invalid Subscriber Protocol in HLL('LINKS'): "_$P(HLSUP("S",ZHLEIDS,ZLOGLINK),U,2,9) Q
"RTN","HLCS2",41,0)
 .. ; patch HL*1.6*122 start
"RTN","HLCS2",42,0)
 .. ; S HLOGLINK=ZLOGLINK D SEND^HLMA2(ZHLEIDS,HLMTIEN,ZLCLIENT,"D",.ZMTIENS,ZLOGLINK),STATUS^HLTF0(+ZMTIENS,1)
"RTN","HLCS2",43,0)
 .. S HLOGLINK=ZLOGLINK
"RTN","HLCS2",44,0)
 .. ; 3rd component for receiving facility
"RTN","HLCS2",45,0)
 .. S ZMTIENS("REC-FACILITY")=$P(HLSUP("S",ZHLEIDS,ZLOGLINK),U,3)
"RTN","HLCS2",46,0)
 .. D SEND^HLMA2(ZHLEIDS,HLMTIEN,ZLCLIENT,"D",.ZMTIENS,ZLOGLINK)
"RTN","HLCS2",47,0)
 .. D STATUS^HLTF0(+ZMTIENS,1)
"RTN","HLCS2",48,0)
 .. ; patch HL*1.6*122 end
"RTN","HLCS2",49,0)
 .. ;
"RTN","HLCS2",50,0)
 K HLL("LINKS"),HLSUP
"RTN","HLCS2",51,0)
 Q
"RTN","HLCS2",52,0)
STALL ;STOP ALL LINKS AND FILERS
"RTN","HLCS2",53,0)
 N DIR,Y
"RTN","HLCS2",54,0)
 W ! S DIR(0)="Y",DIR("A")="Okay to shut down all Links and Filers"
"RTN","HLCS2",55,0)
 D ^DIR
"RTN","HLCS2",56,0)
 I 'Y!($D(DIRUT))!($D(DUOUT)) W !!,"Shutdown Aborted!" Q
"RTN","HLCS2",57,0)
 W !,"Shutting down all Links and Filers..."
"RTN","HLCS2",58,0)
 D CLEAR
"RTN","HLCS2",59,0)
 D LLP(1)
"RTN","HLCS2",60,0)
 Q
"RTN","HLCS2",61,0)
QUE ;Restart Filers and AUTOSTART Logical Links after system re-boot
"RTN","HLCS2",62,0)
 N DIR,Y
"RTN","HLCS2",63,0)
 I '$D(ZTQUEUED) D  Q:'Y!($D(DIRUT))!($D(DUOUT))
"RTN","HLCS2",64,0)
 .W ! S DIR(0)="Y",DIR("A")="Shutdown and restart ALL AUTOSTART links and filers. Okay"
"RTN","HLCS2",65,0)
 .D ^DIR
"RTN","HLCS2",66,0)
 .I 'Y!($D(DIRUT))!($D(DUOUT)) W !!,"RESTART Aborted!" Q
"RTN","HLCS2",67,0)
 .W !,"Restarting all Autostart-Enabled Links and Filers..."
"RTN","HLCS2",68,0)
 D CLEAR
"RTN","HLCS2",69,0)
 D STARTF
"RTN","HLCS2",70,0)
 D LLP(0)
"RTN","HLCS2",71,0)
 D STRT
"RTN","HLCS2",72,0)
 Q
"RTN","HLCS2",73,0)
CLEAR ;Reset state of 869.3
"RTN","HLCS2",74,0)
 S DA(1)=1,DA=0,DIK="^HLCS(869.3,1,2,"
"RTN","HLCS2",75,0)
 F  S DA=$O(^HLCS(869.3,DA(1),2,DA)) Q:DA<1  D ^DIK
"RTN","HLCS2",76,0)
 S DA=0,DIK="^HLCS(869.3,1,3,"
"RTN","HLCS2",77,0)
 F  S DA=$O(^HLCS(869.3,DA(1),3,DA)) Q:DA<1  D ^DIK
"RTN","HLCS2",78,0)
 Q
"RTN","HLCS2",79,0)
STARTF ;Start filers
"RTN","HLCS2",80,0)
 ;Get Defaults
"RTN","HLCS2",81,0)
 N TMP,PTR,DEFCNT,DA,HLCNT,HLNODE1
"RTN","HLCS2",82,0)
 S PTR=+$O(^HLCS(869.3,0)) Q:'PTR
"RTN","HLCS2",83,0)
 ;default # of incoming filers
"RTN","HLCS2",84,0)
 S HLNODE1=$G(^HLCS(869.3,PTR,1)),DEFCNT=+$P(HLNODE1,U) S:'DEFCNT DEFCNT=1
"RTN","HLCS2",85,0)
 F HLCNT=1:1:DEFCNT S TMP=$$TASKFLR^HLCS1("IN")
"RTN","HLCS2",86,0)
 ;default # of outgoing filers
"RTN","HLCS2",87,0)
 S DEFCNT=+$P(HLNODE1,U,2) S:'DEFCNT DEFCNT=1
"RTN","HLCS2",88,0)
 F HLCNT=1:1:DEFCNT S TMP=$$TASKFLR^HLCS1("OUT")
"RTN","HLCS2",89,0)
 Q
"RTN","HLCS2",90,0)
LLP(ALL) ;Stop Logical Links
"RTN","HLCS2",91,0)
 ;ALL=1 OR 0 IF zero, only AUTOSTART LINKS get stopped
"RTN","HLCS2",92,0)
 N HLDP,HLDP0,HLPARM0,HLPARM4,HLJ,X,Y S HLDP=0
"RTN","HLCS2",93,0)
 F  S HLDP=$O(^HLCS(870,HLDP)) Q:'HLDP  S HLDP0=$G(^(HLDP,0)),X=+$P(HLDP0,U,3) D:X
"RTN","HLCS2",94,0)
 .;skip this link if not stopping all and Autostart not enabled
"RTN","HLCS2",95,0)
 . I 'ALL&('$P(HLDP0,U,6)) Q
"RTN","HLCS2",96,0)
 . S HLPARM4=$G(^HLCS(870,HLDP,400))
"RTN","HLCS2",97,0)
 . ; patch HL*1.6*122
"RTN","HLCS2",98,0)
 . ; TCP Multi listener: quit if TCP service as GT.M, DSM,
"RTN","HLCS2",99,0)
 . ; or Cache/VMS
"RTN","HLCS2",100,0)
 . I $P(HLPARM4,U,3)="M" Q:^%ZOSF("OS")'["OpenM"  Q:$$OS^%ZOSV["VMS"
"RTN","HLCS2",101,0)
 . ;
"RTN","HLCS2",102,0)
 . ;4=status,10=Time Stopped,9=Time Started,11=Task Number,3=Device Type,14=shutdown?
"RTN","HLCS2",103,0)
 . S X="HLJ(870,"""_HLDP_","")",@X@(10)=$$NOW^XLFDT,(@X@(11),@X@(9))="@",@X@(14)=1
"RTN","HLCS2",104,0)
 . I "Shutdown,SHUTDOWN"'[$P(HLDP0,U,5) S @X@(4)="Halting"
"RTN","HLCS2",105,0)
 . I $P(HLPARM4,U,3)="C"&("N"[$P(HLPARM4,U,4)),'$P(HLDP0,U,12) S @X@(4)="Shutdown"
"RTN","HLCS2",106,0)
 . D FILE^HLDIE("","HLJ","","LLP","HLCS2") ;HL*1.6*109
"RTN","HLCS2",107,0)
 . I ^%ZOSF("OS")["OpenM",($P(HLPARM4,U,3)="M"!($P(HLPARM4,U,3)="S")) D
"RTN","HLCS2",108,0)
 .. ; pass task number to stop listener
"RTN","HLCS2",109,0)
 .. S:$P(HLDP0,U,12) X=$$ASKSTOP^%ZTLOAD(+$P(HLDP0,U,12))
"RTN","HLCS2",110,0)
 ; patch HL*1.6*122 start
"RTN","HLCS2",111,0)
 ; .. D CALL^%ZISTCP($P(HLPARM4,U),$P(HLPARM4,U,2),10)
"RTN","HLCS2",112,0)
 ; .. I POP D HOME^%ZIS Q
"RTN","HLCS2",113,0)
 ; .. D CLOSE^%ZISTCP
"RTN","HLCS2",114,0)
 ; patch HL*1.6*122 end
"RTN","HLCS2",115,0)
 Q
"RTN","HLCS2",116,0)
STRT ;Start Links
"RTN","HLCS2",117,0)
 N HLDP,HLDP0,HLDAPP,HLTYPTR,HLBGR,HLENV,HLPARAM0,HLPARM4,HLQUIT,ZTRTN,ZTDESC,ZTSK,ZTCPU
"RTN","HLCS2",118,0)
 S HLDP=0
"RTN","HLCS2",119,0)
 F  S HLDP=$O(^HLCS(870,HLDP)) Q:HLDP<1  S HLDP0=$G(^(HLDP,0)) D
"RTN","HLCS2",120,0)
 . S HLPARM4=$G(^HLCS(870,HLDP,400))
"RTN","HLCS2",121,0)
 . ;quit if no parameters or AUTOSTART is disabled
"RTN","HLCS2",122,0)
 . Q:'$P(HLDP0,U,6)
"RTN","HLCS2",123,0)
 . ;HLDAPP=LL name, HLTYPTR=LL type, HLBGR=routine, HLENV=environment check
"RTN","HLCS2",124,0)
 . S HLDAPP=$P(HLDP0,U),HLTYPTR=+$P(HLDP0,U,3),HLBGR=$G(^HLCS(869.1,HLTYPTR,100)),HLENV=$G(^(200))
"RTN","HLCS2",125,0)
 . ;quit if no LL type or no routine
"RTN","HLCS2",126,0)
 . Q:'HLTYPTR!(HLBGR="")
"RTN","HLCS2",127,0)
 . I HLENV'="" K HLQUIT X HLENV Q:$D(HLQUIT)
"RTN","HLCS2",128,0)
 . ; patch HL*1.6*122
"RTN","HLCS2",129,0)
 . ; TCP Multi listener: quit if TCP service as GT.M, DSM,
"RTN","HLCS2",130,0)
 . ; or Cache/VMS
"RTN","HLCS2",131,0)
 . I $P(HLPARM4,U,3)="M" Q:^%ZOSF("OS")'["OpenM"  Q:$$OS^%ZOSV["VMS"
"RTN","HLCS2",132,0)
 . ;
"RTN","HLCS2",133,0)
 . I $P(HLPARM4,U,3)="C"&("N"[$P(HLPARM4,U,4)) D  Q
"RTN","HLCS2",134,0)
 .. ;4=status 9=Time Started, 10=Time Stopped, 11=Task Number 
"RTN","HLCS2",135,0)
 .. ;14=Shutdown LLP, 3=Device Type, 18=Gross Errors
"RTN","HLCS2",136,0)
 .. N HLJ,X
"RTN","HLCS2",137,0)
 .. I $P(HLDP0,U,15)=0 Q
"RTN","HLCS2",138,0)
 .. L +^HLCS(870,HLDP,0):2
"RTN","HLCS2",139,0)
 .. E  Q
"RTN","HLCS2",140,0)
 .. S X="HLJ(870,"""_HLDP_","")"
"RTN","HLCS2",141,0)
 .. S @X@(4)="Enabled",@X@(9)=$$NOW^XLFDT,@X@(14)=0
"RTN","HLCS2",142,0)
 .. D FILE^HLDIE("","HLJ","","STRT","HLCS2") ; HL*1.6*109
"RTN","HLCS2",143,0)
 .. L -^HLCS(870,HLDP,0)
"RTN","HLCS2",144,0)
 .. Q
"RTN","HLCS2",145,0)
 . S ZTRTN=$P(HLBGR," ",2),ZTIO="",ZTDTH=$H,HLTRACE=""
"RTN","HLCS2",146,0)
 . S ZTDESC=HLDAPP_" Low Level Protocol",ZTSAVE("HLDP")=""
"RTN","HLCS2",147,0)
 . ;get startup node
"RTN","HLCS2",148,0)
 . I $P(HLPARM4,U,6),$D(^%ZIS(14.7,+$P(HLPARM4,U,6),0)) S ZTCPU=$P(^(0),U)
"RTN","HLCS2",149,0)
 . D ^%ZTLOAD
"RTN","HLCS2",150,0)
 Q
"RTN","HLCS2",151,0)
SITEP ;Edit Site Parameters
"RTN","HLCS2",152,0)
 S DDSFILE=869.3,DA=1,DR="[HL SITE PARAMETERS]" D ^DDS
"RTN","HLCS2",153,0)
 Q
"RTN","HLCS2",154,0)
PARAM() ;Return HL7 site parameters
"RTN","HLCS2",155,0)
 ;HLPARAM=domain ien^domain name^production or test^institution ien^
"RTN","HLCS2",156,0)
 ;institution name^institution number^mail group ien^mail group name^
"RTN","HLCS2",157,0)
 ;purge completed messages^purge awaiting ack messages^purge all msgs^
"RTN","HLCS2",158,0)
 ;default retention
"RTN","HLCS2",159,0)
 N HLX,HLX4,HLX5,HLDOMP,HLDOMN,HLPROD,HLINSP,HLINSN,HLINSNM,HLMAILP,HLMAILN,HLPARAM,HLPRGAA,HLPRGALL,HLPRGCMP,HLDEFRET
"RTN","HLCS2",160,0)
 S HLX=$G(^HLCS(869.3,1,0))
"RTN","HLCS2",161,0)
 S HLX4=$G(^HLCS(869.3,1,4))
"RTN","HLCS2",162,0)
 S HLX5=$G(^HLCS(869.3,1,5))
"RTN","HLCS2",163,0)
 S HLDOMP=$P(HLX,U,2) I HLDOMP S HLDOMN=$P(^DIC(4.2,HLDOMP,0),U)
"RTN","HLCS2",164,0)
 S HLPROD=$P(HLX,U,3)
"RTN","HLCS2",165,0)
 S HLINSP=$P(HLX,U,4) I HLINSP S HLINSN=$P(^DIC(4,HLINSP,0),U),HLINSNM=$P($G(^DIC(4,HLINSP,99)),U)
"RTN","HLCS2",166,0)
 S HLMAILP=$P(HLX,U,5) I HLMAILP S HLMAILN=$P(^XMB(3.8,HLMAILP,0),U)
"RTN","HLCS2",167,0)
 S HLPRGCMP=$P(HLX4,U),HLPRGAA=$P(HLX4,U,2),HLPRGALL=$P(HLX4,U,3)
"RTN","HLCS2",168,0)
 S HLDEFRET=$P(HLX5,U)
"RTN","HLCS2",169,0)
 S HLPARAM=HLDOMP_U_$G(HLDOMN)_U_$G(HLPROD)_U_HLINSP_U_$G(HLINSN)_U_$G(HLINSNM)_U_HLMAILP_U_$G(HLMAILN)_U_HLPRGCMP_U_HLPRGAA_U_HLPRGALL_U_HLDEFRET
"RTN","HLCS2",170,0)
 Q HLPARAM
"RTN","HLCS2",171,0)
 ;
"RTN","HLCS2",172,0)
GETAPP(HLAPP) ;Function to Retrieve parameters pertaining to a specific sending or receiving application
"RTN","HLCS2",173,0)
 ;HLAPP=APPLICATION NAME OR IEN OF FILE 771
"RTN","HLCS2",174,0)
 ;Returns MAIL GROUP NAME^'a' or 'i' (active or inactive) 
"RTN","HLCS2",175,0)
 S HLAPP=$G(HLAPP)
"RTN","HLCS2",176,0)
 I HLAPP]"",'HLAPP S HLAPP=$O(^HL(771,"B",$E(HLAPP,1,30),0))
"RTN","HLCS2",177,0)
 I 'HLAPP Q ""
"RTN","HLCS2",178,0)
 I HLAPP S HLM=$P(^HL(771,HLAPP,0),U,4)
"RTN","HLCS2",179,0)
 I HLM S HLM=$P($G(^XMB(3.8,HLM,0)),U)
"RTN","HLCS2",180,0)
 Q $G(HLM)_U_$P(^HL(771,HLAPP,0),U,2)
"RTN","HLCSGTM")
0^15^B2303330^n/a
"RTN","HLCSGTM",1,0)
HLCSGTM ;OIFO-O/RWF - (TCP/IP) GT.M Linux ;08/13/2007
"RTN","HLCSGTM",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**122**;Oct 13, 1995;Build 14
"RTN","HLCSGTM",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLCSGTM",4,0)
 ;
"RTN","HLCSGTM",5,0)
 ; 1. port number is input from VMS COM file, such as HLSxxxxDSM.COM,
"RTN","HLCSGTM",6,0)
 ;    HLSxxxxCACHE.COM, or HLSxxxxGTM.COM file, where xxxx is port
"RTN","HLCSGTM",7,0)
 ;    number.
"RTN","HLCSGTM",8,0)
 ; 2. find the ien of #870(logical link file) for the multi-listener
"RTN","HLCSGTM",9,0)
 Q
"RTN","HLCSGTM",10,0)
 ;
"RTN","HLCSGTM",11,0)
IEN(HLPORT) ;
"RTN","HLCSGTM",12,0)
 ; HLIEN870: ien in #870 (logical link file)
"RTN","HLCSGTM",13,0)
 ; HLPRTS: port number in entry to be tested
"RTN","HLCSGTM",14,0)
 ;
"RTN","HLCSGTM",15,0)
 N HLPRTS,HLIEN870
"RTN","HLCSGTM",16,0)
 I '$G(HLPORT) D ^%ZTER Q
"RTN","HLCSGTM",17,0)
 S HLIEN870=0
"RTN","HLCSGTM",18,0)
 F  S HLIEN870=$O(^HLCS(870,"E","M",HLIEN870)) Q:'HLIEN870  D  Q:(HLPRTS=HLPORT)
"RTN","HLCSGTM",19,0)
 . S HLPRTS=$P(^HLCS(870,HLIEN870,400),"^",2)
"RTN","HLCSGTM",20,0)
 I 'HLIEN870 D ^%ZTER Q
"RTN","HLCSGTM",21,0)
 ;
"RTN","HLCSGTM",22,0)
 Q HLIEN870
"RTN","HLCSGTM",23,0)
 ;
"RTN","HLCSGTM",24,0)
GTMLNX ; From Linux xinetd script
"RTN","HLCSGTM",25,0)
 ;Get port from ZSHOW "D"
"RTN","HLCSGTM",26,0)
 S U="^",$ZT="",$ET="D ^%ZTER HALT" ;Setup the error trap
"RTN","HLCSGTM",27,0)
 ; GTM specific code
"RTN","HLCSGTM",28,0)
 S IO=$P X "U IO:(nowrap:nodelimiter:IOERROR=""TRAP"")" ;Setup device
"RTN","HLCSGTM",29,0)
 S @("$ZINTERRUPT=""I $$JOBEXAM^ZU($ZPOSITION)""")
"RTN","HLCSGTM",30,0)
 K ^TMP($J) ZSHOW "D":^TMP($J)
"RTN","HLCSGTM",31,0)
 F %=1:1 Q:'$D(^TMP($J,"D",%))  S X=^(%) Q:X["LOCAL"
"RTN","HLCSGTM",32,0)
 S IO("IP")=$P($P(X,"REMOTE=",2),"@"),IO("PORT")=+$P($P(X,"LOCAL=",2),"@",2)
"RTN","HLCSGTM",33,0)
 S %=$P($ZTRNLNM("SSH_CLIENT")," ") S:%="" %=$ZTRNLNM("REMOTEHOST")
"RTN","HLCSGTM",34,0)
 S HLDP=$$IEN(IO("PORT"))
"RTN","HLCSGTM",35,0)
 ;
"RTN","HLCSGTM",36,0)
 D LISTEN^HLCSTCP
"RTN","HLCSGTM",37,0)
 Q
"RTN","HLCSGTM",38,0)
 ;
"RTN","HLCSGTM",39,0)
 ;Sample Linux script
"RTN","HLCSGTM",40,0)
 ;#!/bin/bash
"RTN","HLCSGTM",41,0)
 ;#HL7 Listener
"RTN","HLCSGTM",42,0)
 ;cd /home/vista/dev/
"RTN","HLCSGTM",43,0)
 ;. ./gtmprofile
"RTN","HLCSGTM",44,0)
 ;#env > hl7log.txt
"RTN","HLCSGTM",45,0)
 ;$gtm_dist/mumps -r GTMLNX^HLCSGTM
"RTN","HLCSGTM",46,0)
 ;exit 0
"RTN","HLCSGTM",47,0)
 ;
"RTN","HLCSGTM",48,0)
 ;Sample xinetd config file
"RTN","HLCSGTM",49,0)
 ;service hl7tcp
"RTN","HLCSGTM",50,0)
 ;{
"RTN","HLCSGTM",51,0)
 ;        socket_type     = stream
"RTN","HLCSGTM",52,0)
 ;        user            = gtmuser
"RTN","HLCSGTM",53,0)
 ;        wait            = no
"RTN","HLCSGTM",54,0)
 ;        disable         = no
"RTN","HLCSGTM",55,0)
 ;        server          = /bin/bash
"RTN","HLCSGTM",56,0)
 ;        server_args     = -l /home/vista/dev/hl7tcp.sh
"RTN","HLCSGTM",57,0)
 ;        passenv         = REMOTE_HOST
"RTN","HLCSGTM",58,0)
 ;}
"RTN","HLCSHDR1")
0^29^B59513881^B57541761
"RTN","HLCSHDR1",1,0)
HLCSHDR1 ;SFIRMFO/RSD - Make HL7 header for TCP ;04/17/2007
"RTN","HLCSHDR1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**19,57,59,72,80,93,120,133,122**;Oct 13, 1995;Build 14
"RTN","HLCSHDR1",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLCSHDR1",4,0)
HEADER(IEN,CLIENT,HLERROR) ; Create an HL7 MSH segment
"RTN","HLCSHDR1",5,0)
 ;
"RTN","HLCSHDR1",6,0)
 ;Input  : IEN - Pointer to entry in Message Administration file (#773)
"RTN","HLCSHDR1",7,0)
 ;               that HL7 MSH segment is being built for
"RTN","HLCSHDR1",8,0)
 ;         CLIENT - IEN of the receiving application
"RTN","HLCSHDR1",9,0)
 ;         HLERROR - Variable to return possible error text in
"RTN","HLCSHDR1",10,0)
 ;                   (pass by reference - only used when needed)
"RTN","HLCSHDR1",11,0)
 ;
"RTN","HLCSHDR1",12,0)
 ;Output : HLHDR(1) - HL7 MSH segment
"RTN","HLCSHDR1",13,0)
 ;         HLHDR(2) - Continuation of HL7 MSH segment (if needed)
"RTN","HLCSHDR1",14,0)
 ;         HLHDR(3) - Continuation of HL7 MSH segment (if needed)
"RTN","HLCSHDR1",15,0)
 ;
"RTN","HLCSHDR1",16,0)
 ;Notes  : HLERROR will only be defined [on output] if an error occurs
"RTN","HLCSHDR1",17,0)
 ;       : HLHDR() will not be defined [on output] if an error occurs
"RTN","HLCSHDR1",18,0)
 ;       : HLHDR(2) & HLHDR(3) are continuation [or roll-over] nodes
"RTN","HLCSHDR1",19,0)
 ;         and will only be used/defined when needed
"RTN","HLCSHDR1",20,0)
 ;
"RTN","HLCSHDR1",21,0)
 N ACKTO,ACCACK,APPACK,CHILD,CLNTAPP,CLNTFAC,CNTRY,EC,EVNTYPE,FS,HLDATE,HLHDRI,HLHDRL,HLID,HLPID,MSGTYPE,PROT,PROTS,SECURITY,SEND,SERAPP,SERFAC,TXTP,TXTP0,X,MSGEVN
"RTN","HLCSHDR1",22,0)
 N COMFLAG ; patch HL*1.6*120
"RTN","HLCSHDR1",23,0)
 S HLERROR=""
"RTN","HLCSHDR1",24,0)
 S HLPARAM=$$PARAM^HLCS2
"RTN","HLCSHDR1",25,0)
 D VAR Q:$G(HLERROR)]""
"RTN","HLCSHDR1",26,0)
 ; The following line commented by HL*1.6*72
"RTN","HLCSHDR1",27,0)
 ;I $D(^HLMA(IEN)) S $P(^HLMA(IEN,0),U,13)=MSGTYPE,$P(^HLMA(IEN,0),U,14)=$G(EVNTYPE)
"RTN","HLCSHDR1",28,0)
 ;Append event type
"RTN","HLCSHDR1",29,0)
 I $G(EVNTYPE)]"" S MSGTYPE=MSGTYPE_$E(EC,1)_EVNTYPE
"RTN","HLCSHDR1",30,0)
 ;Append message structure component
"RTN","HLCSHDR1",31,0)
 I $G(EVNTYPE)]"",$G(MSGEVN)]"" S MSGTYPE=MSGTYPE_$E(EC,1)_MSGEVN
"RTN","HLCSHDR1",32,0)
 ;Build MSH array
"RTN","HLCSHDR1",33,0)
 D RESET^HLCSHDR3 ;HL*1.6*93
"RTN","HLCSHDR1",34,0)
 ;
"RTN","HLCSHDR1",35,0)
 ; patch HL*1.6*120 start
"RTN","HLCSHDR1",36,0)
 ; escape delimiters for SERAPP and CLNTAPP
"RTN","HLCSHDR1",37,0)
 ; escape component separator if the field is not consisted
"RTN","HLCSHDR1",38,0)
 ; of 3 components
"RTN","HLCSHDR1",39,0)
 S EC(1)=$E(EC,1)
"RTN","HLCSHDR1",40,0)
 S EC(2)=$E(EC,2)
"RTN","HLCSHDR1",41,0)
 S EC(3)=$E(EC,3)
"RTN","HLCSHDR1",42,0)
 S EC(4)=$E(EC,4)
"RTN","HLCSHDR1",43,0)
 S COMFLAG=1
"RTN","HLCSHDR1",44,0)
 I $L(SERAPP,$E(EC,1))=3 S COMFLAG=0
"RTN","HLCSHDR1",45,0)
 I (SERAPP[FS)!(SERAPP[EC(1))!(SERAPP[EC(2))!(SERAPP[EC(3))!(SERAPP[EC(4)) D
"RTN","HLCSHDR1",46,0)
 . S SERAPP=$$ESCAPE(SERAPP,COMFLAG)
"RTN","HLCSHDR1",47,0)
 S COMFLAG=1
"RTN","HLCSHDR1",48,0)
 I $L(CLNTAPP,$E(EC,1))=3 S COMFLAG=0
"RTN","HLCSHDR1",49,0)
 I (CLNTAPP[FS)!(CLNTAPP[EC(1))!(CLNTAPP[EC(2))!(CLNTAPP[EC(3))!(CLNTAPP[EC(4)) D
"RTN","HLCSHDR1",50,0)
 . S CLNTAPP=$$ESCAPE(CLNTAPP,COMFLAG)
"RTN","HLCSHDR1",51,0)
 ; patch HL*1.6*120 end
"RTN","HLCSHDR1",52,0)
 ;
"RTN","HLCSHDR1",53,0)
 S HLHDRI=1,HLHDR(1)="MSH"_FS_EC_FS_SERAPP,HLHDRL=$L(HLHDR(1))
"RTN","HLCSHDR1",54,0)
 F X=SERFAC,CLNTAPP,CLNTFAC,HLDATE,SECURITY,MSGTYPE,HLID,HLPID,$P(PROT,U,9),"",$G(^HL(772,TXTP,1)),ACCACK,APPACK,CNTRY D MSH(X)
"RTN","HLCSHDR1",55,0)
 ;in preceeding line, "" is for sequence number - not supported
"RTN","HLCSHDR1",56,0)
 Q
"RTN","HLCSHDR1",57,0)
 ;
"RTN","HLCSHDR1",58,0)
MSH(X) ;add X to HLHDR
"RTN","HLCSHDR1",59,0)
 S:HLHDRL+$L(X)>245 HLHDRI=HLHDRI+1,HLHDR(HLHDRI)=""
"RTN","HLCSHDR1",60,0)
 S HLHDR(HLHDRI)=HLHDR(HLHDRI)_FS_X,HLHDRL=$L(HLHDR(HLHDRI))
"RTN","HLCSHDR1",61,0)
 Q
"RTN","HLCSHDR1",62,0)
BHSHDR(IEN,CLIENT,HLERROR) ; Create Batch Header Segment
"RTN","HLCSHDR1",63,0)
 ; The BHS has 12 segments, of which 4 are blank.
"RTN","HLCSHDR1",64,0)
 ; INPUT: IEN - IEN of entry in file #772
"RTN","HLCSHDR1",65,0)
 ; OUTPUT: HLHDR(1) and HLHDR(2) - the two lines with the 12 segs.
"RTN","HLCSHDR1",66,0)
 ;   ready for adding to a message directly.
"RTN","HLCSHDR1",67,0)
 N ACKTO,ACCACK,ACKMID,APPACK,BNAME,BSTATUS,BTACK,CHILD,CLNTAPP ;HL*1.6*80
"RTN","HLCSHDR1",68,0)
 N CLNTFAC,CNTRY,EC,EVNTYPE,FS,HLDATE,HLHDRI,HLHDRL,HLID,HLPID ;HL*1.6*80 - added HLPID
"RTN","HLCSHDR1",69,0)
 N PROT,PROTS,SECURITY,SEND,SERAPP,SERFAC,TXTP,TXTP0,X ;HL*1.6*80
"RTN","HLCSHDR1",70,0)
 N COMFLAG ; patch HL*1.6*120
"RTN","HLCSHDR1",71,0)
 S HLERROR=""
"RTN","HLCSHDR1",72,0)
 ;
"RTN","HLCSHDR1",73,0)
 S HLPARAM=$$PARAM^HLCS2
"RTN","HLCSHDR1",74,0)
 D VAR Q:$G(HLERROR)]""
"RTN","HLCSHDR1",75,0)
 ; The following line commented by HL*1.6*72
"RTN","HLCSHDR1",76,0)
 ;I $D(^HLMA(IEN)) S $P(^HLMA(IEN,0),U,13)=MSGTYPE,$P(^HLMA(IEN,0),U,14)=$G(EVNTYPE)
"RTN","HLCSHDR1",77,0)
 ;
"RTN","HLCSHDR1",78,0)
 ;Append event type
"RTN","HLCSHDR1",79,0)
 I $G(EVNTYPE)]"" S MSGTYPE=MSGTYPE_$E(EC,2)_EVNTYPE,(ACKMID,BTACK)=""
"RTN","HLCSHDR1",80,0)
 ;batch/name/id/type(#9)=null~process ID~msg type|evnt type~version~CA~AA
"RTN","HLCSHDR1",81,0)
 S BNAME=$E(EC,1)_HLPID_$E(EC,1)_MSGTYPE_$E(EC,1)_$P(PROT,U,9)_$E(EC,1)_ACCACK_$E(EC,1)_APPACK ;HL*1.6*80
"RTN","HLCSHDR1",82,0)
 ;for batch ACK
"RTN","HLCSHDR1",83,0)
 I ACKTO D  S BTACK=X_$E(EC,1)_$P(BSTATUS,U,3)
"RTN","HLCSHDR1",84,0)
 . ;get msg id and status of message that is being ACKed
"RTN","HLCSHDR1",85,0)
 . S ACKMID=$P($G(^HLMA(ACKTO,0)),U,2),BSTATUS=$G(^HLMA(ACKTO,"P")) ;HL*1.6*80
"RTN","HLCSHDR1",86,0)
 . ;set type of ACK based on status
"RTN","HLCSHDR1",87,0)
 . S X=$S(ACKMID="":"AR",(BSTATUS>3)&(BSTATUS<8):"AE",1:"AA")
"RTN","HLCSHDR1",88,0)
 ;
"RTN","HLCSHDR1",89,0)
 D RESET^HLCSHDR3 ;HL*1.6*93
"RTN","HLCSHDR1",90,0)
 ;
"RTN","HLCSHDR1",91,0)
 ; patch HL*1.6*120 start
"RTN","HLCSHDR1",92,0)
 ; escape delimiters for SERAPP and CLNTAPP
"RTN","HLCSHDR1",93,0)
 ; escape component separator if the field is not consisted
"RTN","HLCSHDR1",94,0)
 ; of 3 components
"RTN","HLCSHDR1",95,0)
 S EC(1)=$E(EC,1)
"RTN","HLCSHDR1",96,0)
 S EC(2)=$E(EC,2)
"RTN","HLCSHDR1",97,0)
 S EC(3)=$E(EC,3)
"RTN","HLCSHDR1",98,0)
 S EC(4)=$E(EC,4)
"RTN","HLCSHDR1",99,0)
 S COMFLAG=1
"RTN","HLCSHDR1",100,0)
 I $L(SERAPP,$E(EC,1))=3 S COMFLAG=0
"RTN","HLCSHDR1",101,0)
 I (SERAPP[FS)!(SERAPP[EC(1))!(SERAPP[EC(2))!(SERAPP[EC(3))!(SERAPP[EC(4)) D
"RTN","HLCSHDR1",102,0)
 . S SERAPP=$$ESCAPE(SERAPP,COMFLAG)
"RTN","HLCSHDR1",103,0)
 S COMFLAG=1
"RTN","HLCSHDR1",104,0)
 I $L(CLNTAPP,$E(EC,1))=3 S COMFLAG=0
"RTN","HLCSHDR1",105,0)
 I (CLNTAPP[FS)!(CLNTAPP[EC(1))!(CLNTAPP[EC(2))!(CLNTAPP[EC(3))!(CLNTAPP[EC(4)) D
"RTN","HLCSHDR1",106,0)
 . S CLNTAPP=$$ESCAPE(CLNTAPP,COMFLAG)
"RTN","HLCSHDR1",107,0)
 ; patch HL*1.6*120 end
"RTN","HLCSHDR1",108,0)
 ;
"RTN","HLCSHDR1",109,0)
 S HLHDRI=1,HLHDR(1)="BHS"_FS_EC_FS_SERAPP,HLHDRL=$L(HLHDR(1))
"RTN","HLCSHDR1",110,0)
 F X=SERFAC,CLNTAPP,CLNTFAC,HLDATE,SECURITY,BNAME,BTACK,HLID,ACKMID D MSH(X)
"RTN","HLCSHDR1",111,0)
 Q
"RTN","HLCSHDR1",112,0)
VAR ;Check input
"RTN","HLCSHDR1",113,0)
 N APPPRM,HLPROTS,HLPROT
"RTN","HLCSHDR1",114,0)
 S IEN=+$G(IEN)
"RTN","HLCSHDR1",115,0)
 I '$G(^HLMA(IEN,0)) S HLERROR="Valid pointer to Message Administration file (#772) not passed" Q
"RTN","HLCSHDR1",116,0)
 I '$G(CLIENT) S HLERROR="Could not determine receiving application" Q
"RTN","HLCSHDR1",117,0)
 ;Get child, text pointer,text entry, and sending app.
"RTN","HLCSHDR1",118,0)
 S CHILD=$G(^HLMA(IEN,0)),SEND=+$P($G(^(0)),U,11),TXTP=+CHILD,TXTP0=$G(^HL(772,TXTP,0))
"RTN","HLCSHDR1",119,0)
 I ('SEND) S HLERROR="Could not determine sending application" Q
"RTN","HLCSHDR1",120,0)
 ;Get info for sending & receiving applications
"RTN","HLCSHDR1",121,0)
 D APPPRM^HLUTIL2(CLIENT),APPPRM^HLUTIL2(SEND)
"RTN","HLCSHDR1",122,0)
 ;Get name of sending application, facility, and country
"RTN","HLCSHDR1",123,0)
 S SERAPP=$P(APPPRM(SEND,0),U),SERFAC=$P(APPPRM(SEND,0),U,2),CNTRY=$P(APPPRM(SEND,0),U,3)
"RTN","HLCSHDR1",124,0)
 ;Get name of receiving application and facility
"RTN","HLCSHDR1",125,0)
 S CLNTAPP=$P(APPPRM(CLIENT,0),U),CLNTFAC=$P(APPPRM(CLIENT,0),U,2)
"RTN","HLCSHDR1",126,0)
 ;
"RTN","HLCSHDR1",127,0)
 ; patch HL*1.6*120
"RTN","HLCSHDR1",128,0)
 ; for dynamic addressing, overide the receiving facility from the
"RTN","HLCSHDR1",129,0)
 ; 3rd component of HLL("LINKS") array
"RTN","HLCSHDR1",130,0)
 I $G(HLP("REC-FACILITY"))]"" S CLNTFAC=HLP("REC-FACILITY")
"RTN","HLCSHDR1",131,0)
 ;
"RTN","HLCSHDR1",132,0)
 ;Get field separator & encoding characters
"RTN","HLCSHDR1",133,0)
 S FS=APPPRM(SEND,"FS"),EC=APPPRM(SEND,"EC")
"RTN","HLCSHDR1",134,0)
 S:(EC="") EC="~|\&" S:(FS="") FS="^"
"RTN","HLCSHDR1",135,0)
 ;Determine if it's a response/ACK to another message
"RTN","HLCSHDR1",136,0)
 S ACKTO=+$P(CHILD,U,10)
"RTN","HLCSHDR1",137,0)
 ;subscriber protocol is from child (file 773)
"RTN","HLCSHDR1",138,0)
 ;If response, get MType from subscriber
"RTN","HLCSHDR1",139,0)
 S HLPROTS=+$P(CHILD,U,8)
"RTN","HLCSHDR1",140,0)
 S PROTS=$$TYPE^HLUTIL2(HLPROTS)
"RTN","HLCSHDR1",141,0)
 I ACKTO S MSGTYPE=$P(PROTS,U,10),EVNTYPE=$P(PROTS,U,3),MSGEVN=$P(PROTS,U,4)
"RTN","HLCSHDR1",142,0)
 ;Get accept ack & application ack type (based on server protocol) it
"RTN","HLCSHDR1",143,0)
 ; is always in file 772, TXPT0
"RTN","HLCSHDR1",144,0)
 ;If original message, get MT from Event Driver Protocol
"RTN","HLCSHDR1",145,0)
 S HLPROT=+$P(TXTP0,U,10)
"RTN","HLCSHDR1",146,0)
 S PROT=$$TYPE^HLUTIL2(HLPROT)
"RTN","HLCSHDR1",147,0)
 S:'ACKTO MSGTYPE=$P(PROT,U,2),EVNTYPE=$P(PROT,U,3),MSGEVN=$P(PROT,U,4)
"RTN","HLCSHDR1",148,0)
 S ACCACK=$P(PROT,U,7),APPACK=$P(PROT,U,8)
"RTN","HLCSHDR1",149,0)
 ;
"RTN","HLCSHDR1",150,0)
 ; patch HL*1.6*122
"RTN","HLCSHDR1",151,0)
 ; setting the MSH-15 and MSH-16 from subscriber protocol
"RTN","HLCSHDR1",152,0)
 I HLPROTS,$P($G(^ORD(101,HLPROTS,773)),"^",5) D
"RTN","HLCSHDR1",153,0)
 . S ACCACK=$P(PROTS,U,7)
"RTN","HLCSHDR1",154,0)
 . S APPACK=$P(PROTS,U,8)
"RTN","HLCSHDR1",155,0)
 ;
"RTN","HLCSHDR1",156,0)
PID ;Processing ID
"RTN","HLCSHDR1",157,0)
 ;I PID not 'debug' get from site params
"RTN","HLCSHDR1",158,0)
 ;If event driver set to 'debug' get from protocol
"RTN","HLCSHDR1",159,0)
 ;'production' or 'training' comes from site params
"RTN","HLCSHDR1",160,0)
 S HLPID=$P(PROT,U,5)
"RTN","HLCSHDR1",161,0)
 I $G(HLPID)'="D" S HLPID=$P(HLPARAM,U,3)
"RTN","HLCSHDR1",162,0)
 ;
"RTN","HLCSHDR1",163,0)
 ; patch HL*1.6*120: to include processing mode
"RTN","HLCSHDR1",164,0)
 I $G(HLP("PMOD"))]"",($G(HLTYPE)="M") D
"RTN","HLCSHDR1",165,0)
 . S HLPID=HLPID_$E($G(EC),1)_HLP("PMOD")
"RTN","HLCSHDR1",166,0)
 ;
"RTN","HLCSHDR1",167,0)
 I $G(HLPID)="" S HLERROR="Missing processing ID Site parameter."
"RTN","HLCSHDR1",168,0)
 ;acknowledgements have no application ack, link open no commit ack
"RTN","HLCSHDR1",169,0)
 I ACKTO S:APPACK]"" APPACK="NE" S:ACCACK]""&$G(HLTCPO) ACCACK="NE"
"RTN","HLCSHDR1",170,0)
 ;Get date/time, Message ID, and security
"RTN","HLCSHDR1",171,0)
 S HLDATE=+TXTP0,HLDATE=$$FMTHL7^XLFDT(HLDATE),HLID=$P(CHILD,U,2),SECURITY=$P(CHILD,U,9)
"RTN","HLCSHDR1",172,0)
HDR23 ;generate extended facility field info based on 'facility required'
"RTN","HLCSHDR1",173,0)
 ;default format is INSTITUTION_HLCS_DOMAIN_HLCS_'DNS'
"RTN","HLCSHDR1",174,0)
 ;application parameter entry overrides default
"RTN","HLCSHDR1",175,0)
 N HLEP773,HLS773
"RTN","HLCSHDR1",176,0)
 S SERFAC=$G(SERFAC),CLNTFAC=$G(CLNTFAC)
"RTN","HLCSHDR1",177,0)
 S HLEP773=+$G(^ORD(101,HLPROTS,773))
"RTN","HLCSHDR1",178,0)
 S HLS773=+$P($G(^ORD(101,HLPROTS,773)),U,2)
"RTN","HLCSHDR1",179,0)
 Q:'HLEP773&('HLS773)
"RTN","HLCSHDR1",180,0)
 D GEN^HLCSHDR2
"RTN","HLCSHDR1",181,0)
 I ACKTO D  Q
"RTN","HLCSHDR1",182,0)
 .;Find original message
"RTN","HLCSHDR1",183,0)
 .S X=$G(^HLMA(ACKTO,"MSH",1,0)) ;Find header in TCP nodes
"RTN","HLCSHDR1",184,0)
 .I X["MSH" D
"RTN","HLCSHDR1",185,0)
 ..;
"RTN","HLCSHDR1",186,0)
 ..; patch HL*1.6*120 start
"RTN","HLCSHDR1",187,0)
 .. N HLEC
"RTN","HLCSHDR1",188,0)
 ..S HLFS=$E(X,4),HLEC=$E(X,5)
"RTN","HLCSHDR1",189,0)
 ..S SENDFAC=$P(X,HLFS,4),RECFAC=$P(X,HLFS,6) ;from original msg
"RTN","HLCSHDR1",190,0)
 ..S CLNTFAC=SENDFAC,SERFAC=RECFAC ;reverse facility info
"RTN","HLCSHDR1",191,0)
 ..S EC("COMPONENT")=$E($G(EC),1)
"RTN","HLCSHDR1",192,0)
 ..I $L(EC("COMPONENT"))=1,$L(HLEC)=1,EC("COMPONENT")'=HLEC D
"RTN","HLCSHDR1",193,0)
 ... ; change the the component separator in the sending and
"RTN","HLCSHDR1",194,0)
 ... ; receiving facilities for the outgoing message
"RTN","HLCSHDR1",195,0)
 ... S CLNTFAC=$TR(CLNTFAC,HLEC,EC("COMPONENT"))
"RTN","HLCSHDR1",196,0)
 ... S SERFAC=$TR(SERFAC,HLEC,EC("COMPONENT"))
"RTN","HLCSHDR1",197,0)
 ; patch HL*1.6*120 end
"RTN","HLCSHDR1",198,0)
 ;
"RTN","HLCSHDR1",199,0)
 I HLEP773,SERFAC="" D EP^HLCSHDR2
"RTN","HLCSHDR1",200,0)
 I HLS773,CLNTFAC="" D S^HLCSHDR2
"RTN","HLCSHDR1",201,0)
 Q
"RTN","HLCSHDR1",202,0)
 ;
"RTN","HLCSHDR1",203,0)
ESCAPE(INPUT,COMPONET) ;
"RTN","HLCSHDR1",204,0)
 ; patch HL*1.6*120 - escape delimiters:
"RTN","HLCSHDR1",205,0)
 ; - field separator
"RTN","HLCSHDR1",206,0)
 ; - component separator
"RTN","HLCSHDR1",207,0)
 ; - repetition separator
"RTN","HLCSHDR1",208,0)
 ; - escape character
"RTN","HLCSHDR1",209,0)
 ; - subcomponent separator
"RTN","HLCSHDR1",210,0)
 ;
"RTN","HLCSHDR1",211,0)
 ; input: 
"RTN","HLCSHDR1",212,0)
 ;     INPUT - string data to be escaped
"RTN","HLCSHDR1",213,0)
 ;  COMPONET - if 1, escape component separator
"RTN","HLCSHDR1",214,0)
 ;             if 0, do not escape component separator
"RTN","HLCSHDR1",215,0)
 ;        FS - field separator character
"RTN","HLCSHDR1",216,0)
 ;        EC - encoding characters 
"RTN","HLCSHDR1",217,0)
 ; result: return the escaped string
"RTN","HLCSHDR1",218,0)
 ;
"RTN","HLCSHDR1",219,0)
 N HLDATA,HLESCAPE,HLI,HLCHAR,HLEN,HLOUT,COMFLAG
"RTN","HLCSHDR1",220,0)
 S HLDATA=$G(INPUT)
"RTN","HLCSHDR1",221,0)
 S COMFLAG=$G(COMPONET)
"RTN","HLCSHDR1",222,0)
 Q:$L($G(FS))'=1 HLDATA
"RTN","HLCSHDR1",223,0)
 ;
"RTN","HLCSHDR1",224,0)
 ; patch HL*1.6*133
"RTN","HLCSHDR1",225,0)
 ; Q:$L($G(EC))'=4 HLDATA
"RTN","HLCSHDR1",226,0)
 Q:($L($G(EC))<3) HLDATA
"RTN","HLCSHDR1",227,0)
 Q:HLDATA']"" HLDATA
"RTN","HLCSHDR1",228,0)
 ;
"RTN","HLCSHDR1",229,0)
 S HLESCAPE=FS_EC
"RTN","HLCSHDR1",230,0)
 S HLESCAPE("F")=FS
"RTN","HLCSHDR1",231,0)
 S HLESCAPE("S")=$E(EC,1)
"RTN","HLCSHDR1",232,0)
 S HLESCAPE("R")=$E(EC,2)
"RTN","HLCSHDR1",233,0)
 S HLESCAPE("E")=$E(EC,3)
"RTN","HLCSHDR1",234,0)
 S HLESCAPE("T")=$E(EC,4)
"RTN","HLCSHDR1",235,0)
 S HLEN=$L(HLDATA)
"RTN","HLCSHDR1",236,0)
 S HLOUT=""
"RTN","HLCSHDR1",237,0)
 F HLI=1:1:HLEN D
"RTN","HLCSHDR1",238,0)
 . S HLCHAR=$E(HLDATA,HLI)
"RTN","HLCSHDR1",239,0)
 . I HLESCAPE[HLCHAR D  Q
"RTN","HLCSHDR1",240,0)
 .. I HLCHAR=HLESCAPE("F") S HLOUT=HLOUT_HLESCAPE("E")_"F"_HLESCAPE("E") Q
"RTN","HLCSHDR1",241,0)
 .. I HLCHAR=HLESCAPE("S") D  Q
"RTN","HLCSHDR1",242,0)
 ... I COMFLAG=1 S HLOUT=HLOUT_HLESCAPE("E")_"S"_HLESCAPE("E") Q
"RTN","HLCSHDR1",243,0)
 ... S HLOUT=HLOUT_HLCHAR
"RTN","HLCSHDR1",244,0)
 .. I HLCHAR=HLESCAPE("R") S HLOUT=HLOUT_HLESCAPE("E")_"R"_HLESCAPE("E") Q
"RTN","HLCSHDR1",245,0)
 .. I HLCHAR=HLESCAPE("E") S HLOUT=HLOUT_HLESCAPE("E")_"E"_HLESCAPE("E") Q
"RTN","HLCSHDR1",246,0)
 .. I HLCHAR=HLESCAPE("T") S HLOUT=HLOUT_HLESCAPE("E")_"T"_HLESCAPE("E") Q
"RTN","HLCSHDR1",247,0)
 . ;
"RTN","HLCSHDR1",248,0)
 . S HLOUT=HLOUT_HLCHAR
"RTN","HLCSHDR1",249,0)
 Q HLOUT
"RTN","HLCSHDR4")
0^28^B78131935^B76569108
"RTN","HLCSHDR4",1,0)
HLCSHDR4 ;SFIRMFO/LJA - Reset MSH Segment Fields ;10/09/2007 15:05
"RTN","HLCSHDR4",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**93,108,122**;Oct 13, 1995;Build 14
"RTN","HLCSHDR4",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified
"RTN","HLCSHDR4",4,0)
 ;
"RTN","HLCSHDR4",5,0)
DEBUG(STORE) ; If HLP set up for debugging, capture VIEW...
"RTN","HLCSHDR4",6,0)
 ; HLMSH773 -- req
"RTN","HLCSHDR4",7,0)
 ;
"RTN","HLCSHDR4",8,0)
 N NOW,NUM,VAR,VARS,X,XTMP
"RTN","HLCSHDR4",9,0)
 ;
"RTN","HLCSHDR4",10,0)
 ; 1=some, 2=all
"RTN","HLCSHDR4",11,0)
 S STORE=$S(STORE=1:1,STORE=2:2,1:0) QUIT:'STORE  ;->
"RTN","HLCSHDR4",12,0)
 ;
"RTN","HLCSHDR4",13,0)
 S NOW=$$NOW^XLFDT
"RTN","HLCSHDR4",14,0)
 ;
"RTN","HLCSHDR4",15,0)
 S XTMP="HLCSHDR3 "_HLMSH773
"RTN","HLCSHDR4",16,0)
 S:'$D(^XTMP(XTMP,0)) ^XTMP(XTMP,0)=$$FMADD^XLFDT(NOW,0,4)_U_NOW_U_"Debug data created by DEBUG~HLCSHDR4"
"RTN","HLCSHDR4",17,0)
 ;
"RTN","HLCSHDR4",18,0)
 S NUM=$O(^XTMP(XTMP,":"),-1)+1
"RTN","HLCSHDR4",19,0)
 ;
"RTN","HLCSHDR4",20,0)
 ; Grab only critical (some) variables?
"RTN","HLCSHDR4",21,0)
 I STORE=1 D
"RTN","HLCSHDR4",22,0)
 .
"RTN","HLCSHDR4",23,0)
 .  ; Sending information...
"RTN","HLCSHDR4",24,0)
 .  S ^XTMP(XTMP,NUM,"SA")=HLMSHSAO_U_HLSAN_U_HLMSHSAN
"RTN","HLCSHDR4",25,0)
 .  S ^XTMP(XTMP,NUM,"SF")=HLMSHSFO_U_HLSFN_U_HLMSHSFN
"RTN","HLCSHDR4",26,0)
 .
"RTN","HLCSHDR4",27,0)
 .  ; Receiving information...
"RTN","HLCSHDR4",28,0)
 .  S ^XTMP(XTMP,NUM,"RA")=HLMSHRAO_U_HLRAN_U_HLMSHRAN
"RTN","HLCSHDR4",29,0)
 .  S ^XTMP(XTMP,NUM,"RF")=HLMSHRFO_U_HLRFN_U_HLMSHRFN
"RTN","HLCSHDR4",30,0)
 .
"RTN","HLCSHDR4",31,0)
 .  ; Other information...    (HLMSHPRE and HLMSHPRS hold 2 pieces!)
"RTN","HLCSHDR4",32,0)
 .  S ^XTMP(XTMP,NUM,0)=NOW_U_HLMSH772_U_HLMSHPRE_U_HLMSHPRS
"RTN","HLCSHDR4",33,0)
 .  S ^XTMP(XTMP,NUM,1)=HLMSHPRO
"RTN","HLCSHDR4",34,0)
 ;
"RTN","HLCSHDR4",35,0)
 ; Grab all variables?
"RTN","HLCSHDR4",36,0)
 I STORE=2 D
"RTN","HLCSHDR4",37,0)
 .  S X="^XTMP("""_XTMP_""","_NUM_","
"RTN","HLCSHDR4",38,0)
 .  D DOLRO^%ZOSV
"RTN","HLCSHDR4",39,0)
 ;
"RTN","HLCSHDR4",40,0)
 QUIT
"RTN","HLCSHDR4",41,0)
 ;
"RTN","HLCSHDR4",42,0)
SHOW N I773
"RTN","HLCSHDR4",43,0)
 F  R !!,"Enter 773 IEN: ",I773:60 Q:I773'>0  D
"RTN","HLCSHDR4",44,0)
 .  D SHOW773(I773)
"RTN","HLCSHDR4",45,0)
 QUIT
"RTN","HLCSHDR4",46,0)
 ;
"RTN","HLCSHDR4",47,0)
SHOW773(I773) ; Show Dynamic Routing MSH Field Reset Details
"RTN","HLCSHDR4",48,0)
 N DIV,MSH,N90,N91
"RTN","HLCSHDR4",49,0)
 ;
"RTN","HLCSHDR4",50,0)
 S N90=$G(^HLMA(+I773,90)),N91=$G(^HLMA(+I773,91))
"RTN","HLCSHDR4",51,0)
 I (N90_N91)']"" D  QUIT  ;->
"RTN","HLCSHDR4",52,0)
 .  W "  no debug data found..."
"RTN","HLCSHDR4",53,0)
 ;
"RTN","HLCSHDR4",54,0)
 S MSH=$G(^HLMA(+I773,"MSH",1,0)) QUIT:MSH']""  ;->
"RTN","HLCSHDR4",55,0)
 S DIV=$E(MSH,4)
"RTN","HLCSHDR4",56,0)
 ;
"RTN","HLCSHDR4",57,0)
 W !!,$$CJ^XLFSTR(" 773 # "_I773_" ",IOM,"=")
"RTN","HLCSHDR4",58,0)
 ;
"RTN","HLCSHDR4",59,0)
 D HDR(90,N90)
"RTN","HLCSHDR4",60,0)
 ;
"RTN","HLCSHDR4",61,0)
 W !
"RTN","HLCSHDR4",62,0)
 D HDR(91,N91)
"RTN","HLCSHDR4",63,0)
 ;
"RTN","HLCSHDR4",64,0)
 W !!,$E(MSH,1,IOM)
"RTN","HLCSHDR4",65,0)
 ;
"RTN","HLCSHDR4",66,0)
 S C1=10,C2=30,C3=50
"RTN","HLCSHDR4",67,0)
 W !!,?C1,"Original (91)",?2,"Array (90)",?3,"MSH-Segment"
"RTN","HLCSHDR4",68,0)
 W !,$$REPEAT^XLFSTR("-",IOM)
"RTN","HLCSHDR4",69,0)
 D LINE("snd app",1,2,3)
"RTN","HLCSHDR4",70,0)
 D LINE("snd fac",3,3,4)
"RTN","HLCSHDR4",71,0)
 D LINE("rec app",5,4,5)
"RTN","HLCSHDR4",72,0)
 D LINE("rec fac",7,5,6)
"RTN","HLCSHDR4",73,0)
 ;
"RTN","HLCSHDR4",74,0)
 QUIT
"RTN","HLCSHDR4",75,0)
 ;
"RTN","HLCSHDR4",76,0)
LINE(HDR,PCE1,PCE2,PCE3) ; Print one comparison line...
"RTN","HLCSHDR4",77,0)
 N P1,P2,P3,P4
"RTN","HLCSHDR4",78,0)
 S P1=$P(N91,U,PCE1),P2=$P(N90,U,PCE2),P3=$P(MSH,DIV,PCE3),P4=$P(N91,U,PCE1+1)
"RTN","HLCSHDR4",79,0)
 W !,HDR,":",?C1,P1,?2,P2,?3,P3,$S(P4]"":" ["_P4_"]",1:"")
"RTN","HLCSHDR4",80,0)
 QUIT
"RTN","HLCSHDR4",81,0)
 ;
"RTN","HLCSHDR4",82,0)
HDR(NUM,DATA) N TXT
"RTN","HLCSHDR4",83,0)
 S TXT=$S(NUM=90:"Array (90)",NUM=91:"Original (91)",1:"")
"RTN","HLCSHDR4",84,0)
 W !,$$CJ^XLFSTR("---------- "_TXT_" ----------",IOM)
"RTN","HLCSHDR4",85,0)
 W $$CJ^XLFSTR(DATA,IOM)
"RTN","HLCSHDR4",86,0)
 QUIT
"RTN","HLCSHDR4",87,0)
 ;
"RTN","HLCSHDR4",88,0)
SET(NEW,VAR,PCE) ; This subroutine performs these actions:
"RTN","HLCSHDR4",89,0)
 ; (1) Resets variables used in MSH segment
"RTN","HLCSHDR4",90,0)
 ; (2) Resets SERAPP and CLNTAPP in ^HLMA(#,0)
"RTN","HLCSHDR4",91,0)
 ; (3) Sets HLMSH91 nodes if overwrite occurs by ARRAY value.
"RTN","HLCSHDR4",92,0)
 ;     If overwrite occurs by M code, the overwrite has already
"RTN","HLCSHDR4",93,0)
 ;     been recorded in HLMSH91.  (An overwrite produced by M code
"RTN","HLCSHDR4",94,0)
 ;     is never overwritten by ARRAY data.)
"RTN","HLCSHDR4",95,0)
 ;
"RTN","HLCSHDR4",96,0)
 N IEN771N,IEN771O,HLTCP
"RTN","HLCSHDR4",97,0)
 ;
"RTN","HLCSHDR4",98,0)
 ; VAR is the name of the variable, and not it's value...
"RTN","HLCSHDR4",99,0)
 S PRE=@VAR ; PRE is now the value of the VAR (pre-overwrite) variable...
"RTN","HLCSHDR4",100,0)
 ;
"RTN","HLCSHDR4",101,0)
 ; Tests whether anything was changed...
"RTN","HLCSHDR4",102,0)
 QUIT:NEW']""  ;-> No new value exists to change to...
"RTN","HLCSHDR4",103,0)
 QUIT:NEW=PRE  ;-> New value = Original value.  Nothing changed...
"RTN","HLCSHDR4",104,0)
 ;
"RTN","HLCSHDR4",105,0)
 ; THIS IS THE EPICENTER!!  This is where the variables used in
"RTN","HLCSHDR4",106,0)
 ; the MSH segment is overwritten.
"RTN","HLCSHDR4",107,0)
 S @VAR=NEW
"RTN","HLCSHDR4",108,0)
 ;
"RTN","HLCSHDR4",109,0)
 ; If PRE exists at this point, it was done by M code...
"RTN","HLCSHDR4",110,0)
 QUIT:$P(HLMSH91,U,PCE)]""  ;->
"RTN","HLCSHDR4",111,0)
 ;
"RTN","HLCSHDR4",112,0)
 ; Change was made, but not by M code.  Must be by array...
"RTN","HLCSHDR4",113,0)
 S $P(HLMSH91,U,PCE)=PRE,$P(HLMSH91,U,PCE+1)="A"
"RTN","HLCSHDR4",114,0)
 ;
"RTN","HLCSHDR4",115,0)
 ; patch HL*1.6*122: for "^" as component separater
"RTN","HLCSHDR4",116,0)
 S $P(HLMSH91,U,PCE+2,999)=""
"RTN","HLCSHDR4",117,0)
 ;
"RTN","HLCSHDR4",118,0)
 ; Upgrade ^HLMA(#,0)...
"RTN","HLCSHDR4",119,0)
 QUIT:PCE'=1&(PCE'=5)  ;->
"RTN","HLCSHDR4",120,0)
 ;
"RTN","HLCSHDR4",121,0)
 ; patch HL*1.6*108 start
"RTN","HLCSHDR4",122,0)
 ;S IEN771O=$O(^HL(771,"B",PRE,0)) QUIT:IEN771O'>0  ;-> Orig IEN
"RTN","HLCSHDR4",123,0)
 ;S IEN771N=$O(^HL(771,"B",NEW,0)) QUIT:IEN771N'>0  ;-> New IEN
"RTN","HLCSHDR4",124,0)
 S IEN771O=$O(^HL(771,"B",$E(PRE,1,30),0)) QUIT:IEN771O'>0  ;-> Orig IEN
"RTN","HLCSHDR4",125,0)
 S IEN771N=$O(^HL(771,"B",$E(NEW,1,30),0)) QUIT:IEN771N'>0  ;-> New IEN
"RTN","HLCSHDR4",126,0)
 ; patch HL*1.6*108 end
"RTN","HLCSHDR4",127,0)
 ;
"RTN","HLCSHDR4",128,0)
 QUIT:'IEN771O!('IEN771N)!(IEN771O=IEN771N)  ;->
"RTN","HLCSHDR4",129,0)
 S HLTCP=1 ; So 773 is updated...
"RTN","HLCSHDR4",130,0)
 I PCE=1 D UPDATE^HLTF0(MTIENS,"","O","","",IEN771N)
"RTN","HLCSHDR4",131,0)
 I PCE=5 D UPDATE^HLTF0(MTIENS,"","O","",IEN771N)
"RTN","HLCSHDR4",132,0)
 ;
"RTN","HLCSHDR4",133,0)
 QUIT
"RTN","HLCSHDR4",134,0)
 ;
"RTN","HLCSHDR4",135,0)
FIELDS ; Display the Protocol file fields used by the VistA HL7 package,
"RTN","HLCSHDR4",136,0)
 ; when messages are received, to find the event and subscriber
"RTN","HLCSHDR4",137,0)
 ; protocols.
"RTN","HLCSHDR4",138,0)
 N BY,DIC,DIOEND,L
"RTN","HLCSHDR4",139,0)
 ;
"RTN","HLCSHDR4",140,0)
 D HD
"RTN","HLCSHDR4",141,0)
 ;
"RTN","HLCSHDR4",142,0)
 W !
"RTN","HLCSHDR4",143,0)
 ;
"RTN","HLCSHDR4",144,0)
 S L="",DIC="^ORD(101,",BY="[HL PROTOCOL MESSAGING FIELDS]"
"RTN","HLCSHDR4",145,0)
 S DIOEND="D EXPL^HLCSHDR4"
"RTN","HLCSHDR4",146,0)
 D EN1^DIP
"RTN","HLCSHDR4",147,0)
 ;
"RTN","HLCSHDR4",148,0)
 Q
"RTN","HLCSHDR4",149,0)
 ;
"RTN","HLCSHDR4",150,0)
HD W @IOF,$$CJ^XLFSTR("HL7 Protocol Messaging Fields",IOM)
"RTN","HLCSHDR4",151,0)
 W !,$$REPEAT^XLFSTR("=",IOM)
"RTN","HLCSHDR4",152,0)
 W !,"This 'HL7 Protocol Messaging Fields' report holds information that will help"
"RTN","HLCSHDR4",153,0)
 W !,"you determine the effects from changes to routing-related fields in the MSH"
"RTN","HLCSHDR4",154,0)
 W !,"segment when messages are sent between or within VistA HL7 systems."
"RTN","HLCSHDR4",155,0)
 W !,"Additional explanation is included at the bottom of the report."
"RTN","HLCSHDR4",156,0)
 Q
"RTN","HLCSHDR4",157,0)
 ;
"RTN","HLCSHDR4",158,0)
EXPL N I,T QUIT:'$$EXPL1("Press RETURN for 'printout help', or '^' to exit... ")  X "F I=1:1 S T=$T(EXPL+I) QUIT:T'["";;""  W !,$P(T,"";;"",2,99)" S I=$$EXPL1("Press RETURN to exit... ",1)
"RTN","HLCSHDR4",159,0)
 ;;
"RTN","HLCSHDR4",160,0)
 ;;When messages are received, their SENDING APPLICATION (MSH-3), MESSAGE
"RTN","HLCSHDR4",161,0)
 ;;TYPE (MSH-9), EVENT TYPE (MSH-9), and HL7 VERSION (MSH-12) fields are used to
"RTN","HLCSHDR4",162,0)
 ;;find the event driver protocol to be used in processing the just-received
"RTN","HLCSHDR4",163,0)
 ;;message. After the event protocol is found, that protocol's subscriber
"RTN","HLCSHDR4",164,0)
 ;;protocols are evaluated.  The subscriber protocol with a RECEIVING 
"RTN","HLCSHDR4",165,0)
 ;;APPLICATION value that matches the RECEIVING APPLICATION field in the MSH
"RTN","HLCSHDR4",166,0)
 ;;segment (MSH-5) is used.
"RTN","HLCSHDR4",167,0)
 ;;
"RTN","HLCSHDR4",168,0)
 ;;The first line for every "section" in the printout is the event driver
"RTN","HLCSHDR4",169,0)
 ;;protocol. Lines preceded by dashes, are related subscriber protocols.  An
"RTN","HLCSHDR4",170,0)
 ;;example is shown below.
"RTN","HLCSHDR4",171,0)
 ;;
"RTN","HLCSHDR4",172,0)
 ;;Snd/Rec App's    mTYP   eTYP   Ver        Protocol                     Link
"RTN","HLCSHDR4",173,0)
 ;;------------------------------------------------------------------------------
"RTN","HLCSHDR4",174,0)
 ;;AC-VOICERAD      ORU    R01    2.3    |   AC ORU SERVER
"RTN","HLCSHDR4",175,0)
 ;;-AC-RADIOLOGY    ORU    R01    2.3    |   AC ORU CLIENT                NC  TCP
"RTN","HLCSHDR4",176,0)
 ;;
"RTN","HLCSHDR4",177,0)
 ;;In this example, the 'AC-VOICERAD' line holds information for the 'AC ORU
"RTN","HLCSHDR4",178,0)
 ;;SERVER' event protocol.  And, the '-AC-RADIOLOGY' line holds information for
"RTN","HLCSHDR4",179,0)
 ;;the 'AC ORU CLIENT' subscriber protocol.
"RTN","HLCSHDR4",180,0)
 Q
"RTN","HLCSHDR4",181,0)
 ;
"RTN","HLCSHDR4",182,0)
EXPL1(PMT,FF) ;
"RTN","HLCSHDR4",183,0)
 N DIR,DIRUT,DTOUT,DUOUT,X,Y
"RTN","HLCSHDR4",184,0)
 QUIT:$E($G(IOST),1,2)'="C-" 1 ;->
"RTN","HLCSHDR4",185,0)
 F X=1:1:$G(FF) W !
"RTN","HLCSHDR4",186,0)
 S DIR(0)="EA",DIR("A")=PMT
"RTN","HLCSHDR4",187,0)
 D ^DIR
"RTN","HLCSHDR4",188,0)
 QUIT $S(Y=1:1,1:"")
"RTN","HLCSHDR4",189,0)
 ;
"RTN","HLCSHDR4",190,0)
M ; Covered by Integration Agreement #3988
"RTN","HLCSHDR4",191,0)
 ; Application developers may call here when creating new messages,
"RTN","HLCSHDR4",192,0)
 ; when experimenting with M code to evaluate and conditionally change
"RTN","HLCSHDR4",193,0)
 ; routing-related fields. 
"RTN","HLCSHDR4",194,0)
 ;
"RTN","HLCSHDR4",195,0)
 ; This API is called immediately before the MSH segment is created.
"RTN","HLCSHDR4",196,0)
 N IOINHI,IOINORM,MSHOLD,MSHNEW,MSHPRE,X
"RTN","HLCSHDR4",197,0)
 ;
"RTN","HLCSHDR4",198,0)
 S X="IOINHI;IOINORM" D ENDR^%ZISS
"RTN","HLCSHDR4",199,0)
 ;
"RTN","HLCSHDR4",200,0)
 S MSHOLD=$$MSHBUILD(0),MSHPRE=$$MSHBUILD(1)
"RTN","HLCSHDR4",201,0)
 W !!,"The original MSH segment is...",!!,IOINHI,MSHOLD,IOINORM
"RTN","HLCSHDR4",202,0)
 I MSHPRE'=MSHOLD D
"RTN","HLCSHDR4",203,0)
 .  W !!,"The MSH segment, after modification by passed-in data, is..."
"RTN","HLCSHDR4",204,0)
 .  W !!,IOINHI,MSHPRE,IOINORM
"RTN","HLCSHDR4",205,0)
 ;
"RTN","HLCSHDR4",206,0)
 D MVAR("SENDING APPLICATION","HLMSHSAN","SERAPP")
"RTN","HLCSHDR4",207,0)
 D MVAR("SENDING FACILITY","HLMSHSFN","SERFAC")
"RTN","HLCSHDR4",208,0)
 D MVAR("RECEIVING APPLICATION","HLMSHRAN","CLNTAPP")
"RTN","HLCSHDR4",209,0)
 D MVAR("RECEIVING FACILITY","HLMSHRFN","CLNTFAC")
"RTN","HLCSHDR4",210,0)
 ;
"RTN","HLCSHDR4",211,0)
 S MSHNEW=$$MSHBUILD
"RTN","HLCSHDR4",212,0)
 I MSHNEW'=MSHPRE D
"RTN","HLCSHDR4",213,0)
 .  W !!,"Before your changes above, the modified MSH segment was..."
"RTN","HLCSHDR4",214,0)
 .  W !!,IOINHI,MSHPRE,IOINORM
"RTN","HLCSHDR4",215,0)
 .  W !!,"After your changes, the MSH segment is..."
"RTN","HLCSHDR4",216,0)
 .  W !!,IOINHI,MSHNEW,IOINORM
"RTN","HLCSHDR4",217,0)
 W !!,$$REPEAT^XLFSTR("-",IOM)
"RTN","HLCSHDR4",218,0)
 W !!,"Message being sent..."
"RTN","HLCSHDR4",219,0)
 W !
"RTN","HLCSHDR4",220,0)
 ;
"RTN","HLCSHDR4",221,0)
 Q
"RTN","HLCSHDR4",222,0)
 ;
"RTN","HLCSHDR4",223,0)
MVAR(FLD,VAR,VARO) ; Generic resetting of variable...
"RTN","HLCSHDR4",224,0)
 ;IOINHI,IOINORM -- req
"RTN","HLCSHDR4",225,0)
 N ANS
"RTN","HLCSHDR4",226,0)
 W !!,?4,"Protocol-derived value of ",FLD,": "
"RTN","HLCSHDR4",227,0)
 W IOINHI,@VARO,IOINORM
"RTN","HLCSHDR4",228,0)
 W !,"Passed-in value of ",FLD," (",VAR,"): "
"RTN","HLCSHDR4",229,0)
 W IOINHI,@VAR,IOINORM
"RTN","HLCSHDR4",230,0)
 W !,?10,"Enter new value for ",FLD,": "
"RTN","HLCSHDR4",231,0)
 R ANS:60 Q:'$T  ;->
"RTN","HLCSHDR4",232,0)
 I ANS[U!(ANS']"") D
"RTN","HLCSHDR4",233,0)
 .  W !!,?10,"No changes will be made..."
"RTN","HLCSHDR4",234,0)
 I ANS'[U&(ANS]"") D
"RTN","HLCSHDR4",235,0)
 .  S @VAR=ANS
"RTN","HLCSHDR4",236,0)
 .  W !!,?10,"The variable ",IOINHI,VAR,IOINORM
"RTN","HLCSHDR4",237,0)
 .  W " will be changed to '",IOINHI,ANS,IOINORM,"'."
"RTN","HLCSHDR4",238,0)
 .  W !,?10,"This value will be stored in the ",FLD
"RTN","HLCSHDR4",239,0)
 .  W !,?10,"field in the MSH segment..."
"RTN","HLCSHDR4",240,0)
 .  W !!,$$REPEAT^XLFSTR("-",IOM)
"RTN","HLCSHDR4",241,0)
 Q
"RTN","HLCSHDR4",242,0)
 ;
"RTN","HLCSHDR4",243,0)
MSHBUILD(TYPE) ; Build MSH using current variables...
"RTN","HLCSHDR4",244,0)
 N MSH,PCE,RAN,RFN,SAN,SFN
"RTN","HLCSHDR4",245,0)
 S MSH="MSH"_FS_EC
"RTN","HLCSHDR4",246,0)
 I $G(TYPE)=0 F PCE=SERAPP,SERFAC,CLNTAPP,CLNTFAC,HLDATE,SECURITY,MSGTYPE,HLID,HLPID,$P(PROT,U,9),"",$G(^HL(772,TXTP,1)),ACCACK,APPACK,CNTRY D
"RTN","HLCSHDR4",247,0)
 .  S MSH=MSH_FS_PCE
"RTN","HLCSHDR4",248,0)
 I $G(TYPE)'=0 D
"RTN","HLCSHDR4",249,0)
 .  S SAN=HLMSHSAN,SAN=$S(SAN]"":SAN,1:SERAPP)
"RTN","HLCSHDR4",250,0)
 .  S SFN=HLMSHSFN,SFN=$S(SFN]"":SFN,1:SERFAC)
"RTN","HLCSHDR4",251,0)
 .  S RAN=HLMSHRAN,RAN=$S(RAN]"":RAN,1:CLNTAPP)
"RTN","HLCSHDR4",252,0)
 .  S RFN=HLMSHRFN,RFN=$S(RFN]"":RFN,1:CLNTFAC)
"RTN","HLCSHDR4",253,0)
 .  F PCE=SAN,SFN,RAN,RFN,HLDATE,SECURITY,MSGTYPE,HLID,HLPID,$P(PROT,U,9),"",$G(^HL(772,TXTP,1)),ACCACK,APPACK,CNTRY D
"RTN","HLCSHDR4",254,0)
 .  .  S MSH=MSH_FS_PCE
"RTN","HLCSHDR4",255,0)
 QUIT MSH
"RTN","HLCSHDR4",256,0)
 ;
"RTN","HLCSHDR4",257,0)
EOR ;HLCSHDR4 - Reset MSH Segment Fields ;9/12/02 11:50
"RTN","HLCSIN")
0^16^B34245145^B18983334
"RTN","HLCSIN",1,0)
HLCSIN ;ALB/JRP - INCOMING FILER;01-MAY-95 ;10/17/2007  14:58
"RTN","HLCSIN",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**2,30,14,19,62,109,115,122**;Oct 13, 1995;Build 14
"RTN","HLCSIN",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLCSIN",4,0)
STARTIN ;Main entry point for incoming background filer
"RTN","HLCSIN",5,0)
 ;Create/find entry denoting this filer in the INCOMING FILER TASK
"RTN","HLCSIN",6,0)
 ; NUMBER multiple (field #20) of the HL COMMUNICATION SERVER PARAMETER
"RTN","HLCSIN",7,0)
 ; file (#869.3)
"RTN","HLCSIN",8,0)
 N HLFLG,HLEXIT,HLPTRFLR
"RTN","HLCSIN",9,0)
 ;
"RTN","HLCSIN",10,0)
 ; patch HL*1.6*122
"RTN","HLCSIN",11,0)
 ;; N HLDUZ,DUZ  ; patch HL*1.6*122 TEST v2: DUZ code removed
"RTN","HLCSIN",12,0)
 N HLDUZ
"RTN","HLCSIN",13,0)
 S HLDUZ=+$G(DUZ)
"RTN","HLCSIN",14,0)
 ;
"RTN","HLCSIN",15,0)
 S HLPTRFLR=+$$CRTFLR^HLCSUTL1(ZTSK,"IN")
"RTN","HLCSIN",16,0)
 ;Loop through Logical Links and check for incoming messages
"RTN","HLCSIN",17,0)
 S HLEXIT=0
"RTN","HLCSIN",18,0)
 ; patch HL*1.6*122 TEST v2: DUZ code removed
"RTN","HLCSIN",19,0)
 ; patch HL*1.6*122, set DUZ for application proxy user
"RTN","HLCSIN",20,0)
 ;; D PROXY^HLCSTCP4
"RTN","HLCSIN",21,0)
 S HLPTRFLR("$J")=$J
"RTN","HLCSIN",22,0)
 F  D  Q:HLEXIT
"RTN","HLCSIN",23,0)
 . S HLFLG=0
"RTN","HLCSIN",24,0)
 . D DEFACK(.HLPTRFLR,.HLFLG,.HLEXIT) Q:HLEXIT
"RTN","HLCSIN",25,0)
 . D ACKNOW(.HLPTRFLR,.HLFLG,.HLEXIT) Q:HLEXIT
"RTN","HLCSIN",26,0)
 . Q:HLFLG
"RTN","HLCSIN",27,0)
 . I $$HDIFF^XLFDT($H,$G(HLPTRFLR("LASTDEL")),2)>3600 D  Q
"RTN","HLCSIN",28,0)
 . . S HLPTRFLR("LASTDEL")=$H    ; maintain queue sizes
"RTN","HLCSIN",29,0)
 . . D DELQUE(.HLPTRFLR,.HLEXIT) ; no more than once an hour.
"RTN","HLCSIN",30,0)
 . ; patch HL*1.6*122
"RTN","HLCSIN",31,0)
 . ; H 5
"RTN","HLCSIN",32,0)
 . H 1
"RTN","HLCSIN",33,0)
 . D CHKUPD(.HLPTRFLR,.HLEXIT) Q:HLEXIT
"RTN","HLCSIN",34,0)
 S ZTSTOP=1 ;Asked to stop
"RTN","HLCSIN",35,0)
 D DELFLR^HLCSUTL1(HLPTRFLR,"IN") ;Delete entry denoting this filer
"RTN","HLCSIN",36,0)
 S ZTREQ="@"
"RTN","HLCSIN",37,0)
 Q
"RTN","HLCSIN",38,0)
DEFACK(HLPTRFLR,HLFLG,HLEXIT) ; Process TCP links with a deferred response
"RTN","HLCSIN",39,0)
 N HLXX,HLD0,HLPCT
"RTN","HLCSIN",40,0)
 S HLXX=0
"RTN","HLCSIN",41,0)
 F  S HLXX=$O(^HLMA("AC","I",HLXX)) Q:'HLXX  D  Q:HLEXIT
"RTN","HLCSIN",42,0)
 . ; HL*1.6*122, check the in-queue stop flag
"RTN","HLCSIN",43,0)
 . Q:$P($G(^HLCS(870,HLXX,0)),"^",9)
"RTN","HLCSIN",44,0)
 . D CHKUPD(.HLPTRFLR,.HLEXIT) Q:HLEXIT
"RTN","HLCSIN",45,0)
 . ; patch HL*1.6*109: Does another filer have this?
"RTN","HLCSIN",46,0)
 . ; L +^HLMA("AC","I",HLXX):0 Q:'$T
"RTN","HLCSIN",47,0)
 . L +^HLMA("AC","I",HLXX):2 Q:'$T  ; patch HL*1.6*122
"RTN","HLCSIN",48,0)
 . S HLD0=0,HLFLG=1
"RTN","HLCSIN",49,0)
 . ; HL*1.6*109 changes in for loop below, and post-quit code placed
"RTN","HLCSIN",50,0)
 . ; on following lines.
"RTN","HLCSIN",51,0)
 . S HLPCT=0 ; Counter whether filer should stop every 100th entry.
"RTN","HLCSIN",52,0)
 .;**109 - insure queue last processed at least 2 seconds ago
"RTN","HLCSIN",53,0)
 . I ($$HDIFF^XLFDT($H,$G(^XTMP("HL7-AC","I",HLXX)),2)<2) L -^HLMA("AC","I",HLXX) Q
"RTN","HLCSIN",54,0)
 . F  S HLD0=$O(^HLMA("AC","I",HLXX,HLD0)) Q:'HLD0!(HLEXIT)  D
"RTN","HLCSIN",55,0)
 .. ; patch HL*1.6*122 start
"RTN","HLCSIN",56,0)
 .. ; patch HL*1.6*122 TEST v2: DUZ code removed
"RTN","HLCSIN",57,0)
 .. ; DUZ comparison/reset for application proxy user
"RTN","HLCSIN",58,0)
 .. ;; D HLDUZ^HLCSTCP4
"RTN","HLCSIN",59,0)
 .. D HLDUZ2^HLCSTCP4
"RTN","HLCSIN",60,0)
 .. ; protect HLDUZ
"RTN","HLCSIN",61,0)
 .. N HLDUZ
"RTN","HLCSIN",62,0)
 .. S HLPCT=HLPCT+1
"RTN","HLCSIN",63,0)
 .. I '(HLPCT#100) D CHKUPD(.HLPTRFLR,.HLEXIT) Q:HLEXIT
"RTN","HLCSIN",64,0)
 .. ; L +^HLMA(HLD0):0 Q:'$T
"RTN","HLCSIN",65,0)
 .. F  L +^HLMA(HLD0):30 Q:$T  H 1
"RTN","HLCSIN",66,0)
 .. I '$$CHECKAC("I",HLXX,HLD0) L -^HLMA(HLD0) Q  ;-> Quit if not a valid AC xref
"RTN","HLCSIN",67,0)
 .. D DEFACK^HLTP3(HLXX,HLD0)
"RTN","HLCSIN",68,0)
 .. D DEQUE^HLCSREP(HLXX,"I",HLD0)
"RTN","HLCSIN",69,0)
 .. L -^HLMA(HLD0)
"RTN","HLCSIN",70,0)
 . ; patch HL*1.6*122 end
"RTN","HLCSIN",71,0)
 . ;**109 -add dt/tm stamp to time queue last processed
"RTN","HLCSIN",72,0)
 . S ^XTMP("HL7-AC","I",HLXX)=$H
"RTN","HLCSIN",73,0)
 . ;**109 -unlock the queue
"RTN","HLCSIN",74,0)
 . L -^HLMA("AC","I",HLXX)
"RTN","HLCSIN",75,0)
 Q
"RTN","HLCSIN",76,0)
 ;
"RTN","HLCSIN",77,0)
CHECKAC(WAY,IEN870,IEN773) ; If AC xref shouldn't exist, kill it...
"RTN","HLCSIN",78,0)
 ;
"RTN","HLCSIN",79,0)
 ; Check status and if 3 (processed) kill XREF...
"RTN","HLCSIN",80,0)
 I $P($G(^HLMA(+IEN773,"P")),U)=3 D  QUIT "" ;->
"RTN","HLCSIN",81,0)
 .  D DEQUE^HLCSREP(IEN870,WAY,IEN773)
"RTN","HLCSIN",82,0)
 ;
"RTN","HLCSIN",83,0)
 ; Add other checks here in the future...
"RTN","HLCSIN",84,0)
 ;
"RTN","HLCSIN",85,0)
 Q 1
"RTN","HLCSIN",86,0)
 ;
"RTN","HLCSIN",87,0)
ACKNOW(HLPTRFLR,HLFLG,HLEXIT) ; Process Logical Link's IN-queue for received message
"RTN","HLCSIN",88,0)
 N HLXX,HLD0,HLD1
"RTN","HLCSIN",89,0)
 S HLXX=0
"RTN","HLCSIN",90,0)
 F  S HLXX=$O(^HLCS(870,"AISTAT","P",HLXX)) Q:'HLXX  D  Q:HLEXIT
"RTN","HLCSIN",91,0)
 . ; HL*1.6*122, check the in-queue stop flag
"RTN","HLCSIN",92,0)
 . Q:$P($G(^HLCS(870,HLXX,0)),"^",9)
"RTN","HLCSIN",93,0)
 . D CHKUPD(.HLPTRFLR,.HLEXIT) Q:HLEXIT
"RTN","HLCSIN",94,0)
 . ; HL*1.6*109: Does another filer have this?
"RTN","HLCSIN",95,0)
 . ; L +^HLCS(870,HLXX,"INFILER"):0 Q:'$T
"RTN","HLCSIN",96,0)
 . L +^HLCS(870,HLXX,"INFILER"):2 Q:'$T  ; patch HL*1.6*122
"RTN","HLCSIN",97,0)
 . F  D CHKUPD(.HLPTRFLR,.HLEXIT) Q:HLEXIT  S HLD0=$$DEQUEUE^HLCSQUE(HLXX,"IN") Q:+HLD0<0  D
"RTN","HLCSIN",98,0)
 .. ;
"RTN","HLCSIN",99,0)
 .. ; patch HL*1.6*122 start
"RTN","HLCSIN",100,0)
 .. ; clean variables except Kernel related variables
"RTN","HLCSIN",101,0)
 .. D
"RTN","HLCSIN",102,0)
 ... ; protect variables defined in STARTIN^HLCSIN
"RTN","HLCSIN",103,0)
 ... N HLFLG,HLEXIT,HLPTRFLR
"RTN","HLCSIN",104,0)
 ... N HLDUZ
"RTN","HLCSIN",105,0)
 ... ; protect variables defined in ACKNOW^HLCSIN
"RTN","HLCSIN",106,0)
 ... N HLXX,HLD0,HLD1
"RTN","HLCSIN",107,0)
 ... D KILL^XUSCLEAN
"RTN","HLCSIN",108,0)
 .. ;
"RTN","HLCSIN",109,0)
 .. ; patch HL*1.6*122 TEST v2: DUZ code removed
"RTN","HLCSIN",110,0)
 .. ; DUZ comparison/reset for application proxy user
"RTN","HLCSIN",111,0)
 .. ;; D HLDUZ^HLCSTCP4
"RTN","HLCSIN",112,0)
 .. D HLDUZ2^HLCSTCP4
"RTN","HLCSIN",113,0)
 .. ; protect HLDUZ
"RTN","HLCSIN",114,0)
 .. N HLDUZ
"RTN","HLCSIN",115,0)
 .. ;Make sure message is ready to be received
"RTN","HLCSIN",116,0)
 .. S HLFLG=1
"RTN","HLCSIN",117,0)
 .. S HLD1=$P(HLD0,"^",2)
"RTN","HLCSIN",118,0)
 .. S HLD0=+HLD0 ; At this point, HLD0=HLXX
"RTN","HLCSIN",119,0)
 .. I $P($G(^HLCS(870,HLD0,1,HLD1,0)),"^",3)'="A" D  Q
"RTN","HLCSIN",120,0)
 ... D MONITOR^HLCSDR2("D",2,HLD0,HLD1,"IN") ;Set status to DONE
"RTN","HLCSIN",121,0)
 .. D RECEIVE^HLMA0(HLD0,HLD1) ;Process received message
"RTN","HLCSIN",122,0)
 .. D MONITOR^HLCSDR2("D",2,HLD0,HLD1,"IN") ;Set status to DONE
"RTN","HLCSIN",123,0)
 . ; patch HL*1.6*122 end
"RTN","HLCSIN",124,0)
 . I HLD0<0,$D(^HLCS(870,"AISTAT","P",HLXX)) D
"RTN","HLCSIN",125,0)
 . . S HLD1=0 ; Make sure there aren't any loose xrefs hanging around.
"RTN","HLCSIN",126,0)
 . . F  S HLD1=$O(^HLCS(870,"AISTAT","P",HLXX,HLD1)) Q:'HLD1  D
"RTN","HLCSIN",127,0)
 . . . ;I '$D(^HLCS(870,HLXX,1,HLD1,0)) K ^HLCS(870,"AISTAT","P",HLXX,HLD1)
"RTN","HLCSIN",128,0)
 . . . I $P($G(^HLCS(870,HLXX,1,HLD1,0)),U,2)'="P" K ^HLCS(870,"AISTAT","P",HLXX,HLD1)
"RTN","HLCSIN",129,0)
 . L -^HLCS(870,HLXX,"INFILER")
"RTN","HLCSIN",130,0)
 Q
"RTN","HLCSIN",131,0)
DELQUE(HLPTRFLR,HLEXIT) ; Delete messages outside the 'queue size' window.
"RTN","HLCSIN",132,0)
 N HLDIR,HLXX,HLFRONT
"RTN","HLCSIN",133,0)
 S HLDIR=1,HLXX=0
"RTN","HLCSIN",134,0)
 F  S HLXX=$O(^HLCS(870,HLXX)) Q:'HLXX  D  Q:HLEXIT
"RTN","HLCSIN",135,0)
 . D CHKUPD(.HLPTRFLR,.HLEXIT) Q:HLEXIT
"RTN","HLCSIN",136,0)
 . ; patch HL*1.6*122, comment out, no need to lock
"RTN","HLCSIN",137,0)
 . ; L +^HLCS(870,HLXX,"IN QUEUE FRONT POINTER"):0 Q:'$T
"RTN","HLCSIN",138,0)
 . S HLFRONT=$G(^HLCS(870,HLXX,"IN QUEUE FRONT POINTER"))
"RTN","HLCSIN",139,0)
 . ; patch HL*1.6*122, comment out
"RTN","HLCSIN",140,0)
 . ; L -^HLCS(870,HLXX,"IN QUEUE FRONT POINTER")
"RTN","HLCSIN",141,0)
 . D DELETE^HLCSQUE1(HLXX,HLDIR,HLFRONT)
"RTN","HLCSIN",142,0)
 Q
"RTN","HLCSIN",143,0)
CHKUPD(HLPTRFLR,HLEXIT) ;
"RTN","HLCSIN",144,0)
 Q:$$HDIFF^XLFDT($H,$G(HLPTRFLR("LASTUP")),2)<15
"RTN","HLCSIN",145,0)
 D SETFLRDH^HLCSUTL1(HLPTRFLR,"IN") ; Update LAST KNOWN $H (field #.03) for filer
"RTN","HLCSIN",146,0)
 S HLPTRFLR("LASTUP")=$H
"RTN","HLCSIN",147,0)
 D CHK4STOP^HLCSUTL2(HLPTRFLR,"IN",.HLEXIT) Q:HLEXIT
"RTN","HLCSIN",148,0)
 Q
"RTN","HLCSLNCH")
0^17^B46750262^B37171475
"RTN","HLCSLNCH",1,0)
HLCSLNCH ;ALB/MTC/JC - START AND STOP THE LLP ;07/26/2007  17:10
"RTN","HLCSLNCH",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**6,19,43,49,57,75,84,109,122**;Oct 13, 1995;Build 14
"RTN","HLCSLNCH",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLCSLNCH",4,0)
 ;
"RTN","HLCSLNCH",5,0)
 ;This program is callable from a menu
"RTN","HLCSLNCH",6,0)
 ;It allows the user to Start and Stop the Lower Layer
"RTN","HLCSLNCH",7,0)
 ;Protocol in the Background or in the foreground
"RTN","HLCSLNCH",8,0)
 ;
"RTN","HLCSLNCH",9,0)
 ;Required or Optional INPUT PARAMETERS
"RTN","HLCSLNCH",10,0)
 ;             None
"RTN","HLCSLNCH",11,0)
 ;
"RTN","HLCSLNCH",12,0)
 ;
"RTN","HLCSLNCH",13,0)
 ;Output variables
"RTN","HLCSLNCH",14,0)
 ;             HLDP=IEN of Logical Link in file #870
"RTN","HLCSLNCH",15,0)
 ;(optional)HLTRACE=if SET it launches the LLP in the Foreground
"RTN","HLCSLNCH",16,0)
 ;(optional)   ZTSK=if defined LLP was launched in the
"RTN","HLCSLNCH",17,0)
 ;background
"RTN","HLCSLNCH",18,0)
 ;
"RTN","HLCSLNCH",19,0)
 ;
"RTN","HLCSLNCH",20,0)
START ; Start up the lower level protocol
"RTN","HLCSLNCH",21,0)
 N DIC,DIRUT,DTOUT,DUOUT,HLDP,HLDAPP,HLJ,HLQUIT,HLTRACE
"RTN","HLCSLNCH",22,0)
 N HLPARM0,HLPARM4,HLTYPTR,HLBGR,X,Y,ZTCPU,ZTSK,ZTRTN,ZTDESC
"RTN","HLCSLNCH",23,0)
 W !!,"This option is used to launch the lower level protocol for the"
"RTN","HLCSLNCH",24,0)
 W !,"appropriate device.  Please select the node with which you want"
"RTN","HLCSLNCH",25,0)
 W !,"to communicate",!
"RTN","HLCSLNCH",26,0)
 ; patch HL*1.6*122
"RTN","HLCSLNCH",27,0)
 S POP=0
"RTN","HLCSLNCH",28,0)
 S DIC="^HLCS(870,",DIC(0)="QEAMZ" D ^DIC G:Y<0 STARTQ
"RTN","HLCSLNCH",29,0)
 S HLDP=+Y,HLDAPP=Y(0,0),HLTYPTR=+$P(Y(0),U,3),HLPARM0=Y(0)
"RTN","HLCSLNCH",30,0)
 ;-- check if parameter have been setup
"RTN","HLCSLNCH",31,0)
 ;-- check for LLP type
"RTN","HLCSLNCH",32,0)
 I 'HLTYPTR W !!,$C(7),"A Lower Layer Protocol must be selected before start-up can occur." G STARTQ
"RTN","HLCSLNCH",33,0)
 ;-- get TCP information
"RTN","HLCSLNCH",34,0)
 S HLPARM4=$G(^HLCS(870,HLDP,400))
"RTN","HLCSLNCH",35,0)
 ;-- get routine (background job for LLP)
"RTN","HLCSLNCH",36,0)
 S HLBGR=$G(^HLCS(869.1,HLTYPTR,100))
"RTN","HLCSLNCH",37,0)
 ;-- get environment check routine (HLQUIT should be defined in fails)
"RTN","HLCSLNCH",38,0)
 S HLENV=$G(^HLCS(869.1,HLTYPTR,200))
"RTN","HLCSLNCH",39,0)
 ;
"RTN","HLCSLNCH",40,0)
 I HLBGR="" W !!,$C(7),"No routine has been specified for this LLP." G STARTQ
"RTN","HLCSLNCH",41,0)
 ;
"RTN","HLCSLNCH",42,0)
 ;-- execute environment check routine if HLQUIT is defined then terminate
"RTN","HLCSLNCH",43,0)
 I HLENV'="" X HLENV G:$D(HLQUIT) STARTQ
"RTN","HLCSLNCH",44,0)
 ; patch HL*1.6*122 start
"RTN","HLCSLNCH",45,0)
 ; Multi-Servers: TCP service (GT.M, DSM, and Cache/VMS) is controlled
"RTN","HLCSLNCH",46,0)
 ; by the external service
"RTN","HLCSLNCH",47,0)
 I $P(HLPARM4,U,3)="M",$S(^%ZOSF("OS")'["OpenM":1,1:$$OS^%ZOSV["VMS") D  G STARTQ
"RTN","HLCSLNCH",48,0)
 . W !,$C(7),"This LLP is a multi-threaded server. It is controlled by external service, i.e. TCPIP/UCX. You must use the external service to start this LLP."
"RTN","HLCSLNCH",49,0)
 . Q
"RTN","HLCSLNCH",50,0)
 ; patch HL*1.6*122 end
"RTN","HLCSLNCH",51,0)
 ;
"RTN","HLCSLNCH",52,0)
 I $P(HLPARM0,U,10) W !,$C(7),"The LLP was last started on ",$$DAT2^HLUTIL1($P(HLPARM0,U,10)),"." G STP1:$P(HLPARM0,U,5)'="Error"
"RTN","HLCSLNCH",53,0)
 I $P(HLPARM0,U,11) W !,"The LLP was last shutdown on ",$$DAT2^HLUTIL1($P(HLPARM0,U,11)),"."
"RTN","HLCSLNCH",54,0)
 ; patch HL*1.6*122 start
"RTN","HLCSLNCH",55,0)
 ; comment out-should be taken care of by the code 2 line above
"RTN","HLCSLNCH",56,0)
 ; I $P(HLPARM0,U,5)'="Error",'($P(HLPARM4,U,3)="C"&("N"[$P(HLPARM4,U,4))),$P(HLPARM0,U,10)]""&($P(HLPARM0,U,11)=""),$P(HLPARM0,U,12) W !,"The LLP appears to be online already !"
"RTN","HLCSLNCH",57,0)
 ; I $$TASK^HLUTIL1($P(HLPARM0,U,12)) D  G STARTQ
"RTN","HLCSLNCH",58,0)
 ; . W !,$C(7),"NOTE: The lower level protocol for this application is already running."
"RTN","HLCSLNCH",59,0)
 N HLTEMP
"RTN","HLCSLNCH",60,0)
 S HLTEMP=0
"RTN","HLCSLNCH",61,0)
 I $P(HLPARM0,U,12) D  G:HLTEMP STARTQ
"RTN","HLCSLNCH",62,0)
 . N ZTSK
"RTN","HLCSLNCH",63,0)
 . S ZTSK=$P(HLPARM0,U,12)
"RTN","HLCSLNCH",64,0)
 . D STAT^%ZTLOAD
"RTN","HLCSLNCH",65,0)
 . I "12"[ZTSK(1) D
"RTN","HLCSLNCH",66,0)
 .. W !,$C(7),"NOTE: The lower level protocol for this application is already running."
"RTN","HLCSLNCH",67,0)
 .. I '$P(^HLCS(870,HLDP,0),"^",10) S $P(^HLCS(870,HLDP,0),"^",10)=$$NOW^XLFDT
"RTN","HLCSLNCH",68,0)
 .. S HLTEMP=1
"RTN","HLCSLNCH",69,0)
 ; patch HL*1.6*122 end
"RTN","HLCSLNCH",70,0)
 I $P(HLPARM4,U,3)="C"&("N"[$P(HLPARM4,U,4)) D  G STARTQ
"RTN","HLCSLNCH",71,0)
 .;4=status 9=Time Started, 10=Time Stopped, 11=Task Number
"RTN","HLCSLNCH",72,0)
 .;14=Shutdown LLP, 3=Device Type, 18=Gross Errors
"RTN","HLCSLNCH",73,0)
 .N HLJ,X
"RTN","HLCSLNCH",74,0)
 . ; patch HL*1.6*122-comment out
"RTN","HLCSLNCH",75,0)
 . ; I $P(HLPARM0,U,15)=0 W !,"This LLP is already enabled!" Q
"RTN","HLCSLNCH",76,0)
 .L +^HLCS(870,HLDP,0):2
"RTN","HLCSLNCH",77,0)
 .E  W !,$C(7),"Unable to enable this LLP !" Q
"RTN","HLCSLNCH",78,0)
 .S X="HLJ(870,"""_HLDP_","")"
"RTN","HLCSLNCH",79,0)
 .S @X@(4)="Enabled",@X@(9)=$$NOW^XLFDT,@X@(14)=0
"RTN","HLCSLNCH",80,0)
 .D FILE^HLDIE("","HLJ","","START","HLCSLNCH") ;HL*1.6*109
"RTN","HLCSLNCH",81,0)
 .L -^HLCS(870,HLDP,0)
"RTN","HLCSLNCH",82,0)
 .W !,"This LLP has been enabled!"
"RTN","HLCSLNCH",83,0)
 .Q
"RTN","HLCSLNCH",84,0)
 I $P(HLPARM4,U,6),$D(^%ZIS(14.7,+$P(HLPARM4,U,6),0)) S ZTCPU=$P(^(0),U) W !,"This LLP will start on node ",ZTCPU," if it is run in the Background.",!
"RTN","HLCSLNCH",85,0)
 ;
"RTN","HLCSLNCH",86,0)
 ; patch HL*1.6*122 start, for tcp link
"RTN","HLCSLNCH",87,0)
 I HLTYPTR=4 D  Q
"RTN","HLCSLNCH",88,0)
 . S Y="B"
"RTN","HLCSLNCH",89,0)
 . D STARTJOB
"RTN","HLCSLNCH",90,0)
 ; patch HL*1.6*122 end
"RTN","HLCSLNCH",91,0)
 ;
"RTN","HLCSLNCH",92,0)
 W ! S DIR(0)="SM^F:FOREGROUND;B:BACKGROUND;Q:QUIT"
"RTN","HLCSLNCH",93,0)
 S DIR("A")="Method for running the receiver"
"RTN","HLCSLNCH",94,0)
 S DIR("B")="B"
"RTN","HLCSLNCH",95,0)
 S DIR("?",1)="Enter F for Foreground (and trace)"
"RTN","HLCSLNCH",96,0)
 S DIR("?",2)="      B for Background (normal) or"
"RTN","HLCSLNCH",97,0)
 S DIR("?")="      Q to quit without starting the receiver"
"RTN","HLCSLNCH",98,0)
 D ^DIR K DIR
"RTN","HLCSLNCH",99,0)
 Q:(Y=U)!(Y="Q")
"RTN","HLCSLNCH",100,0)
 ;
"RTN","HLCSLNCH",101,0)
STARTJOB ;
"RTN","HLCSLNCH",102,0)
 S HLX=$G(^HLCS(870,HLDP,0))
"RTN","HLCSLNCH",103,0)
 ;-- foreground
"RTN","HLCSLNCH",104,0)
 I Y="F" S HLTRACE=1 D  G STARTQ
"RTN","HLCSLNCH",105,0)
 . S $P(^HLCS(870,HLDP,0),"^",10)=$$NOW^XLFDT
"RTN","HLCSLNCH",106,0)
 . D MON^HLCSTCP("Start")
"RTN","HLCSLNCH",107,0)
 . X HLBGR
"RTN","HLCSLNCH",108,0)
 ;-- background
"RTN","HLCSLNCH",109,0)
 I Y="B" D  G STARTQ
"RTN","HLCSLNCH",110,0)
 . S ZTRTN=$P(HLBGR," ",2),HLTRACE="",ZTIO="",ZTDTH=$H
"RTN","HLCSLNCH",111,0)
 . S ZTDESC=HLDAPP_" Low Level Protocol",ZTSAVE("HLDP")=""
"RTN","HLCSLNCH",112,0)
 . D ^%ZTLOAD
"RTN","HLCSLNCH",113,0)
 . ; patch HL*1.6*122 start
"RTN","HLCSLNCH",114,0)
 . I $D(ZTSK) D
"RTN","HLCSLNCH",115,0)
 .. K HLTRACE
"RTN","HLCSLNCH",116,0)
 .. D MON^HLCSTCP("Tasked")
"RTN","HLCSLNCH",117,0)
 .. S $P(^HLCS(870,HLDP,0),"^",10)=$$NOW^XLFDT
"RTN","HLCSLNCH",118,0)
 . ; patch HL*1.6*122 end
"RTN","HLCSLNCH",119,0)
 . W !,$S($D(ZTSK):"Job was queued as "_ZTSK_".",1:"Unable to queue job.")
"RTN","HLCSLNCH",120,0)
 ;
"RTN","HLCSLNCH",121,0)
 Q
"RTN","HLCSLNCH",122,0)
 ;
"RTN","HLCSLNCH",123,0)
STARTQ ;
"RTN","HLCSLNCH",124,0)
 I $G(POP) W !,?5,"-Unable to Open the Device !",!,!,?6,"Check that Port is Logged Out, and that the",!,?6,"Lower Level Protocol is not Already Running."
"RTN","HLCSLNCH",125,0)
 Q
"RTN","HLCSLNCH",126,0)
 ;
"RTN","HLCSLNCH",127,0)
STOP ; Shut down a lower level protocol..
"RTN","HLCSLNCH",128,0)
 N DIC,DIRUT,DTOUT,DUOUT,HLDP,HLDAPP,HLJ,HLPARM0,HLPARM4,X,Y
"RTN","HLCSLNCH",129,0)
 W !!,"This option is used to shut down the lower level protocol for the"
"RTN","HLCSLNCH",130,0)
 W !,"appropriate device.  Please select the link which you would"
"RTN","HLCSLNCH",131,0)
 W !,"like to shutdown.",!
"RTN","HLCSLNCH",132,0)
 S DIC="^HLCS(870,",DIC(0)="QEAMZ" D ^DIC K DIC Q:Y<0
"RTN","HLCSLNCH",133,0)
 S HLDP=+Y,HLDAPP=Y(0,0),HLPARM0=Y(0),HLPARM4=$G(^HLCS(870,HLDP,400))
"RTN","HLCSLNCH",134,0)
 ; patch HL*1.6*122
"RTN","HLCSLNCH",135,0)
 ; Multi-Servers: TCP service (GT.M, DSM, and Cache/VMS) is controlled
"RTN","HLCSLNCH",136,0)
 ; by the external service
"RTN","HLCSLNCH",137,0)
 I $P(HLPARM4,U,3)="M",$S(^%ZOSF("OS")'["OpenM":1,1:$$OS^%ZOSV["VMS") D  Q
"RTN","HLCSLNCH",138,0)
 . W !,$C(7),"This LLP is a multi-threaded server. It is controlled by external service, i.e. TCPIP/UCX. You must use the external service to disable this LLP."
"RTN","HLCSLNCH",139,0)
 . Q
"RTN","HLCSLNCH",140,0)
 ;
"RTN","HLCSLNCH",141,0)
 I $P(HLPARM0,U,15) W !,$C(7),"The lower level protocol is already ",$P(HLPARM0,U,5),"." Q
"RTN","HLCSLNCH",142,0)
 I $P(HLPARM0,U,10) W !,$C(7),"The lower level protocol was started on ",$$DAT2^HLUTIL1($P(HLPARM0,U,10)),"."
"RTN","HLCSLNCH",143,0)
STP1 ;
"RTN","HLCSLNCH",144,0)
 W ! S DIR(0)="Y",DIR("A")="Okay to shut down this job" D ^DIR K DIR
"RTN","HLCSLNCH",145,0)
 I 'Y!($D(DIRUT))!($D(DUOUT)) W !!,"The job will not be shut down." Q
"RTN","HLCSLNCH",146,0)
S ;
"RTN","HLCSLNCH",147,0)
 F  L +^HLCS(870,HLDP,0):2 Q:$T
"RTN","HLCSLNCH",148,0)
 ;4=status,10=Time Stopped,9=Time Started,11=Task Number,3=Device Type,14=shutdown
"RTN","HLCSLNCH",149,0)
 S X="HLJ(870,"""_HLDP_","")",@X@(4)="Halting",@X@(10)=$$NOW^XLFDT,(@X@(11),@X@(9))="@",@X@(14)=1
"RTN","HLCSLNCH",150,0)
 I $P(HLPARM4,U,3)="C"&("N"[$P(HLPARM4,U,4)),'$P(HLPARM0,U,12) S @X@(4)="Shutdown"
"RTN","HLCSLNCH",151,0)
 D FILE^HLDIE("","HLJ","","STOP","HLCSLNCH") ; HL*1.6*109
"RTN","HLCSLNCH",152,0)
 ; patch HL*1.6*122 start
"RTN","HLCSLNCH",153,0)
 ; I ^%ZOSF("OS")["OpenM",(($P(HLPARM4,U,3)="M"&($$OS^%ZOSV'["VMS"))!($P(HLPARM4,U,3)="S")) D
"RTN","HLCSLNCH",154,0)
 ; I ^%ZOSF("OS")'["DSM",(($P(HLPARM4,U,3)="M"&($$OS^%ZOSV'["VMS"))!($P(HLPARM4,U,3)="S")) D
"RTN","HLCSLNCH",155,0)
 I ($P(HLPARM4,U,3)="S")!(($P(HLPARM4,U,3)="M")&($S(^%ZOSF("OS")'["OpenM":0,1:$$OS^%ZOSV'["VMS"))) D
"RTN","HLCSLNCH",156,0)
 . ;pass task number to stop listener
"RTN","HLCSLNCH",157,0)
 . S:$P(HLPARM0,U,12) X=$$ASKSTOP^%ZTLOAD(+$P(HLPARM0,U,12))
"RTN","HLCSLNCH",158,0)
 . ; D CALL^%ZISTCP($P(HLPARM4,U),$P(HLPARM4,U,2),10)
"RTN","HLCSLNCH",159,0)
 . ; I POP D HOME^%ZIS U IO W !,"Unable to shutdown logical link!!!",$C(7),$C(7) Q
"RTN","HLCSLNCH",160,0)
 . ; U IO W "**STOP**"
"RTN","HLCSLNCH",161,0)
 . ; W !
"RTN","HLCSLNCH",162,0)
 . ; D CLOSE^%ZISTCP
"RTN","HLCSLNCH",163,0)
 . ; patch HL*1.6*122 end
"RTN","HLCSLNCH",164,0)
 L -^HLCS(870,HLDP,0)
"RTN","HLCSLNCH",165,0)
 W !,"The job for the "_HLDAPP_" Lower Level Protocol will be shut down."
"RTN","HLCSLNCH",166,0)
 Q
"RTN","HLCSLNCH",167,0)
 ;
"RTN","HLCSLNCH",168,0)
STOPQ Q
"RTN","HLCSMON")
0^35^B54162059^B52128223
"RTN","HLCSMON",1,0)
HLCSMON ;SF-DISPLAY DRIVER PROGRAM  ;12/11/2007  17:07
"RTN","HLCSMON",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**34,40,48,49,65,66,73,109,122**;Oct 13, 1995;Build 14
"RTN","HLCSMON",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLCSMON",4,0)
 ;
"RTN","HLCSMON",5,0)
 ;This Program drives a real-time display monitor for the HL7
"RTN","HLCSMON",6,0)
 ;Package. All the data used by this display is stored in file
"RTN","HLCSMON",7,0)
 ;# 870. Several callable entry points were broken
"RTN","HLCSMON",8,0)
 ;out of this routine and placed into HLCSMON1
"RTN","HLCSMON",9,0)
 ;
"RTN","HLCSMON",10,0)
 ;This routine has no required input parameters other than require that
"RTN","HLCSMON",11,0)
 ;U be defined, it does not instantiate any parameters either.
"RTN","HLCSMON",12,0)
 ;
"RTN","HLCSMON",13,0)
 ;
"RTN","HLCSMON",14,0)
 ;HLARY=array of all,HLARYD=array of display,HLARYO=array of old values
"RTN","HLCSMON",15,0)
 ;HLPTR1=top of display,HLPTR2=bottom of display,HLPTR3=last in HLVARY
"RTN","HLCSMON",16,0)
INIT N HLARY,HLARYD,HLARYO,HLCOFF,HLCON,HLDISP,HLPTR1,HLPTR2,HLPTR3,HLRESP
"RTN","HLCSMON",17,0)
 N HLDEV,HLERR,HLEVL,HLHDR,HLNODE,HLOCK
"RTN","HLCSMON",18,0)
 N HLPARAM,HLPROC,HLPROD,HLSEND,HLSENT,HLSITE
"RTN","HLCSMON",19,0)
 N HLI,HLREC,HLRUNCNT,HLSTAT,HLTMSTAT,HLLMSTAT,HLVIEW,HLXX,HLYY,X,Y,DX,DY
"RTN","HLCSMON",20,0)
 ;
"RTN","HLCSMON",21,0)
 ; patch HL*1.6*122 start
"RTN","HLCSMON",22,0)
 D HOME^%ZIS
"RTN","HLCSMON",23,0)
 W @IOF
"RTN","HLCSMON",24,0)
 ; patch HL*1.6*122 end
"RTN","HLCSMON",25,0)
 ;
"RTN","HLCSMON",26,0)
 D ^HLCSTERM ;Sets up variables to control display attributes
"RTN","HLCSMON",27,0)
INIT1 ;
"RTN","HLCSMON",28,0)
 ; Next 4 lines copied here from top of START by patch 73...
"RTN","HLCSMON",29,0)
 ;HLRUNCNT=number of in filers^out filers, HLDISP=display mode
"RTN","HLCSMON",30,0)
 S HLRUNCNT="-1^-1",HLPTR1=1 S:'$D(HLDISP) HLDISP="S"
"RTN","HLCSMON",31,0)
 D BUILDARY ;Build an array for display
"RTN","HLCSMON",32,0)
 QUIT:$$LOCKED(.HLOCK)  ;-> Anything locked?
"RTN","HLCSMON",33,0)
 ;
"RTN","HLCSMON",34,0)
 W HLCOFF ;Shut Cursor off
"RTN","HLCSMON",35,0)
 D HEADER^HLCSTERM ;Write header
"RTN","HLCSMON",36,0)
 D WDATA^HLCSMON1(5,17,"","","Incoming filers running => ")
"RTN","HLCSMON",37,0)
 D WDATA^HLCSMON1(5,18,"","","Outgoing filers running => ")
"RTN","HLCSMON",38,0)
 D WDATA^HLCSMON1(5,20,"","","Select a Command:")
"RTN","HLCSMON",39,0)
 D WDATA^HLCSMON1(1,21,"","","(N)EXT  (B)ACKUP  (A)LL LINKS  (S)CREENED  (V)IEWS  (Q)UIT  (?) HELP: ")
"RTN","HLCSMON",40,0)
 ;HLRUNCNT=number of in filers^out filers, HLDISP=display mode
"RTN","HLCSMON",41,0)
 S HLRUNCNT="-1^-1",HLPTR1=1 S:'$D(HLDISP) HLDISP="S"
"RTN","HLCSMON",42,0)
START ;
"RTN","HLCSMON",43,0)
 D BUILDARY ;Build an array for display
"RTN","HLCSMON",44,0)
 D DISPLAY^HLCSMON1 ;Display the array just built
"RTN","HLCSMON",45,0)
 D READ
"RTN","HLCSMON",46,0)
 ;HLRESP=user response
"RTN","HLCSMON",47,0)
 I '$L(HLRESP) G START
"RTN","HLCSMON",48,0)
 G:HLRESP="Q" EXIT
"RTN","HLCSMON",49,0)
 ;any of following commands, kill old values
"RTN","HLCSMON",50,0)
 K HLARYO,HLTMSTAT,HLLMSTAT
"RTN","HLCSMON",51,0)
 I HLRESP="?" D HELP G INIT1
"RTN","HLCSMON",52,0)
 I HLRESP="V" D VIEW G INIT1
"RTN","HLCSMON",53,0)
 I "AS"[HLRESP K HLARY,HLEVL S HLDISP=HLRESP G INIT1
"RTN","HLCSMON",54,0)
 I "NB"[HLRESP D NEXT
"RTN","HLCSMON",55,0)
 G START
"RTN","HLCSMON",56,0)
 ;
"RTN","HLCSMON",57,0)
READ ;Prompt the user for the next action
"RTN","HLCSMON",58,0)
 D WDATA^HLCSMON1(71,21,"","","",1)
"RTN","HLCSMON",59,0)
 W HLCON
"RTN","HLCSMON",60,0)
 R X#1:3
"RTN","HLCSMON",61,0)
 W HLCOFF
"RTN","HLCSMON",62,0)
 S HLRESP=$S(X="":X,"Qq^"[X:"Q","Bb"[X:"B","Nn"[X:"N","Aa"[X:"A","Vv"[X:"V",X="?":"?","Ss"[X:"S",1:"")
"RTN","HLCSMON",63,0)
 Q
"RTN","HLCSMON",64,0)
 ;
"RTN","HLCSMON",65,0)
VIEW ;select new view
"RTN","HLCSMON",66,0)
 W HLCON,!!
"RTN","HLCSMON",67,0)
 N DIC
"RTN","HLCSMON",68,0)
 S DIC="^HLCS(869.3,1,6,",DIC(0)="QEA"
"RTN","HLCSMON",69,0)
 D ^DIC Q:Y<0
"RTN","HLCSMON",70,0)
 S HLVIEW=+Y,HLDISP="V"
"RTN","HLCSMON",71,0)
 W HLCOFF
"RTN","HLCSMON",72,0)
 Q
"RTN","HLCSMON",73,0)
 ;
"RTN","HLCSMON",74,0)
NEXT ;
"RTN","HLCSMON",75,0)
 ;Next page
"RTN","HLCSMON",76,0)
 I HLRESP="N" D
"RTN","HLCSMON",77,0)
 . ;no more
"RTN","HLCSMON",78,0)
 . I HLPTR2=HLPTR3 D EOB Q
"RTN","HLCSMON",79,0)
 . S Y=HLPTR2+10,HLEVL(HLPTR1)=""
"RTN","HLCSMON",80,0)
 . ;exceed list, get last 10
"RTN","HLCSMON",81,0)
 . I Y>HLPTR3 S HLPTR2=HLPTR3,HLPTR1=HLPTR2-9 Q
"RTN","HLCSMON",82,0)
 . S HLPTR1=HLPTR2,HLPTR2=Y
"RTN","HLCSMON",83,0)
 ;
"RTN","HLCSMON",84,0)
 ;Backup a page
"RTN","HLCSMON",85,0)
 I HLRESP="B" D
"RTN","HLCSMON",86,0)
 . ;top of list
"RTN","HLCSMON",87,0)
 . I HLPTR1=1 D EOB Q
"RTN","HLCSMON",88,0)
 . I HLDISP="S" S HLPTR1=$O(HLEVL(HLPTR1),-1) Q
"RTN","HLCSMON",89,0)
 . S Y=HLPTR1-9
"RTN","HLCSMON",90,0)
 . ;can't go back 10, reset to top
"RTN","HLCSMON",91,0)
 . I Y'>0 S HLPTR1=1,HLPTR2=10 Q
"RTN","HLCSMON",92,0)
 . S HLPTR2=HLPTR1,HLPTR1=Y
"RTN","HLCSMON",93,0)
 ;
"RTN","HLCSMON",94,0)
 ;Erase what might be displayed on line 22
"RTN","HLCSMON",95,0)
 D WDATA^HLCSMON1(1,22,IOELALL,"","")
"RTN","HLCSMON",96,0)
 Q
"RTN","HLCSMON",97,0)
EOB D WDATA^HLCSMON1(5,22,IORVON,IORVOFF,"CANNOT "_$S(HLRESP="N":"ADVANCE",1:"BACKUP")_" BEYOND END OF BUFFER")
"RTN","HLCSMON",98,0)
 W $C(7) H 2
"RTN","HLCSMON",99,0)
 Q
"RTN","HLCSMON",100,0)
 ;
"RTN","HLCSMON",101,0)
BUILDARY ;
"RTN","HLCSMON",102,0)
 K HLARYD
"RTN","HLCSMON",103,0)
 ;
"RTN","HLCSMON",104,0)
 ;if view is defined, get links
"RTN","HLCSMON",105,0)
 I $G(HLVIEW) D  S HLVIEW=0,HLDISP="V"
"RTN","HLCSMON",106,0)
 . N HLTMP
"RTN","HLCSMON",107,0)
 . K HLARY,HLEVL S HLI=0
"RTN","HLCSMON",108,0)
 . F  S HLI=$O(^HLCS(869.3,1,6,HLVIEW,1,HLI)) Q:'HLI  S HLYY=+$P($G(^(HLI,0)),U,2) D
"RTN","HLCSMON",109,0)
 .. S Y=$P($G(^HLCS(870,HLI,0)),U) Q:Y=""
"RTN","HLCSMON",110,0)
 .. ;build array by DISPLAY ORDER and then by NAME
"RTN","HLCSMON",111,0)
 .. I HLYY S HLTMP(HLYY,HLI)="" Q
"RTN","HLCSMON",112,0)
 .. S HLTMP(Y,HLI)=""
"RTN","HLCSMON",113,0)
 . S (HLI,HLYY)=0
"RTN","HLCSMON",114,0)
 . ;rebuild array to put in proper order
"RTN","HLCSMON",115,0)
 . F  S HLI=$O(HLTMP(HLI)),HLXX=0 Q:HLI=""  D
"RTN","HLCSMON",116,0)
 .. F  S HLXX=$O(HLTMP(HLI,HLXX)) Q:'HLXX  S HLYY=HLYY+1,HLARY(HLYY,HLXX)=""
"RTN","HLCSMON",117,0)
 . S HLPTR3=HLYY
"RTN","HLCSMON",118,0)
 ;
"RTN","HLCSMON",119,0)
 I '$D(HLARY)  S HLYY=0,HLXX="" D
"RTN","HLCSMON",120,0)
 . ;build array in alphabetical order
"RTN","HLCSMON",121,0)
 . F  S HLXX=$O(^HLCS(870,"B",HLXX)) Q:HLXX=""  S Y=$O(^(HLXX,0)),HLYY=HLYY+1,HLARY(HLYY,Y)=""
"RTN","HLCSMON",122,0)
 . S HLPTR3=HLYY
"RTN","HLCSMON",123,0)
 ;
"RTN","HLCSMON",124,0)
 S HLI=HLPTR1,HLYY=6 ;HLYY=6TH Line of display
"RTN","HLCSMON",125,0)
 ;HLARYD(6) through HLARYD(15) with 6 through 15 also representing line
"RTN","HLCSMON",126,0)
 ;numbers on the display
"RTN","HLCSMON",127,0)
 F HLI=HLI:1 S HLXX=$O(HLARY(HLI,0)) Q:HLYY=16!'HLXX  D COPY
"RTN","HLCSMON",128,0)
 S HLPTR2=HLI-1
"RTN","HLCSMON",129,0)
 ;Set all HLARY elements not defined on this pass to null
"RTN","HLCSMON",130,0)
 F HLYY=HLYY:1:15 S HLARYD(HLYY)=""
"RTN","HLCSMON",131,0)
 Q
"RTN","HLCSMON",132,0)
COPY ;
"RTN","HLCSMON",133,0)
 Q:'$D(^HLCS(870,HLXX))
"RTN","HLCSMON",134,0)
 ;
"RTN","HLCSMON",135,0)
 ;These lock tags lock nodes in the global so that the screen is
"RTN","HLCSMON",136,0)
 ;refreshed in real-time. The lock forces the buffer to be refreshed,
"RTN","HLCSMON",137,0)
 ;so that the display is up to date.
"RTN","HLCSMON",138,0)
 ;
"RTN","HLCSMON",139,0)
 ;**109**
"RTN","HLCSMON",140,0)
 ;L +^HLCS(870,HLXX,0):0 L -^HLCS(870,HLXX,0) D CHKLOCK
"RTN","HLCSMON",141,0)
 ;
"RTN","HLCSMON",142,0)
 ; Set, even if not able to lock...
"RTN","HLCSMON",143,0)
 S Y=$G(^HLCS(870,HLXX,0))
"RTN","HLCSMON",144,0)
 ;
"RTN","HLCSMON",145,0)
 ;name^rec^proc^send^sent^device^state^error
"RTN","HLCSMON",146,0)
 S HLARYD(HLYY)=$P(Y,U)_"^^^^^"_$P(Y,U,4)_"^"_$P(Y,U,5)_"^"_$P(Y,U,19)
"RTN","HLCSMON",147,0)
 ;
"RTN","HLCSMON",148,0)
 ;**109**
"RTN","HLCSMON",149,0)
 ;L +^HLCS(870,HLXX,"IN QUEUE BACK POINTER"):0 D CHKLOCK
"RTN","HLCSMON",150,0)
 ;L -^HLCS(870,HLXX,"IN QUEUE BACK POINTER")
"RTN","HLCSMON",151,0)
 ;
"RTN","HLCSMON",152,0)
 S $P(HLARYD(HLYY),U,2)=$G(^HLCS(870,HLXX,"IN QUEUE BACK POINTER"))
"RTN","HLCSMON",153,0)
 ;
"RTN","HLCSMON",154,0)
 ;**109**
"RTN","HLCSMON",155,0)
 ;L +^HLCS(870,HLXX,"IN QUEUE FRONT POINTER"):0 D CHKLOCK
"RTN","HLCSMON",156,0)
 ;L -^HLCS(870,HLXX,"IN QUEUE FRONT POINTER")
"RTN","HLCSMON",157,0)
 ;
"RTN","HLCSMON",158,0)
 S $P(HLARYD(HLYY),U,3)=$G(^HLCS(870,HLXX,"IN QUEUE FRONT POINTER"))
"RTN","HLCSMON",159,0)
 ;
"RTN","HLCSMON",160,0)
 ;**109**
"RTN","HLCSMON",161,0)
 ;L +^HLCS(870,HLXX,"OUT QUEUE BACK POINTER"):0 D CHKLOCK
"RTN","HLCSMON",162,0)
 ;L -^HLCS(870,HLXX,"OUT QUEUE BACK POINTER")
"RTN","HLCSMON",163,0)
 ;
"RTN","HLCSMON",164,0)
 S $P(HLARYD(HLYY),U,4)=$G(^HLCS(870,HLXX,"OUT QUEUE BACK POINTER"))
"RTN","HLCSMON",165,0)
 ;
"RTN","HLCSMON",166,0)
 ;**109**
"RTN","HLCSMON",167,0)
 ;L +^HLCS(870,HLXX,"OUT QUEUE FRONT POINTER"):0 D CHKLOCK
"RTN","HLCSMON",168,0)
 ;L -^HLCS(870,HLXX,"OUT QUEUE FRONT POINTER")
"RTN","HLCSMON",169,0)
 ;
"RTN","HLCSMON",170,0)
 S $P(HLARYD(HLYY),U,5)=$G(^HLCS(870,HLXX,"OUT QUEUE FRONT POINTER"))
"RTN","HLCSMON",171,0)
 ;
"RTN","HLCSMON",172,0)
 S X=HLARYD(HLYY),Y=$P(X,U,2)+$P(X,U,3)+$P(X,U,4)+$P(X,U,5)
"RTN","HLCSMON",173,0)
 ;if Select and the Y=0, nothing to report
"RTN","HLCSMON",174,0)
 I 'Y,HLDISP="S" S HLARYD(HLYY)="" Q
"RTN","HLCSMON",175,0)
 S HLYY=HLYY+1
"RTN","HLCSMON",176,0)
 Q
"RTN","HLCSMON",177,0)
 ;
"RTN","HLCSMON",178,0)
CHKLOCK ; Call here immediately after trying to lock.  And, BE SURE that 
"RTN","HLCSMON",179,0)
 ; nothing might occur that would change $T after the lock attempt!!
"RTN","HLCSMON",180,0)
 ; $T,HLXX -- req
"RTN","HLCSMON",181,0)
 N NM870
"RTN","HLCSMON",182,0)
 QUIT:$T  ;-> Lock obtained...
"RTN","HLCSMON",183,0)
 S NM870=$P($G(^HLCS(870,+HLXX,0)),U)
"RTN","HLCSMON",184,0)
 S NM870=$S(NM870]"":NM870_" (IEN #"_HLXX_")",1:"IEN #"_HLXX)
"RTN","HLCSMON",185,0)
 S HLOCK(NM870)=""
"RTN","HLCSMON",186,0)
 QUIT
"RTN","HLCSMON",187,0)
 ;
"RTN","HLCSMON",188,0)
HELP ;
"RTN","HLCSMON",189,0)
 W HLCON,@IOF
"RTN","HLCSMON",190,0)
 W !,"You have the following options when monitoring the Messaging System:"
"RTN","HLCSMON",191,0)
 W !,"Enter the command letter parentheses: N,B,Q,A,S,V or ?"
"RTN","HLCSMON",192,0)
 W !!,"(N) takes you to the next page of the display of Logical Links."
"RTN","HLCSMON",193,0)
 W !!,"(B) takes you back one page."
"RTN","HLCSMON",194,0)
 W !!,"(Q) terminates the monitor."
"RTN","HLCSMON",195,0)
 W !!,"(A) provides a display of all links defined on your system."
"RTN","HLCSMON",196,0)
 W !!,"(S) displays only those links that have had message traffic."
"RTN","HLCSMON",197,0)
 W !!,"(V) prompts for a view name and displays links defined in view."
"RTN","HLCSMON",198,0)
 W !!,"    Note that (S) is the default display at startup."
"RTN","HLCSMON",199,0)
 W !!,"**PRESS <RET> TO CONTINUE**"
"RTN","HLCSMON",200,0)
 R X:DTIME
"RTN","HLCSMON",201,0)
 W @IOF
"RTN","HLCSMON",202,0)
 W !,?25,"Device Types and corresponding prefixes:"
"RTN","HLCSMON",203,0)
 W !!,?30,"PC -- Persistent TCP/IP Client"
"RTN","HLCSMON",204,0)
 W !!,?30,"NC -- Non-Persistent TCP/IP Client"
"RTN","HLCSMON",205,0)
 W !!,?30,"SS -- Single-threaded TCP/IP Server"
"RTN","HLCSMON",206,0)
 W !!,?30,"MS -- Multi-threaded TCP/IP Server"
"RTN","HLCSMON",207,0)
 W !!,?30,"SH -- Serial HLLP"
"RTN","HLCSMON",208,0)
 W !!,?30,"SX -- Serial X3.28"
"RTN","HLCSMON",209,0)
 W !!,?30,"MM -- MailMan"
"RTN","HLCSMON",210,0)
 W !!,"**PRESS <RET> TO CONTINUE**"
"RTN","HLCSMON",211,0)
 R X:DTIME
"RTN","HLCSMON",212,0)
 W HLCOFF
"RTN","HLCSMON",213,0)
 Q
"RTN","HLCSMON",214,0)
EXIT ;
"RTN","HLCSMON",215,0)
 ;Turn Cursor back on
"RTN","HLCSMON",216,0)
 W HLCON
"RTN","HLCSMON",217,0)
 D KVAR^HLCSTERM
"RTN","HLCSMON",218,0)
 Q
"RTN","HLCSMON",219,0)
 ;
"RTN","HLCSMON",220,0)
LOCKED(HLOCK) ; Anything locked?
"RTN","HLCSMON",221,0)
 ;
"RTN","HLCSMON",222,0)
 ;
"RTN","HLCSMON",223,0)
 ; Nothing locked...
"RTN","HLCSMON",224,0)
 I '$D(HLOCK) QUIT "" ;->
"RTN","HLCSMON",225,0)
 ;
"RTN","HLCSMON",226,0)
 W !!,"Editing of logical link data is occurring right now.  For this reason, some of"
"RTN","HLCSMON",227,0)
 W !,"the information on the 'System Link Monitor' report might not be accurate for"
"RTN","HLCSMON",228,0)
 W !,"the following node(s)..."
"RTN","HLCSMON",229,0)
 W !
"RTN","HLCSMON",230,0)
 ;
"RTN","HLCSMON",231,0)
 S HLOCK=""
"RTN","HLCSMON",232,0)
 F  S HLOCK=$O(HLOCK(HLOCK)) Q:HLOCK']""  D
"RTN","HLCSMON",233,0)
 .  W !,?5,HLOCK
"RTN","HLCSMON",234,0)
 ;
"RTN","HLCSMON",235,0)
 S ACTION=$$BTE("Press RETURN to print report or '^' to exit... ",1)
"RTN","HLCSMON",236,0)
 ;
"RTN","HLCSMON",237,0)
 QUIT $S(ACTION=1:1,1:"")
"RTN","HLCSMON",238,0)
 ;
"RTN","HLCSMON",239,0)
BTE(PMT,FF) ; 
"RTN","HLCSMON",240,0)
 N DIR,DIRUT,DTOUT,DUOUT,X,Y
"RTN","HLCSMON",241,0)
 F X=1:1:$G(FF) W !
"RTN","HLCSMON",242,0)
 S DIR(0)="EA",DIR("A")=PMT
"RTN","HLCSMON",243,0)
 D ^DIR
"RTN","HLCSMON",244,0)
 QUIT $S(Y=1:"",1:1)
"RTN","HLCSMON",245,0)
 ;
"RTN","HLCSMON1")
0^18^B10975872^B8085567
"RTN","HLCSMON1",1,0)
HLCSMON1 ;SF-Utilities for Driver Program  ;07/17/2007  17:05
"RTN","HLCSMON1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**15,40,49,65,109,122**;Oct 13, 1995;Build 14
"RTN","HLCSMON1",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLCSMON1",4,0)
 ;
"RTN","HLCSMON1",5,0)
 ;This routine contains several entry points called from HLCSMON
"RTN","HLCSMON1",6,0)
 ;no input parameters are required. All variables used which are
"RTN","HLCSMON1",7,0)
 ;not newed here are newed in HLCSMON
"RTN","HLCSMON1",8,0)
 ;
"RTN","HLCSMON1",9,0)
DISPLAY ;display link info
"RTN","HLCSMON1",10,0)
 ;turn of line wrap
"RTN","HLCSMON1",11,0)
 S HLXX=0,X=0 X ^%ZOSF("RM")
"RTN","HLCSMON1",12,0)
 F  S HLXX=$O(HLARYD(HLXX)) Q:(HLXX'>0)  D WLINE(HLXX)
"RTN","HLCSMON1",13,0)
 ;DISPLAY INCOMING FILER STATUS
"RTN","HLCSMON1",14,0)
 ; patch HL*1.6*122
"RTN","HLCSMON1",15,0)
 S HLXX=$P(HLRUNCNT,"^",1)
"RTN","HLCSMON1",16,0)
 ; S HLXX=$$CNTFLR^HLCSUTL2("IN")
"RTN","HLCSMON1",17,0)
 I (+HLXX)=-1 S HLXX=$$CNTFLR^HLCSUTL2("IN")
"RTN","HLCSMON1",18,0)
 ;
"RTN","HLCSMON1",19,0)
 ;ONLY UPDATE SCREEN IF COUNT HAS CHANGED
"RTN","HLCSMON1",20,0)
 I (HLXX'=+HLRUNCNT) D
"RTN","HLCSMON1",21,0)
 .D WDATA(5,17,"","",$J(" ",31)),WDATA^HLCSMON1(5,17,"","","Incoming filers running => ",35)
"RTN","HLCSMON1",22,0)
 .I (HLXX) D WDATA(32,17,"","",HLXX)
"RTN","HLCSMON1",23,0)
 .I ('HLXX) D WDATA(32,17,IOINHI,IOINORM,"Zero")
"RTN","HLCSMON1",24,0)
 .S $P(HLRUNCNT,"^",1)=HLXX
"RTN","HLCSMON1",25,0)
 ;DISPLAY OUTGOING FILER STATUS
"RTN","HLCSMON1",26,0)
 ; patch HL*1.6*122
"RTN","HLCSMON1",27,0)
 S HLXX=$P(HLRUNCNT,"^",2)
"RTN","HLCSMON1",28,0)
 ; S HLXX=$$CNTFLR^HLCSUTL2("OUT") 
"RTN","HLCSMON1",29,0)
 I (+HLXX)=-1 S HLXX=$$CNTFLR^HLCSUTL2("OUT")
"RTN","HLCSMON1",30,0)
 ;
"RTN","HLCSMON1",31,0)
 ;ONLY UPDATE SCREEN IF COUNT HAS CHANGED
"RTN","HLCSMON1",32,0)
 I (HLXX'=+$P(HLRUNCNT,"^",2)) D
"RTN","HLCSMON1",33,0)
 .D WDATA(5,18,"","",$J(" ",31)),WDATA^HLCSMON1(5,18,"","","Outgoing filers running => ",35)
"RTN","HLCSMON1",34,0)
 .I (HLXX) D WDATA(32,18,"","",HLXX)
"RTN","HLCSMON1",35,0)
 .I ('HLXX) D WDATA(32,18,IOINHI,IOINORM,"Zero")
"RTN","HLCSMON1",36,0)
 .S $P(HLRUNCNT,"^",2)=HLXX
"RTN","HLCSMON1",37,0)
 S X=$$TM^%ZTLOAD
"RTN","HLCSMON1",38,0)
 I X'=$G(HLTMSTAT) D
"RTN","HLCSMON1",39,0)
 .S HLTMSTAT=X
"RTN","HLCSMON1",40,0)
 .S HLXX=$S('HLTMSTAT:"***TASKMAN NOT RUNNING!!!***",1:"")
"RTN","HLCSMON1",41,0)
 .I 'HLTMSTAT D WDATA^HLCSMON1(45,17,IOELEOL_IOBON_IORVON,IOBOFF_IORVOFF,HLXX) I 1
"RTN","HLCSMON1",42,0)
 .E  D WDATA(45,17,IOELEOL,"",$J("TaskMan running ",16)) ;D WDATA(5,19,IOELALL,"","")
"RTN","HLCSMON1",43,0)
 S X=$$STAT^HLCSLM
"RTN","HLCSMON1",44,0)
 I X'=$G(HLLMSTAT) D
"RTN","HLCSMON1",45,0)
 .S HLLMSTAT=X Q:HLLMSTAT=3
"RTN","HLCSMON1",46,0)
 .S HLXX=$S('HLLMSTAT:"***LINK MANAGER NOT RUNNING!!!***",1:"")
"RTN","HLCSMON1",47,0)
 .I 'HLLMSTAT D WDATA^HLCSMON1(45,18,IOELEOL_IOBON_IORVON,IOBOFF_IORVOFF,HLXX) I 1
"RTN","HLCSMON1",48,0)
 .E  D WDATA^HLCSMON1(45,18,IOELEOL,"",$J("Link Manager running",18))
"RTN","HLCSMON1",49,0)
 ;Turn terminal line wrap back on
"RTN","HLCSMON1",50,0)
 D WDATA(45,19,IOELEOL,"",$$SLM^HLEVUTIL) ; HL*1.6*109
"RTN","HLCSMON1",51,0)
 S X=IOM X ^%ZOSF("RM")
"RTN","HLCSMON1",52,0)
 Q
"RTN","HLCSMON1",53,0)
 ;
"RTN","HLCSMON1",54,0)
WLINE(HLXX) ;write line from HLARYD=current values, HLARYO=old values
"RTN","HLCSMON1",55,0)
 ;if values haven't changed, don't do anything
"RTN","HLCSMON1",56,0)
 I HLARYD(HLXX)]"",HLARYD(HLXX)=$G(HLARYO(HLXX)) Q
"RTN","HLCSMON1",57,0)
 S HLARYO(HLXX)=HLARYD(HLXX),HLERR=$P(HLARYD(HLXX),U,8),DX=1
"RTN","HLCSMON1",58,0)
 ; patch HL*1.6*122
"RTN","HLCSMON1",59,0)
 ; F X=1:1:7 S @$P("HLNODE^HLREC^HLPROC^HLSEND^HLSENT^HLDEV^HLSTAT",U,X)=$E($P(HLARYD(HLXX),U,X)_"        ",1,8)
"RTN","HLCSMON1",60,0)
 F X=1,7 S @$P("HLNODE^HLREC^HLPROC^HLSEND^HLSENT^HLDEV^HLSTAT",U,X)=$E($P(HLARYD(HLXX),U,X)_"        ",1,10)
"RTN","HLCSMON1",61,0)
 F X=2:1:5 S @$P("HLNODE^HLREC^HLPROC^HLSEND^HLSENT^HLDEV^HLSTAT",U,X)=$E($P(HLARYD(HLXX),U,X)_"        ",1,8)
"RTN","HLCSMON1",62,0)
 S X=6,@$P("HLNODE^HLREC^HLPROC^HLSEND^HLSENT^HLDEV^HLSTAT",U,X)=$E($P(HLARYD(HLXX),U,X)_"        ",1,7)
"RTN","HLCSMON1",63,0)
 ;
"RTN","HLCSMON1",64,0)
 ;if link is in error, write node in rev. video
"RTN","HLCSMON1",65,0)
 I HLERR]"" D WDATA(5,HLXX,IOBON_IORVON,IOBOFF_IORVOFF,HLNODE,8) S DX=14
"RTN","HLCSMON1",66,0)
 ;Turn off terminal line wrap & inform O/S where cursor is located
"RTN","HLCSMON1",67,0)
 S DY=HLXX X IOXY,^%ZOSF("XY")
"RTN","HLCSMON1",68,0)
 ; patch HL*1.6*122
"RTN","HLCSMON1",69,0)
 W:HLERR="" ?4,HLNODE
"RTN","HLCSMON1",70,0)
 W ?16,HLREC,?26,HLPROC,?37,HLSEND,?47,HLSENT,?58,HLDEV,?63,HLSTAT
"RTN","HLCSMON1",71,0)
 ;
"RTN","HLCSMON1",72,0)
 Q
"RTN","HLCSMON1",73,0)
 ;
"RTN","HLCSMON1",74,0)
WDATA(DX,DY,IO1,IO2,HLDATA,HLENGTH) ;
"RTN","HLCSMON1",75,0)
 ;
"RTN","HLCSMON1",76,0)
 ;First erase the data block then write to it. Attributes are 
"RTN","HLCSMON1",77,0)
 ;contained in IO1 & IO2
"RTN","HLCSMON1",78,0)
 ;
"RTN","HLCSMON1",79,0)
 N X S X=0 X ^%ZOSF("RM") X ^%ZOSF("XY")
"RTN","HLCSMON1",80,0)
 ;Turn off terminal line wrap & inform O/S where cursor is located
"RTN","HLCSMON1",81,0)
 I '$D(HLENGTH) S HLENGTH=$L(HLDATA)
"RTN","HLCSMON1",82,0)
 X IOXY W IOSC,$E($J(" ",79),1,HLENGTH),IORC W IO1,$E(HLDATA,1,HLENGTH),IO2
"RTN","HLCSMON1",83,0)
 S X=IOM X ^%ZOSF("RM")
"RTN","HLCSMON1",84,0)
 ;Turn terminal line wrap back on
"RTN","HLCSMON1",85,0)
 Q
"RTN","HLCSREP")
0^30^B2826311^B2010073
"RTN","HLCSREP",1,0)
HLCSREP ;ALB/MFK - HL7 QUEUE MANAGEMENT ;10/17/2007  08:56
"RTN","HLCSREP",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109,122**;Oct 13, 1995;Build 14
"RTN","HLCSREP",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLCSREP",4,0)
 ;
"RTN","HLCSREP",5,0)
REPMSG ;Duplicate messages on a queue
"RTN","HLCSREP",6,0)
 ; INPUT:  MSG   - Array which contains the queue and the
"RTN","HLCSREP",7,0)
 ;                 message numbers for msgs to be re-queued
"RTN","HLCSREP",8,0)
 ;                 MSG(QUEUE,NUMBER)
"RTN","HLCSREP",9,0)
 ; OUTPUT: NONE
"RTN","HLCSREP",10,0)
 N DIC,LLE,X,Y,DA,ERROR,FROMID,MSGID
"RTN","HLCSREP",11,0)
 N TOID,ENTRY,LLE
"RTN","HLCSREP",12,0)
 Q:('$D(MSG))
"RTN","HLCSREP",13,0)
 ;  create new entries
"RTN","HLCSREP",14,0)
 S (LLE,ERROR)=""
"RTN","HLCSREP",15,0)
 F  S LLE=$O(MSG(LLE)) Q:(LLE="")!(ERROR)  D
"RTN","HLCSREP",16,0)
 .S ENTRY=""
"RTN","HLCSREP",17,0)
 .F  S ENTRY=$O(MSG(LLE,ENTRY)) Q:(ENTRY="")!(ERROR)  D
"RTN","HLCSREP",18,0)
 ..S MSGID=$$ENQUEUE^HLCSQUE(LLE,"OUT")
"RTN","HLCSREP",19,0)
 ..I +MSGID'>0 S ERROR=1 Q
"RTN","HLCSREP",20,0)
 ..S TOID=$P(MSGID,"^",2)
"RTN","HLCSREP",21,0)
 ..M ^HLCS(870,LLE,2,TOID)=^HLCS(870,LLE,2,ENTRY)
"RTN","HLCSREP",22,0)
 ..;  Change .01 of new record to be IEN
"RTN","HLCSREP",23,0)
 ..S $P(^HLCS(870,LLE,2,TOID,0),"^",1)=TOID
"RTN","HLCSREP",24,0)
 ..S $P(^HLCS(870,LLE,2,TOID,0),"^",2)="P"
"RTN","HLCSREP",25,0)
EXIT ;
"RTN","HLCSREP",26,0)
 Q
"RTN","HLCSREP",27,0)
 ;
"RTN","HLCSREP",28,0)
ENQUE(LINK,DIR,IEN773) ;
"RTN","HLCSREP",29,0)
 ;This routine will place the message=IEN773 on the "AC" xref of file 773.
"RTN","HLCSREP",30,0)
 ;Input:
"RTN","HLCSREP",31,0)
 ;  DIR = "I" or "O", denoting the direction that the message is going in
"RTN","HLCSREP",32,0)
 ;  LINK = the ien of the logical link
"RTN","HLCSREP",33,0)
 ;  IEN773 = ien of the message in file 773
"RTN","HLCSREP",34,0)
 ;
"RTN","HLCSREP",35,0)
 Q:'$G(LINK)
"RTN","HLCSREP",36,0)
 I DIR'="I",DIR'="O" Q
"RTN","HLCSREP",37,0)
 Q:'$G(IEN773)
"RTN","HLCSREP",38,0)
 ;
"RTN","HLCSREP",39,0)
 ; patch HL*1.6*122: MPI-client/server
"RTN","HLCSREP",40,0)
 F  L +^HLMA("AC",DIR,LINK,IEN773):10 Q:$T  H 1
"RTN","HLCSREP",41,0)
 S ^HLMA("AC",DIR,LINK,IEN773)=""
"RTN","HLCSREP",42,0)
 L -^HLMA("AC",DIR,LINK,IEN773)
"RTN","HLCSREP",43,0)
 ;
"RTN","HLCSREP",44,0)
 S $P(^HLMA(+IEN773,0),U,17)=+LINK ; HL*1.6*109 - lja
"RTN","HLCSREP",45,0)
 I DIR="O" D LLCNT^HLCSTCP(LINK,3)
"RTN","HLCSREP",46,0)
 Q
"RTN","HLCSREP",47,0)
 ;
"RTN","HLCSREP",48,0)
DEQUE(LINK,DIR,IEN773) ;
"RTN","HLCSREP",49,0)
 ;This routine will remove the message=IEN773 on the "AC" xref of file 773.
"RTN","HLCSREP",50,0)
 ;Input:
"RTN","HLCSREP",51,0)
 ;  DIR = "I" or "O", denoting the direction that the message is going in
"RTN","HLCSREP",52,0)
 ;  LINK = the ien of the logical link
"RTN","HLCSREP",53,0)
 ;  IEN773 = ien of the message in file 773
"RTN","HLCSREP",54,0)
 ;
"RTN","HLCSREP",55,0)
 Q:'$G(LINK)
"RTN","HLCSREP",56,0)
 I DIR'="I",DIR'="O" Q
"RTN","HLCSREP",57,0)
 Q:'$G(IEN773)
"RTN","HLCSREP",58,0)
 ;
"RTN","HLCSREP",59,0)
 ; patch HL*1.6*122: MPI-client/server
"RTN","HLCSREP",60,0)
 F  L +^HLMA("AC",DIR,LINK,IEN773):10 Q:$T  H 1
"RTN","HLCSREP",61,0)
 K ^HLMA("AC",DIR,LINK,IEN773)
"RTN","HLCSREP",62,0)
 L -^HLMA("AC",DIR,LINK,IEN773)
"RTN","HLCSREP",63,0)
 ;
"RTN","HLCSREP",64,0)
 Q
"RTN","HLCSTCP")
0^19^B46918121^B33765852
"RTN","HLCSTCP",1,0)
HLCSTCP ;SFIRMFO/TNV-ALB/JFP,PKE - (TCP/IP) MLLP ;09/19/2007  10:21
"RTN","HLCSTCP",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**19,43,49,57,58,64,84,109,133,122**;Oct 13, 1995;Build 14
"RTN","HLCSTCP",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLCSTCP",4,0)
 ;
"RTN","HLCSTCP",5,0)
 ; This is an implementation of the HL7 Minimal Lower Layer Protocol
"RTN","HLCSTCP",6,0)
 ; taskman entry/startup option, HLDP defined in menu entry.
"RTN","HLCSTCP",7,0)
 ;
"RTN","HLCSTCP",8,0)
 Q:'$D(HLDP)
"RTN","HLCSTCP",9,0)
 ; patch HL*1.6*122 start
"RTN","HLCSTCP",10,0)
 L +^HLCS("HLTCPLINK",HLDP):5 I '$T D  Q
"RTN","HLCSTCP",11,0)
 . D MON^HLCSTCP("TskLcked")
"RTN","HLCSTCP",12,0)
 N HLCSOUT,HLDBACK,HLDBSIZE,HLDREAD,HLDRETR,HLRETRA,HLDWAIT,HLOS,HLTCPADD,HLTCPCS,HLTCPLNK,HLTCPORT,HLTCPRET
"RTN","HLCSTCP",13,0)
 N HLZRULE
"RTN","HLCSTCP",14,0)
 ;HLCSOUT= 1-error
"RTN","HLCSTCP",15,0)
 I '$$INIT D EXITS("Init Error") Q
"RTN","HLCSTCP",16,0)
 S HLDP("$J")=$J
"RTN","HLCSTCP",17,0)
 S HLDP("$J",0,"LENGTH")=$L(HLDP("$J"))
"RTN","HLCSTCP",18,0)
 ; Start the client
"RTN","HLCSTCP",19,0)
 I $G(HLTCPCS)="C" D  Q
"RTN","HLCSTCP",20,0)
 . S HLDP("$J",0,"START")=HLDP("$J",0,"LENGTH")-8+$L(HLTCPORT)+$L(HLDP)
"RTN","HLCSTCP",21,0)
 . I HLDP("$J",0,"START")<1 S HLDP("$J",0,"START")=1
"RTN","HLCSTCP",22,0)
 . S HLDP("$J",0)=$E(HLDP("$J"),HLDP("$J",0,"START"),HLDP("$J",0,"LENGTH"))
"RTN","HLCSTCP",23,0)
 . ; identify process for ^%SY
"RTN","HLCSTCP",24,0)
 . ; D SETNM^%ZOSV($E("HLClnt:"_HLDP,1,15))
"RTN","HLCSTCP",25,0)
 . D SETNM^%ZOSV($E("HLc:"_HLTCPORT_"-"_HLDP_"-"_HLDP("$J",0),1,15))
"RTN","HLCSTCP",26,0)
 . K HLDP("$J",0)
"RTN","HLCSTCP",27,0)
 . D ST1
"RTN","HLCSTCP",28,0)
 . F  D ^HLCSTCP2 Q:$$STOP!$G(HLCSOUT)
"RTN","HLCSTCP",29,0)
 . ; I $G(HLCSOUT)=1 D MON("Error") H 1 Q
"RTN","HLCSTCP",30,0)
 . I $G(HLCSOUT)=1 D  Q
"RTN","HLCSTCP",31,0)
 .. D MON("Error") H 1
"RTN","HLCSTCP",32,0)
 .. L -^HLCS("HLTCPLINK",HLDP)
"RTN","HLCSTCP",33,0)
 . I $G(HLCSOUT)=2 D EXITS("Inactive") Q
"RTN","HLCSTCP",34,0)
 . D EXITS("Shutdown")
"RTN","HLCSTCP",35,0)
 ;
"RTN","HLCSTCP",36,0)
 S HLDP("$J",0,"START")=HLDP("$J",0,"LENGTH")-9+$L(HLTCPORT)
"RTN","HLCSTCP",37,0)
 I HLDP("$J",0,"START")<1 S HLDP("$J",0,"START")=1
"RTN","HLCSTCP",38,0)
 S HLDP("$J",0)=$E(HLDP("$J"),HLDP("$J",0,"START"),HLDP("$J",0,"LENGTH"))
"RTN","HLCSTCP",39,0)
 ; identify process for ^%SY
"RTN","HLCSTCP",40,0)
 ; D SETNM^%ZOSV($E("HLSrv:"_HLDP,1,15))
"RTN","HLCSTCP",41,0)
 D SETNM^%ZOSV($E("HLs:"_HLTCPORT_"-"_HLDP("$J",0),1,15))
"RTN","HLCSTCP",42,0)
 K HLDP("$J",0)
"RTN","HLCSTCP",43,0)
 ; to stop the listener via updated Kernel API, need to pass the
"RTN","HLCSTCP",44,0)
 ; listener logical link (HLDP)
"RTN","HLCSTCP",45,0)
 S HLZRULE="S HLDP="_HLDP_" S ZISQUIT=$$STOP^HLCSTCP"
"RTN","HLCSTCP",46,0)
 ;single threaded listener
"RTN","HLCSTCP",47,0)
 I $G(HLTCPCS)="S" D  Q
"RTN","HLCSTCP",48,0)
 . D ST1,MON("Listen"),LISTEN^%ZISTCP(HLTCPORT,"SERVER^HLCSTCP("""_HLDP_""")",HLZRULE)
"RTN","HLCSTCP",49,0)
 . I $$STOP D EXITS("Shutdown") Q
"RTN","HLCSTCP",50,0)
 . D EXITS("Openfail")
"RTN","HLCSTCP",51,0)
 ;
"RTN","HLCSTCP",52,0)
 ;multi-threaded listener (for OpenM/NT)
"RTN","HLCSTCP",53,0)
 I ($G(HLTCPCS)'="M")!(^%ZOSF("OS")'["OpenM") D  Q
"RTN","HLCSTCP",54,0)
 . L -^HLCS("HLTCPLINK",HLDP)
"RTN","HLCSTCP",55,0)
 I $$OS^%ZOSV["VMS" L -^HLCS("HLTCPLINK",HLDP) Q
"RTN","HLCSTCP",56,0)
 D ST1,MON("Listen"),LISTEN^%ZISTCPS(HLTCPORT,"SERVERS^HLCSTCP("""_HLDP_""")",HLZRULE)
"RTN","HLCSTCP",57,0)
 ; update status of listener
"RTN","HLCSTCP",58,0)
 I $$STOP D EXITS("Shutdown") Q
"RTN","HLCSTCP",59,0)
 D EXITS("Openfail")
"RTN","HLCSTCP",60,0)
 ; HL*1.6*122 end
"RTN","HLCSTCP",61,0)
 Q
"RTN","HLCSTCP",62,0)
 ;
"RTN","HLCSTCP",63,0)
SERVER(HLDP) ; single server using Taskman
"RTN","HLCSTCP",64,0)
 I '$$INIT D EXITS("Init error") Q
"RTN","HLCSTCP",65,0)
 D ^HLCSTCP1
"RTN","HLCSTCP",66,0)
 I $$STOP D CLOSE^%ZISTCP,EXITS("Shutdown") S IO("C")="" Q
"RTN","HLCSTCP",67,0)
 Q:$G(HLCSOUT)=1
"RTN","HLCSTCP",68,0)
 D MON("Idle")
"RTN","HLCSTCP",69,0)
 Q
"RTN","HLCSTCP",70,0)
 ;
"RTN","HLCSTCP",71,0)
SERVERS(HLDP) ; Multi-threaded server using Taskman
"RTN","HLCSTCP",72,0)
 I '$$INIT D EXITS("Init error") Q
"RTN","HLCSTCP",73,0)
 G LISTEN
"RTN","HLCSTCP",74,0)
 ;
"RTN","HLCSTCP",75,0)
 ;multiple process servers, called from an external utility
"RTN","HLCSTCP",76,0)
MSM ;MSM entry point, called from User-Defined Services
"RTN","HLCSTCP",77,0)
 ;HLDP=ien in the HL LOWER LEVEL PROTOCOL PARAMETER file for the
"RTN","HLCSTCP",78,0)
 ;HL7 Multi-Threaded SERVER
"RTN","HLCSTCP",79,0)
 S (IO,IO(0))=$P
"RTN","HLCSTCP",80,0)
 G LISTEN
"RTN","HLCSTCP",81,0)
 ;
"RTN","HLCSTCP",82,0)
LISTEN ;
"RTN","HLCSTCP",83,0)
 N HLLSTN,HLCSOUT,HLDBACK,HLDBSIZE,HLDREAD,HLDRETR,HLRETRA,HLDWAIT,HLOS,HLTCPADD,HLTCPCS,HLTCPLNK,HLTCPORT,HLTCPRET
"RTN","HLCSTCP",84,0)
 I '$$INIT D ^%ZTER Q
"RTN","HLCSTCP",85,0)
 ; patch HL*1.6*122 start
"RTN","HLCSTCP",86,0)
 S HLDP("$J")=$J
"RTN","HLCSTCP",87,0)
 S HLDP("$J",0,"LENGTH")=$L(HLDP("$J"))
"RTN","HLCSTCP",88,0)
 S HLDP("$J",0,"START")=HLDP("$J",0,"LENGTH")-9+$L(HLTCPORT)
"RTN","HLCSTCP",89,0)
 I HLDP("$J",0,"START")<1 S HLDP("$J",0,"START")=1
"RTN","HLCSTCP",90,0)
 S HLDP("$J",0)=$E(HLDP("$J"),HLDP("$J",0,"START"),HLDP("$J",0,"LENGTH"))
"RTN","HLCSTCP",91,0)
 ; identify process for ^%SY
"RTN","HLCSTCP",92,0)
 ; D SETNM^%ZOSV($E("HLSrv:"_HLDP,1,15))
"RTN","HLCSTCP",93,0)
 D SETNM^%ZOSV($E("HLs:"_HLTCPORT_"-"_HLDP("$J",0),1,15))
"RTN","HLCSTCP",94,0)
 K HLDP("$J",0)
"RTN","HLCSTCP",95,0)
 ; patch HL*1.6*122 end
"RTN","HLCSTCP",96,0)
 ;HLLSTN used to identify a listener to tag MON
"RTN","HLCSTCP",97,0)
 S HLLSTN=1
"RTN","HLCSTCP",98,0)
 ;increment job count, run server
"RTN","HLCSTCP",99,0)
 D UPDT(1),^HLCSTCP1,EXITM
"RTN","HLCSTCP",100,0)
 Q
"RTN","HLCSTCP",101,0)
 ;
"RTN","HLCSTCP",102,0)
DCOPEN(HLDP) ;open direct connect - called from HLMA2
"RTN","HLCSTCP",103,0)
 Q:'$$INIT 0
"RTN","HLCSTCP",104,0)
 Q:HLTCPADD=""!(HLTCPORT="") 0
"RTN","HLCSTCP",105,0)
 Q:'$$OPEN^HLCSTCP2 0
"RTN","HLCSTCP",106,0)
 Q 1
"RTN","HLCSTCP",107,0)
 ;
"RTN","HLCSTCP",108,0)
INIT() ; Initialize Variables
"RTN","HLCSTCP",109,0)
 ; HLDP should be set to the IEN or name of Logical Link, file 870
"RTN","HLCSTCP",110,0)
 S HLOS=$P($G(^%ZOSF("OS")),"^")
"RTN","HLCSTCP",111,0)
 N DA,DIQUIET,DR,TMP,X,Y
"RTN","HLCSTCP",112,0)
 S IOF=$$FLUSHCHR^%ZISTCP ; HL*1.6*122 set device flush character
"RTN","HLCSTCP",113,0)
 S DIQUIET=1
"RTN","HLCSTCP",114,0)
 D DT^DICRW
"RTN","HLCSTCP",115,0)
 I 'HLDP S HLDP=$O(^HLCS(870,"B",HLDP,0)) I 'HLDP Q 0
"RTN","HLCSTCP",116,0)
 S DA=HLDP
"RTN","HLCSTCP",117,0)
 ; patch HL*1.6*122 for field 400.09
"RTN","HLCSTCP",118,0)
 S DR="200.02;200.021;200.022;200.03;200.04;200.05;200.09;400.01;400.02;400.03;400.04;400.05;400.09"
"RTN","HLCSTCP",119,0)
 D GETS^DIQ(870,DA,DR,"IN","TMP","TMP")
"RTN","HLCSTCP",120,0)
 ;
"RTN","HLCSTCP",121,0)
 I $D(TMP("DIERR")) QUIT 0
"RTN","HLCSTCP",122,0)
 ; -- re-transmit attempts
"RTN","HLCSTCP",123,0)
 S HLDRETR=+$G(TMP(870,DA_",",200.02,"I"))
"RTN","HLCSTCP",124,0)
 S HLDRETR("CLOSE")=+$G(TMP(870,DA_",",200.022,"I"))
"RTN","HLCSTCP",125,0)
 ; -- exceed re-transmit action
"RTN","HLCSTCP",126,0)
 S HLRETRA=$G(TMP(870,DA_",",200.021,"I"))
"RTN","HLCSTCP",127,0)
 ; -- block size
"RTN","HLCSTCP",128,0)
 S HLDBSIZE=+$G(TMP(870,DA_",",200.03,"I"))
"RTN","HLCSTCP",129,0)
 ; -- read timeout
"RTN","HLCSTCP",130,0)
 S HLDREAD=+$G(TMP(870,DA_",",200.04,"I"))
"RTN","HLCSTCP",131,0)
 ; -- ack timeout
"RTN","HLCSTCP",132,0)
 S HLDBACK=+$G(TMP(870,DA_",",200.05,"I"))
"RTN","HLCSTCP",133,0)
 ; -- uni-directional wait
"RTN","HLCSTCP",134,0)
 S HLDWAIT=$G(TMP(870,DA_",",200.09,"I"))
"RTN","HLCSTCP",135,0)
 ; -- tcp address
"RTN","HLCSTCP",136,0)
 S HLTCPADD=$G(TMP(870,DA_",",400.01,"I"))
"RTN","HLCSTCP",137,0)
 ; -- tcp port
"RTN","HLCSTCP",138,0)
 S HLTCPORT=$G(TMP(870,DA_",",400.02,"I"))
"RTN","HLCSTCP",139,0)
 ; -- tcp/ip service type
"RTN","HLCSTCP",140,0)
 S HLTCPCS=$G(TMP(870,DA_",",400.03,"I"))
"RTN","HLCSTCP",141,0)
 ; -- link persistence
"RTN","HLCSTCP",142,0)
 S HLTCPLNK=$G(TMP(870,DA_",",400.04,"I"))
"RTN","HLCSTCP",143,0)
 ; -- retention
"RTN","HLCSTCP",144,0)
 S HLTCPRET=$G(TMP(870,DA_",",400.05,"I"))
"RTN","HLCSTCP",145,0)
 ;
"RTN","HLCSTCP",146,0)
 ; patch HL*1.6*122 for field 400.09
"RTN","HLCSTCP",147,0)
 ; -- tcp/ip openfail timeout
"RTN","HLCSTCP",148,0)
 S HLTCPLNK("TIMEOUT")=$G(TMP(870,DA_",",400.09,"I"))
"RTN","HLCSTCP",149,0)
 ;
"RTN","HLCSTCP",150,0)
 ; -- set defaults in case something's not set
"RTN","HLCSTCP",151,0)
 S:HLDREAD=0 HLDREAD=10
"RTN","HLCSTCP",152,0)
 S:HLDBACK=0 HLDBACK=60
"RTN","HLCSTCP",153,0)
 ; patch HL*1.6*122
"RTN","HLCSTCP",154,0)
 ; S:HLDBSIZE=0 HLDBSIZE=245
"RTN","HLCSTCP",155,0)
 S:HLDBSIZE<245 HLDBSIZE=245
"RTN","HLCSTCP",156,0)
 S:HLDRETR=0 HLDRETR=5
"RTN","HLCSTCP",157,0)
 S:HLTCPRET="" X=$P($$PARAM^HLCS2,U,12),HLTCPRET=$S(X:X,1:15)
"RTN","HLCSTCP",158,0)
 ;
"RTN","HLCSTCP",159,0)
 ; patch HL*1.6*122 for field 400.09
"RTN","HLCSTCP",160,0)
 S:HLTCPLNK("TIMEOUT")=0 HLTCPLNK("TIMEOUT")=5
"RTN","HLCSTCP",161,0)
 ;
"RTN","HLCSTCP",162,0)
 Q 1
"RTN","HLCSTCP",163,0)
 ;
"RTN","HLCSTCP",164,0)
ST1 ;record startup in 870 for single server
"RTN","HLCSTCP",165,0)
 ;4=status 9=Time Started, 10=Time Stopped, 11=Task Number 
"RTN","HLCSTCP",166,0)
 ;14=Shutdown LLP, 3=LLP Online, 18=Gross Errors
"RTN","HLCSTCP",167,0)
 N HLJ,X
"RTN","HLCSTCP",168,0)
 ; HL*1.6*122 remove unnecessary locks
"RTN","HLCSTCP",169,0)
 ;F  L +^HLCS(870,HLDP,0):2 Q:$T
"RTN","HLCSTCP",170,0)
 S X="HLJ(870,"""_HLDP_","")"
"RTN","HLCSTCP",171,0)
 S @X@(4)="Init",(@X@(10),@X@(18))="@",@X@(14)=0
"RTN","HLCSTCP",172,0)
 I HLTCPCS["C" S @X@(3)=$S(HLTCPLNK["Y":"PC",1:"NC")
"RTN","HLCSTCP",173,0)
 E  S @X@(3)=$S(HLTCPCS["S":"SS",HLTCPCS["M":"MS",1:"")
"RTN","HLCSTCP",174,0)
 I @X@(3)'="NC" S @X@(9)=$$NOW^XLFDT
"RTN","HLCSTCP",175,0)
 S:$G(ZTSK) @X@(11)=ZTSK
"RTN","HLCSTCP",176,0)
 D FILE^HLDIE("","HLJ","","ST1","HLCSTCP") ;HL*1.6*109
"RTN","HLCSTCP",177,0)
 ;L -^HLCS(870,HLDP,0)
"RTN","HLCSTCP",178,0)
 Q
"RTN","HLCSTCP",179,0)
 ;
"RTN","HLCSTCP",180,0)
MON(Y) ;Display current state & check for shutdown
"RTN","HLCSTCP",181,0)
 ;don't display for multiple server
"RTN","HLCSTCP",182,0)
 Q:$G(HLLSTN)
"RTN","HLCSTCP",183,0)
 ; HL*1.6*122 remove unnecessary locks
"RTN","HLCSTCP",184,0)
 ;F  L +^HLCS(870,HLDP,0):2 Q:$T
"RTN","HLCSTCP",185,0)
 S $P(^HLCS(870,HLDP,0),U,5)=Y
"RTN","HLCSTCP",186,0)
 ;L -^HLCS(870,HLDP,0)
"RTN","HLCSTCP",187,0)
 Q:'$D(HLTRACE)
"RTN","HLCSTCP",188,0)
 N X U IO(0)
"RTN","HLCSTCP",189,0)
 W !,"IN State: ",Y
"RTN","HLCSTCP",190,0)
 I '$$STOP D
"RTN","HLCSTCP",191,0)
 . ; patch HL*1.6*122
"RTN","HLCSTCP",192,0)
 . ; R !,"Type Q to Quit: ",X#1:1
"RTN","HLCSTCP",193,0)
 . R !,"Type Q to Quit: ",X:1
"RTN","HLCSTCP",194,0)
 . ; I $L(X),"Qq"[X S $P(^HLCS(870,HLDP,0),U,15)=1
"RTN","HLCSTCP",195,0)
 . I $L(X),"Qq"[$E(X) S $P(^HLCS(870,HLDP,0),U,15)=1
"RTN","HLCSTCP",196,0)
 . ; patch HL*1.6*122 end
"RTN","HLCSTCP",197,0)
 U IO
"RTN","HLCSTCP",198,0)
 Q
"RTN","HLCSTCP",199,0)
UPDT(Y) ;update job count for multiple servers,X=1 increment
"RTN","HLCSTCP",200,0)
 N HLJ,X
"RTN","HLCSTCP",201,0)
 ;
"RTN","HLCSTCP",202,0)
 ; HL*1.6*122 start
"RTN","HLCSTCP",203,0)
 ; F  L +^HLCS(870,HLDP,0):2 Q:$T
"RTN","HLCSTCP",204,0)
 Q:'$G(HLDP)
"RTN","HLCSTCP",205,0)
 Q:'$D(^HLCS(870,"E","M",HLDP))
"RTN","HLCSTCP",206,0)
 F  L +^HLCS(870,HLDP,0):10 Q:$T  H 1
"RTN","HLCSTCP",207,0)
 ; S X=+$P(^HLCS(870,HLDP,0),U,5),$P(^(0),U,5)=$S(Y:X+1,1:X-1)_" server"
"RTN","HLCSTCP",208,0)
 S X=+$P(^HLCS(870,HLDP,0),U,5)
"RTN","HLCSTCP",209,0)
 I X<0 S X=0
"RTN","HLCSTCP",210,0)
 S $P(^HLCS(870,HLDP,0),U,5)=$S(Y:(X+1),X<1:0,1:X-1)_" server"
"RTN","HLCSTCP",211,0)
 ;if incrementing, set the Device Type field to Multi-Server
"RTN","HLCSTCP",212,0)
 ; I X S HLJ(870,HLDP_",",3)="MS" D FILE^HLDIE("","HLJ","","UPDT","HLCSTCP")
"RTN","HLCSTCP",213,0)
 I $P(^HLCS(870,HLDP,0),"^",4)']"" S $P(^HLCS(870,HLDP,0),"^",4)="MS"
"RTN","HLCSTCP",214,0)
 ; HL*1.6*122 end
"RTN","HLCSTCP",215,0)
 ;
"RTN","HLCSTCP",216,0)
 L -^HLCS(870,HLDP,0)
"RTN","HLCSTCP",217,0)
 Q
"RTN","HLCSTCP",218,0)
STOP() ;stop flag set
"RTN","HLCSTCP",219,0)
 N X
"RTN","HLCSTCP",220,0)
 F  L +^HLCS(870,HLDP,0):2 Q:$T
"RTN","HLCSTCP",221,0)
 S X=+$P(^HLCS(870,HLDP,0),U,15)
"RTN","HLCSTCP",222,0)
 L -^HLCS(870,HLDP,0)
"RTN","HLCSTCP",223,0)
 Q X
"RTN","HLCSTCP",224,0)
 ;
"RTN","HLCSTCP",225,0)
LLCNT(DP,Y,Z) ;update Logical Link counters
"RTN","HLCSTCP",226,0)
 ;DP=ien of Logical Link in file 870
"RTN","HLCSTCP",227,0)
 ;Y: 1=msg rec, 2=msg proc, 3=msg to send, 4=msg sent
"RTN","HLCSTCP",228,0)
 ;Z: ""=add to counter, 1=subtract from counter
"RTN","HLCSTCP",229,0)
 Q:'$D(^HLCS(870,+$G(DP),0))!('$G(Y))
"RTN","HLCSTCP",230,0)
 N P,X
"RTN","HLCSTCP",231,0)
 S P=$S(Y<3:"IN",1:"OUT")_" QUEUE "_$S(Y#2:"BACK",1:"FRONT")_" POINTER"
"RTN","HLCSTCP",232,0)
 ; patch HL*1.6*122 start
"RTN","HLCSTCP",233,0)
 ; F  L +^HLCS(870,DP,P):2 Q:$T
"RTN","HLCSTCP",234,0)
 ; S X=+$G(^HLCS(870,DP,P)),^(P)=X+$S($G(Z):-1,1:1)
"RTN","HLCSTCP",235,0)
 I '$L($G(OS)) N OS S OS=$G(^%ZOSF("OS"))
"RTN","HLCSTCP",236,0)
 I OS'["DSM",OS'["OpenM" D
"RTN","HLCSTCP",237,0)
 . F  L +^HLCS(870,DP,P):10 Q:$T  H 1
"RTN","HLCSTCP",238,0)
 . S X=+$G(^HLCS(870,DP,P)),^(P)=X+$S($G(Z):-1,1:1)
"RTN","HLCSTCP",239,0)
 . L -^HLCS(870,DP,P)
"RTN","HLCSTCP",240,0)
 E  D
"RTN","HLCSTCP",241,0)
 . S X=$I(^HLCS(870,DP,P),$S($G(Z):-1,1:1))
"RTN","HLCSTCP",242,0)
 ; L -^HLCS(870,DP,P)
"RTN","HLCSTCP",243,0)
 ; patch HL*1.6*122 end
"RTN","HLCSTCP",244,0)
 Q
"RTN","HLCSTCP",245,0)
SDFLD ; set Shutdown? field to yes
"RTN","HLCSTCP",246,0)
 Q:'$G(HLDP)
"RTN","HLCSTCP",247,0)
 ; HL*1.6*122 remove unnecessary lock and call to FM
"RTN","HLCSTCP",248,0)
 S $P(^HLCS(870,HLDP,0),U,15)=1
"RTN","HLCSTCP",249,0)
 ;N HLJ,X
"RTN","HLCSTCP",250,0)
 ;F  L +^HLCS(870,HLDP,0):2 Q:$T
"RTN","HLCSTCP",251,0)
 ;14=Shutdown LLP?
"RTN","HLCSTCP",252,0)
 ;S HLJ(870,HLDP_",",14)=1
"RTN","HLCSTCP",253,0)
 ;D FILE^HLDIE("","HLJ","","SDFLD","HLCSTCP") ;HL*1.6*109
"RTN","HLCSTCP",254,0)
 ;L -^HLCS(870,HLDP,0)
"RTN","HLCSTCP",255,0)
 Q
"RTN","HLCSTCP",256,0)
 ;
"RTN","HLCSTCP",257,0)
EXITS(Y) ; shutdown and clean up the listener process for either
"RTN","HLCSTCP",258,0)
 ; single-threaded or multi-threaded
"RTN","HLCSTCP",259,0)
 N HLJ,X
"RTN","HLCSTCP",260,0)
 F  L +^HLCS(870,HLDP,0):2 Q:$T
"RTN","HLCSTCP",261,0)
 ;4=status,10=Time Stopped,9=Time Started,11=Task Number
"RTN","HLCSTCP",262,0)
 S X="HLJ(870,"""_HLDP_","")"
"RTN","HLCSTCP",263,0)
 S @X@(4)=Y,@X@(11)="@"
"RTN","HLCSTCP",264,0)
 S:$G(HLCSOUT)'=2 @X@(10)=$$NOW^XLFDT,@X@(9)="@"
"RTN","HLCSTCP",265,0)
 D FILE^HLDIE("","HLJ","","EXITS","HLCSTCP") ; HL*1.6*109
"RTN","HLCSTCP",266,0)
 L -^HLCS(870,HLDP,0)
"RTN","HLCSTCP",267,0)
 I $D(ZTQUEUED) S ZTREQ="@"
"RTN","HLCSTCP",268,0)
 ; HL*1.6*122
"RTN","HLCSTCP",269,0)
 L -^HLCS("HLTCPLINK",HLDP)
"RTN","HLCSTCP",270,0)
 Q
"RTN","HLCSTCP",271,0)
 ;
"RTN","HLCSTCP",272,0)
EXITM ;Multiple service shutdown and clean up
"RTN","HLCSTCP",273,0)
 ; shutdown and clean up a connection spawned by the listener
"RTN","HLCSTCP",274,0)
 ; process for a multi-threaded listener
"RTN","HLCSTCP",275,0)
 D UPDT(0)
"RTN","HLCSTCP",276,0)
 I $D(ZTQUEUED) S ZTREQ="@"
"RTN","HLCSTCP",277,0)
 Q
"RTN","HLCSTCP1")
0^20^B70690150^B37159862
"RTN","HLCSTCP1",1,0)
HLCSTCP1 ;SFIRMFO/RSD - BI-DIRECTIONAL TCP ;10/17/2007  12:59
"RTN","HLCSTCP1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**19,43,57,64,71,133,132,122**;OCT 13,1995;Build 14
"RTN","HLCSTCP1",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLCSTCP1",4,0)
 ;Receiver
"RTN","HLCSTCP1",5,0)
 ;connection is initiated by sender and listener accepts connection
"RTN","HLCSTCP1",6,0)
 ;and calls this routine
"RTN","HLCSTCP1",7,0)
 ;
"RTN","HLCSTCP1",8,0)
 N $ETRAP,$ESTACK S $ETRAP="D ERROR^HLCSTCP1"
"RTN","HLCSTCP1",9,0)
 N HLMIEN,HLASTMSG
"RTN","HLCSTCP1",10,0)
 ;
"RTN","HLCSTCP1",11,0)
 ; patch HL*1.6*122 start
"RTN","HLCSTCP1",12,0)
 ; variable to replace ^TMP
"RTN","HLCSTCP1",13,0)
 N HLTMBUF
"RTN","HLCSTCP1",14,0)
 ;
"RTN","HLCSTCP1",15,0)
 ; for HL7 application proxy user
"RTN","HLCSTCP1",16,0)
 ;; N HLDUZ,DUZ  ; patch HL*1.6*122 TEST v2: DUZ code removed
"RTN","HLCSTCP1",17,0)
 N HLDUZ
"RTN","HLCSTCP1",18,0)
 S HLDUZ=+$G(DUZ)
"RTN","HLCSTCP1",19,0)
 ;
"RTN","HLCSTCP1",20,0)
 D MON^HLCSTCP("Open")
"RTN","HLCSTCP1",21,0)
 ; K ^TMP("HLCSTCP",$J,0)
"RTN","HLCSTCP1",22,0)
 S HLMIEN=0,HLASTMSG=""
"RTN","HLCSTCP1",23,0)
 ;
"RTN","HLCSTCP1",24,0)
 ; patch HL*1.6*122 TEST v2: DUZ code removed
"RTN","HLCSTCP1",25,0)
 ; set DUZ for application proxy user
"RTN","HLCSTCP1",26,0)
 ;; D PROXY^HLCSTCP4
"RTN","HLCSTCP1",27,0)
 ;
"RTN","HLCSTCP1",28,0)
 F  D  Q:$$STOP^HLCSTCP  I 'HLMIEN D MON^HLCSTCP("Idle") H 3
"RTN","HLCSTCP1",29,0)
 . ; clean variables
"RTN","HLCSTCP1",30,0)
 . D CLEANVAR^HLCSTCP4
"RTN","HLCSTCP1",31,0)
 . S HLMIEN=$$READ
"RTN","HLCSTCP1",32,0)
 . Q:'HLMIEN
"RTN","HLCSTCP1",33,0)
 . ;
"RTN","HLCSTCP1",34,0)
 . ; patch HL*1.6*122 TEST v2: DUZ code removed
"RTN","HLCSTCP1",35,0)
 . ; DUZ comparison/reset for application proxy user
"RTN","HLCSTCP1",36,0)
 . ;; D HLDUZ^HLCSTCP4
"RTN","HLCSTCP1",37,0)
 . D HLDUZ2^HLCSTCP4
"RTN","HLCSTCP1",38,0)
 . ; protect HLDUZ 
"RTN","HLCSTCP1",39,0)
 . N HLDUZ
"RTN","HLCSTCP1",40,0)
 . D PROCESS
"RTN","HLCSTCP1",41,0)
 ; patch HL*1.6*122 end
"RTN","HLCSTCP1",42,0)
 Q
"RTN","HLCSTCP1",43,0)
 ;
"RTN","HLCSTCP1",44,0)
PROCESS ;check message and reply
"RTN","HLCSTCP1",45,0)
 ;HLDP=LL in 870
"RTN","HLCSTCP1",46,0)
 N HLTCP,HLTCPI,HLTCPO
"RTN","HLCSTCP1",47,0)
 S HLTCP="",HLTCPO=HLDP,HLTCPI=+HLMIEN
"RTN","HLCSTCP1",48,0)
 ;update monitor, msg. received
"RTN","HLCSTCP1",49,0)
 D LLCNT^HLCSTCP(HLDP,1)
"RTN","HLCSTCP1",50,0)
 D NEW^HLTP3(HLMIEN)
"RTN","HLCSTCP1",51,0)
 ;update monitor, msg. processed
"RTN","HLCSTCP1",52,0)
 D LLCNT^HLCSTCP(HLDP,2)
"RTN","HLCSTCP1",53,0)
 Q
"RTN","HLCSTCP1",54,0)
 ;
"RTN","HLCSTCP1",55,0)
READ() ;read 1 message, returns ien in 773^ien in 772 for message
"RTN","HLCSTCP1",56,0)
 D MON^HLCSTCP("Reading")
"RTN","HLCSTCP1",57,0)
 N HLDB,HLDT,HLDEND,HLACKWT,HLDSTRT,HLHDR,HLIND1,HLINE,HLMSG,HLRDOUT,HLRS,HLX,X
"RTN","HLCSTCP1",58,0)
 ;HLDSTRT=start char., HLDEND=end char., HLRS=record seperator
"RTN","HLCSTCP1",59,0)
 S HLDSTRT=$C(11),HLDEND=$C(28),HLRS=$C(13)
"RTN","HLCSTCP1",60,0)
 ;HLRDOUT=exit read loop, HLINE=line count, HLIND1=ien 773^ien 772
"RTN","HLCSTCP1",61,0)
 ;HLHDR=have a header, HLTMBUF()=excess from last read, HLACKWT=wait for ack
"RTN","HLCSTCP1",62,0)
 ; HL*1.6*122 start
"RTN","HLCSTCP1",63,0)
 ; S (HLRDOUT,HLINE,HLIND1,HLHDR)=0,HLX=$G(^TMP("HLCSTCP",$J,0)),HLACKWT=HLDBACK
"RTN","HLCSTCP1",64,0)
 S (HLRDOUT,HLINE,HLIND1,HLHDR)=0,HLX=$G(HLTMBUF(0)),HLACKWT=HLDBACK
"RTN","HLCSTCP1",65,0)
 N HLBUFF,HLXX,MAXWAIT
"RTN","HLCSTCP1",66,0)
 ; based on patch 132 for readtime
"RTN","HLCSTCP1",67,0)
 S MAXWAIT=$S((HLACKWT>HLDREAD):HLACKWT,1:HLDREAD)
"RTN","HLCSTCP1",68,0)
 S HLRS("START-FLAG")=0
"RTN","HLCSTCP1",69,0)
 S HLTMBUF(0)=""
"RTN","HLCSTCP1",70,0)
 ; variable used to store data in HLBUFF
"RTN","HLCSTCP1",71,0)
 S HLX(1)=$G(HLTMBUF(1))
"RTN","HLCSTCP1",72,0)
 S HLTMBUF(1)=""
"RTN","HLCSTCP1",73,0)
 S HLBUFF("START")=0
"RTN","HLCSTCP1",74,0)
 S HLBUFF("END")=0
"RTN","HLCSTCP1",75,0)
 I (HLX]"")!(HLX(1)]"") D
"RTN","HLCSTCP1",76,0)
 . I (HLX[HLDSTRT)!(HLX(1)[HLDSTRT) D
"RTN","HLCSTCP1",77,0)
 .. S HLBUFF("START")=1
"RTN","HLCSTCP1",78,0)
 . I (HLX[HLDEND)!(HLX(1)[HLDEND) D
"RTN","HLCSTCP1",79,0)
 .. S HLBUFF("END")=1
"RTN","HLCSTCP1",80,0)
 F  D RDBLK Q:HLRDOUT
"RTN","HLCSTCP1",81,0)
 ;**132**
"RTN","HLCSTCP1",82,0)
 ;switch to null device if opened to prevent 'leakage'
"RTN","HLCSTCP1",83,0)
 I $G(IO(0))]"",IO(0)'=IO U IO(0)
"RTN","HLCSTCP1",84,0)
 ;
"RTN","HLCSTCP1",85,0)
 ;save any excess for next time
"RTN","HLCSTCP1",86,0)
 S:HLX]"" HLTMBUF(0)=HLX
"RTN","HLCSTCP1",87,0)
 S:HLX(1)]"" HLTMBUF(1)=HLX(1)
"RTN","HLCSTCP1",88,0)
 I +HLIND1,'$P(HLIND1,U,3) D DELMSG(HLIND1) S HLIND1=0
"RTN","HLCSTCP1",89,0)
 Q HLIND1
"RTN","HLCSTCP1",90,0)
 ;
"RTN","HLCSTCP1",91,0)
RDBLK ;
"RTN","HLCSTCP1",92,0)
 ; initialize
"RTN","HLCSTCP1",93,0)
 S HLBUFF=""
"RTN","HLCSTCP1",94,0)
 ;
"RTN","HLCSTCP1",95,0)
 ;S HLDB=HLDBSIZE-$L(HLX)
"RTN","HLCSTCP1",96,0)
 ; store the total length of HLX and HLX(1) in HLDB(1)
"RTN","HLCSTCP1",97,0)
 S HLDB(1)=$L(HLX)+$L(HLX(1))
"RTN","HLCSTCP1",98,0)
 ;
"RTN","HLCSTCP1",99,0)
 ;**132 **
"RTN","HLCSTCP1",100,0)
 ;U IO R X#HLDB:HLDREAD
"RTN","HLCSTCP1",101,0)
 ; U IO R X#HLDB:MAXWAIT
"RTN","HLCSTCP1",102,0)
 ;
"RTN","HLCSTCP1",103,0)
 ; remove the readcount to speedup GT.M
"RTN","HLCSTCP1",104,0)
 U IO
"RTN","HLCSTCP1",105,0)
 R:(HLDB(1)<HLDBSIZE) HLBUFF:MAXWAIT
"RTN","HLCSTCP1",106,0)
 I HLBUFF]"" D
"RTN","HLCSTCP1",107,0)
 . I HLBUFF[HLDSTRT,(HLBUFF("START")=0) D
"RTN","HLCSTCP1",108,0)
 .. ; remove the extraneous text prefixing the "START" char
"RTN","HLCSTCP1",109,0)
 .. I $P(HLBUFF,HLDSTRT)]"" S HLBUFF=HLDSTRT_$P(HLBUFF,HLDSTRT,2,99)
"RTN","HLCSTCP1",110,0)
 .. S HLBUFF("START")=1
"RTN","HLCSTCP1",111,0)
 . ;
"RTN","HLCSTCP1",112,0)
 . I HLBUFF[HLDEND,(HLBUFF("END")=0) S HLBUFF("END")=1
"RTN","HLCSTCP1",113,0)
 ; detect disconnect for GT.M
"RTN","HLCSTCP1",114,0)
 I $G(^%ZOSF("OS"))["GT.M",$DEVICE S $ECODE=",UREAD,"
"RTN","HLCSTCP1",115,0)
 ; timedout, <clean up>, quit
"RTN","HLCSTCP1",116,0)
 ;I '$T,X="",HLX="" S HLACKWT=HLACKWT-HLDREAD D:HLACKWT<0&'HLHDR CLEAN Q
"RTN","HLCSTCP1",117,0)
 ;I '$T,X="",HLX="" D:'HLHDR CLEAN Q
"RTN","HLCSTCP1",118,0)
 I '$T,HLBUFF="",HLX="",HLX(1)="" D  Q
"RTN","HLCSTCP1",119,0)
 . D:('HLHDR)&('HLIND1) CLEAN
"RTN","HLCSTCP1",120,0)
 ;add incoming line to what wasn't processed in last read
"RTN","HLCSTCP1",121,0)
 ;S HLX=$G(HLX)_X
"RTN","HLCSTCP1",122,0)
 ;
"RTN","HLCSTCP1",123,0)
 ; get block of characters from read buffer HLBUFF
"RTN","HLCSTCP1",124,0)
 ; every 'for-loop' deal with one read at most, and one message at most
"RTN","HLCSTCP1",125,0)
 ; if HLX is not empty, loop continues even no data is read
"RTN","HLCSTCP1",126,0)
 ; quit, if both HLDBUFF and HLX(1) are empty, means one read is done
"RTN","HLCSTCP1",127,0)
 ; quit, when HLRDOUT is set to 1, means one message is encountered
"RTN","HLCSTCP1",128,0)
 ; an "end"
"RTN","HLCSTCP1",129,0)
 ; F  D  Q:HLXX=""!(HLRDOUT)
"RTN","HLCSTCP1",130,0)
 F  D  Q:(HLRDOUT)!(HLBUFF=""&(HLX(1)=""))
"RTN","HLCSTCP1",131,0)
 . ;
"RTN","HLCSTCP1",132,0)
 . ; if HLX(1) is not empty
"RTN","HLCSTCP1",133,0)
 . I HLX(1)]"" D
"RTN","HLCSTCP1",134,0)
 .. ; hldb(2) is the number of characters extracted from hlx(1)
"RTN","HLCSTCP1",135,0)
 .. ; to be concatenated with hlx
"RTN","HLCSTCP1",136,0)
 .. S HLDB(2)=HLDBSIZE-$L(HLX)
"RTN","HLCSTCP1",137,0)
 .. ; hlx(2) stores the first hldb(2) characters extracted
"RTN","HLCSTCP1",138,0)
 .. ; from hlx(1)
"RTN","HLCSTCP1",139,0)
 .. S HLX(2)=$E(HLX(1),1,HLDB(2))
"RTN","HLCSTCP1",140,0)
 .. S HLX(1)=$E(HLX(1),HLDB(2)+1,$L(HLX(1)))
"RTN","HLCSTCP1",141,0)
 .. S HLX=$G(HLX)_HLX(2)
"RTN","HLCSTCP1",142,0)
 . ;
"RTN","HLCSTCP1",143,0)
 . ; if HLX(1) is empty, and HLBUFF contains data
"RTN","HLCSTCP1",144,0)
 . ; all the data in hlx(1) need to be extracted first
"RTN","HLCSTCP1",145,0)
 . I HLX(1)="",HLBUFF]"" D
"RTN","HLCSTCP1",146,0)
 .. S HLDB=HLDBSIZE-$L(HLX)
"RTN","HLCSTCP1",147,0)
 .. S HLXX=$E(HLBUFF,1,HLDB)
"RTN","HLCSTCP1",148,0)
 .. S HLBUFF=$E(HLBUFF,HLDB+1,$L(HLBUFF))
"RTN","HLCSTCP1",149,0)
 .. S HLX=$G(HLX)_HLXX
"RTN","HLCSTCP1",150,0)
 . ; quit when HLX is empty
"RTN","HLCSTCP1",151,0)
 . Q:(HLX="")
"RTN","HLCSTCP1",152,0)
 . ; ** 132 **
"RTN","HLCSTCP1",153,0)
 . ; if no segment end, HLX not full, go back for more
"RTN","HLCSTCP1",154,0)
 . I $L(HLX)<HLDBSIZE,HLX'[HLRS,HLX'[HLDEND Q
"RTN","HLCSTCP1",155,0)
 . ;add incoming line to what wasn't processed
"RTN","HLCSTCP1",156,0)
 . D RDBLK2
"RTN","HLCSTCP1",157,0)
 ;
"RTN","HLCSTCP1",158,0)
 ; it is possible one message is encountered an "end" and other
"RTN","HLCSTCP1",159,0)
 ; messages left in buffer,HLBUFF, save it in HLX for next run
"RTN","HLCSTCP1",160,0)
 I HLBUFF]"" D
"RTN","HLCSTCP1",161,0)
 . ; variable HLBUFF may remain data with size more than HLDBSIZE
"RTN","HLCSTCP1",162,0)
 . ; variable HLBUFF is not empty, only if the total length of
"RTN","HLCSTCP1",163,0)
 . ; HLX and HLX(1) is less than HLDBSIZE and HLX(1) should be
"RTN","HLCSTCP1",164,0)
 . ; empty when the command s hlx(1)=$g(hlx(1))_hlbuff is executed
"RTN","HLCSTCP1",165,0)
 . ; use hlx(1) to store the data of hlbuff to avoid "MAXTRING" error
"RTN","HLCSTCP1",166,0)
 . S HLX(1)=$G(HLX(1))_HLBUFF
"RTN","HLCSTCP1",167,0)
 . S HLBUFF=""
"RTN","HLCSTCP1",168,0)
 Q
"RTN","HLCSTCP1",169,0)
 ;
"RTN","HLCSTCP1",170,0)
RDBLK2 ;data stream: <sb>dddd<cr><eb><cr>
"RTN","HLCSTCP1",171,0)
 ; HL*1.6*122 end
"RTN","HLCSTCP1",172,0)
 ; look for segment= <CR>
"RTN","HLCSTCP1",173,0)
 F  Q:HLX'[HLRS  D  Q:HLRDOUT
"RTN","HLCSTCP1",174,0)
 . ; Get the first piece, save the rest of the line
"RTN","HLCSTCP1",175,0)
 . S HLINE=HLINE+1,HLMSG(HLINE,0)=$P(HLX,HLRS),HLX=$P(HLX,HLRS,2,999)
"RTN","HLCSTCP1",176,0)
 . ; check for start block, Quit if no ien
"RTN","HLCSTCP1",177,0)
 . I HLMSG(HLINE,0)[HLDSTRT!HLHDR D  Q
"RTN","HLCSTCP1",178,0)
 .. S HLRS("START-FLAG")=1 ; HL*1.6*122
"RTN","HLCSTCP1",179,0)
 .. D:HLMSG(HLINE,0)[HLDSTRT
"RTN","HLCSTCP1",180,0)
 ... S X=$L(HLMSG(HLINE,0),HLDSTRT)
"RTN","HLCSTCP1",181,0)
 ... S:X>2 HLMSG(HLINE,0)=HLDSTRT_$P(HLMSG(HLINE,0),HLDSTRT,X)
"RTN","HLCSTCP1",182,0)
 ... S HLMSG(HLINE,0)=$P(HLMSG(HLINE,0),HLDSTRT,2)
"RTN","HLCSTCP1",183,0)
 ... D RESET:(HLINE>1)
"RTN","HLCSTCP1",184,0)
 .. ;
"RTN","HLCSTCP1",185,0)
 .. ; patch HL*1.6*122
"RTN","HLCSTCP1",186,0)
 .. ; if the first line less than 10 characters
"RTN","HLCSTCP1",187,0)
 .. I HLHDR,$L(HLMSG(1,0))<10,$D(HLMSG(2,0)) D
"RTN","HLCSTCP1",188,0)
 ... S HLMSG(1,0)=HLMSG(1,0)_$E(HLMSG(2,0),1,10)
"RTN","HLCSTCP1",189,0)
 ... S HLMSG(2,0)=$E(HLMSG(2,0),11,9999999)
"RTN","HLCSTCP1",190,0)
 .. ;
"RTN","HLCSTCP1",191,0)
 .. ;ping message
"RTN","HLCSTCP1",192,0)
 .. I $E(HLMSG(1,0),1,9)="MSH^PING^" D PING Q
"RTN","HLCSTCP1",193,0)
 .. ; get next ien to store
"RTN","HLCSTCP1",194,0)
 .. D MIEN^HLCSTCP4
"RTN","HLCSTCP1",195,0)
 .. K HLMSG
"RTN","HLCSTCP1",196,0)
 .. S (HLINE,HLHDR)=0
"RTN","HLCSTCP1",197,0)
 . ; check for end block; <eb><cr>
"RTN","HLCSTCP1",198,0)
 . I HLMSG(HLINE,0)[HLDEND D
"RTN","HLCSTCP1",199,0)
 .. ; patch HL*1.6*122 start
"RTN","HLCSTCP1",200,0)
 .. ;no msg. ien
"RTN","HLCSTCP1",201,0)
 .. ; Q:'HLIND1
"RTN","HLCSTCP1",202,0)
 .. I 'HLIND1 D CLEAN Q
"RTN","HLCSTCP1",203,0)
 .. ; Kill just the last line if no data before HLDEND
"RTN","HLCSTCP1",204,0)
 .. I $P(HLMSG(HLINE,0),HLDEND)']"" D
"RTN","HLCSTCP1",205,0)
 ... K HLMSG(HLINE,0) S HLINE=HLINE-1
"RTN","HLCSTCP1",206,0)
 .. E  S HLMSG(HLINE,0)=$P(HLMSG(HLINE,0),HLDEND)
"RTN","HLCSTCP1",207,0)
 .. ; patch HL*1.6*122 end
"RTN","HLCSTCP1",208,0)
 .. ;
"RTN","HLCSTCP1",209,0)
 .. ; move into 772
"RTN","HLCSTCP1",210,0)
 .. D SAVE(.HLMSG,"^HL(772,"_+$P(HLIND1,U,2)_",""IN"")")
"RTN","HLCSTCP1",211,0)
 .. ;mark that end block has been received
"RTN","HLCSTCP1",212,0)
 .. ;HLIND1=ien in 773^ien in 772^1 if end block was received
"RTN","HLCSTCP1",213,0)
 .. S $P(HLIND1,U,3)=1
"RTN","HLCSTCP1",214,0)
 .. S HLBUFF("HLIND1")=HLIND1
"RTN","HLCSTCP1",215,0)
 .. ;reset variables for next message
"RTN","HLCSTCP1",216,0)
 .. D CLEAN
"RTN","HLCSTCP1",217,0)
 . ;add blank line for carriage return
"RTN","HLCSTCP1",218,0)
 . I HLINE'=0,HLMSG(HLINE,0)]"" S HLINE=HLINE+1,HLMSG(HLINE,0)=""
"RTN","HLCSTCP1",219,0)
 Q:HLRDOUT
"RTN","HLCSTCP1",220,0)
 ;If the line is long and no <CR> move it into the array.
"RTN","HLCSTCP1",221,0)
 I ($L(HLX)=HLDBSIZE),(HLX'[HLRS),(HLX'[HLDEND),(HLX'[HLDSTRT) D  Q
"RTN","HLCSTCP1",222,0)
 . S HLINE=HLINE+1,HLMSG(HLINE,0)=HLX,HLX=""
"RTN","HLCSTCP1",223,0)
 ;have start block but no record seperator
"RTN","HLCSTCP1",224,0)
 I HLX[HLDSTRT D  Q
"RTN","HLCSTCP1",225,0)
 . ;check for more than 1 start block
"RTN","HLCSTCP1",226,0)
 . S X=$L(HLX,HLDSTRT) S:X>2 HLX=HLDSTRT_$P(HLX,HLDSTRT,X)
"RTN","HLCSTCP1",227,0)
 . ;
"RTN","HLCSTCP1",228,0)
 . ; patch HL*1.6*122
"RTN","HLCSTCP1",229,0)
 . ; S:$L($P(HLX,HLDSTRT,2))>8 HLINE=HLINE+1,HLMSG(HLINE,0)=$P(HLX,HLDSTRT,2),HLX="",HLHDR=1
"RTN","HLCSTCP1",230,0)
 . S HLINE=HLINE+1,HLMSG(HLINE,0)=$P(HLX,HLDSTRT,2),HLX="",HLHDR=1
"RTN","HLCSTCP1",231,0)
 . ;
"RTN","HLCSTCP1",232,0)
 . D RESET:(HLHDR&(HLINE>1))
"RTN","HLCSTCP1",233,0)
 ;if no ien, reset
"RTN","HLCSTCP1",234,0)
 ; patch HL*1.6*122
"RTN","HLCSTCP1",235,0)
 ; I 'HLIND1 D CLEAN Q
"RTN","HLCSTCP1",236,0)
 I (HLRS("START-FLAG")=1),'HLIND1 D CLEAN Q
"RTN","HLCSTCP1",237,0)
 ; big message-merge from local to global every 100 lines
"RTN","HLCSTCP1",238,0)
 I (HLINE-$O(HLMSG(0)))>100 D
"RTN","HLCSTCP1",239,0)
 . M ^HL(772,+$P(HLIND1,U,2),"IN")=HLMSG
"RTN","HLCSTCP1",240,0)
 . ; reset working array
"RTN","HLCSTCP1",241,0)
 . K HLMSG
"RTN","HLCSTCP1",242,0)
 Q
"RTN","HLCSTCP1",243,0)
 ;
"RTN","HLCSTCP1",244,0)
SAVE(SRC,DEST) ;save into global & set top node
"RTN","HLCSTCP1",245,0)
 ;SRC=source array (passed by ref.), DEST=destination global
"RTN","HLCSTCP1",246,0)
 ;
"RTN","HLCSTCP1",247,0)
 ; patch HL*1.6*122: MPI-client/server
"RTN","HLCSTCP1",248,0)
 I DEST["HLMA" D
"RTN","HLCSTCP1",249,0)
 . F  L +^HLMA(+HLIND1):10 Q:$T  H 1
"RTN","HLCSTCP1",250,0)
 E  D
"RTN","HLCSTCP1",251,0)
 . F  L +^HL(772,+$P(HLIND1,U,2)):10 Q:$T  H 1
"RTN","HLCSTCP1",252,0)
 ;
"RTN","HLCSTCP1",253,0)
 M @DEST=SRC
"RTN","HLCSTCP1",254,0)
 S @DEST@(0)="^^"_HLINE_"^"_HLINE_"^"_DT_"^"
"RTN","HLCSTCP1",255,0)
 ;
"RTN","HLCSTCP1",256,0)
 I DEST["HLMA" L -^HLMA(+HLIND1)
"RTN","HLCSTCP1",257,0)
 E  L -^HL(772,+$P(HLIND1,U,2))
"RTN","HLCSTCP1",258,0)
 ;
"RTN","HLCSTCP1",259,0)
 Q
"RTN","HLCSTCP1",260,0)
 ;
"RTN","HLCSTCP1",261,0)
DELMSG(HLMAMT) ;delete message from Message Administration/Message Text files.
"RTN","HLCSTCP1",262,0)
 N DIK,DA
"RTN","HLCSTCP1",263,0)
 S DA=+HLMAMT,DIK="^HLMA("
"RTN","HLCSTCP1",264,0)
 D ^DIK
"RTN","HLCSTCP1",265,0)
 S DA=$P(HLMAMT,U,2),DIK="^HL(772,"
"RTN","HLCSTCP1",266,0)
 D ^DIK
"RTN","HLCSTCP1",267,0)
 Q
"RTN","HLCSTCP1",268,0)
PING ;process PING message
"RTN","HLCSTCP1",269,0)
 S X=HLMSG(1,0)
"RTN","HLCSTCP1",270,0)
 I X[HLDEND U IO W X,! D
"RTN","HLCSTCP1",271,0)
 . ; switch to null device if opened to prevent 'leakage'
"RTN","HLCSTCP1",272,0)
 . I $G(IO(0))]"",$G(IO(0))'=IO U IO(0)
"RTN","HLCSTCP1",273,0)
CLEAN ;reset var. for next message
"RTN","HLCSTCP1",274,0)
 K HLMSG
"RTN","HLCSTCP1",275,0)
 S HLINE=0,HLRDOUT=1
"RTN","HLCSTCP1",276,0)
 Q
"RTN","HLCSTCP1",277,0)
 ;
"RTN","HLCSTCP1",278,0)
ERROR ; Error trap for disconnect error and return back to the read loop.
"RTN","HLCSTCP1",279,0)
 ; patch HL*1.6*122
"RTN","HLCSTCP1",280,0)
 ; move to routine HLCSTCP4 (splitted-size over 10000)
"RTN","HLCSTCP1",281,0)
 D ERROR1^HLCSTCP4
"RTN","HLCSTCP1",282,0)
 Q
"RTN","HLCSTCP1",283,0)
 ;
"RTN","HLCSTCP1",284,0)
CC(X) ;cleanup and close
"RTN","HLCSTCP1",285,0)
 D MON^HLCSTCP(X)
"RTN","HLCSTCP1",286,0)
 H 2
"RTN","HLCSTCP1",287,0)
 Q
"RTN","HLCSTCP1",288,0)
RESET ;reset info as a result of no end block
"RTN","HLCSTCP1",289,0)
 N %
"RTN","HLCSTCP1",290,0)
 S HLMSG(1,0)=HLMSG(HLINE,0)
"RTN","HLCSTCP1",291,0)
 F %=2:1:HLINE K HLMSG(%,0)
"RTN","HLCSTCP1",292,0)
 S HLINE=1
"RTN","HLCSTCP1",293,0)
 Q
"RTN","HLCSTCP2")
0^21^B68574650^B63043745
"RTN","HLCSTCP2",1,0)
HLCSTCP2 ;SFIRMFO/RSD - BI-DIRECTIONAL TCP ;10/17/2007  09:37
"RTN","HLCSTCP2",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**19,43,49,57,63,64,66,67,76,77,87,109,133,122**;Oct 13,1995;Build 14
"RTN","HLCSTCP2",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLCSTCP2",4,0)
 ;Sender 
"RTN","HLCSTCP2",5,0)
 ;Request connection, send outbound message(s) delimited by MLLP
"RTN","HLCSTCP2",6,0)
 ;Input : HLDP=Logical Link to use
"RTN","HLCSTCP2",7,0)
 ; Set up error trap
"RTN","HLCSTCP2",8,0)
 N $ETRAP,$ESTACK S $ETRAP="D ERROR^HLCSTCP2"
"RTN","HLCSTCP2",9,0)
 N HLMSG,HLPORT,HLRETRY,HLRETMG,HLTCPO,POP
"RTN","HLCSTCP2",10,0)
 ;HLRETRY=number of retranmission for this link,HLRETMG=alert sent
"RTN","HLCSTCP2",11,0)
 S HLTCPO=HLDP,HLMSG="",(HLRETRY,HLRETMG)=0
"RTN","HLCSTCP2",12,0)
 ;
"RTN","HLCSTCP2",13,0)
 ; patch 122
"RTN","HLCSTCP2",14,0)
 ; patch 133
"RTN","HLCSTCP2",15,0)
 ; set IO(0) to the null device
"RTN","HLCSTCP2",16,0)
 I $G(^%ZOSF("OS"))]"",^%ZOSF("OS")'["GT.M" D
"RTN","HLCSTCP2",17,0)
 . S IO(0)=$S(^%ZOSF("OS")["OpenM":$S($$OS^%ZOSV()["VMS":"_NLA0:",$$OS^%ZOSV()["UNIX":"/dev/null",1:$P),^%ZOSF("OS")["DSM":"_NLA0:",1:$P)
"RTN","HLCSTCP2",18,0)
 . O IO(0) U IO(0)
"RTN","HLCSTCP2",19,0)
 ;
"RTN","HLCSTCP2",20,0)
 ;persistent conection, open connection first, HLPORT=open port
"RTN","HLCSTCP2",21,0)
 I $G(HLTCPLNK)["Y" F  Q:$$OPEN  G EXIT:$$STOP^HLCSTCP H 1
"RTN","HLCSTCP2",22,0)
 F  D QUE Q:$$STOP^HLCSTCP  D:'HLMSG  Q:$G(HLCSOUT)
"RTN","HLCSTCP2",23,0)
 . ;no messages to send
"RTN","HLCSTCP2",24,0)
 . D MON^HLCSTCP("Idle") H 3
"RTN","HLCSTCP2",25,0)
 . ;persistent connection, no retention
"RTN","HLCSTCP2",26,0)
 . Q:$G(HLTCPLNK)["Y"
"RTN","HLCSTCP2",27,0)
 . D MON^HLCSTCP("Retention")
"RTN","HLCSTCP2",28,0)
 . N % I 0
"RTN","HLCSTCP2",29,0)
 . ;if message comes in or ask to stop
"RTN","HLCSTCP2",30,0)
 . F %=1:1:HLTCPRET H 1 I $$STOP^HLCSTCP!$O(^HLMA("AC","O",HLDP,0)) Q
"RTN","HLCSTCP2",31,0)
 . E  S HLCSOUT=2 Q
"RTN","HLCSTCP2",32,0)
 . Q:$$STOP^HLCSTCP
"RTN","HLCSTCP2",33,0)
 . D MON^HLCSTCP("Idle")
"RTN","HLCSTCP2",34,0)
 ;Close port
"RTN","HLCSTCP2",35,0)
 I $D(HLPORT) D CLOSE^%ZISTCP K HLPORT
"RTN","HLCSTCP2",36,0)
EXIT Q
"RTN","HLCSTCP2",37,0)
 ;
"RTN","HLCSTCP2",38,0)
QUE ; -- Check "OUT" queue for processing IF there is a message do it
"RTN","HLCSTCP2",39,0)
 ; and then check the link if it open or not
"RTN","HLCSTCP2",40,0)
 N HL,HLN,HLARR,HLHDR,HLI,HLJ,HLMSA,HLRESP,HLRESLT,HLRETRM,HLTCP,HLTCPI,X,Z,HLREREAD
"RTN","HLCSTCP2",41,0)
 N HLTMBUF
"RTN","HLCSTCP2",42,0)
 D MON^HLCSTCP("CheckOut")
"RTN","HLCSTCP2",43,0)
 ;HLMSG=next msg, set at tag DONE
"RTN","HLCSTCP2",44,0)
 I 'HLMSG S HLMSG=+$O(^HLMA("AC","O",HLDP,0)),HLRETRY=0 Q:'HLMSG
"RTN","HLCSTCP2",45,0)
 ;
"RTN","HLCSTCP2",46,0)
 S HLI=+$G(^HLMA(HLMSG,0)),HLJ=$O(^("MSH",0)),HLTCP=""
"RTN","HLCSTCP2",47,0)
 ;don't have message text or MSH, kill x-ref and decrement 'to send'
"RTN","HLCSTCP2",48,0)
 ;
"RTN","HLCSTCP2",49,0)
 ; patch HL*1.6*122: MPI-client/server
"RTN","HLCSTCP2",50,0)
 ; I 'HLI!'HLJ K ^HLMA("AC","O",HLDP,HLMSG) D LLCNT^HLCSTCP(HLDP,3,1) S HLMSG=0 Q
"RTN","HLCSTCP2",51,0)
 I 'HLI!'HLJ D  Q
"RTN","HLCSTCP2",52,0)
 . F  L +^HLMA("AC","O",HLDP,HLMSG):10 Q:$T  H 1
"RTN","HLCSTCP2",53,0)
 . K ^HLMA("AC","O",HLDP,HLMSG)
"RTN","HLCSTCP2",54,0)
 . L -^HLMA("AC","O",HLDP,HLMSG)
"RTN","HLCSTCP2",55,0)
 . D LLCNT^HLCSTCP(HLDP,3,1)
"RTN","HLCSTCP2",56,0)
 . S HLMSG=0
"RTN","HLCSTCP2",57,0)
 ;
"RTN","HLCSTCP2",58,0)
 ;update msg status to 'being transmitted'; if cancelled decrement link and quit
"RTN","HLCSTCP2",59,0)
 I '$$CHKMSG(1.5) D LLCNT^HLCSTCP(HLDP,3,1) S HLMSG=0 Q
"RTN","HLCSTCP2",60,0)
 ;number of retransmissions for message
"RTN","HLCSTCP2",61,0)
 S HLRETRM=+$P(^HLMA(HLMSG,"P"),U,5)
"RTN","HLCSTCP2",62,0)
 ;retries exceeded, HLRETRA:action i=ignore, r=restart, s=shutdown
"RTN","HLCSTCP2",63,0)
 ;quit if restart or shutdown, link is going down
"RTN","HLCSTCP2",64,0)
 I HLRETRY>HLDRETR D  Q:"I"'[HLRETRA
"RTN","HLCSTCP2",65,0)
 . D MON^HLCSTCP("Error")
"RTN","HLCSTCP2",66,0)
 . ;only 1 alert per link up time, don't send if restart
"RTN","HLCSTCP2",67,0)
 . D:'HLRETMG&(HLRETRA'="R")
"RTN","HLCSTCP2",68,0)
 .. ;send alert
"RTN","HLCSTCP2",69,0)
 .. N XQA,XQAMSG,XQAOPT,XQAROU,XQAID,Z
"RTN","HLCSTCP2",70,0)
 .. ;get mailgroup from file 869.3
"RTN","HLCSTCP2",71,0)
 .. S HLRETMG=1,Z=$P($$PARAM^HLCS2,U,8) Q:Z=""
"RTN","HLCSTCP2",72,0)
 .. S XQA("G."_Z)="",XQAMSG=$$HTE^XLFDT($H,2)_" HL7 LL "_$P(^HLCS(870,HLDP,0),U)_" exceeded retries. LL will "_$S(HLRETRA="S":"shutdown.",HLRETRA="R":"restart.",1:"keep trying.")
"RTN","HLCSTCP2",73,0)
 .. D SETUP^XQALERT
"RTN","HLCSTCP2",74,0)
 . ;quit if action is ignore
"RTN","HLCSTCP2",75,0)
 . Q:"I"[HLRETRA
"RTN","HLCSTCP2",76,0)
 . ;this will shutdown this link
"RTN","HLCSTCP2",77,0)
 . S HLCSOUT=1
"RTN","HLCSTCP2",78,0)
 . ;action is shutdown, set shutdown flag so LM won't restart
"RTN","HLCSTCP2",79,0)
 . S:HLRETRA="S" $P(^HLCS(870,HLDP,0),U,15)=1
"RTN","HLCSTCP2",80,0)
 . D STATUS^HLTF0(HLMSG,4,103,"LLP Exceeded Retry Param")
"RTN","HLCSTCP2",81,0)
 I '$$OPEN Q
"RTN","HLCSTCP2",82,0)
 D MON^HLCSTCP("Send")
"RTN","HLCSTCP2",83,0)
 ; -- data passed in global array, success=1
"RTN","HLCSTCP2",84,0)
 I $$WRITE(HLMSG)<0 Q
"RTN","HLCSTCP2",85,0)
 S (HLTCP,HLTCPI)=HLMSG,HLRETRY=HLRETRY+1,HLRETRM=HLRETRM+1
"RTN","HLCSTCP2",86,0)
 ;update status to awaiting response, decrement link if cancelled
"RTN","HLCSTCP2",87,0)
 I '$$CHKMSG(1.7) D LLCNT^HLCSTCP(HLDP,3,1) S HLMSG=0 Q
"RTN","HLCSTCP2",88,0)
 ;set transmission count, get ACKTIMEOUT override
"RTN","HLCSTCP2",89,0)
 S $P(^HLMA(HLMSG,"P"),U,5)=HLRETRM I $P(^("P"),U,7) S HLN("ACKTIME")=+$P(^("P"),U,7)
"RTN","HLCSTCP2",90,0)
 ;get header of message just sent
"RTN","HLCSTCP2",91,0)
 K HLJ M HLJ=^HLMA(HLMSG,"MSH")
"RTN","HLCSTCP2",92,0)
 ;first component of sending app.
"RTN","HLCSTCP2",93,0)
 S HLN("ECH")=$$P^HLTPCK2(.HLJ,2),HLN("SAN")=$P($$P^HLTPCK2(.HLJ,3),$E(HLN("ECH")))
"RTN","HLCSTCP2",94,0)
 ;msg type, msg. id, commit ack, and app. ack parameter
"RTN","HLCSTCP2",95,0)
 S HLN("TYPE")=$$P^HLTPCK2(.HLJ,1),HLN("MID")=$$P^HLTPCK2(.HLJ,10),HLN("ACAT")=$$P^HLTPCK2(.HLJ,15),HLN("APAT")=$$P^HLTPCK2(.HLJ,16)
"RTN","HLCSTCP2",96,0)
 ;MSA segment, message is a response, can't have an a. ack.
"RTN","HLCSTCP2",97,0)
 S Z=$$MSA^HLTP3(+^HLMA(HLMSG,0)) I Z]"" S:HLN("ACAT")="" HLN("ACAT")="NE" S HLN("APAT")="NE"
"RTN","HLCSTCP2",98,0)
 ;for batch/file with commit ack, reset c. ack and a. ack variables
"RTN","HLCSTCP2",99,0)
 I "BHS,FHS"[HLN("TYPE") S Z=$E(HLJ(1,0),5),X=$$P^HLTPCK2(.HLJ,9),HLN("ACAT")=$P(X,Z,5),HLN("APAT")=$P(X,Z,6),HLN("MID")=$$P^HLTPCK2(.HLJ,11)
"RTN","HLCSTCP2",100,0)
 ;get event protocol
"RTN","HLCSTCP2",101,0)
 S HLN("EID")=+$P(^HLMA(HLMSG,0),U,8),X=$G(^ORD(101,HLN("EID"),770))
"RTN","HLCSTCP2",102,0)
 ;set link counter to msg sent
"RTN","HLCSTCP2",103,0)
 D LLCNT^HLCSTCP(HLDP,4)
"RTN","HLCSTCP2",104,0)
 ;commit and app. ack is never, update status to complete and hang UNI-DIRECTIONAL WAIT
"RTN","HLCSTCP2",105,0)
 I HLN("ACAT")="NE",HLN("APAT")="NE" D  Q
"RTN","HLCSTCP2",106,0)
 .D DONE(3)
"RTN","HLCSTCP2",107,0)
 .;
"RTN","HLCSTCP2",108,0)
 .;
"RTN","HLCSTCP2",109,0)
 .H $G(HLDWAIT)
"RTN","HLCSTCP2",110,0)
 ;
"RTN","HLCSTCP2",111,0)
 ;do structure is to stack error
"RTN","HLCSTCP2",112,0)
 D
"RTN","HLCSTCP2",113,0)
 . N $ETRAP,$ESTACK S $ETRAP="D RDERR^HLCSTCP2"
"RTN","HLCSTCP2",114,0)
 . ;HL*1.6*87: Read acknowledgement.  
"RTN","HLCSTCP2",115,0)
 . ;Loop to re-read from buffer when receiving incorrect ack.
"RTN","HLCSTCP2",116,0)
 . F  D  Q:'+$G(HLREREAD)
"RTN","HLCSTCP2",117,0)
 .. S HLREREAD=1
"RTN","HLCSTCP2",118,0)
 .. ;override ack timeout
"RTN","HLCSTCP2",119,0)
 .. I $G(HLN("ACKTIME")) N HLDBACK S HLDBACK=HLN("ACKTIME")
"RTN","HLCSTCP2",120,0)
 .. ;check for response, quit if no-response, msg will be resent
"RTN","HLCSTCP2",121,0)
 .. ;HLRESP=ien 773^ien 772 for response message
"RTN","HLCSTCP2",122,0)
 .. S HLRESP=$$READ^HLCSTCP1()
"RTN","HLCSTCP2",123,0)
 .. ;if no response, decrement counter and quit
"RTN","HLCSTCP2",124,0)
 .. I 'HLRESP D  Q
"RTN","HLCSTCP2",125,0)
 ...D LLCNT^HLCSTCP(HLDP,4,1)
"RTN","HLCSTCP2",126,0)
 ...S HLREREAD="0^No Response"
"RTN","HLCSTCP2",127,0)
 ...;check if the port needs to be closed and re-opened before the next re-transmission attempt
"RTN","HLCSTCP2",128,0)
 ...I $G(HLDRETRY("CLOSE")) D CLOSE^%ZISTCP K HLPORT
"RTN","HLCSTCP2",129,0)
 .. ;X 0=re-read msg, 1=commit ack, 3=app ack success, 4=error
"RTN","HLCSTCP2",130,0)
 .. S X=$$RSP^HLTP31(HLRESP,.HLN)
"RTN","HLCSTCP2",131,0)
 .. ;X=0, re-read msg. Incorrect ack (bad MSH,MSA,msg id,or sending app)
"RTN","HLCSTCP2",132,0)
 .. Q:'X 
"RTN","HLCSTCP2",133,0)
 .. ;commit ack - done
"RTN","HLCSTCP2",134,0)
 .. I X=1 D  S HLREREAD="0^Commit Ack" Q
"RTN","HLCSTCP2",135,0)
 ... ;don't need app. ack, set status to complete
"RTN","HLCSTCP2",136,0)
 ... I "NE"[HLN("APAT") D  Q
"RTN","HLCSTCP2",137,0)
 ....D DONE(3)
"RTN","HLCSTCP2",138,0)
 ....;
"RTN","HLCSTCP2",139,0)
 ... ;response is deferred, set status to awaiting ack
"RTN","HLCSTCP2",140,0)
 ... D DONE(2)
"RTN","HLCSTCP2",141,0)
 ...;
"RTN","HLCSTCP2",142,0)
 .. ;Error, HLRESLT=error number^error message from HLTP3
"RTN","HLCSTCP2",143,0)
 .. I X=4 D  Q
"RTN","HLCSTCP2",144,0)
 ... D DONE(4,+$G(HLRESLT),$P($G(HLRESLT),U,2))
"RTN","HLCSTCP2",145,0)
 ...;
"RTN","HLCSTCP2",146,0)
 ... S HLREREAD="0^Error"
"RTN","HLCSTCP2",147,0)
 .. ;app ack was successful
"RTN","HLCSTCP2",148,0)
 .. D DONE(3) S HLREREAD="0^App Ack"
"RTN","HLCSTCP2",149,0)
 ..;
"RTN","HLCSTCP2",150,0)
 Q
"RTN","HLCSTCP2",151,0)
 ;
"RTN","HLCSTCP2",152,0)
DCSEND ;direct connect
"RTN","HLCSTCP2",153,0)
 ; Set up error trap
"RTN","HLCSTCP2",154,0)
 N $ETRAP,$ESTACK S $ETRAP="D ERROR^HLCSTCP2"
"RTN","HLCSTCP2",155,0)
 ; patch HL*1.6*122
"RTN","HLCSTCP2",156,0)
 N HLTMBUF
"RTN","HLCSTCP2",157,0)
 ;override ack timeout
"RTN","HLCSTCP2",158,0)
 I $G(HLP("ACKTIME")) N HLDBACK S HLDBACK=HLP("ACKTIME")
"RTN","HLCSTCP2",159,0)
 I $$WRITE(HLMSG)<0 D:$G(HLERROR)]""  Q  ;HL*1.6*77
"RTN","HLCSTCP2",160,0)
 .  D STATUS^HLTF0(HLMSG,4,$P(HLERROR,"^"),$P(HLERROR,"^",2),1) ;HL*1.6*77
"RTN","HLCSTCP2",161,0)
 .  D LLCNT^HLCSTCP(HLDP,3,1)
"RTN","HLCSTCP2",162,0)
 D LLCNT^HLCSTCP(HLDP,4)
"RTN","HLCSTCP2",163,0)
 ;do structure is to stack error
"RTN","HLCSTCP2",164,0)
 D
"RTN","HLCSTCP2",165,0)
 . N $ETRAP,$ESTACK S $ETRAP="D RDERR^HLCSTCP2"
"RTN","HLCSTCP2",166,0)
 . ;HLRESP=ien 773^ien 772 for response message
"RTN","HLCSTCP2",167,0)
 . S HLRESP=$$READ^HLCSTCP1()
"RTN","HLCSTCP2",168,0)
 ;
"RTN","HLCSTCP2",169,0)
 D DONE(3):$G(HLRESP),DONE(4,108,$S($G(HLERROR)]"":$P(HLERROR,"^",2),1:"No response")):'$G(HLRESP)
"RTN","HLCSTCP2",170,0)
 I $G(HLERROR)']"" D
"RTN","HLCSTCP2",171,0)
 .D MON^HLCSTCP("Idle")
"RTN","HLCSTCP2",172,0)
 .I '$G(HLRESP) S HLERROR="108^No response"
"RTN","HLCSTCP2",173,0)
 ;Close port
"RTN","HLCSTCP2",174,0)
 I $D(HLPORT) D CLOSE^%ZISTCP K HLPORT
"RTN","HLCSTCP2",175,0)
 Q
"RTN","HLCSTCP2",176,0)
 ;
"RTN","HLCSTCP2",177,0)
DONE(ST,ERR,ERRMSG) ;set status to complete
"RTN","HLCSTCP2",178,0)
 ;ST=status, ERR=error ien, ERRMSG=error msg
"RTN","HLCSTCP2",179,0)
 D STATUS^HLTF0(HLMSG,ST,$G(ERR),$G(ERRMSG),1)
"RTN","HLCSTCP2",180,0)
 ;
"RTN","HLCSTCP2",181,0)
 D DEQUE^HLCSREP(HLDP,"O",HLMSG)
"RTN","HLCSTCP2",182,0)
 ;
"RTN","HLCSTCP2",183,0)
 ;check for more msg.
"RTN","HLCSTCP2",184,0)
 I $G(HLPRIO)'="I" S HLMSG=+$O(^HLMA("AC","O",HLDP,0)),HLRETRY=0
"RTN","HLCSTCP2",185,0)
 Q
"RTN","HLCSTCP2",186,0)
 ;
"RTN","HLCSTCP2",187,0)
CHKMSG(HLI) ;check status of message and update if not cancelled
"RTN","HLCSTCP2",188,0)
 ;input: HLI=new status, HLMSG=ien of msg in 773
"RTN","HLCSTCP2",189,0)
 ;returns 1=msg was updated, 0=msg has been canceled
"RTN","HLCSTCP2",190,0)
 N X
"RTN","HLCSTCP2",191,0)
 ;
"RTN","HLCSTCP2",192,0)
 ; New HL*1.6*77 code starting here...
"RTN","HLCSTCP2",193,0)
 I '$D(^HLMA(HLMSG,"P")) D  Q 0
"RTN","HLCSTCP2",194,0)
 .  S HLERROR="2^Missing status field"
"RTN","HLCSTCP2",195,0)
 .  D STATUS^HLTF0(HLMSG,4,$P(HLERROR,U),$P(HLERROR,U,2),1)
"RTN","HLCSTCP2",196,0)
 .;
"RTN","HLCSTCP2",197,0)
 . D DEQUE^HLCSREP(HLDP,"O",HLMSG)
"RTN","HLCSTCP2",198,0)
 ;
"RTN","HLCSTCP2",199,0)
 ; End of HL*1.6*77
"RTN","HLCSTCP2",200,0)
 ;
"RTN","HLCSTCP2",201,0)
 ;get status, quit if msg was cancelled
"RTN","HLCSTCP2",202,0)
 ;
"RTN","HLCSTCP2",203,0)
 S X=+^HLMA(HLMSG,"P") Q:X=3 0
"RTN","HLCSTCP2",204,0)
 ;
"RTN","HLCSTCP2",205,0)
 ;update status if it is different
"RTN","HLCSTCP2",206,0)
 I $G(HLI),HLI'=X D STATUS^HLTF0(HLMSG,HLI)
"RTN","HLCSTCP2",207,0)
 ;
"RTN","HLCSTCP2",208,0)
 Q 1
"RTN","HLCSTCP2",209,0)
 ;
"RTN","HLCSTCP2",210,0)
WRITE(HLDA) ; write message in HL7 format
"RTN","HLCSTCP2",211,0)
 ;  HLDA       - ien of message in 773
"RTN","HLCSTCP2",212,0)
 ;             - start block $C(11)
"RTN","HLCSTCP2",213,0)
 ;             - end block $C(28)
"RTN","HLCSTCP2",214,0)
 ;             - record separator $C(13)
"RTN","HLCSTCP2",215,0)
 ;Output(s): 1 - Successful
"RTN","HLCSTCP2",216,0)
 ;           -1 - Unsuccessful
"RTN","HLCSTCP2",217,0)
 ;
"RTN","HLCSTCP2",218,0)
 N HLDA2,HLAR,HLI,LINENO,X,CRCOUNT
"RTN","HLCSTCP2",219,0)
 S CRCOUNT=0
"RTN","HLCSTCP2",220,0)
 ;set error trap, used when called from HLTP3
"RTN","HLCSTCP2",221,0)
 ;
"RTN","HLCSTCP2",222,0)
 ; New HL*1.6*77 code starts here...
"RTN","HLCSTCP2",223,0)
 N $ETRAP,$ESTACK S $ETRAP="D ERROR^HLCSTCP2"
"RTN","HLCSTCP2",224,0)
 I $G(^HLMA(HLDA,0))'>0 D  Q -1
"RTN","HLCSTCP2",225,0)
 .  S HLERROR="2^Message Text pointer missing"
"RTN","HLCSTCP2",226,0)
 S HLDA2=+$G(^HLMA(HLDA,0))
"RTN","HLCSTCP2",227,0)
 ; End of HL*1.6*77 modifications...
"RTN","HLCSTCP2",228,0)
 ;
"RTN","HLCSTCP2",229,0)
 Q:'$G(^HLMA(HLDA,0)) -1 ;HL*1.6*77
"RTN","HLCSTCP2",230,0)
 ; header is in ^HLMA(, message is in ^HL(772,
"RTN","HLCSTCP2",231,0)
 S LINENO=1,HLI=0,HLAR="^HLMA(HLDA,""MSH"")"
"RTN","HLCSTCP2",232,0)
 U IO
"RTN","HLCSTCP2",233,0)
 D  W $C(13) S HLAR="^HL(772,HLDA2,""IN"")",HLI=0 D
"RTN","HLCSTCP2",234,0)
 . F  S HLI=$O(@HLAR@(HLI)) Q:'HLI  S X=$G(^(HLI,0)) D
"RTN","HLCSTCP2",235,0)
 .. ;first line, need start block char.
"RTN","HLCSTCP2",236,0)
 .. S:LINENO=1 X=$C(11)_X
"RTN","HLCSTCP2",237,0)
 .. ; HL*1.6*122
"RTN","HLCSTCP2",238,0)
 .. ; I X]"" W X,!
"RTN","HLCSTCP2",239,0)
 .. N LENGTH
"RTN","HLCSTCP2",240,0)
 .. S LENGTH=$L(X)
"RTN","HLCSTCP2",241,0)
 .. ; buffer should be limited to 512
"RTN","HLCSTCP2",242,0)
 .. I LENGTH>512 D
"RTN","HLCSTCP2",243,0)
 ... N X1
"RTN","HLCSTCP2",244,0)
 ... F  Q:LENGTH<512  D
"RTN","HLCSTCP2",245,0)
 .... S X1=$E(X,1,512),X=$E(X,513,999999)
"RTN","HLCSTCP2",246,0)
 .... S LENGTH=$L(X)
"RTN","HLCSTCP2",247,0)
 .... W X1,@IOF
"RTN","HLCSTCP2",248,0)
 .. ;
"RTN","HLCSTCP2",249,0)
 .. ; @IOF (! or #) for flush character
"RTN","HLCSTCP2",250,0)
 .. I X]"" W X,@IOF S CRCOUNT=0
"RTN","HLCSTCP2",251,0)
 .. ;send CR
"RTN","HLCSTCP2",252,0)
 .. I X="" W $C(13) S CRCOUNT=CRCOUNT+1
"RTN","HLCSTCP2",253,0)
 .. ; prevent from maxstring error
"RTN","HLCSTCP2",254,0)
 .. I CRCOUNT>200 W @IOF S CRCOUNT=0
"RTN","HLCSTCP2",255,0)
 .. S LINENO=LINENO+1
"RTN","HLCSTCP2",256,0)
 ; Sends end block for this message
"RTN","HLCSTCP2",257,0)
 S X=$C(28)_$C(13)
"RTN","HLCSTCP2",258,0)
 ; U IO W X,!
"RTN","HLCSTCP2",259,0)
 U IO W X,@IOF
"RTN","HLCSTCP2",260,0)
 ;switch to null device
"RTN","HLCSTCP2",261,0)
 I $G(IO(0))'="",$G(IO(0))'=IO U IO(0)
"RTN","HLCSTCP2",262,0)
 Q 1
"RTN","HLCSTCP2",263,0)
 ;
"RTN","HLCSTCP2",264,0)
OPEN() ; -- Open TCP/IP device (Client)
"RTN","HLCSTCP2",265,0)
 ;HLPORT=port, defined only if port is open
"RTN","HLCSTCP2",266,0)
 ;HLPORTA=number of attempted opens
"RTN","HLCSTCP2",267,0)
 I $D(HLPORT) S IO=HLPORT D  Q 1
"RTN","HLCSTCP2",268,0)
 . U IO
"RTN","HLCSTCP2",269,0)
 . I HLOS["OpenM" X "U IO:(::""-M"")" ;use packet mode on Cache'
"RTN","HLCSTCP2",270,0)
 N HLDOM,HLI,HLIP,HLPORTA
"RTN","HLCSTCP2",271,0)
 G OPENA^HLCSTCP3
"RTN","HLCSTCP2",272,0)
 ;
"RTN","HLCSTCP2",273,0)
RDERR D RDERR^HLCSTCP4 Q
"RTN","HLCSTCP2",274,0)
ERROR D ERROR^HLCSTCP4 Q
"RTN","HLCSTCP2",275,0)
 ;
"RTN","HLCSTCP2",276,0)
CC(X) ;cleanup and close
"RTN","HLCSTCP2",277,0)
 D MON^HLCSTCP(X)
"RTN","HLCSTCP2",278,0)
 I $D(HLPORT) D CLOSE^%ZISTCP K HLPORT
"RTN","HLCSTCP2",279,0)
 H 2
"RTN","HLCSTCP2",280,0)
 Q
"RTN","HLCSTCP3")
0^22^B12715740^B4549114
"RTN","HLCSTCP3",1,0)
HLCSTCP3 ;SFIRMFO/RSD - BI-DIRECTIONAL TCP ; 09/13/2006  15:36
"RTN","HLCSTCP3",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**76,77,133,122**;OCT 13, 1995;Build 14
"RTN","HLCSTCP3",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLCSTCP3",4,0)
 ;
"RTN","HLCSTCP3",5,0)
OPENA ;
"RTN","HLCSTCP3",6,0)
 ; called from $$OPEN^HLCSTCP2 and this sub-routine OPENA
"RTN","HLCSTCP3",7,0)
 ;
"RTN","HLCSTCP3",8,0)
 I $G(HLMSG),$D(^HLMA(HLMSG,"P")) S HLPORTA=+$P(^("P"),U,6)
"RTN","HLCSTCP3",9,0)
 S POP=1
"RTN","HLCSTCP3",10,0)
 ;
"RTN","HLCSTCP3",11,0)
 ; patch HL*1.6*122 start
"RTN","HLCSTCP3",12,0)
 ; variable HLDRETR=re-transmit attemps (#870,200.02)
"RTN","HLCSTCP3",13,0)
 ; variable HLTCPLNK("TIMEOUT")=timeout for 3rd parameter of CALL^%ZISTCP()
"RTN","HLCSTCP3",14,0)
 ; defined in HLCSTCP routine
"RTN","HLCSTCP3",15,0)
 ;
"RTN","HLCSTCP3",16,0)
 I '$G(HLDRETR("COUNT")) S HLDRETR("COUNT")=1
"RTN","HLCSTCP3",17,0)
 I '$G(HLTCPLNK("TIMEOUT")) S HLTCPLNK("TIMEOUT")=5
"RTN","HLCSTCP3",18,0)
 S HLDRETR("COUNT-2")=HLDRETR("COUNT")+HLDRETR
"RTN","HLCSTCP3",19,0)
 ; patch 133
"RTN","HLCSTCP3",20,0)
 ; I $G(HLDIRECT("OPEN TIMEOUT")) D
"RTN","HLCSTCP3",21,0)
 ; .S HLI=1
"RTN","HLCSTCP3",22,0)
 ; .D CALL^%ZISTCP(HLTCPADD,HLTCPORT,HLDIRECT("OPEN TIMEOUT"))
"RTN","HLCSTCP3",23,0)
 ; E  D
"RTN","HLCSTCP3",24,0)
 ; .F HLI=1:1:HLDRETR D CALL^%ZISTCP(HLTCPADD,HLTCPORT) Q:'POP
"RTN","HLCSTCP3",25,0)
 I $G(HLDIRECT("OPEN TIMEOUT")) D
"RTN","HLCSTCP3",26,0)
 . D MON^HLCSTCP("Open")
"RTN","HLCSTCP3",27,0)
 . D CALL^%ZISTCP(HLTCPADD,HLTCPORT,HLDIRECT("OPEN TIMEOUT"))
"RTN","HLCSTCP3",28,0)
 . ; give site one more chance to override the application setup
"RTN","HLCSTCP3",29,0)
 . I $G(POP),(HLTCPLNK("TIMEOUT")>HLDIRECT("OPEN TIMEOUT")) D
"RTN","HLCSTCP3",30,0)
 .. D CALL^%ZISTCP(HLTCPADD,HLTCPORT,HLTCPLNK("TIMEOUT"))
"RTN","HLCSTCP3",31,0)
 E  D
"RTN","HLCSTCP3",32,0)
 . N COUNT
"RTN","HLCSTCP3",33,0)
 . ; try to connect HLDRETR times
"RTN","HLCSTCP3",34,0)
 . F HLDRETR("COUNT")=HLDRETR("COUNT"):1:HLDRETR("COUNT-2") D  Q:('POP)!($$STOP^HLCSTCP)
"RTN","HLCSTCP3",35,0)
 .. D MON^HLCSTCP("Open")
"RTN","HLCSTCP3",36,0)
 .. ; D CALL^%ZISTCP(HLTCPADD,HLTCPORT)
"RTN","HLCSTCP3",37,0)
 .. D CALL^%ZISTCP(HLTCPADD,HLTCPORT,HLTCPLNK("TIMEOUT"))
"RTN","HLCSTCP3",38,0)
 .. ;open error
"RTN","HLCSTCP3",39,0)
 .. I POP D
"RTN","HLCSTCP3",40,0)
 ... D CC^HLCSTCP2("Openfail")
"RTN","HLCSTCP3",41,0)
 ... H $S(HLDRETR("COUNT")=1:0,HLDRETR("COUNT")<10:1,1:8)
"RTN","HLCSTCP3",42,0)
 ... I '$D(^XTMP("HL7-Openfail",$J)) D
"RTN","HLCSTCP3",43,0)
 .... S ^XTMP("HL7-Openfail",0)=$$FMADD^XLFDT($$NOW^XLFDT,3)_"^"_$$NOW^XLFDT
"RTN","HLCSTCP3",44,0)
 .... S ^XTMP("HL7-Openfail",$J,"COUNT","FIRST")=HLDRETR("COUNT")_"^"_$$NOW^XLFDT
"RTN","HLCSTCP3",45,0)
 ... S COUNT=$P($G(^XTMP("HL7-Openfail",$J,"COUNT","LAST")),"^")+1
"RTN","HLCSTCP3",46,0)
 ... S ^XTMP("HL7-Openfail",$J,"COUNT","LAST")=COUNT_"^"_$$NOW^XLFDT
"RTN","HLCSTCP3",47,0)
 ;
"RTN","HLCSTCP3",48,0)
 ;set # of opens back in msg
"RTN","HLCSTCP3",49,0)
 ; I $G(HLMSG),$D(^HLMA(HLMSG,"P")) S $P(^("P"),U,6)=HLPORTA+HLI
"RTN","HLCSTCP3",50,0)
 I $G(HLMSG),$D(^HLMA(HLMSG,"P")) S $P(^("P"),U,6)=HLDRETR("COUNT")
"RTN","HLCSTCP3",51,0)
 ; patch HL*1.6*122 end
"RTN","HLCSTCP3",52,0)
 ;
"RTN","HLCSTCP3",53,0)
 ;device open
"RTN","HLCSTCP3",54,0)
 I 'POP S HLPORT=IO D  Q $S($G(HLERROR)]"":0,1:1)
"RTN","HLCSTCP3",55,0)
 . N $ETRAP,$ESTACK S $ETRAP="D ERROR^HLCSTCP2" ;HL*1.6*77
"RTN","HLCSTCP3",56,0)
 . ;if address came from DNS, set back into LL
"RTN","HLCSTCP3",57,0)
 . I $D(HLIP) S $P(^HLCS(870,HLDP,400),U)=HLTCPADD
"RTN","HLCSTCP3",58,0)
 . ; write and read to check if still open
"RTN","HLCSTCP3",59,0)
 . Q:HLOS'["OpenM"  X "U IO:(::""-M"")" ; must be Cache/NT + use packet mode
"RTN","HLCSTCP3",60,0)
 . Q:$P(^HLCS(870,HLDP,400),U,7)'="Y"  ; must want to SAY HELO
"RTN","HLCSTCP3",61,0)
 . U IO W "HELO "_$$KSP^XUPARAM("WHERE"),! R X:1
"RTN","HLCSTCP3",62,0)
 ;openfail-try DNS lookup
"RTN","HLCSTCP3",63,0)
 ;
"RTN","HLCSTCP3",64,0)
 ; patch HL*1.6*122 start
"RTN","HLCSTCP3",65,0)
 ;I '$D(HLDOM) S HLDOM=+$P(^HLCS(870,HLDP,0),U,7),HLDOM=$P($G(^DIC(4.2,HLDOM,0)),U) D:HLDOM]"" DNS
"RTN","HLCSTCP3",66,0)
 I '$D(HLDOM) D
"RTN","HLCSTCP3",67,0)
 . S HLDOM=+$P(^HLCS(870,HLDP,0),U,7),HLDOM=$P($G(^DIC(4.2,HLDOM,0)),U)
"RTN","HLCSTCP3",68,0)
 . S HLDOM("DNS")=$P($G(^HLCS(870,+$G(HLDP),0)),"^",8)
"RTN","HLCSTCP3",69,0)
 . D:HLDOM]""!($L(HLDOM("DNS"),".")>2) DNS
"RTN","HLCSTCP3",70,0)
 ;
"RTN","HLCSTCP3",71,0)
 Q:$$STOP^HLCSTCP 0
"RTN","HLCSTCP3",72,0)
 ;HLIP=ip add. from DNS call, get first one and try open again
"RTN","HLCSTCP3",73,0)
 I $D(HLIP) S HLTCPADD=$P(HLIP,","),HLIP=$P(HLIP,",",2,99) G:HLTCPADD OPENA
"RTN","HLCSTCP3",74,0)
 ; open error
"RTN","HLCSTCP3",75,0)
 ;cleanup and close
"RTN","HLCSTCP3",76,0)
 ; patch 133
"RTN","HLCSTCP3",77,0)
 I $G(HLDIRECT("OPEN TIMEOUT")) D
"RTN","HLCSTCP3",78,0)
 . D MON^HLCSTCP("Openfail")
"RTN","HLCSTCP3",79,0)
 . I $D(HLPORT) D CLOSE^%ZISTCP K HLPORT
"RTN","HLCSTCP3",80,0)
 E  D
"RTN","HLCSTCP3",81,0)
 . D CC^HLCSTCP2("Openfail")
"RTN","HLCSTCP3",82,0)
 Q 0
"RTN","HLCSTCP3",83,0)
 ; patch HL*1.6*122 end
"RTN","HLCSTCP3",84,0)
 ;
"RTN","HLCSTCP3",85,0)
 ;
"RTN","HLCSTCP3",86,0)
 ;following code was removed, site's complained of to many alerts
"RTN","HLCSTCP3",87,0)
 ;couldn't open, send 1 alert
"RTN","HLCSTCP3",88,0)
 ;I '$G(HLPORTA) D
"RTN","HLCSTCP3",89,0)
 ;. ;send alert
"RTN","HLCSTCP3",90,0)
 ;. N XQA,XQAMSG,XQAOPT,XQAROU,XQAID,Z
"RTN","HLCSTCP3",91,0)
 ;. ;get mailgroup from file 869.3
"RTN","HLCSTCP3",92,0)
 ;. S Z=$P($$PARAM^HLCS2,U,8),HLPORTA="" Q:Z=""
"RTN","HLCSTCP3",93,0)
 ;. S XQA("G."_Z)="",XQAMSG=$$HTE^XLFDT($H,2)_" Logical Link "_$P(^HLCS(870,HLDP,0),U)_" exceeded Open Retries."
"RTN","HLCSTCP3",94,0)
 ;. D SETUP^XQALERT
"RTN","HLCSTCP3",95,0)
 ;open error
"RTN","HLCSTCP3",96,0)
 ;D CC("Openfail") H 3
"RTN","HLCSTCP3",97,0)
 ;Q 0
"RTN","HLCSTCP3",98,0)
 ;
"RTN","HLCSTCP3",99,0)
 ;
"RTN","HLCSTCP3",100,0)
DNS ;VA domains must have "med" inserted.
"RTN","HLCSTCP3",101,0)
 ;All domains must use port 5000 and are prepended with "HL7"
"RTN","HLCSTCP3",102,0)
 ;non-VA DNS lookups will succeed if site uses port 5000 and 
"RTN","HLCSTCP3",103,0)
 ;configure their local DNS with "HL7.yourdomain.com" and entries
"RTN","HLCSTCP3",104,0)
 ;are created in the logical link file and domain file.
"RTN","HLCSTCP3",105,0)
 D MON^HLCSTCP("DNS Lkup")
"RTN","HLCSTCP3",106,0)
 I HLDOM["VA.GOV"&(HLDOM'[".MED.") S HLDOM=$P(HLDOM,".VA.GOV")_".MED.VA.GOV"
"RTN","HLCSTCP3",107,0)
 I HLTCPORT=5000 S HLDOM="HL7."_HLDOM
"RTN","HLCSTCP3",108,0)
 I HLTCPORT=5500 S HLDOM="MPI."_HLDOM
"RTN","HLCSTCP3",109,0)
 ;
"RTN","HLCSTCP3",110,0)
 ; patch HL*1.6*122 start
"RTN","HLCSTCP3",111,0)
 I $L($G(HLDOM("DNS")),".")>2 D
"RTN","HLCSTCP3",112,0)
 . S HLDOM=HLDOM("DNS")
"RTN","HLCSTCP3",113,0)
 ; patch HL*1.6*122 end
"RTN","HLCSTCP3",114,0)
 ;
"RTN","HLCSTCP3",115,0)
 S HLIP=$$ADDRESS^XLFNSLK(HLDOM)
"RTN","HLCSTCP3",116,0)
 K:HLIP="" HLIP
"RTN","HLCSTCP3",117,0)
 Q
"RTN","HLCSTCP3",118,0)
 ;
"RTN","HLCSTCP4")
0^23^B39383548^B2712680
"RTN","HLCSTCP4",1,0)
HLCSTCP4 ;SFIRMFO/RSD - BI-DIRECTIONAL TCP ;10/18/2007  09:56
"RTN","HLCSTCP4",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109,122**;Oct 13,1995;Build 14
"RTN","HLCSTCP4",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLCSTCP4",4,0)
 ;
"RTN","HLCSTCP4",5,0)
 Q
"RTN","HLCSTCP4",6,0)
 ; RDERR & ERROR moved from HLCSTCP2 on 12/2/2003 - LJA
"RTN","HLCSTCP4",7,0)
 ;
"RTN","HLCSTCP4",8,0)
RDERR ; Error during read process, decrement counter
"RTN","HLCSTCP4",9,0)
 D LLCNT^HLCSTCP(HLDP,4,1)
"RTN","HLCSTCP4",10,0)
ERROR ; Error trap
"RTN","HLCSTCP4",11,0)
 ; OPEN ERROR-retry.
"RTN","HLCSTCP4",12,0)
 ; WRITE ERROR (SERVER DISCONNECT)-close channel, retry
"RTN","HLCSTCP4",13,0)
 ;
"RTN","HLCSTCP4",14,0)
 ;**109**
"RTN","HLCSTCP4",15,0)
 ;I $G(HLMSG) L -^HLMA(HLMSG)
"RTN","HLCSTCP4",16,0)
 ;
"RTN","HLCSTCP4",17,0)
 ; patch HL*1.6*122 start
"RTN","HLCSTCP4",18,0)
 N STOP
"RTN","HLCSTCP4",19,0)
 S STOP=0
"RTN","HLCSTCP4",20,0)
 I $G(HLDP) S STOP=$$STOP^HLCSTCP
"RTN","HLCSTCP4",21,0)
 S $ETRAP="D UNWIND^%ZTER"
"RTN","HLCSTCP4",22,0)
 S HLTCP("$ZA\8192#2")=""
"RTN","HLCSTCP4",23,0)
 I (^%ZOSF("OS")["OpenM") D
"RTN","HLCSTCP4",24,0)
 . S HLTCP("$ZA")=$ZA
"RTN","HLCSTCP4",25,0)
 . ; For TCP devices $ZA\8192#2: the device is currently in the
"RTN","HLCSTCP4",26,0)
 . ; Connected state talking to a remote host.
"RTN","HLCSTCP4",27,0)
 . S HLTCP("$ZA\8192#2")=$ZA\8192#2
"RTN","HLCSTCP4",28,0)
 ;
"RTN","HLCSTCP4",29,0)
 S HLTCPERR("ERR-$ZE")=$$EC^%ZOSV
"RTN","HLCSTCP4",30,0)
 ; I $$EC^%ZOSV["OPENERR"!($$EC^%ZOSV["NOTOPEN")!($$EC^%ZOSV["DEVNOTOPN") D CC^HLCSTCP2("Op-err") S:$G(HLPRIO)="I" HLERROR="15^Open Related Error" D UNWIND^%ZTER Q
"RTN","HLCSTCP4",31,0)
 I $$EC^%ZOSV["OPENERR"!($$EC^%ZOSV["NOTOPEN")!($$EC^%ZOSV["DEVNOTOPN") D  G:STOP H2^XUSCLEAN Q
"RTN","HLCSTCP4",32,0)
 . D CC^HLCSTCP2("Op-err") H 1
"RTN","HLCSTCP4",33,0)
 . S:$G(HLPRIO)="I" HLERROR="15^Open Related Error"
"RTN","HLCSTCP4",34,0)
 . I STOP D  Q
"RTN","HLCSTCP4",35,0)
 .. D CC^HLCSTCP2("Shutdown: (with 'Op-err')")
"RTN","HLCSTCP4",36,0)
 . I 'STOP D UNWIND^%ZTER
"RTN","HLCSTCP4",37,0)
 I $$EC^%ZOSV["WRITE" D  G:STOP!(HLTCP("$ZA\8192#2")=0) H2^XUSCLEAN Q
"RTN","HLCSTCP4",38,0)
 . D CC^HLCSTCP2("Wr-err") H 1
"RTN","HLCSTCP4",39,0)
 . S:$G(HLPRIO)="I" HLERROR="108^Write Error"
"RTN","HLCSTCP4",40,0)
 . I STOP D  Q
"RTN","HLCSTCP4",41,0)
 .. D CC^HLCSTCP2("Shutdown: (with 'Wr-err')")
"RTN","HLCSTCP4",42,0)
 . I HLTCP("$ZA\8192#2")=0 D  Q
"RTN","HLCSTCP4",43,0)
 .. D CC^HLCSTCP2("Halt (Wr): (Disconnected with 'Wr-err')")
"RTN","HLCSTCP4",44,0)
 . I 'STOP,HLTCP("$ZA\8192#2") D UNWIND^%ZTER
"RTN","HLCSTCP4",45,0)
 ; I $$EC^%ZOSV["READ" D CC^HLCSTCP2("Rd-err") S:$G(HLPRIO)="I" HLERROR="108^Read Error" D UNWIND^%ZTER Q
"RTN","HLCSTCP4",46,0)
 I $$EC^%ZOSV["READ" D  G:STOP!(HLTCP("$ZA\8192#2")=0) H2^XUSCLEAN Q
"RTN","HLCSTCP4",47,0)
 . D CC^HLCSTCP2("Rd-err") H 1
"RTN","HLCSTCP4",48,0)
 . S:$G(HLPRIO)="I" HLERROR="108^Read Error"
"RTN","HLCSTCP4",49,0)
 . I STOP D  Q
"RTN","HLCSTCP4",50,0)
 .. D CC^HLCSTCP2("Shutdown: (with 'Rd-err')")
"RTN","HLCSTCP4",51,0)
 . I HLTCP("$ZA\8192#2")=0 D  Q
"RTN","HLCSTCP4",52,0)
 .. D CC^HLCSTCP2("Halt (Rd): (Disconnected with 'Rd-err')")
"RTN","HLCSTCP4",53,0)
 . I 'STOP,HLTCP("$ZA\8192#2") D UNWIND^%ZTER
"RTN","HLCSTCP4",54,0)
 S HLCSOUT=1 D ^%ZTER,CC^HLCSTCP2("Error"),SDFLD^HLCSTCP
"RTN","HLCSTCP4",55,0)
 S:$G(HLPRIO)="I" HLERROR="9^Error"
"RTN","HLCSTCP4",56,0)
 I STOP D CC^HLCSTCP2("Shutdown: (with 'Error')")
"RTN","HLCSTCP4",57,0)
 I HLTCP("$ZA\8192#2")=0 D
"RTN","HLCSTCP4",58,0)
 . D CC^HLCSTCP2("Halt (Er): (Disconnected with 'Error')")
"RTN","HLCSTCP4",59,0)
 G:STOP!(HLTCP("$ZA\8192#2")=0) H2^XUSCLEAN
"RTN","HLCSTCP4",60,0)
 ; patch HL*1.6*122 end
"RTN","HLCSTCP4",61,0)
 D UNWIND^%ZTER
"RTN","HLCSTCP4",62,0)
 Q
"RTN","HLCSTCP4",63,0)
 ;
"RTN","HLCSTCP4",64,0)
PROXY ; set DUZ for application proxy user
"RTN","HLCSTCP4",65,0)
 ;
"RTN","HLCSTCP4",66,0)
 ; removed the execcution: patch 122 TEST v2
"RTN","HLCSTCP4",67,0)
 Q
"RTN","HLCSTCP4",68,0)
 ;
"RTN","HLCSTCP4",69,0)
 ;; S HLDUZ=+$$APFIND^XUSAP("HLSEVEN,APPLICATION PROXY")
"RTN","HLCSTCP4",70,0)
 ;; S DUZ=HLDUZ
"RTN","HLCSTCP4",71,0)
 ;; D DUZ^XUP(DUZ)
"RTN","HLCSTCP4",72,0)
 ;; Q
"RTN","HLCSTCP4",73,0)
 ;
"RTN","HLCSTCP4",74,0)
HLDUZ ; compare DUZ and set DUZ to application proxy user
"RTN","HLCSTCP4",75,0)
 ;
"RTN","HLCSTCP4",76,0)
 ; removed the execcution: patch 122 TEST v2
"RTN","HLCSTCP4",77,0)
 Q
"RTN","HLCSTCP4",78,0)
 ;
"RTN","HLCSTCP4",79,0)
 ;; I '$G(HLDUZ) D PROXY
"RTN","HLCSTCP4",80,0)
 ;
"RTN","HLCSTCP4",81,0)
HLDUZ2 ; compare DUZ and HLDUZ
"RTN","HLCSTCP4",82,0)
 I $G(DUZ)'=HLDUZ D
"RTN","HLCSTCP4",83,0)
 . S DUZ=HLDUZ
"RTN","HLCSTCP4",84,0)
 . D DUZ^XUP(DUZ)
"RTN","HLCSTCP4",85,0)
 Q
"RTN","HLCSTCP4",86,0)
 ;
"RTN","HLCSTCP4",87,0)
CLEANVAR ; clean variables for server, called from HLCSTCP1
"RTN","HLCSTCP4",88,0)
 ;
"RTN","HLCSTCP4",89,0)
 ; clean variables except Kernel related variables
"RTN","HLCSTCP4",90,0)
 ; protect variables defined in HLCSTCP
"RTN","HLCSTCP4",91,0)
 N HLDP
"RTN","HLCSTCP4",92,0)
 N HLCSOUT,HLDBACK,HLDBSIZE,HLDREAD,HLDRETR,HLRETRA,HLDWAIT,HLOS
"RTN","HLCSTCP4",93,0)
 N HLTCPADD,HLTCPCS,HLTCPLNK,HLTCPORT,HLTCPRET,HLCSFAIL,HLZRULE
"RTN","HLCSTCP4",94,0)
 ;
"RTN","HLCSTCP4",95,0)
 ; protect variables defined in LISTEN^HLCSTCP
"RTN","HLCSTCP4",96,0)
 ; N HLLSTN,HLCSOUT,HLDBACK,HLDBSIZE,HLDREAD,HLDRETR,HLRETRA,HLDWAIT
"RTN","HLCSTCP4",97,0)
 ; N HLOS,HLTCPADD,HLTCPCS,HLTCPLNK,HLTCPORT,HLTCPRET,HLCSFAIL
"RTN","HLCSTCP4",98,0)
 N HLLSTN
"RTN","HLCSTCP4",99,0)
 ;
"RTN","HLCSTCP4",100,0)
 ; protect variables defined in CACHEVMS^HLCSTCP and EN^HLCSTCP
"RTN","HLCSTCP4",101,0)
 N %
"RTN","HLCSTCP4",102,0)
 ; protect variables defined in this routine HLCSTCP1
"RTN","HLCSTCP4",103,0)
 N $ETRAP,$ESTACK
"RTN","HLCSTCP4",104,0)
 N HLMIEN,HLASTMSG
"RTN","HLCSTCP4",105,0)
 N HLTMBUF
"RTN","HLCSTCP4",106,0)
 N HLDUZ,DUZ
"RTN","HLCSTCP4",107,0)
 ; Kernel variables for single listener
"RTN","HLCSTCP4",108,0)
 N ZISOS,ZRULE
"RTN","HLCSTCP4",109,0)
 ;
"RTN","HLCSTCP4",110,0)
 D KILL^XUSCLEAN
"RTN","HLCSTCP4",111,0)
 Q
"RTN","HLCSTCP4",112,0)
MIEN ; sets HLIND1=ien in 773^ien in 772 for message
"RTN","HLCSTCP4",113,0)
 N HLMID,X
"RTN","HLCSTCP4",114,0)
 I HLIND1 D
"RTN","HLCSTCP4",115,0)
 . S:'$G(^HLMA(+HLIND1,0)) HLIND1=0
"RTN","HLCSTCP4",116,0)
 . S:'$G(^HL(772,+$P(HLIND1,U,2),0)) HLIND1=0
"RTN","HLCSTCP4",117,0)
 ;msg. id is 10th of MSH & 11th for BSH or FSH
"RTN","HLCSTCP4",118,0)
 S X=10+($E(HLMSG(1,0),1,3)'="MSH"),HLMID=$$PMSH(.HLMSG,X)
"RTN","HLCSTCP4",119,0)
 ;if HLIND1 is set, kill old message, use HLIND1 for new
"RTN","HLCSTCP4",120,0)
 ;message, it means we never got end block for 1st msg.
"RTN","HLCSTCP4",121,0)
 I HLIND1 D  Q
"RTN","HLCSTCP4",122,0)
 . ;get pointer to 772, kill header
"RTN","HLCSTCP4",123,0)
 . ;
"RTN","HLCSTCP4",124,0)
 . ; patch HL*1.6*122: MPI-client/server
"RTN","HLCSTCP4",125,0)
 . F  L +^HLMA(+HLIND1):10 Q:$T  H 1
"RTN","HLCSTCP4",126,0)
 . K ^HLMA(+HLIND1,"MSH")
"RTN","HLCSTCP4",127,0)
 . L -^HLMA(+HLIND1)
"RTN","HLCSTCP4",128,0)
 . ;
"RTN","HLCSTCP4",129,0)
 . I $D(^HL(772,+$P(HLIND1,U,2),"IN")) K ^("IN")
"RTN","HLCSTCP4",130,0)
 . S X=$$MAID^HLTF(+HLIND1,HLMID)
"RTN","HLCSTCP4",131,0)
 . D SAVE^HLCSTCP1(.HLMSG,"^HLMA("_+HLIND1_",""MSH"")")
"RTN","HLCSTCP4",132,0)
 . S:$P(HLIND1,U,3) $P(HLIND1,U,3)=""
"RTN","HLCSTCP4",133,0)
 D TCP^HLTF(.HLMID,.X,.HLDT)
"RTN","HLCSTCP4",134,0)
 S HLBUFF("IEN773")=X
"RTN","HLCSTCP4",135,0)
 I 'X D  Q
"RTN","HLCSTCP4",136,0)
 . ;error - record and reset array
"RTN","HLCSTCP4",137,0)
 . ;killing HLLSTN will allow MON^HLCSTCP to work with multi-server
"RTN","HLCSTCP4",138,0)
 . D CLEAN^HLCSTCP1 K HLLSTN
"RTN","HLCSTCP4",139,0)
 . ;error 100=LLP Could not Enqueue the Message, reset array
"RTN","HLCSTCP4",140,0)
 . D MONITOR^HLCSDR2(100,19,HLDP),MON^HLCSTCP("ERROR") H 30
"RTN","HLCSTCP4",141,0)
 ;HLIND1=ien in 773^ien in 772
"RTN","HLCSTCP4",142,0)
 S HLIND1=X_U_+$G(^HLMA(X,0))
"RTN","HLCSTCP4",143,0)
 S HLBUFF("HLIND1")=HLIND1
"RTN","HLCSTCP4",144,0)
 ;save MSH into 773
"RTN","HLCSTCP4",145,0)
 D SAVE^HLCSTCP1(.HLMSG,"^HLMA("_+HLIND1_",""MSH"")")
"RTN","HLCSTCP4",146,0)
 Q
"RTN","HLCSTCP4",147,0)
 ;
"RTN","HLCSTCP4",148,0)
PMSH(MSH,P) ;get piece P from MSH array (passed by ref.)
"RTN","HLCSTCP4",149,0)
 N FS,I,L,L1,L2,X,Y
"RTN","HLCSTCP4",150,0)
 S FS=$E(MSH(1,0),4),(L2,Y)=0,X=""
"RTN","HLCSTCP4",151,0)
 F I=1:1 S L1=$L($G(MSH(I,0)),FS),L=L1+Y-1 D  Q:$L(X)!'$D(MSH(I,0))
"RTN","HLCSTCP4",152,0)
 . S:L1=1 L=L+1
"RTN","HLCSTCP4",153,0)
 . S:P'>L X=$P($G(MSH(I-1,0)),FS,P-L2)_$P($G(MSH(I,0)),FS,(P-Y))
"RTN","HLCSTCP4",154,0)
 . S L2=Y,Y=L
"RTN","HLCSTCP4",155,0)
 Q X
"RTN","HLCSTCP4",156,0)
 ;
"RTN","HLCSTCP4",157,0)
ERROR1 ;
"RTN","HLCSTCP4",158,0)
 ; moved from ERROR^HLCSTCP1
"RTN","HLCSTCP4",159,0)
 ; Error trap for disconnect error and return back to the read loop.
"RTN","HLCSTCP4",160,0)
 ; patch HL*1.6*122 start
"RTN","HLCSTCP4",161,0)
 I (^%ZOSF("OS")["OpenM") D
"RTN","HLCSTCP4",162,0)
 . S HLTCP("$ZA")=$ZA
"RTN","HLCSTCP4",163,0)
 . ; For TCP devices $ZA\8192#2: the device is currently in the
"RTN","HLCSTCP4",164,0)
 . ; Connected state talking to a remote host.
"RTN","HLCSTCP4",165,0)
 . S HLTCP("$ZA\8192#2")=$ZA\8192#2
"RTN","HLCSTCP4",166,0)
 . I HLTCP("$ZA\8192#2")=0 D
"RTN","HLCSTCP4",167,0)
 .. ; decrement counter of multi-listener
"RTN","HLCSTCP4",168,0)
 .. I $D(^HLCS(870,"E","M",+$G(HLDP))) D EXITM^HLCSTCP
"RTN","HLCSTCP4",169,0)
 .. ; process terminated
"RTN","HLCSTCP4",170,0)
 .. D H2^XUSCLEAN
"RTN","HLCSTCP4",171,0)
 S $ETRAP="D UNWIND^%ZTER"
"RTN","HLCSTCP4",172,0)
 ; I $$EC^%ZOSV["READ"!($$EC^%ZOSV["NOTOPEN")!($$EC^%ZOSV["DEVNOTOPN") D UNWIND^%ZTER Q
"RTN","HLCSTCP4",173,0)
 I ($$EC^%ZOSV["NOTOPEN")!($$EC^%ZOSV["DEVNOTOPN") D  Q
"RTN","HLCSTCP4",174,0)
 . ; if it is not a multi-listener
"RTN","HLCSTCP4",175,0)
 . I '$D(^HLCS(870,"E","M",+$G(HLDP))) D CC^HLCSTCP1("Open-err")
"RTN","HLCSTCP4",176,0)
 . D UNWIND^%ZTER
"RTN","HLCSTCP4",177,0)
 I $$EC^%ZOSV["READ" D  Q
"RTN","HLCSTCP4",178,0)
 . ; if it is not a multi-listener
"RTN","HLCSTCP4",179,0)
 . I '$D(^HLCS(870,"E","M",+$G(HLDP))) D CC^HLCSTCP1("Rd-err")
"RTN","HLCSTCP4",180,0)
 . D UNWIND^%ZTER
"RTN","HLCSTCP4",181,0)
 ;
"RTN","HLCSTCP4",182,0)
 ; I $$EC^%ZOSV["WRITE" D CC("Wr-err") D UNWIND^%ZTER Q
"RTN","HLCSTCP4",183,0)
 I $$EC^%ZOSV["WRITE" D  Q
"RTN","HLCSTCP4",184,0)
 . ; if it is not a multi-listener
"RTN","HLCSTCP4",185,0)
 . I '$D(^HLCS(870,"E","M",+$G(HLDP))) D CC^HLCSTCP1("Wr-err")
"RTN","HLCSTCP4",186,0)
 . D UNWIND^%ZTER
"RTN","HLCSTCP4",187,0)
 ;
"RTN","HLCSTCP4",188,0)
 ; for GT.M
"RTN","HLCSTCP4",189,0)
 I $ECODE["UREAD" D  Q
"RTN","HLCSTCP4",190,0)
 . ; if it is not a multi-listener
"RTN","HLCSTCP4",191,0)
 . I '$D(^HLCS(870,"E","M",+$G(HLDP))) D CC^HLCSTCP1("Rd-err")
"RTN","HLCSTCP4",192,0)
 . D UNWIND^%ZTER
"RTN","HLCSTCP4",193,0)
 ;
"RTN","HLCSTCP4",194,0)
 ; S HLCSOUT=1 D ^%ZTER,CC("Error")
"RTN","HLCSTCP4",195,0)
 S HLCSOUT=1
"RTN","HLCSTCP4",196,0)
 D ^%ZTER
"RTN","HLCSTCP4",197,0)
 ; if it is not a multi-listener
"RTN","HLCSTCP4",198,0)
 I '$D(^HLCS(870,"E","M",+$G(HLDP))) D CC^HLCSTCP1("Error")
"RTN","HLCSTCP4",199,0)
 ; patch HL*1.6*122 end
"RTN","HLCSTCP4",200,0)
 ;
"RTN","HLCSTCP4",201,0)
 D UNWIND^%ZTER
"RTN","HLCSTCP4",202,0)
 Q
"RTN","HLCSTCP4",203,0)
 ;
"RTN","HLCSTCP4",204,0)
CLRMCNTR ;
"RTN","HLCSTCP4",205,0)
 ; clear the counter to set as "0 server" for multi-listener
"RTN","HLCSTCP4",206,0)
 ; HL*1.6*122 start
"RTN","HLCSTCP4",207,0)
 Q:'$G(HLDP)
"RTN","HLCSTCP4",208,0)
 Q:'$D(^HLCS(870,"E","M",HLDP))
"RTN","HLCSTCP4",209,0)
 S $P(^HLCS(870,HLDP,0),"^",4)="MS"
"RTN","HLCSTCP4",210,0)
 S $P(^HLCS(870,HLDP,0),U,5)="0 server"
"RTN","HLCSTCP4",211,0)
 Q
"RTN","HLCSTCP4",212,0)
 ;
"RTN","HLCSTCP4",213,0)
CREATUSR ;
"RTN","HLCSTCP4",214,0)
 ; patch HL*1.6*122 TEST v2: DUZ code removed
"RTN","HLCSTCP4",215,0)
 ; create application proxy users for listeners and incoming filer
"RTN","HLCSTCP4",216,0)
 ;; N HLTEMP
"RTN","HLCSTCP4",217,0)
 ;; S HLTEMP=$$CREATE^XUSAP("HLSEVEN,APPLICATION PROXY","#")
"RTN","HLCSTCP4",218,0)
 Q
"RTN","HLCSTCPA")
0^24^B6096093^B1420563
"RTN","HLCSTCPA",1,0)
HLCSTCPA ;OIFO-O/RJH - (TCP/IP) VMS ;07/26/2007  10:29
"RTN","HLCSTCPA",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**84,122**;Oct 13, 1995;Build 14
"RTN","HLCSTCPA",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLCSTCPA",4,0)
 ;
"RTN","HLCSTCPA",5,0)
 ; 1. port number is input from VMS COM file, such as HLSxxxxDSM.COM,
"RTN","HLCSTCPA",6,0)
 ;    HLSxxxxCACHE.COM, or HLSxxxxGTM.COM file, where xxxx is port
"RTN","HLCSTCPA",7,0)
 ;    number.
"RTN","HLCSTCPA",8,0)
 ; 2. find the ien of #870(logical link file) for the multi-listener
"RTN","HLCSTCPA",9,0)
 Q
"RTN","HLCSTCPA",10,0)
 ;
"RTN","HLCSTCPA",11,0)
GTMPORT(%) ; From tcpip ZFOO for GT.M
"RTN","HLCSTCPA",12,0)
 ; %: device^port number
"RTN","HLCSTCPA",13,0)
 N HLPORT
"RTN","HLCSTCPA",14,0)
 S HLPORT=$P($G(%),"^",2)
"RTN","HLCSTCPA",15,0)
 I $G(^%ZOSF("OS"))'["GT.M" D ^%ZTER Q
"RTN","HLCSTCPA",16,0)
 D IEN
"RTN","HLCSTCPA",17,0)
 Q
"RTN","HLCSTCPA",18,0)
 ;
"RTN","HLCSTCPA",19,0)
PORT ;
"RTN","HLCSTCPA",20,0)
 ; HLPORT: port number of multi-listener
"RTN","HLCSTCPA",21,0)
 ; input of DSM: % = device^port number of multi-listener
"RTN","HLCSTCPA",22,0)
 ; input of Cache: port number of TCPIP
"RTN","HLCSTCPA",23,0)
 ;
"RTN","HLCSTCPA",24,0)
 N HLPORT
"RTN","HLCSTCPA",25,0)
 S HLPORT=0
"RTN","HLCSTCPA",26,0)
 I ^%ZOSF("OS")["OpenM" D
"RTN","HLCSTCPA",27,0)
 . S HLPORT=$ZF("GETSYM","PORT")
"RTN","HLCSTCPA",28,0)
 I ^%ZOSF("OS")["DSM" D
"RTN","HLCSTCPA",29,0)
 . S HLPORT=$P(%,"^",2)
"RTN","HLCSTCPA",30,0)
 ;
"RTN","HLCSTCPA",31,0)
IEN ;
"RTN","HLCSTCPA",32,0)
 ; HLIEN870: ien in #870 (logical link file)
"RTN","HLCSTCPA",33,0)
 ; HLPRTS: port number in entry to be tested
"RTN","HLCSTCPA",34,0)
 ;
"RTN","HLCSTCPA",35,0)
 N HLIEN870
"RTN","HLCSTCPA",36,0)
 I 'HLPORT D ^%ZTER Q
"RTN","HLCSTCPA",37,0)
 S HLIEN870=0
"RTN","HLCSTCPA",38,0)
 F  S HLIEN870=$O(^HLCS(870,"E","M",HLIEN870)) Q:'HLIEN870  D  Q:(HLPRTS=HLPORT)
"RTN","HLCSTCPA",39,0)
 . S HLPRTS=$P(^HLCS(870,HLIEN870,400),"^",2)
"RTN","HLCSTCPA",40,0)
 I 'HLIEN870 D ^%ZTER Q
"RTN","HLCSTCPA",41,0)
 ;
"RTN","HLCSTCPA",42,0)
 K HLPORT,HLPRTS
"RTN","HLCSTCPA",43,0)
 ; patch 122
"RTN","HLCSTCPA",44,0)
 S U="^"
"RTN","HLCSTCPA",45,0)
 ;
"RTN","HLCSTCPA",46,0)
 ;for Cache/VMS
"RTN","HLCSTCPA",47,0)
 I ^%ZOSF("OS")["OpenM" D  Q
"RTN","HLCSTCPA",48,0)
 . D CACHEVMS(HLIEN870)
"RTN","HLCSTCPA",49,0)
 ;
"RTN","HLCSTCPA",50,0)
 ;for DSM
"RTN","HLCSTCPA",51,0)
 I ^%ZOSF("OS")["DSM" D  Q
"RTN","HLCSTCPA",52,0)
 . S $P(%,"^",2)=HLIEN870   ;set % = device^ien of #870
"RTN","HLCSTCPA",53,0)
 . K HLIEN870
"RTN","HLCSTCPA",54,0)
 . D EN
"RTN","HLCSTCPA",55,0)
 ;
"RTN","HLCSTCPA",56,0)
 ;for GT.M
"RTN","HLCSTCPA",57,0)
 I ^%ZOSF("OS")["GT.M" D  Q
"RTN","HLCSTCPA",58,0)
 . S HLDP=HLIEN870   ;set HLDP = ien of #870
"RTN","HLCSTCPA",59,0)
 . K HLIEN870
"RTN","HLCSTCPA",60,0)
 . D GTMUCX
"RTN","HLCSTCPA",61,0)
 ;
"RTN","HLCSTCPA",62,0)
 D ^%ZTER
"RTN","HLCSTCPA",63,0)
 Q
"RTN","HLCSTCPA",64,0)
GTMUCX ; GT.M /VMS tcpip
"RTN","HLCSTCPA",65,0)
 ;listener,  % = device^port
"RTN","HLCSTCPA",66,0)
 S U="^",IO=$P(%,U)
"RTN","HLCSTCPA",67,0)
 ; S IO(0)=$P O IO(0) ;Setup null device
"RTN","HLCSTCPA",68,0)
 ; GTM specific code
"RTN","HLCSTCPA",69,0)
 S @("$ZINTERRUPT=""I $$JOBEXAM^ZU($ZPOSITION)""")
"RTN","HLCSTCPA",70,0)
 X "O IO:(RECORDSIZE=512)"
"RTN","HLCSTCPA",71,0)
 D LISTEN^HLCSTCP
"RTN","HLCSTCPA",72,0)
 C IO
"RTN","HLCSTCPA",73,0)
 Q
"RTN","HLCSTCPA",74,0)
 ;
"RTN","HLCSTCPA",75,0)
 ; $ x=f$trnlnm("sys$net")  !This is our MBX device
"RTN","HLCSTCPA",76,0)
 ; $!
"RTN","HLCSTCPA",77,0)
 ; $! for GT.M
"RTN","HLCSTCPA",78,0)
 ; $ assign 'f$trnlnm("SYS$NET")' SYS$NET
"RTN","HLCSTCPA",79,0)
 ; $! Depending on how your command files are set up, you may need to
"RTN","HLCSTCPA",80,0)
 ; $! run the GT.M profile file.
"RTN","HLCSTCPA",81,0)
 ; $ @<user$:[gtmmgr]>gtmprofile.com
"RTN","HLCSTCPA",82,0)
 ; $ forfoo="$" + f$parse("user$:[gtmmgr.r]ZFOO.exe")
"RTN","HLCSTCPA",83,0)
 ; $ PORT=5000
"RTN","HLCSTCPA",84,0)
 ; $ data="''x'^''PORT'"
"RTN","HLCSTCPA",85,0)
 ; $ forfoo GTMPORT^HLCSTCPA("''data'")
"RTN","HLCSTCPA",86,0)
 ;
"RTN","HLCSTCPA",87,0)
CACHEVMS(%) ;Cache'/VMS tcpip
"RTN","HLCSTCPA",88,0)
 ;listener,  % = HLDP
"RTN","HLCSTCPA",89,0)
 I $G(%)="" D ^%ZTER Q
"RTN","HLCSTCPA",90,0)
 ; patch 133
"RTN","HLCSTCPA",91,0)
 S IO="SYS$NET",U="^",HLDP=%
"RTN","HLCSTCPA",92,0)
 S IO(0)="_NLA0:" O IO(0) ;Setup null device
"RTN","HLCSTCPA",93,0)
 ; **Cache'/VMS specific code**
"RTN","HLCSTCPA",94,0)
 O IO::5 E  D MON^HLCSTCP("Openfail") Q
"RTN","HLCSTCPA",95,0)
 X "U IO:(::""-M"")" ;Packet mode like DSM
"RTN","HLCSTCPA",96,0)
 D LISTEN^HLCSTCP
"RTN","HLCSTCPA",97,0)
 C IO
"RTN","HLCSTCPA",98,0)
 Q
"RTN","HLCSTCPA",99,0)
 ;
"RTN","HLCSTCPA",100,0)
EN ; DSM/VMS tcpip
"RTN","HLCSTCPA",101,0)
 ;listener,  % = device^HLDP
"RTN","HLCSTCPA",102,0)
 I $G(%)="" D ^%ZTER Q
"RTN","HLCSTCPA",103,0)
 ; patch 122
"RTN","HLCSTCPA",104,0)
 ; S IO="SYS$NET",U="^",HLDP=$P(%,U,2)
"RTN","HLCSTCPA",105,0)
 S U="^",IO=$P(%,U),HLDP=$P(%,U,2)
"RTN","HLCSTCPA",106,0)
 ; patch 133
"RTN","HLCSTCPA",107,0)
 S IO(0)="_NLA0:" O IO(0) ;Setup null device
"RTN","HLCSTCPA",108,0)
 ; **VMS specific code, need to share device**
"RTN","HLCSTCPA",109,0)
 O IO:(TCPDEV):60 E  D MON^HLCSTCP("Openfail") Q
"RTN","HLCSTCPA",110,0)
 ; patch 122
"RTN","HLCSTCPA",111,0)
 D LISTEN^HLCSTCP
"RTN","HLCSTCPA",112,0)
 C IO
"RTN","HLCSTCPA",113,0)
 Q
"RTN","HLCSTERM")
0^25^B4335770^B4136031
"RTN","HLCSTERM",1,0)
HLCSTERM ;ALB/RJS - SET UP VIDEO ATTRIBUTES ;06/27/2007  17:04
"RTN","HLCSTERM",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**40,49,122**;Oct 13, 1995;Build 14
"RTN","HLCSTERM",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLCSTERM",4,0)
 ;
"RTN","HLCSTERM",5,0)
TERM ; -- set up term characteristics
"RTN","HLCSTERM",6,0)
 N X
"RTN","HLCSTERM",7,0)
 I '$D(IOST(0)) D HOME^%ZIS
"RTN","HLCSTERM",8,0)
 S X=$$IO D ENDR^%ZISS
"RTN","HLCSTERM",9,0)
 S (HLCON,HLCOFF)=""
"RTN","HLCSTERM",10,0)
 I $E(IOST,1,4)="C-VT" S HLCOFF=$C(13,27,91)_"?25l"_$C(13),HLCON=$C(27,91)_"?25h"
"RTN","HLCSTERM",11,0)
 Q
"RTN","HLCSTERM",12,0)
HEADER ;
"RTN","HLCSTERM",13,0)
 ;Write out Header
"RTN","HLCSTERM",14,0)
 ;
"RTN","HLCSTERM",15,0)
 N HLMIDDLE,HLLNGTH,HLJUST
"RTN","HLCSTERM",16,0)
 W @IOF,!
"RTN","HLCSTERM",17,0)
 S HLPARAM=$$PARAM^HLCS2
"RTN","HLCSTERM",18,0)
 S HLSITE=$P(HLPARAM,U,5),HLPROD=$P(HLPARAM,U,3)
"RTN","HLCSTERM",19,0)
 S HLHDR="SYSTEM LINK MONITOR for "_HLSITE_" ("_HLPROD_" System)"
"RTN","HLCSTERM",20,0)
 S HLMIDDLE=IOM\2,HLLNGTH=$L(HLHDR)\2,HLJUST=HLMIDDLE-HLLNGTH
"RTN","HLCSTERM",21,0)
 D WDATA^HLCSMON1(HLJUST,1,IORVON,IORVOFF,HLHDR,75)
"RTN","HLCSTERM",22,0)
 D WDATA^HLCSMON1(5,4,IOUON,IOUOFF,"NODE",8)
"RTN","HLCSTERM",23,0)
 D WDATA^HLCSMON1(16,3,"","","MESSAGES",8),WDATA^HLCSMON1(16,4,IOUON,IOUOFF,"RECEIVED",8)
"RTN","HLCSTERM",24,0)
 D WDATA^HLCSMON1(26,3,"","","MESSAGES",8),WDATA^HLCSMON1(26,4,IOUON,IOUOFF,"PROCESSED",9)
"RTN","HLCSTERM",25,0)
 D WDATA^HLCSMON1(37,3,"","","MESSAGES",8),WDATA^HLCSMON1(37,4,IOUON,IOUOFF,"TO SEND ",8)
"RTN","HLCSTERM",26,0)
 D WDATA^HLCSMON1(47,3,"","","MESSAGES",8),WDATA^HLCSMON1(47,4,IOUON,IOUOFF,"SENT    ",8)
"RTN","HLCSTERM",27,0)
 ; patch HL*1.6*122
"RTN","HLCSTERM",28,0)
 ; D WDATA^HLCSMON1(57,3,"","","DEVICE",8),WDATA^HLCSMON1(57,4,IOUON,IOUOFF,"TYPE   ",8)
"RTN","HLCSTERM",29,0)
 D WDATA^HLCSMON1(57,3,"","","DEVICE",8),WDATA^HLCSMON1(57,4,IOUON,IOUOFF,"TYPE   ",6)
"RTN","HLCSTERM",30,0)
 ;
"RTN","HLCSTERM",31,0)
 D WDATA^HLCSMON1(66,4,IOUON,IOUOFF,"STATE",8)
"RTN","HLCSTERM",32,0)
 Q
"RTN","HLCSTERM",33,0)
KVAR ;
"RTN","HLCSTERM",34,0)
 D KILL^%ZISS
"RTN","HLCSTERM",35,0)
 K HLCON,HLCOFF
"RTN","HLCSTERM",36,0)
 Q
"RTN","HLCSTERM",37,0)
IO() ; -- what device params
"RTN","HLCSTERM",38,0)
 Q "IOELALL;IOELEOL;IORESET;IORVON;IORVOFF;IOIL;IOSTBM;IOSC;IORC;IOEDEOP;IOINHI;IOINORM;IOUON;IOUOFF;IOBOFF;IOBON"
"RTN","HLCSTERM",39,0)
 Q
"RTN","HLDIE")
0^31^B47013227^B42269584
"RTN","HLDIE",1,0)
HLDIE ;CIOFO-O/LJA - Direct 772 & 773 Sets ; 10/19/2007 11:15
"RTN","HLDIE",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109,122**;Oct 13,1995;Build 14
"RTN","HLDIE",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLDIE",4,0)
 Q
"RTN","HLDIE",5,0)
 ;
"RTN","HLDIE",6,0)
 ; Rules: if any of these rules is broken, FILE^DIE is called instead
"RTN","HLDIE",7,0)
 ;
"RTN","HLDIE",8,0)
 ;         * Can't edit files other than 772,773
"RTN","HLDIE",9,0)
 ;         * Don't pass IENS value with multiples IENs.  You can only
"RTN","HLDIE",10,0)
 ;             edit one IEN at a time!
"RTN","HLDIE",11,0)
 ;         * Only flag "S" is honored.  Flag "K" is ignored. Other
"RTN","HLDIE",12,0)
 ;             flags result in FILE^DIE being called.
"RTN","HLDIE",13,0)
 ;         * Can't edit ^HLMA(IEN,90) data.
"RTN","HLDIE",14,0)
 ;         * Can't edit ^HLMA(IEN,91) data.
"RTN","HLDIE",15,0)
 ;         * Can't edit ^HL(772,IEN,"IN") data (field #200, MESSAGE TEXT)
"RTN","HLDIE",16,0)
 ;         * No checking of data performed!  (Data format MUST be OK.)
"RTN","HLDIE",17,0)
 ;         * No locking of records in files 772 or 773. (Locks on queues.)
"RTN","HLDIE",18,0)
 ;
"RTN","HLDIE",19,0)
FILE(FLAGS,ROOT,ERR,SUB,RTN) ; FILE^DIE functional equivalent...
"RTN","HLDIE",20,0)
 ; This call has similar parameters to FILE^DIE, but changes data
"RTN","HLDIE",21,0)
 ; using hard sets.  The first two parameters of this API are the
"RTN","HLDIE",22,0)
 ; same as FILE^DIE.  So, if any file other than 772 or 773 is being
"RTN","HLDIE",23,0)
 ; edited, this API just passes on the FLAGS,ROOT,ERR parameters to
"RTN","HLDIE",24,0)
 ; FILE^DIE and quits.  If file 772 or 773 is being edited, the hard
"RTN","HLDIE",25,0)
 ; set code in HLDIE772 and HLDIE773 is called. 
"RTN","HLDIE",26,0)
 ;
"RTN","HLDIE",27,0)
 N DEBUG,FILE,HLEDITOR,LERR,IEN,X,XECMCODE
"RTN","HLDIE",28,0)
 ;
"RTN","HLDIE",29,0)
 S DT=$$NOW^XLFDT\1
"RTN","HLDIE",30,0)
 ;
"RTN","HLDIE",31,0)
 D BEGIN ; Debug call at beginning or process
"RTN","HLDIE",32,0)
 ;
"RTN","HLDIE",33,0)
 ; Check FILE, IEN, FIELDs passed, etc...
"RTN","HLDIE",34,0)
 I '$$CHECKS D  QUIT  ;->
"RTN","HLDIE",35,0)
 .
"RTN","HLDIE",36,0)
 .  S HLEDITOR="FILE^DIE"
"RTN","HLDIE",37,0)
 .
"RTN","HLDIE",38,0)
 .  ; Call FILEMAN...
"RTN","HLDIE",39,0)
 .  D FILE^DIE($G(FLAGS),$G(ROOT),$G(ERR))
"RTN","HLDIE",40,0)
 .
"RTN","HLDIE",41,0)
 .  ; Debug call made even with Fileman...
"RTN","HLDIE",42,0)
 .  D END
"RTN","HLDIE",43,0)
 ;
"RTN","HLDIE",44,0)
 S HLEDITOR="FILE^HLDIE"
"RTN","HLDIE",45,0)
 ;
"RTN","HLDIE",46,0)
 ; If this point is reached, file 772 or 773 is being edited, data
"RTN","HLDIE",47,0)
 ; in ROOT() has been checked, and data is being hard set...
"RTN","HLDIE",48,0)
 ;
"RTN","HLDIE",49,0)
 ;
"RTN","HLDIE",50,0)
 ; Make sure ERR is defined...
"RTN","HLDIE",51,0)
 I $G(ERR)']"" N HLERR S ERR="HLERR"
"RTN","HLDIE",52,0)
 ;
"RTN","HLDIE",53,0)
 ; All editing occurs in this call...
"RTN","HLDIE",54,0)
 D EDITALL(.ROOT,FILE,IEN)
"RTN","HLDIE",55,0)
 ;
"RTN","HLDIE",56,0)
 ; Store debug data if XTMP debug string set...
"RTN","HLDIE",57,0)
 D END
"RTN","HLDIE",58,0)
 ;
"RTN","HLDIE",59,0)
 ;check if ROOT needs to be retained
"RTN","HLDIE",60,0)
 I FLAGS'["S" K @ROOT,FLAGS
"RTN","HLDIE",61,0)
 ;
"RTN","HLDIE",62,0)
 Q
"RTN","HLDIE",63,0)
 ;
"RTN","HLDIE",64,0)
EDITALL(ROOT,FILE,IEN) ; Edit 772 or 773 by direct sets...
"RTN","HLDIE",65,0)
 ;
"RTN","HLDIE",66,0)
 ; FILE,IEN -- optional (parsed from ROOT())
"RTN","HLDIE",67,0)
 ;
"RTN","HLDIE",68,0)
 N ERRNO,FIELD,GBL,NODE,ROUTINE,TAG,VALUE,XRF
"RTN","HLDIE",69,0)
 ;
"RTN","HLDIE",70,0)
 S GBL=$$GBL(FILE,+IEN)
"RTN","HLDIE",71,0)
 ;
"RTN","HLDIE",72,0)
 ;check if .01="@" for deletion of record...
"RTN","HLDIE",73,0)
 I $G(@ROOT@(FILE,IEN,.01))="@" D  Q
"RTN","HLDIE",74,0)
 .I FILE=773 D DEL773^HLUOPT3(+IEN) Q
"RTN","HLDIE",75,0)
 .I FILE=772 D DEL772^HLUOPT3(+IEN)
"RTN","HLDIE",76,0)
 ;
"RTN","HLDIE",77,0)
 ; patch HL*1.6*122: MPI-client/server
"RTN","HLDIE",78,0)
 ; If no data in record passed in, log an error and quit...
"RTN","HLDIE",79,0)
 ; I '$D(@GBL) D  Q  ; Remember.  GBL contains IEN...
"RTN","HLDIE",80,0)
 N HLDGBL
"RTN","HLDIE",81,0)
 F  L +@GBL:10 Q:$T  H 1
"RTN","HLDIE",82,0)
 S HLDGBL=$D(@GBL)
"RTN","HLDIE",83,0)
 L -@GBL
"RTN","HLDIE",84,0)
 I 'HLDGBL D  Q  ; Remember.  GBL contains IEN...
"RTN","HLDIE",85,0)
 .  S ERRNO=$$ERRNO(601,"The entry does not exist.",FILE,2)
"RTN","HLDIE",86,0)
 .  S @ERR@("DIERR",+ERRNO,"PARAM","IENS")=IEN_$S(IEN'[",":",",1:"")
"RTN","HLDIE",87,0)
 ;
"RTN","HLDIE",88,0)
 ;
"RTN","HLDIE",89,0)
 ; What routine holds the file-specific field/xref set code?
"RTN","HLDIE",90,0)
 S ROUTINE=$S(FILE=772:"HLDIE772",FILE=773:"HLDIE773",1:"")
"RTN","HLDIE",91,0)
 ;
"RTN","HLDIE",92,0)
 ; Load NODEs...
"RTN","HLDIE",93,0)
 D GETNODES(FILE,+IEN,.NODE)
"RTN","HLDIE",94,0)
 ;
"RTN","HLDIE",95,0)
 ; When a field is edited, the NODE(1) is changed
"RTN","HLDIE",96,0)
 ;
"RTN","HLDIE",97,0)
 ; Edit NODE(1), adding new values, and set XRF(XREF) nodes...
"RTN","HLDIE",98,0)
 S FIELD=0
"RTN","HLDIE",99,0)
 F  S FIELD=$O(@ROOT@(FILE,IEN,FIELD)) Q:FIELD'>0  D
"RTN","HLDIE",100,0)
 .  ; VALUE = value passed in by process that is to be stored in file
"RTN","HLDIE",101,0)
 .  S VALUE=$G(@ROOT@(FILE,IEN,FIELD))
"RTN","HLDIE",102,0)
 .
"RTN","HLDIE",103,0)
 .  ; If field should be deleted, VALUE will equal @...
"RTN","HLDIE",104,0)
 .  I VALUE="@" S VALUE=""
"RTN","HLDIE",105,0)
 .
"RTN","HLDIE",106,0)
 .  ; Get and check tag...
"RTN","HLDIE",107,0)
 .  S TAG="F"_(FILE-770)_$TR(FIELD,".","")_U_ROUTINE
"RTN","HLDIE",108,0)
 .  S TAG(1)=$T(@TAG) I TAG(1)']"" D  QUIT  ;->
"RTN","HLDIE",109,0)
 .  .  S ERRNO=$$ERRNO(501,"No set logic for file #"_FILE_"'s field# "_FIELD,FILE,3)
"RTN","HLDIE",110,0)
 .  .  S @ERR@("DIERR",+ERRNO,"PARAM",1)=FIELD
"RTN","HLDIE",111,0)
 .  .  S @ERR@("DIERR",+ERRNO,"PARAM","FIELD")=FIELD
"RTN","HLDIE",112,0)
 .
"RTN","HLDIE",113,0)
 .  ; Call the subroutine below that is for the specific field...
"RTN","HLDIE",114,0)
 .  ; (No editing of xrefs or global data occurs in these calls.)
"RTN","HLDIE",115,0)
 .  D @("F"_(FILE-770)_$TR(FIELD,".","")_U_ROUTINE)
"RTN","HLDIE",116,0)
 ;
"RTN","HLDIE",117,0)
 ; If no data actually changed, quit...
"RTN","HLDIE",118,0)
 QUIT:'$D(NODE("CHG"))  ;->
"RTN","HLDIE",119,0)
 ;
"RTN","HLDIE",120,0)
 ; patch HL*1.6*122: MPI-client/server
"RTN","HLDIE",121,0)
 I FILE=773 D
"RTN","HLDIE",122,0)
 . F  L +^HLMA(IEN):10 Q:$T  H 1
"RTN","HLDIE",123,0)
 E  D
"RTN","HLDIE",124,0)
 . F  L +^HL(772,IEN):10 Q:$T  H 1
"RTN","HLDIE",125,0)
 ;
"RTN","HLDIE",126,0)
 ; Store changes in the global now...
"RTN","HLDIE",127,0)
 D STORE(FILE,IEN,.NODE)
"RTN","HLDIE",128,0)
 ;
"RTN","HLDIE",129,0)
 ; Set xrefs to correspond to the just-stored data...
"RTN","HLDIE",130,0)
 S XRF=""
"RTN","HLDIE",131,0)
 F  S XRF=$O(XRF(XRF)) Q:XRF']""  D
"RTN","HLDIE",132,0)
 .  D @("XRF"_XRF_U_ROUTINE)
"RTN","HLDIE",133,0)
 ;
"RTN","HLDIE",134,0)
 ; patch HL*1.6*122: MPI-client/server
"RTN","HLDIE",135,0)
 I FILE=773 L -^HLMA(IEN)
"RTN","HLDIE",136,0)
 E  L -^HL(772,IEN)
"RTN","HLDIE",137,0)
 ;
"RTN","HLDIE",138,0)
 Q
"RTN","HLDIE",139,0)
 ;
"RTN","HLDIE",140,0)
GETNODES(FILE,IEN,NODE) ; Load pre-change data for each node in 
"RTN","HLDIE",141,0)
 ; NODE(node,0), and load node to be changed in NODE(node,1).
"RTN","HLDIE",142,0)
 ; GBL -- req
"RTN","HLDIE",143,0)
 F NODE=0,1,2,"P","S" D
"RTN","HLDIE",144,0)
 .  ; After setting, NODE(NODE,0) will equal each other.
"RTN","HLDIE",145,0)
 .  ; However, after each edited field is processed, the pieces of
"RTN","HLDIE",146,0)
 .  ; data in NODE(NODE,1) will be changed.  The pre and post nodes
"RTN","HLDIE",147,0)
 .  ; then are of comparison value.
"RTN","HLDIE",148,0)
 .  S NODE(NODE,0)=$G(@GBL@(NODE)) ; Pre-change node
"RTN","HLDIE",149,0)
 .  S NODE(NODE,1)=NODE(NODE,0) ; Node that is changed
"RTN","HLDIE",150,0)
 Q
"RTN","HLDIE",151,0)
 ;
"RTN","HLDIE",152,0)
STORE(FILE,IEN,NODE) ; Store changes in file...
"RTN","HLDIE",153,0)
 N DATA,ND
"RTN","HLDIE",154,0)
 ;
"RTN","HLDIE",155,0)
 ; Loop thru change nodes, get changed data, and store it...
"RTN","HLDIE",156,0)
 S ND=""
"RTN","HLDIE",157,0)
 F  S ND=$O(NODE("CHG",ND)) Q:ND']""  D
"RTN","HLDIE",158,0)
 .  S DATA=$G(NODE(ND,1))
"RTN","HLDIE",159,0)
 .  ; Even if no data no node, store it.  (Will be removed by purge.)
"RTN","HLDIE",160,0)
 .  I FILE=772 S ^HL(772,+IEN,ND)=DATA
"RTN","HLDIE",161,0)
 .  I FILE=773 S ^HLMA(+IEN,ND)=DATA
"RTN","HLDIE",162,0)
 ;
"RTN","HLDIE",163,0)
 QUIT
"RTN","HLDIE",164,0)
 ;
"RTN","HLDIE",165,0)
GBL(FILE,IEN) QUIT $S(FILE=772:"^HL(772,"_+IEN_")",1:"^HLMA("_+IEN_")")
"RTN","HLDIE",166,0)
 ;
"RTN","HLDIE",167,0)
CHKFLD(FILE,FIELD) ; Does passed-in field exist?
"RTN","HLDIE",168,0)
 ; Returns -- @ERR@(...) ->
"RTN","HLDIE",169,0)
 ;
"RTN","HLDIE",170,0)
 ; Quit if field exists...
"RTN","HLDIE",171,0)
 QUIT:$D(^DD(+FILE,+FIELD)) 1 ;->
"RTN","HLDIE",172,0)
 ;
"RTN","HLDIE",173,0)
 ; Field doesn't exist.  Log error...
"RTN","HLDIE",174,0)
 S ERRNO=$$ERRNO(501,"File #"_FILE_" does not contain a field "_FIELD_".",FILE,3)
"RTN","HLDIE",175,0)
 S @ERR@("DIERR",+ERRNO,"PARAM",1)=FIELD
"RTN","HLDIE",176,0)
 S @ERR@("DIERR",+ERRNO,"PARAM","FIELD")=FIELD
"RTN","HLDIE",177,0)
 ;
"RTN","HLDIE",178,0)
 Q ""
"RTN","HLDIE",179,0)
 ;
"RTN","HLDIE",180,0)
ERRNO(NUM,TXT,FILE,PNO) ; Return next ERROR number and create general data...
"RTN","HLDIE",181,0)
 N NO
"RTN","HLDIE",182,0)
 S NO=$G(@ERR@("DIERR"))+1,@ERR@("DIERR")=+NO_U_+NO
"RTN","HLDIE",183,0)
 S @ERR@("DIERR",NO)=NUM
"RTN","HLDIE",184,0)
 S @ERR@("DIERR",NO,"PARAM",0)=PNO
"RTN","HLDIE",185,0)
 S @ERR@("DIERR",NO,"PARAM","FILE")=FILE
"RTN","HLDIE",186,0)
 S @ERR@("DIERR",NO,"TEXT",1)=TXT
"RTN","HLDIE",187,0)
 S @ERR@("DIERR","E",NUM,NO)=""
"RTN","HLDIE",188,0)
 Q NO
"RTN","HLDIE",189,0)
 ;
"RTN","HLDIE",190,0)
GENLERR(ETXT) ; Store GENERAL (and fatal) error...
"RTN","HLDIE",191,0)
 ; ERR -- req
"RTN","HLDIE",192,0)
 N NO
"RTN","HLDIE",193,0)
 S NO=$G(@ERR@("DIERR"))+1,@ERR@("DIERR")=+NO_U_+NO
"RTN","HLDIE",194,0)
 S @ERR@("DIERR",NO)=999_U_ETXT ; Made up error number
"RTN","HLDIE",195,0)
 Q
"RTN","HLDIE",196,0)
 ;
"RTN","HLDIE",197,0)
CHECKS() ; Check ROOT() for file and validity of data...
"RTN","HLDIE",198,0)
 ; FLAGS, ROOT() -- req --> FILE,IEN
"RTN","HLDIE",199,0)
 N I,OK,FIELD
"RTN","HLDIE",200,0)
 ;
"RTN","HLDIE",201,0)
 ;check the file & ien
"RTN","HLDIE",202,0)
 S FILE=$O(@ROOT@(0))
"RTN","HLDIE",203,0)
 I FILE'=772,FILE'=773 D  QUIT "" ;->
"RTN","HLDIE",204,0)
 .  S IEN=$S(FILE:$O(@ROOT@(FILE,0)),1:0) ; Set for debugging
"RTN","HLDIE",205,0)
 ;
"RTN","HLDIE",206,0)
 ; ;shouldn't be more than 1 file!
"RTN","HLDIE",207,0)
 QUIT:$O(@ROOT@(FILE)) "" ;->
"RTN","HLDIE",208,0)
 ;
"RTN","HLDIE",209,0)
 ;check the ien structure, and that only ien passed...
"RTN","HLDIE",210,0)
 S IEN=$O(@ROOT@(FILE,0))
"RTN","HLDIE",211,0)
 ; Structure check...
"RTN","HLDIE",212,0)
 QUIT:$P(IEN,",")'=+IEN_"," "" ;->
"RTN","HLDIE",213,0)
 ; Is it numeric?
"RTN","HLDIE",214,0)
 QUIT:'(+IEN) "" ;->
"RTN","HLDIE",215,0)
 ; Has more than one IEN been passed?
"RTN","HLDIE",216,0)
 QUIT:($O(@ROOT@(FILE,IEN))'="") "" ;->
"RTN","HLDIE",217,0)
 ;
"RTN","HLDIE",218,0)
 ;check the flags.  Only K and S flags allowed...
"RTN","HLDIE",219,0)
 I $L(FLAGS) D  QUIT:'OK "" ;->
"RTN","HLDIE",220,0)
 .  S OK=1
"RTN","HLDIE",221,0)
 .  F I=0:1:$L(FLAGS) I $E(FLAGS,I)'="K",$E(FLAGS,I)'="S" S OK=0
"RTN","HLDIE",222,0)
 ;
"RTN","HLDIE",223,0)
 ; Check for existence of FIELD in FILE's DD & if an excluded field.
"RTN","HLDIE",224,0)
 ; (See rules for fields which cannot be updated by FILE^HLDIE.)
"RTN","HLDIE",225,0)
 S FIELD=0,OK=1
"RTN","HLDIE",226,0)
 F  S FIELD=$O(@ROOT@(FILE,IEN,FIELD)) Q:FIELD=""  D  Q:'OK
"RTN","HLDIE",227,0)
 .  I '$$CHKFLD(FILE,FIELD) S OK=0 Q
"RTN","HLDIE",228,0)
 .  I FILE=773,FIELD\1=90 S OK=0 Q
"RTN","HLDIE",229,0)
 .  I FILE=773,FIELD\1=91 S OK=0 Q
"RTN","HLDIE",230,0)
 .  I FILE=772,FIELD=200 S OK=0 Q
"RTN","HLDIE",231,0)
 ;
"RTN","HLDIE",232,0)
 ; If not OK to use FILE^HLDIE, skip any further testing...
"RTN","HLDIE",233,0)
 QUIT:'OK "" ;->
"RTN","HLDIE",234,0)
 ;
"RTN","HLDIE",235,0)
 ;                    *** WARNING ***
"RTN","HLDIE",236,0)
 ; The following check **MUST** be removed after FILE^HLDIE is working.
"RTN","HLDIE",237,0)
 ;
"RTN","HLDIE",238,0)
 ; Final check for whether FILE^HLDIE should be used...
"RTN","HLDIE",239,0)
 I $G(^XTMP("HLDIE-DEBUG","CALL"))]"" QUIT "" ;->
"RTN","HLDIE",240,0)
 ; If this node exists and follows null, FILE^DIE will be used.
"RTN","HLDIE",241,0)
 ; Otherwise, execution defaults to using FILE^HLDIE.
"RTN","HLDIE",242,0)
 ;
"RTN","HLDIE",243,0)
 Q OK
"RTN","HLDIE",244,0)
 ;
"RTN","HLDIE",245,0)
BEGIN ; Always call here before any ^HLDIE or ^DIE calls...
"RTN","HLDIE",246,0)
 D DEBUG(1)
"RTN","HLDIE",247,0)
 Q
"RTN","HLDIE",248,0)
 ;
"RTN","HLDIE",249,0)
END ; Always call here after all ^HLDIE or ^DIE actions...
"RTN","HLDIE",250,0)
 D DEBUG(2)
"RTN","HLDIE",251,0)
 Q
"RTN","HLDIE",252,0)
 ;
"RTN","HLDIE",253,0)
DEBUG(LOC) ; Debug presets and setup...
"RTN","HLDIE",254,0)
 ; Most variables created here should be left around.  These variables
"RTN","HLDIE",255,0)
 ; are newed above.
"RTN","HLDIE",256,0)
 N STORE
"RTN","HLDIE",257,0)
 ;
"RTN","HLDIE",258,0)
 S RTN=$G(RTN),SUB=$G(SUB)
"RTN","HLDIE",259,0)
 ;
"RTN","HLDIE",260,0)
 ; First-time (beginning) call setups...
"RTN","HLDIE",261,0)
 I LOC=1 D
"RTN","HLDIE",262,0)
 .  S RTN=$S(RTN]"":RTN,1:"HLDIE")_"~"_$S(RTN="HLDIE":"FILE",1:SUB)
"RTN","HLDIE",263,0)
 .  S DEBUG=$G(^XTMP("HLDIE-DEBUG","STATUS"))
"RTN","HLDIE",264,0)
 .  S XECMCODE=$P(DEBUG,U,3)
"RTN","HLDIE",265,0)
 ; DEBUG is always called at beginning (LOC=1) and end (LOC=2) or
"RTN","HLDIE",266,0)
 ; FILE^HLDIE.  So, set up variables only once, at beginning...
"RTN","HLDIE",267,0)
 ;
"RTN","HLDIE",268,0)
 ; Setup that is individual to each (1 or 2) call...
"RTN","HLDIE",269,0)
 S STORE=$P(DEBUG,U,LOC),STORE=$S(STORE=1:1,STORE=2:2,1:"")
"RTN","HLDIE",270,0)
 ; Some, All, or no data stored?
"RTN","HLDIE",271,0)
 ;
"RTN","HLDIE",272,0)
 ; If no STORE instructions, and no M code to specify STORE, quit...
"RTN","HLDIE",273,0)
 QUIT:'STORE&($G(XECMCODE)'=1)  ;->
"RTN","HLDIE",274,0)
 ;
"RTN","HLDIE",275,0)
 ; Call DEBUG to STORE data...
"RTN","HLDIE",276,0)
 D DEBUG^HLDIEDBG(RTN,LOC,STORE,XECMCODE)
"RTN","HLDIE",277,0)
 ;
"RTN","HLDIE",278,0)
 Q
"RTN","HLDIE",279,0)
 ;
"RTN","HLDIE",280,0)
EOR ;HLDIE - Direct 772 & 773 Sets ; 11/18/2003 11:17
"RTN","HLMA")
0^10^B50301067^B41973628
"RTN","HLMA",1,0)
HLMA ;AISC/SAW-Message Administration Module ;10/24/2007  10:15
"RTN","HLMA",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**19,43,58,63,66,82,91,109,115,133,132,122**;Oct 13, 1995;Build 14
"RTN","HLMA",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLMA",4,0)
GENERATE(HLEID,HLARYTYP,HLFORMAT,HLRESLT,HLMTIEN,HLP) ;
"RTN","HLMA",5,0)
 ;Entry point to generate a deferred message
"RTN","HLMA",6,0)
 ;
"RTN","HLMA",7,0)
 ;This is a subroutine call with parameter passing.  It returns a
"RTN","HLMA",8,0)
 ;value in the variable HLRESLT with 1 to 3 pieces separated by uparrows
"RTN","HLMA",9,0)
 ;as follows:  1st message ID^error code^error description
"RTN","HLMA",10,0)
 ;If no error occurs, only the first piece is returned equal to a unique
"RTN","HLMA",11,0)
 ;ID for the 1st message.  If message was sent to more than 1 subscriber
"RTN","HLMA",12,0)
 ;than the other message IDs will be in the array HLRESLT(n)=ID
"RTN","HLMA",13,0)
 ;Otherwise, three pieces are returned with the
"RTN","HLMA",14,0)
 ;first piece equal to the message ID, if one was assigned, otherwise 0
"RTN","HLMA",15,0)
 ;
"RTN","HLMA",16,0)
 ;Required Input Parameters
"RTN","HLMA",17,0)
 ;     HLEID = Name or IEN of event driver protocol in the Protocol file
"RTN","HLMA",18,0)
 ;  HLARYTYP = Array type.  One of the following codes:
"RTN","HLMA",19,0)
 ;               LM = local array containing a single message
"RTN","HLMA",20,0)
 ;               LB = local array containig a batch of messages
"RTN","HLMA",21,0)
 ;               GM = global array containing a single message
"RTN","HLMA",22,0)
 ;               GB = global array containing a batch of messages
"RTN","HLMA",23,0)
 ;  HLFORMAT = Format of array, 1 for pre-formatted in HL7 format,
"RTN","HLMA",24,0)
 ;               otherwise 0
"RTN","HLMA",25,0)
 ;NOTE:  The parameter HLRESLT must be passed by reference
"RTN","HLMA",26,0)
 ;   HLRESLT = The variable that will be returned to the calling
"RTN","HLMA",27,0)
 ;               application as descibed above
"RTN","HLMA",28,0)
 ;Optional Parameters
"RTN","HLMA",29,0)
 ;   HLMTIEN = IEN of entry in Message Text file where the message
"RTN","HLMA",30,0)
 ;               being generated is to be stored.  This parameter is
"RTN","HLMA",31,0)
 ;               only passed for a batch type message
"RTN","HLMA",32,0)
 ;NOTE:  The parameter HLP used for the following parameters must be
"RTN","HLMA",33,0)
 ;       passed by reference
"RTN","HLMA",34,0)
 ;  HLP("SECURITY") = A 1 to 40 character string
"RTN","HLMA",35,0)
 ;   HLP("CONTPTR") = Continuation pointer, a 1 to 180 character string
"RTN","HLMA",36,0)
 ; HLP("NAMESPACE") = Passed in by application namespace - HL*1.6*91
"RTN","HLMA",37,0)
 ; HLP("EXCLUDE SUBSCRIBER",<n=1,2,3...>)=<subscriber protocol ien> or
"RTN","HLMA",38,0)
 ;   <subscriber protocol name> - A list of protocols to dynamically
"RTN","HLMA",39,0)
 ;   drop from the event protocol's subscriber multiple.
"RTN","HLMA",40,0)
 ;
"RTN","HLMA",41,0)
 ;can't have link open when generating new message
"RTN","HLMA",42,0)
 N HLTCP,HLTCPO,HLPRIO,HLMIDAR
"RTN","HLMA",43,0)
 S HLPRIO="D"
"RTN","HLMA",44,0)
 S HLRESLT=""
"RTN","HLMA",45,0)
 ;Check for required parameters
"RTN","HLMA",46,0)
CONT ;
"RTN","HLMA",47,0)
 I $G(HLEID)']""!($G(HLARYTYP)']"")!($G(HLFORMAT)']"") D  G EXIT
"RTN","HLMA",48,0)
 . S HLRESLT="0^7^"_$G(^HL(771.7,7,0))_" at GENERATE^HLMA entry point"
"RTN","HLMA",49,0)
 I 'HLEID S HLEID=$O(^ORD(101,"B",HLEID,0)) I 'HLEID S HLRESLT="0^1^"_$G(^HL(771.7,1,0)) G EXIT
"RTN","HLMA",50,0)
 N HLRESLT1,HLRESLTA S (HLRESLTA,HLRESLT1)=""
"RTN","HLMA",51,0)
 I "GL"'[$E(HLARYTYP) S HLRESLT="0^4^"_$G(^HL(771.7,4,0)) G EXIT
"RTN","HLMA",52,0)
 I $L($G(HLP("SECURITY")))>40 S HLRESLT="0^6^"_$G(^HL(771.7,6,0)) G EXIT
"RTN","HLMA",53,0)
 I $L($G(HLP("CONTPTR")))>180 S HLRESLT="0^11^"_$G(^HL(771.7,11,0)) G EXIT
"RTN","HLMA",54,0)
 I $D(HLL("LINKS")) D  G:$G(HLRESLT)]"" EXIT
"RTN","HLMA",55,0)
 . N I,HLPNAM,HLPIEN,HLLNAM,HLLIEN
"RTN","HLMA",56,0)
 . S I=0
"RTN","HLMA",57,0)
 . F  S I=$O(HLL("LINKS",I)) Q:'I  D  Q:$G(HLRESLT)]""
"RTN","HLMA",58,0)
 . . S HLPNAM=$P(HLL("LINKS",I),U)
"RTN","HLMA",59,0)
 . . S HLPIEN=+$O(^ORD(101,"B",HLPNAM,0))
"RTN","HLMA",60,0)
 . . I $P($G(^ORD(101,HLPIEN,0)),U,4)'="S" S HLRESLT="0^15^Invalid Subscriber Protocol in HLL('LINKS'): "_HLL("LINKS",I) Q
"RTN","HLMA",61,0)
 . . S HLLNAM=$P(HLL("LINKS",I),U,2)
"RTN","HLMA",62,0)
 . . S HLLIEN=+$O(^HLCS(870,"B",HLLNAM,0))
"RTN","HLMA",63,0)
 . . I '$D(^HLCS(870,HLLIEN,0)) S HLRESLT="0^15^Invalid HL Node in HLL('LINKS'): "_HLL("LINKS",I) Q
"RTN","HLMA",64,0)
 ;Extract data from Protocol file
"RTN","HLMA",65,0)
 D EVENT^HLUTIL1(HLEID,"15,20,771",.HLN)
"RTN","HLMA",66,0)
 S HLENROU=$G(HLN(20)),HLEXROU=$G(HLN(15))
"RTN","HLMA",67,0)
 S HLP("GROUTINE")=$G(HLN(771)) K HLN I HLP("GROUTINE")']"",'HLFORMAT S HLRESLT="0^3^"_$G(^HL(771.7,3,0)) G EXIT
"RTN","HLMA",68,0)
 ;Create message ID and Message Text IEN if Message Text IEN not
"RTN","HLMA",69,0)
 ;previously created ('$G(HLMTIEN))
"RTN","HLMA",70,0)
 I '$G(HLMTIEN) D CREATE^HLTF(.HLMID,.HLMTIEN,.HLDT,.HLDT1)
"RTN","HLMA",71,0)
 ;Get message ID if Message Text IEN already created
"RTN","HLMA",72,0)
 I '$G(HLMID) D
"RTN","HLMA",73,0)
 .S HLDT=$G(^HL(772,HLMTIEN,0)),HLMID=$P(HLDT,"^",6),HLDT=+HLDT
"RTN","HLMA",74,0)
 .S HLDT1=$$HLDATE^HLFNC(HLDT)
"RTN","HLMA",75,0)
 S HLMIDAR=0,HLRESLT=HLMID,HLP("DT")=HLDT,HLP("DTM")=HLDT1
"RTN","HLMA",76,0)
 ;Execute entry action for event driver protocol
"RTN","HLMA",77,0)
 I HLENROU]"" X HLENROU
"RTN","HLMA",78,0)
 ;Invoke transaction processor
"RTN","HLMA",79,0)
 K HLDT,HLDT1,HLENROU
"RTN","HLMA",80,0)
 D GENERATE^HLTP(HLMID,HLMTIEN,HLEID,HLARYTYP,HLFORMAT,.HLRESLT1,.HLP)
"RTN","HLMA",81,0)
 ;HLMIDAR is array of message IDs, only set for broadcast messages
"RTN","HLMA",82,0)
 I HLMIDAR K HLMIDAR("N") M HLRESLT=HLMIDAR
"RTN","HLMA",83,0)
 S HLRESLT=HLRESLT_"^"_HLRESLT1
"RTN","HLMA",84,0)
 ;
"RTN","HLMA",85,0)
 ; patch HL*1.6*122
"RTN","HLMA",86,0)
 S HLRESLT("HLMID")=$G(HLMIDAR("HLMID"))
"RTN","HLMA",87,0)
 S HLRESLT("IEN773")=$G(HLMIDAR("IEN773"))
"RTN","HLMA",88,0)
 ;
"RTN","HLMA",89,0)
 ;Execute exit action for event driver protocol
"RTN","HLMA",90,0)
 I HLEXROU]"" X HLEXROU
"RTN","HLMA",91,0)
EXIT ;Update status if Message Text file entry has been created
"RTN","HLMA",92,0)
 K HLTCP
"RTN","HLMA",93,0)
 I $D(HLMTIEN) D STATUS^HLTF0(HLMTIEN,$S($P(HLRESLT,"^",2):4,1:3),$S($P(HLRESLT,"^",2):$P(HLRESLT,"^",2),1:""),$S($P(HLRESLT,"^",2):$P(HLRESLT,"^",3),1:""))
"RTN","HLMA",94,0)
 K HLDT,HLDT1,HLMID,HLRESLT1,HLENROU,HLEXROU
"RTN","HLMA",95,0)
 Q
"RTN","HLMA",96,0)
DIRECT(HLEID,HLARYTYP,HLFORMAT,HLRESLT,HLMTIENO,HLP) ;
"RTN","HLMA",97,0)
 ;Entry point to generate an immediate message, must be TCP Logical Link
"RTN","HLMA",98,0)
 ;Input:
"RTN","HLMA",99,0)
 ;  The same as GENERATE,with one additional subscript to the HLP input 
"RTN","HLMA",100,0)
 ;  array:
"RTN","HLMA",101,0)
 ; 
"RTN","HLMA",102,0)
 ;  HLP("OPEN TIMEOUT") (optional, pass by reference) a number between 
"RTN","HLMA",103,0)
 ;    1 and 120 that specifies how many seconds the DIRECT CONNECT should
"RTN","HLMA",104,0)
 ;    try to open a connection before failing.  It is killed upon 
"RTN","HLMA",105,0)
 ;    completion.
"RTN","HLMA",106,0)
 ; 
"RTN","HLMA",107,0)
 N HLTCP,HLTCPO,HLPRIO,HLSAN,HLN,HLMIDAR,HLMTIENR,ZMID,HLDIRECT
"RTN","HLMA",108,0)
 S HLRESLT=""
"RTN","HLMA",109,0)
 ;HLMTIENO=ien passed in, batch message
"RTN","HLMA",110,0)
 S HLMTIEN=$G(HLMTIENO)
"RTN","HLMA",111,0)
 I $G(HLP("OPEN TIMEOUT")),((HLP("OPEN TIMEOUT")\1)'=+HLP("OPEN TIMEOUT"))!HLP("OPEN TIMEOUT")>120 Q "0^4^INVALID OPEN TIMEOUT PARAMETER"
"RTN","HLMA",112,0)
 I $G(HLP("OPEN TIMEOUT")) D
"RTN","HLMA",113,0)
 .S HLDIRECT("OPEN TIMEOUT")=HLP("OPEN TIMEOUT")
"RTN","HLMA",114,0)
 .K HLP("OPEN TIMEOUT")
"RTN","HLMA",115,0)
 K HL,HLMTIENO
"RTN","HLMA",116,0)
 D INIT^HLFNC2(HLEID,.HL)
"RTN","HLMA",117,0)
 I $G(HL) S HLRESLT="0^"_HL Q
"RTN","HLMA",118,0)
 S HLPRIO="I" D CONT
"RTN","HLMA",119,0)
 ;HLMTIENO=original msg. ien in file 772, HLMTIENR=response ien set in HLMA2
"RTN","HLMA",120,0)
 S HLMTIENO=HLMTIEN,HLMTIEN=$G(HLMTIENR)
"RTN","HLMA",121,0)
 ;Set special HL variables
"RTN","HLMA",122,0)
 S HLQUIT=0,HLNODE="",HLNEXT="D HLNEXT^HLCSUTL"
"RTN","HLMA",123,0)
 Q
"RTN","HLMA",124,0)
 ;
"RTN","HLMA",125,0)
CLOSE(LOGLINK) ;close connection that was open in tag DIRECT
"RTN","HLMA",126,0)
 Q
"RTN","HLMA",127,0)
PING ;ping another VAMC to test Link
"RTN","HLMA",128,0)
 ;set HLQUIET =1 to skip writes
"RTN","HLMA",129,0)
 ;look for HLTPUT to get turnaround time over network.
"RTN","HLMA",130,0)
 N DA,DIC,HLDP,HLDPNM,HLDPDM,HLCSOUT,HLDBSIZE,HLDREAD,HLOS,HLTCPADD,HLTCPCS,HLTCPLNK,HLTCPORT,HLTCPRET,HLCSFAIL,HLPARAM
"RTN","HLMA",131,0)
 N HCS,HCSCMD,HLCS,HCSDAT,HCSER,HCSEXIT,HCSTRACE,HLDT1,HLDRETR,HLRETRA,HLDBACK,HLDWAIT,HLTCPCS,INPUT,OUTPUT,POP,X,Y,HLX1,HLX2
"RTN","HLMA",132,0)
 S HLQUIET=$G(HLQUIET)
"RTN","HLMA",133,0)
 S HLCS="",HCSTRACE="C: ",POP=1,INPUT="INPUT",OUTPUT="OUTPUT"
"RTN","HLMA",134,0)
 S DIC="^HLCS(870,",DIC(0)="QEAMZ"
"RTN","HLMA",135,0)
 D ^DIC Q:Y<0
"RTN","HLMA",136,0)
 S HLDP=+Y,HLDPNM=Y(0,0),HLDPDM=$P($$PARAM^HLCS2,U,2)
"RTN","HLMA",137,0)
 ;I $P($G(^HLCS(870,HLDP,400)),U)="" W !,"Missing IP Address" Q
"RTN","HLMA",138,0)
 D SETUP^HLCSAC G:HLCS PINGQ
"RTN","HLMA",139,0)
 ; patch HL*1.6*122
"RTN","HLMA",140,0)
 G:$$DONTPING^HLMA4 PINGQ
"RTN","HLMA",141,0)
 ;PING header=MSH^PING^domain^PING^logical link^datetime
"RTN","HLMA",142,0)
 S INPUT(1)="MSH^PING^"_HLDPDM_"^PING^"_HLDPNM_"^"_$$HTE^XLFDT($H)
"RTN","HLMA",143,0)
 D OPEN^HLCSAC
"RTN","HLMA",144,0)
 I HLCS D DNS G:HLCS PINGQ
"RTN","HLMA",145,0)
 D
"RTN","HLMA",146,0)
 . N $ETRAP,$ESTACK S $ETRAP="D PINGERR^HLMA"
"RTN","HLMA",147,0)
 . ;non-standard HL7 header; start block,header,end block
"RTN","HLMA",148,0)
 . S HLX1=$H
"RTN","HLMA",149,0)
 . ;
"RTN","HLMA",150,0)
 . ; HL*1.6*122 start
"RTN","HLMA",151,0)
 . ; replace flush character '!' with @IOF (! or #)
"RTN","HLMA",152,0)
 . ; W $C(11)_INPUT(1)_$C(28)_$C(13),! ;HL*1.6*115, restored ! char
"RTN","HLMA",153,0)
 . W $C(11)_INPUT(1)_$C(28)_$C(13),@IOF
"RTN","HLMA",154,0)
 . ; HL*1.6*122 end
"RTN","HLMA",155,0)
 . ;
"RTN","HLMA",156,0)
 . ;read response
"RTN","HLMA",157,0)
 . R X:HLDREAD
"RTN","HLMA",158,0)
 . S HLX2=$H
"RTN","HLMA",159,0)
 . S X=$P(X,$C(28)),HLCS=$S(X=INPUT(1):"PING worked",X="":"No response",1:"Incorrect response")
"RTN","HLMA",160,0)
 . ;Get roundtrip time
"RTN","HLMA",161,0)
 . K HLTPUT I X]"" S HLTPUT=$$HDIFF^XLFDT(HLX2,HLX1,2)
"RTN","HLMA",162,0)
 D CLOSE^%ZISTCP
"RTN","HLMA",163,0)
PINGQ ;write back status and quit
"RTN","HLMA",164,0)
 I 'HLQUIET W !,HLCS,!
"RTN","HLMA",165,0)
 Q
"RTN","HLMA",166,0)
PINGERR ;process errors from PING
"RTN","HLMA",167,0)
 S $ETRAP="G UNWIND^%ZTER",HLCS="-1^Error"
"RTN","HLMA",168,0)
 ;I $ZE["READ" S HLCS="-1^Error during read"
"RTN","HLMA",169,0)
 ;I $ZE["WRITE" S HLCS="-1^Error during write"
"RTN","HLMA",170,0)
 ; HL*1.6*115, SACC compliance
"RTN","HLMA",171,0)
 I $$EC^%ZOSV["READ" S HLCS="-1^Error during read"
"RTN","HLMA",172,0)
 I $$EC^%ZOSV["WRITE" S HLCS="-1^Error during write"
"RTN","HLMA",173,0)
 G UNWIND^%ZTER
"RTN","HLMA",174,0)
DNS ;
"RTN","HLMA",175,0)
 ;openfail-try DNS lookup-Link must contain point to Domain Name
"RTN","HLMA",176,0)
 S POP=$G(POP)
"RTN","HLMA",177,0)
 S HLQUIET=$G(HLQUIET)
"RTN","HLMA",178,0)
 I 'HLQUIET W !,"Calling DNS"
"RTN","HLMA",179,0)
 N HLDOM,HLIP S HLCS=""
"RTN","HLMA",180,0)
 S HLDOM=$P(^HLCS(870,HLDP,0),U,7)
"RTN","HLMA",181,0)
 ; patch HL*1.6*122 start
"RTN","HLMA",182,0)
 S HLDOM("DNS")=$P($G(^HLCS(870,+$G(HLDP),0)),"^",8)
"RTN","HLMA",183,0)
 ; I 'HLDOM,'HLQUIET W !,"Domain Unknown" Q
"RTN","HLMA",184,0)
 I 'HLDOM,($L(HLDOM("DNS"),".")<3) D  Q
"RTN","HLMA",185,0)
 . I 'HLQUIET W !,"Domain Unknown"
"RTN","HLMA",186,0)
 . S HLCS="-1^Connection Fail"
"RTN","HLMA",187,0)
 ; patch HL*1.6*122 end
"RTN","HLMA",188,0)
 I HLDOM S HLDOM=$P(^DIC(4.2,HLDOM,0),U)
"RTN","HLMA",189,0)
 ; patch HL*1.6*122
"RTN","HLMA",190,0)
 ; I HLDOM]"" D  Q:'POP
"RTN","HLMA",191,0)
 I HLDOM]""!($L(HLDOM("DNS"),".")>2) D  Q:'POP
"RTN","HLMA",192,0)
 . I HLDOM["VA.GOV"&(HLDOM'[".MED.") S HLDOM=$P(HLDOM,".VA.GOV")_".MED.VA.GOV"
"RTN","HLMA",193,0)
 . I HLTCPORT=5000 S HLDOM="HL7."_HLDOM
"RTN","HLMA",194,0)
 . I HLTCPORT=5500 S HLDOM="MPI."_HLDOM
"RTN","HLMA",195,0)
 . ; patch HL*1.6*122
"RTN","HLMA",196,0)
 . I ($L(HLDOM("DNS"),".")>2) S HLDOM=HLDOM("DNS")
"RTN","HLMA",197,0)
 . I 'HLQUIET W !,"Domain, "_HLDOM
"RTN","HLMA",198,0)
 . I 'HLQUIET W !,"Port: ",HLTCPORT
"RTN","HLMA",199,0)
 . S HLIP=$$ADDRESS^XLFNSLK(HLDOM)
"RTN","HLMA",200,0)
 . I HLIP]"",'HLQUIET W !,"DNS Returned: ",HLIP
"RTN","HLMA",201,0)
 . I HLIP]"" D
"RTN","HLMA",202,0)
 . . ;If more than one IP returned, try each, cache successful open
"RTN","HLMA",203,0)
 . . N HLI,HLJ,HLIP1
"RTN","HLMA",204,0)
 . . F HLJ=1:1:$L(HLIP,",") D  Q:'POP
"RTN","HLMA",205,0)
 . . . S HLIP1=$P(HLIP,",",HLJ)
"RTN","HLMA",206,0)
 . . . F HLI=1:1:HLDRETR W:'HLQUIET !,"Trying ",HLIP1 D CALL^%ZISTCP(HLIP1,HLTCPORT,1) Q:'POP
"RTN","HLMA",207,0)
 . . . I 'POP S $P(^HLCS(870,HLDP,400),U)=HLIP1
"RTN","HLMA",208,0)
 . . . U IO
"RTN","HLMA",209,0)
 I POP S HLCS="-1^DNS Lookup Failed"
"RTN","HLMA4")
0^12^B23979433^n/a
"RTN","HLMA4",1,0)
HLMA4 ;OIFO-O/RJH-DON'T PING VIE ;03/29/2007  16:21
"RTN","HLMA4",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**122**;Oct 13, 1995;Build 14
"RTN","HLMA4",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLMA4",4,0)
 ;
"RTN","HLMA4",5,0)
 Q
"RTN","HLMA4",6,0)
DONTPING(PAR) ;
"RTN","HLMA4",7,0)
 ; check the data stored in file #869.3 related multiples to
"RTN","HLMA4",8,0)
 ; to see if ping is allowed for the Ping option, PING^HLMA
"RTN","HLMA4",9,0)
 ; return 1: don't ping this link.
"RTN","HLMA4",10,0)
 ; return 0: ok to ping the link.
"RTN","HLMA4",11,0)
 ;
"RTN","HLMA4",12,0)
 N ONE,LINE,PINGOK
"RTN","HLMA4",13,0)
 S HLQUIET=$G(HLQUIET)
"RTN","HLMA4",14,0)
 ;
"RTN","HLMA4",15,0)
 ; the only one entry in file #869.3
"RTN","HLMA4",16,0)
 S ONE=$O(^HLCS(869.3,0))
"RTN","HLMA4",17,0)
 ;
"RTN","HLMA4",18,0)
 D PINGIP
"RTN","HLMA4",19,0)
 Q:PINGOK 0
"RTN","HLMA4",20,0)
 ;
"RTN","HLMA4",21,0)
 D DONTPORT
"RTN","HLMA4",22,0)
 Q:'PINGOK 1
"RTN","HLMA4",23,0)
 ;
"RTN","HLMA4",24,0)
 D DONTDOMN
"RTN","HLMA4",25,0)
 Q:'PINGOK 1
"RTN","HLMA4",26,0)
 ;
"RTN","HLMA4",27,0)
 D DONTNAME
"RTN","HLMA4",28,0)
 Q:'PINGOK 1
"RTN","HLMA4",29,0)
 ;
"RTN","HLMA4",30,0)
 D DONTIP
"RTN","HLMA4",31,0)
 Q:'PINGOK 1
"RTN","HLMA4",32,0)
 ;
"RTN","HLMA4",33,0)
 D PINGDOMN
"RTN","HLMA4",34,0)
 Q:PINGOK 0
"RTN","HLMA4",35,0)
 ;
"RTN","HLMA4",36,0)
 I 'HLQUIET S HLCS="This link is not allowed to ping"
"RTN","HLMA4",37,0)
 Q 1
"RTN","HLMA4",38,0)
 ;
"RTN","HLMA4",39,0)
PINGIP ;
"RTN","HLMA4",40,0)
 ; retrieve the "Ping IP" multiple, which are ok to ping
"RTN","HLMA4",41,0)
 S PINGOK=0
"RTN","HLMA4",42,0)
 S LINE=0
"RTN","HLMA4",43,0)
 F  S LINE=$O(^HLCS(869.3,ONE,7,LINE)) Q:'LINE  D  Q:PINGOK
"RTN","HLMA4",44,0)
 . N DATAS,COUNT,DATA
"RTN","HLMA4",45,0)
 . S DATAS=$G(^HLCS(869.3,ONE,7,LINE,0))
"RTN","HLMA4",46,0)
 . S COUNT=$L(DATAS,",")
"RTN","HLMA4",47,0)
 . F I=1:1:COUNT D  Q:PINGOK
"RTN","HLMA4",48,0)
 .. S DATA=$P(DATAS,",",I),DATA=$TR(DATA," ","")
"RTN","HLMA4",49,0)
 .. I DATA=HLTCPADD S PINGOK=1
"RTN","HLMA4",50,0)
 Q
"RTN","HLMA4",51,0)
 ;
"RTN","HLMA4",52,0)
DONTPORT ;
"RTN","HLMA4",53,0)
 ; retrieve the "Don't Ping Port" multiple, which are not
"RTN","HLMA4",54,0)
 ; allowed to ping
"RTN","HLMA4",55,0)
 S PINGOK=1
"RTN","HLMA4",56,0)
 S LINE=0
"RTN","HLMA4",57,0)
 F  S LINE=$O(^HLCS(869.3,ONE,9,LINE)) Q:'LINE  D  Q:'PINGOK
"RTN","HLMA4",58,0)
 . N DATAS,COUNT,DATA
"RTN","HLMA4",59,0)
 . S DATAS=$G(^HLCS(869.3,ONE,9,LINE,0))
"RTN","HLMA4",60,0)
 . S COUNT=$L(DATAS,",")
"RTN","HLMA4",61,0)
 . F I=1:1:COUNT D  Q:'PINGOK
"RTN","HLMA4",62,0)
 .. S DATA=$P(DATAS,",",I),DATA=$TR(DATA," ","")
"RTN","HLMA4",63,0)
 .. I DATA=HLTCPORT D
"RTN","HLMA4",64,0)
 ... S PINGOK=0
"RTN","HLMA4",65,0)
 ... I 'HLQUIET D
"RTN","HLMA4",66,0)
 .... S HLCS="This link with 'PORT' as '"_HLTCPORT
"RTN","HLMA4",67,0)
 .... S HLCS=HLCS_"' is not allowed to ping"
"RTN","HLMA4",68,0)
 Q
"RTN","HLMA4",69,0)
 ;
"RTN","HLMA4",70,0)
DONTDOMN ;
"RTN","HLMA4",71,0)
 ; retrieve the "Don't Ping Domain (Full)" multiple,
"RTN","HLMA4",72,0)
 ; which are not allowed to ping
"RTN","HLMA4",73,0)
 ;
"RTN","HLMA4",74,0)
 N HLDOM
"RTN","HLMA4",75,0)
 S PINGOK=1
"RTN","HLMA4",76,0)
 S HLDOM=$P(^HLCS(870,HLDP,0),U,7)
"RTN","HLMA4",77,0)
 S HLDOM("DNS")=$P($G(^HLCS(870,+$G(HLDP),0)),"^",8)
"RTN","HLMA4",78,0)
 I 'HLDOM,($L(HLDOM("DNS"),".")<3) Q
"RTN","HLMA4",79,0)
 ;
"RTN","HLMA4",80,0)
 I HLDOM S HLDOM=$P(^DIC(4.2,HLDOM,0),U)
"RTN","HLMA4",81,0)
 ;
"RTN","HLMA4",82,0)
 S LINE=0
"RTN","HLMA4",83,0)
 F  S LINE=$O(^HLCS(869.3,ONE,12,LINE)) Q:'LINE  D  Q:'PINGOK
"RTN","HLMA4",84,0)
 . N DATAS,COUNT,DATA,DNSDOMN,MAILDOMN
"RTN","HLMA4",85,0)
 . S DATAS=$G(^HLCS(869.3,ONE,12,LINE,0))
"RTN","HLMA4",86,0)
 . S COUNT=$L(DATAS,",")
"RTN","HLMA4",87,0)
 . F I=1:1:COUNT D  Q:'PINGOK
"RTN","HLMA4",88,0)
 .. S DATA=$P(DATAS,",",I),DATA=$TR(DATA," ","")
"RTN","HLMA4",89,0)
 .. ; set PINGOK to 0 if domain is not allowed to ping
"RTN","HLMA4",90,0)
 .. I ($L(HLDOM("DNS"),".")>2),HLDOM("DNS")=DATA D  Q
"RTN","HLMA4",91,0)
 ... D SETHLCS(HLDOM("DNS"),"DNS DOMAIN")
"RTN","HLMA4",92,0)
 .. I $L(HLDOM)>5,HLDOM=DATA D
"RTN","HLMA4",93,0)
 ... D SETHLCS(HLDOM,"MAILMAN DOMAIN")
"RTN","HLMA4",94,0)
 Q
"RTN","HLMA4",95,0)
 ;
"RTN","HLMA4",96,0)
SETHLCS(DATA,TYPE) ;
"RTN","HLMA4",97,0)
 ; to be called from sub-routine DONTDOMN
"RTN","HLMA4",98,0)
 S PINGOK=0
"RTN","HLMA4",99,0)
 I 'HLQUIET D
"RTN","HLMA4",100,0)
 . S HLCS="This link with '"_TYPE_"' as '"_DATA
"RTN","HLMA4",101,0)
 . S HLCS=HLCS_"' is not allowed to ping"
"RTN","HLMA4",102,0)
 Q
"RTN","HLMA4",103,0)
 ;
"RTN","HLMA4",104,0)
DONTNAME ;
"RTN","HLMA4",105,0)
 ; retrieve the "Don't Ping Link Name (Partial)" multiple,
"RTN","HLMA4",106,0)
 ; which are not allowed to ping
"RTN","HLMA4",107,0)
 ;
"RTN","HLMA4",108,0)
 N LINKNAME
"RTN","HLMA4",109,0)
 S PINGOK=1
"RTN","HLMA4",110,0)
 ;
"RTN","HLMA4",111,0)
 S LINKNAME=$P(^HLCS(870,HLDP,0),U,1)
"RTN","HLMA4",112,0)
 ;
"RTN","HLMA4",113,0)
 S LINE=0
"RTN","HLMA4",114,0)
 F  S LINE=$O(^HLCS(869.3,ONE,10,LINE)) Q:'LINE  D  Q:'PINGOK
"RTN","HLMA4",115,0)
 . N DATAS,COUNT,DATA
"RTN","HLMA4",116,0)
 . S DATAS=$G(^HLCS(869.3,ONE,10,LINE,0))
"RTN","HLMA4",117,0)
 . S COUNT=$L(DATAS,",")
"RTN","HLMA4",118,0)
 . F I=1:1:COUNT D  Q:'PINGOK
"RTN","HLMA4",119,0)
 .. S DATA=$P(DATAS,",",I),DATA=$TR(DATA," ","")
"RTN","HLMA4",120,0)
 .. I LINKNAME[DATA D
"RTN","HLMA4",121,0)
 ... S PINGOK=0
"RTN","HLMA4",122,0)
 ... I 'HLQUIET D
"RTN","HLMA4",123,0)
 .... S HLCS="This link 'NAME' containing name-stub"
"RTN","HLMA4",124,0)
 .... S HLCS=HLCS_" '"_DATA_"' is not allowed to ping"
"RTN","HLMA4",125,0)
 Q
"RTN","HLMA4",126,0)
 ;
"RTN","HLMA4",127,0)
DONTIP ;
"RTN","HLMA4",128,0)
 ; retrieve the "Don't Ping IP" multiple, which are not 
"RTN","HLMA4",129,0)
 ; allowed to ping
"RTN","HLMA4",130,0)
 ;
"RTN","HLMA4",131,0)
 S PINGOK=1
"RTN","HLMA4",132,0)
 ;
"RTN","HLMA4",133,0)
 S LINE=0
"RTN","HLMA4",134,0)
 F  S LINE=$O(^HLCS(869.3,ONE,11,LINE)) Q:'LINE  D  Q:'PINGOK
"RTN","HLMA4",135,0)
 . N DATAS,COUNT,DATA
"RTN","HLMA4",136,0)
 . S DATAS=$G(^HLCS(869.3,ONE,11,LINE,0))
"RTN","HLMA4",137,0)
 . S COUNT=$L(DATAS,",")
"RTN","HLMA4",138,0)
 . F I=1:1:COUNT D  Q:'PINGOK
"RTN","HLMA4",139,0)
 .. S DATA=$P(DATAS,",",I),DATA=$TR(DATA," ","")
"RTN","HLMA4",140,0)
 .. I DATA=HLTCPADD D
"RTN","HLMA4",141,0)
 ... S PINGOK=0
"RTN","HLMA4",142,0)
 ... I 'HLQUIET D
"RTN","HLMA4",143,0)
 .... S HLCS="This link with 'IP' as '"_HLTCPADD
"RTN","HLMA4",144,0)
 .... S HLCS=HLCS_"' is not allowed to ping"
"RTN","HLMA4",145,0)
 Q
"RTN","HLMA4",146,0)
 ;
"RTN","HLMA4",147,0)
PINGDOMN ;
"RTN","HLMA4",148,0)
 ; retrieve the "Ping Domain (Partial)" multiple,
"RTN","HLMA4",149,0)
 ; which is ok to ping, data could be partial domain.
"RTN","HLMA4",150,0)
 ;
"RTN","HLMA4",151,0)
 N HLDOM
"RTN","HLMA4",152,0)
 S PINGOK=0
"RTN","HLMA4",153,0)
 ;
"RTN","HLMA4",154,0)
 S HLDOM=$P(^HLCS(870,HLDP,0),U,7)
"RTN","HLMA4",155,0)
 S HLDOM("DNS")=$P($G(^HLCS(870,+$G(HLDP),0)),"^",8)
"RTN","HLMA4",156,0)
 I 'HLDOM,($L(HLDOM("DNS"),".")<3) Q
"RTN","HLMA4",157,0)
 ;
"RTN","HLMA4",158,0)
 I HLDOM S HLDOM=$P(^DIC(4.2,HLDOM,0),U)
"RTN","HLMA4",159,0)
 ;
"RTN","HLMA4",160,0)
 S LINE=0
"RTN","HLMA4",161,0)
 F  S LINE=$O(^HLCS(869.3,ONE,8,LINE)) Q:'LINE  D  Q:PINGOK
"RTN","HLMA4",162,0)
 . N DATAS,COUNT,DATA,DNSDOMN,MAILDOMN
"RTN","HLMA4",163,0)
 . S DATAS=$G(^HLCS(869.3,ONE,8,LINE,0))
"RTN","HLMA4",164,0)
 . S COUNT=$L(DATAS,",")
"RTN","HLMA4",165,0)
 . F I=1:1:COUNT D  Q:PINGOK
"RTN","HLMA4",166,0)
 .. S DATA=$P(DATAS,",",I),DATA=$TR(DATA," ","")
"RTN","HLMA4",167,0)
 .. ; set PINGOK to 1 if domain is allowed to ping
"RTN","HLMA4",168,0)
 .. I ($L(HLDOM("DNS"),".")>2),HLDOM("DNS")[DATA S PINGOK=1 Q
"RTN","HLMA4",169,0)
 .. I $L(HLDOM)>5,HLDOM[DATA S PINGOK=1
"RTN","HLMA4",170,0)
 Q
"RTN","HLMA4",171,0)
 ;
"RTN","HLPAT122")
0^^B4294969^n/a
"RTN","HLPAT122",1,0)
HLPAT122 ;OIFO-OAKLAND/RJH - HL7 PATCH 122 PRE-INIT ;12/14/2007  13:18
"RTN","HLPAT122",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**122**;Oct 13, 1995;Build 14
"RTN","HLPAT122",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLPAT122",4,0)
 ;
"RTN","HLPAT122",5,0)
 Q
"RTN","HLPAT122",6,0)
PRE ;
"RTN","HLPAT122",7,0)
 ; remove HL7 Proxy user, "HLSEVEN,APPLICATION PROXY" : TEST v2
"RTN","HLPAT122",8,0)
 ;
"RTN","HLPAT122",9,0)
 ; create application proxy users for listeners and incoming filer
"RTN","HLPAT122",10,0)
 ; N HLTEMP
"RTN","HLPAT122",11,0)
 ; S HLTEMP=$$CREATE^XUSAP("HLSEVEN,APPLICATION PROXY","#")
"RTN","HLPAT122",12,0)
 ;
"RTN","HLPAT122",13,0)
 ; for Patch HL*1.6*122 TEST v5: remove the code, which is used to
"RTN","HLPAT122",14,0)
 ; delete the entry, "HLSEVEN,APPLICATION PROXY" in file #200, the
"RTN","HLPAT122",15,0)
 ; deletion has caused the problem to the IB at the testing sites.
"RTN","HLPAT122",16,0)
 ; N DIK,DA
"RTN","HLPAT122",17,0)
 ;
"RTN","HLPAT122",18,0)
 ; S DIK="^VA(200,"
"RTN","HLPAT122",19,0)
 ; S DA=$O(^VA(200,"B","HLSEVEN,APPLICATION PROXY",0))
"RTN","HLPAT122",20,0)
 ; I DA D ^DIK
"RTN","HLPAT122",21,0)
 Q
"RTN","HLPAT122",22,0)
POST ;
"RTN","HLPAT122",23,0)
 D POST1
"RTN","HLPAT122",24,0)
 D POST2
"RTN","HLPAT122",25,0)
 Q
"RTN","HLPAT122",26,0)
 ;
"RTN","HLPAT122",27,0)
POST1 ;
"RTN","HLPAT122",28,0)
 ; insert data for multiple fields: #8, #9, #10, #11, and #12.
"RTN","HLPAT122",29,0)
 N DATA,DA
"RTN","HLPAT122",30,0)
 ;
"RTN","HLPAT122",31,0)
 S DA=$O(^HLCS(869.3,0))
"RTN","HLPAT122",32,0)
 Q:'DA
"RTN","HLPAT122",33,0)
 Q:'$D(^DD(869.3,70))
"RTN","HLPAT122",34,0)
 Q:'$D(^DD(869.3,80))
"RTN","HLPAT122",35,0)
 Q:'$D(^DD(869.3,90))
"RTN","HLPAT122",36,0)
 Q:'$D(^DD(869.3,91))
"RTN","HLPAT122",37,0)
 Q:'$D(^DD(869.3,92))
"RTN","HLPAT122",38,0)
 Q:'$D(^DD(869.3,93))
"RTN","HLPAT122",39,0)
 S DATA(1,8,0)="^869.35^1^1"
"RTN","HLPAT122",40,0)
 S DATA(1,8,1,0)="MED.VA.GOV"
"RTN","HLPAT122",41,0)
 ;
"RTN","HLPAT122",42,0)
 S DATA(1,9,0)="^869.36^4^4"
"RTN","HLPAT122",43,0)
 S DATA(1,9,1,0)="8090, 5561"
"RTN","HLPAT122",44,0)
 S DATA(1,9,2,0)="9059, 9060, 27315, 27316"
"RTN","HLPAT122",45,0)
 S DATA(1,9,3,0)="7010, 1583"
"RTN","HLPAT122",46,0)
 S DATA(1,9,4,0)="8080"
"RTN","HLPAT122",47,0)
 ;
"RTN","HLPAT122",48,0)
 S DATA(1,10,0)="^869.391^3^3"
"RTN","HLPAT122",49,0)
 S DATA(1,10,1,0)="VAHDR, VAFHIE, VA-VIE"
"RTN","HLPAT122",50,0)
 S DATA(1,10,2,0)="VHAAAC, VAHTH"
"RTN","HLPAT122",51,0)
 S DATA(1,10,3,0)="VDEF"
"RTN","HLPAT122",52,0)
 ;
"RTN","HLPAT122",53,0)
 S DATA(1,11,0)="^869.392^2^2"
"RTN","HLPAT122",54,0)
 S DATA(1,11,1,0)="10.224.129.80"
"RTN","HLPAT122",55,0)
 S DATA(1,11,2,0)="10.224.132.23, 10.224.132.28, 10.224.151.133, 10.224.151.153"
"RTN","HLPAT122",56,0)
 ;
"RTN","HLPAT122",57,0)
 S DATA(1,12,0)="^869.393^1^1"
"RTN","HLPAT122",58,0)
 S DATA(1,12,1,0)="HDR.MED.VA.GOV, FHIE.MED.VA.GOV"
"RTN","HLPAT122",59,0)
 ;
"RTN","HLPAT122",60,0)
 M ^HLCS(869.3,DA)=DATA(1)
"RTN","HLPAT122",61,0)
 ; re-index
"RTN","HLPAT122",62,0)
 S DIK="^HLCS(869.3,"
"RTN","HLPAT122",63,0)
 D IX^DIK
"RTN","HLPAT122",64,0)
 ;
"RTN","HLPAT122",65,0)
 ; kill the original "C" x-ref in file #773 and #772
"RTN","HLPAT122",66,0)
 K ^DD(773,2,1,1)
"RTN","HLPAT122",67,0)
 K ^DD(772,6,1,1)
"RTN","HLPAT122",68,0)
 Q
"RTN","HLPAT122",69,0)
 ;
"RTN","HLPAT122",70,0)
POST2 ;
"RTN","HLPAT122",71,0)
 ; clear and set the counter of multi-listener, with port not equal to 5500,
"RTN","HLPAT122",72,0)
 ; to "0 server"
"RTN","HLPAT122",73,0)
 N HLDP,HLIEN
"RTN","HLPAT122",74,0)
 S HLDP=0
"RTN","HLPAT122",75,0)
 F  S HLDP=$O(^HLCS(870,"E","M",HLDP)) Q:'HLDP  D
"RTN","HLPAT122",76,0)
 . ; if port number = 5500 quit
"RTN","HLPAT122",77,0)
 . I $P(^HLCS(870,HLDP,400),"^",2)=5500 Q
"RTN","HLPAT122",78,0)
 . D CLRMCNTR^HLCSTCP4
"RTN","HLPAT122",79,0)
 . S HLIEN=HLDP
"RTN","HLPAT122",80,0)
 . F X="IN","OUT" D CLRQUET^HLUTIL2(X)
"RTN","HLPAT122",81,0)
 Q
"RTN","HLPAT122",82,0)
 ;
"RTN","HLTF")
0^32^B22809391^B49703549
"RTN","HLTF",1,0)
HLTF ;AISC/SAW,JRP-Create/Process Message Text File Entries ;10/17/2007  09:41
"RTN","HLTF",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**1,19,43,55,109,120,122**;Oct 13, 1995;Build 14
"RTN","HLTF",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLTF",4,0)
 ;
"RTN","HLTF",5,0)
 Q
"RTN","HLTF",6,0)
 ;
"RTN","HLTF",7,0)
FILE ;Create Entries in files 772 and 773 for Version 1.5 Interface Only
"RTN","HLTF",8,0)
 D CREATE(,.HLDA,.HLDT,.HLDT1)
"RTN","HLTF",9,0)
 Q
"RTN","HLTF",10,0)
CREATE(HLMID,MTIEN,HLDT,HLDT1) ;Create entries in Message Text (#772)
"RTN","HLTF",11,0)
 ;
"RTN","HLTF",12,0)
 ;Input  : HLMID = Variable in which value of message ID will be
"RTN","HLTF",13,0)
 ;                 returned (pass by reference)
"RTN","HLTF",14,0)
 ;         MTIEN = Variable in which IEN of Message Text file entry
"RTN","HLTF",15,0)
 ;                 will be returned (pass by reference)
"RTN","HLTF",16,0)
 ;         HLDT = Variable in which current date/time in FM internal
"RTN","HLTF",17,0)
 ;                format will be returned (pass by reference)
"RTN","HLTF",18,0)
 ;         HLDT1 = Variable in which current date/time in HL7 format
"RTN","HLTF",19,0)
 ;                 will be returned (pass by reference)
"RTN","HLTF",20,0)
 ;
"RTN","HLTF",21,0)
 ;Output : See above
"RTN","HLTF",22,0)
 ;
"RTN","HLTF",23,0)
 ;Notes  : If HLDT has a value [upon entry], the created entries will
"RTN","HLTF",24,0)
 ;         be given that value for their date/time (value of .01)
"RTN","HLTF",25,0)
 ;       : Current date/time used if HLDT is not passed or invalid
"RTN","HLTF",26,0)
 ;
"RTN","HLTF",27,0)
 ;Make entry in Message Administration file
"RTN","HLTF",28,0)
 N Y
"RTN","HLTF",29,0)
 S HLDT=$G(HLDT)
"RTN","HLTF",30,0)
 D MT(.HLDT)
"RTN","HLTF",31,0)
 S Y=$$CHNGMID(MTIEN,.HLMID),HLDT1=$$HLDATE^HLFNC(HLDT)
"RTN","HLTF",32,0)
 Q
"RTN","HLTF",33,0)
TCP(HLMID,MTIEN,HLDT) ;create new message in 772 & 773 entries
"RTN","HLTF",34,0)
 ;used for incoming messages and outgoing responses
"RTN","HLTF",35,0)
 ;Input  : HLMID = Variable in which value of message ID will be
"RTN","HLTF",36,0)
 ;                 returned (pass by reference)
"RTN","HLTF",37,0)
 ;         MTIEN = Variable in which IEN of file 773 entry
"RTN","HLTF",38,0)
 ;                 will be returned (pass by reference)
"RTN","HLTF",39,0)
 ;         HLDT = Variable in which current date/time in FM internal
"RTN","HLTF",40,0)
 ;                format will be returned (pass by reference)
"RTN","HLTF",41,0)
 ;
"RTN","HLTF",42,0)
 S HLDT=$G(HLDT),HLMID=$G(HLMID)
"RTN","HLTF",43,0)
 D MT(.HLDT)
"RTN","HLTF",44,0)
 S MTIEN=$$MA(MTIEN,.HLMID)
"RTN","HLTF",45,0)
 Q
"RTN","HLTF",46,0)
 ;
"RTN","HLTF",47,0)
MT(HLX) ;Create entry in Message Text file (#772)
"RTN","HLTF",48,0)
 ;
"RTN","HLTF",49,0)
 ;Input  : HLX = Date/time entry in file should be given (value of .01)
"RTN","HLTF",50,0)
 ;               Defaults to current date/time
"RTN","HLTF",51,0)
 ;
"RTN","HLTF",52,0)
 ;Output : HLDT = Date/time of created entry (value of .01)
"RTN","HLTF",53,0)
 ;       : HLDT1 = HLDT in HL7 format
"RTN","HLTF",54,0)
 ;
"RTN","HLTF",55,0)
 ;Notes  : HLX must be in FileMan format (default value used if not)
"RTN","HLTF",56,0)
 ;       : HLDT will be in FileMan format
"RTN","HLTF",57,0)
 ;       : MTIEN is ien in file 772
"RTN","HLTF",58,0)
 ;
"RTN","HLTF",59,0)
 ;Check for input
"RTN","HLTF",60,0)
 S HLX=$G(HLX)
"RTN","HLTF",61,0)
 ;Declare variables
"RTN","HLTF",62,0)
 N DIC,DD,DO,HLCNT,HLJ,X,Y
"RTN","HLTF",63,0)
 F HLCNT=0:1 D  Q:Y>0  H HLCNT
"RTN","HLTF",64,0)
 . I (HLX'?7N.1".".6N) S HLX=$$NOW^XLFDT
"RTN","HLTF",65,0)
 . S DIC="^HL(772,",DIC(0)="L",(HLDT,X)=HLX
"RTN","HLTF",66,0)
 . S Y=$$STUB772(X) ; This call substituted for D FILE^DICN by HL*1.6*109
"RTN","HLTF",67,0)
 . ;Entry not created - try again
"RTN","HLTF",68,0)
 . I Y<0 S HLX="" Q
"RTN","HLTF",69,0)
 . S MTIEN=+Y
"RTN","HLTF",70,0)
 ;***If we didn't get a record in 772, need to do something
"RTN","HLTF",71,0)
 I Y<0 Q
"RTN","HLTF",72,0)
 S HLDT1=$$HLDATE^HLFNC(HLDT)
"RTN","HLTF",73,0)
 Q
"RTN","HLTF",74,0)
 ;add to Message Admin file #773
"RTN","HLTF",75,0)
MA(X,HLMID) ;X=ien in file 772, HLMID=msg. id (passed by ref.)
"RTN","HLTF",76,0)
 ;return ien in file 773
"RTN","HLTF",77,0)
 ;
"RTN","HLTF",78,0)
 ; patch HL*1.6*122: MPI-client/server start
"RTN","HLTF",79,0)
 F  L +^HL(772,+$G(X)):10 Q:$T  H 1
"RTN","HLTF",80,0)
 Q:'$G(^HL(772,X,0)) 0
"RTN","HLTF",81,0)
 L -^HL(772,+$G(X))
"RTN","HLTF",82,0)
 ; patch HL*1.6*122: MPI-client/server end
"RTN","HLTF",83,0)
 ;
"RTN","HLTF",84,0)
 N DA,DD,DO,DIC,DIE,DR,HLDA,HLCNT,HLJ,Y
"RTN","HLTF",85,0)
 S DIC="^HLMA(",DIC(0)="L"
"RTN","HLTF",86,0)
 F HLCNT=0:1 D  Q:Y>0  H HLCNT
"RTN","HLTF",87,0)
 . S Y=$$STUB773(X) ; This call substituted for D FILE^DICN by HL*1.6*109
"RTN","HLTF",88,0)
 ;***If we didn't get a record in 773, need to do something
"RTN","HLTF",89,0)
 I Y<0 Q 0
"RTN","HLTF",90,0)
 S HLDA=+Y,HLMID=$$MAID(HLDA,$G(HLMID))
"RTN","HLTF",91,0)
 Q HLDA
"RTN","HLTF",92,0)
 ;
"RTN","HLTF",93,0)
MAID(Y,HLMID) ;Determine message ID (if needed) & store message ID
"RTN","HLTF",94,0)
 ;Y=ien in 773, HLMID=id,  Output message id
"RTN","HLTF",95,0)
 N HLJ
"RTN","HLTF",96,0)
 ;need to have id contain institution number to make unique
"RTN","HLTF",97,0)
 S:$G(HLMID)="" HLMID=+$P($$PARAM^HLCS2,U,6)_Y
"RTN","HLTF",98,0)
 S HLJ(773,Y_",",2)=HLMID
"RTN","HLTF",99,0)
 D FILE^HLDIE("","HLJ","","MAID","HLTF") ;HL*1.6*109
"RTN","HLTF",100,0)
 Q HLMID
"RTN","HLTF",101,0)
 ;
"RTN","HLTF",102,0)
CHNGMID(PTRMT,NEWID) ;Change message ID for entry in Message Text file
"RTN","HLTF",103,0)
 ;Input  : PTRMT - Pointer to entry in Message Text file (#772)
"RTN","HLTF",104,0)
 ;         NEWID - New message ID
"RTN","HLTF",105,0)
 ;Output : 0 = Success
"RTN","HLTF",106,0)
 ;         -1^ErrorText = Error/Bad input
"RTN","HLTF",107,0)
 ;
"RTN","HLTF",108,0)
 ;Check input
"RTN","HLTF",109,0)
 S PTRMT=+$G(PTRMT)
"RTN","HLTF",110,0)
 S NEWID=$G(NEWID)
"RTN","HLTF",111,0)
 Q:('$D(^HL(772,PTRMT,0))) "-1^Did not pass valid pointer to Message Text file (#772)"
"RTN","HLTF",112,0)
 N HLJ
"RTN","HLTF",113,0)
 I $G(NEWID)="" S NEWID=+$P($$PARAM^HLCS2,U,6)_PTRMT
"RTN","HLTF",114,0)
 S HLJ(772,PTRMT_",",6)=NEWID
"RTN","HLTF",115,0)
 D FILE^HLDIE("","HLJ","","CHNGMID","HLTF") ; HL*1.6*109
"RTN","HLTF",116,0)
 Q 0
"RTN","HLTF",117,0)
 ;
"RTN","HLTF",118,0)
OUT(HLDA,HLMID,HLMTN) ;File Data in Message Text File for Outgoing Message
"RTN","HLTF",119,0)
 ;Version 1.5 Interface Only
"RTN","HLTF",120,0)
 ;
"RTN","HLTF",121,0)
 ; patch HL*1.6*122: HLTF routine splitted, moves sub-routines,
"RTN","HLTF",122,0)
 ; OUT, IN, and ACK to HLTF2 routine.
"RTN","HLTF",123,0)
 ;
"RTN","HLTF",124,0)
 D OUT^HLTF2($G(HLDA),$G(HLMID),$G(HLMTN))
"RTN","HLTF",125,0)
 Q
"RTN","HLTF",126,0)
 ;
"RTN","HLTF",127,0)
IN(HLMTN,HLMID,HLTIME) ;File Data in Message Text File for Incoming Message
"RTN","HLTF",128,0)
 ;Version 1.5 Interface Only
"RTN","HLTF",129,0)
 ;
"RTN","HLTF",130,0)
 ; patch HL*1.6*122: HLTF routine splitted, moves sub-routines,
"RTN","HLTF",131,0)
 ; OUT, IN, and ACK to HLTF2 routine.
"RTN","HLTF",132,0)
 ;
"RTN","HLTF",133,0)
 D IN^HLTF2($G(HLMTN),$G(HLMID),$G(HLTIME))
"RTN","HLTF",134,0)
 Q
"RTN","HLTF",135,0)
 ;
"RTN","HLTF",136,0)
ACK(HLMSA,HLIO,HLDA) ;Process 'ACK' Message Type - Version 1.5 Interface Only
"RTN","HLTF",137,0)
 ;
"RTN","HLTF",138,0)
 ; patch HL*1.6*122: HLTF routine splitted, moves sub-routines,
"RTN","HLTF",139,0)
 ; OUT, IN, and ACK to HLTF2 routine.
"RTN","HLTF",140,0)
 ;
"RTN","HLTF",141,0)
 D ACK^HLTF2($G(HLMSA),$G(HLIO),$G(HLDA))
"RTN","HLTF",142,0)
 Q
"RTN","HLTF",143,0)
 ;
"RTN","HLTF",144,0)
STUB772(FLD01,OS) ;
"RTN","HLTF",145,0)
 ;This function creates a new stub record in file 772. The Stub record may consist of only the 0 node with a value of "^". If a value is passed in for the .01 field it will be included in the 0 node and its "B" x-ref set.
"RTN","HLTF",146,0)
 ;Inputs:
"RTN","HLTF",147,0)
 ;  OS (optional), the value of ^%ZOSF("OS")
"RTN","HLTF",148,0)
 ;  FLD01 (optional), the value for the .01 field
"RTN","HLTF",149,0)
 ;Output - the function returns the ien of the newly created record
"RTN","HLTF",150,0)
 ;
"RTN","HLTF",151,0)
 N IEN
"RTN","HLTF",152,0)
 I '$L($G(OS)) N OS S OS=$G(^%ZOSF("OS"))
"RTN","HLTF",153,0)
 ;
"RTN","HLTF",154,0)
 I OS'["DSM",OS'["OpenM" D
"RTN","HLTF",155,0)
 .F  L +^HLCS(869.3,1,772):10 S IEN=+$G(^HLCS(869.3,1,772))+1,^HLCS(869.3,1,772)=IEN S:$D(^HL(772,IEN)) IEN=0,^HLCS(869.3,1,772)=($O(^HL(772,":"),-1)\1) L -^HLCS(869.3,1,772) Q:IEN
"RTN","HLTF",156,0)
 E  D
"RTN","HLTF",157,0)
 .F  S IEN=$I(^HLCS(869.3,1,772),1) S:$D(^HL(772,IEN)) IEN=0,^HLCS(869.3,1,772)=($O(^HL(772,":"),-1)\1) Q:IEN
"RTN","HLTF",158,0)
 ;
"RTN","HLTF",159,0)
 ; patch HL*1.6*122: MPI-client/server start
"RTN","HLTF",160,0)
 F  L +^HL(772,IEN):10 Q:$T  H 1
"RTN","HLTF",161,0)
 S ^HL(772,IEN,0)=$G(FLD01)_"^"
"RTN","HLTF",162,0)
 I $L($G(FLD01)) S ^HL(772,"B",FLD01,IEN)=""
"RTN","HLTF",163,0)
 L -^HL(772,IEN)
"RTN","HLTF",164,0)
 ; patch HL*1.6*122: MPI-client/server end
"RTN","HLTF",165,0)
 ;
"RTN","HLTF",166,0)
 Q IEN
"RTN","HLTF",167,0)
 ;
"RTN","HLTF",168,0)
STUB773(FLD01,OS) ;
"RTN","HLTF",169,0)
 ;This function creates a new stub record in file 772. The Stub record may consist of only the 0 node with a value of "^". If a value is passed in for the .01 field it will be included in the 0 node and its "B" x-ref set.
"RTN","HLTF",170,0)
 ;Inputs:
"RTN","HLTF",171,0)
 ;  OS (optional), the value of ^%ZOSF("OS")
"RTN","HLTF",172,0)
 ;  FLD01 (optional), the value for the .01 field
"RTN","HLTF",173,0)
 ;Output - the function returns the ien of the newly created record
"RTN","HLTF",174,0)
 ;
"RTN","HLTF",175,0)
 N IEN
"RTN","HLTF",176,0)
 I '$L($G(OS)) N OS S OS=$G(^%ZOSF("OS"))
"RTN","HLTF",177,0)
 ;
"RTN","HLTF",178,0)
 I OS'["DSM",OS'["OpenM" D
"RTN","HLTF",179,0)
 .F  L +^HLCS(869.3,1,773):10 S IEN=+$G(^HLCS(869.3,1,773))+1,^HLCS(869.3,1,773)=IEN S:$D(^HLMA(IEN)) IEN=0,^HLCS(869.3,1,773)=($O(^HLMA(":"),-1)\1) L -^HLCS(869.3,1,773) Q:IEN
"RTN","HLTF",180,0)
 E  D
"RTN","HLTF",181,0)
 .F  S IEN=$I(^HLCS(869.3,1,773),1) S:$D(^HLMA(IEN)) IEN=0,^HLCS(869.3,1,773)=($O(^HLMA(":"),-1)\1) Q:IEN
"RTN","HLTF",182,0)
 ;
"RTN","HLTF",183,0)
 ; patch HL*1.6*122: MPI-client/server
"RTN","HLTF",184,0)
 F  L +^HLMA(IEN):10 Q:$T  H 1
"RTN","HLTF",185,0)
 S ^HLMA(IEN,0)=$G(FLD01)_"^"
"RTN","HLTF",186,0)
 I $L($G(FLD01)) S ^HLMA("B",FLD01,IEN)=""
"RTN","HLTF",187,0)
 L -^HLMA(IEN)
"RTN","HLTF",188,0)
 ;
"RTN","HLTF",189,0)
 Q IEN
"RTN","HLTF1")
0^33^B25518513^B24283055
"RTN","HLTF1",1,0)
HLTF1 ;AISC/SAW/MTC-Process Message Text File Entries (Cont'd) ;10/17/2007  09:43
"RTN","HLTF1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**5,8,22,25,19,78,122**;Oct 13, 1995;Build 14
"RTN","HLTF1",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLTF1",4,0)
 ;
"RTN","HLTF1",5,0)
MERGE15(ARAYTYPE,MTIEN,SUB1,SUB2) ;Merge Local/Global Array From Application into
"RTN","HLTF1",6,0)
 ;Message Text File
"RTN","HLTF1",7,0)
 ;
"RTN","HLTF1",8,0)
 ;This is a routine call with parameter passing.  There are no output
"RTN","HLTF1",9,0)
 ;parameters returned by this call.
"RTN","HLTF1",10,0)
 ;
"RTN","HLTF1",11,0)
 ;**  Merges incoming data for v1.5 applications only **
"RTN","HLTF1",12,0)
 ;
"RTN","HLTF1",13,0)
 ;Required input parameters
"RTN","HLTF1",14,0)
 ;   MTIEN = The IEN from the Message Text file of the entry to be
"RTN","HLTF1",15,0)
 ;             updated
"RTN","HLTF1",16,0)
 ;  ARAYTYPE = Array type, G for global or L for local
"RTN","HLTF1",17,0)
 ;      SUB1 = The first level subscript of the array.  Must be
"RTN","HLTF1",18,0)
 ;               either HLS or HLA
"RTN","HLTF1",19,0)
 ;Optional input parameter
"RTN","HLTF1",20,0)
 ;      SUB2 = A second subscript associated with the array
"RTN","HLTF1",21,0)
 ;
"RTN","HLTF1",22,0)
 ;Check for required parameters
"RTN","HLTF1",23,0)
 I "GL"'[$G(ARAYTYPE)!($G(SUB1)']"")!('$G(MTIEN)) G MRGE15X
"RTN","HLTF1",24,0)
 ;
"RTN","HLTF1",25,0)
 N HLCHAR,HLEVN,HLFS,I,X,X1,X2,X3 S (HLCHAR,HLEVN,X)=0
"RTN","HLTF1",26,0)
 ;
"RTN","HLTF1",27,0)
 ;Merge data from a global array with two subscript
"RTN","HLTF1",28,0)
 I ARAYTYPE="G",$G(SUB2)'="" D
"RTN","HLTF1",29,0)
 . S X="",I=0
"RTN","HLTF1",30,0)
 . F  S X=$O(^TMP(SUB1,$J,SUB2,X)) Q:'X  S I=I+1,X1=^TMP(SUB1,$J,SUB2,X),HLCHAR=HLCHAR+$L(X1) S:$E(X1,1,3)="MSH" HLFS=$E(X1,4),$P(X1,HLFS,8)="",HLEVN=HLEVN+1 S ^HL(772,MTIEN,"IN",I,0)=X1
"RTN","HLTF1",31,0)
 ;
"RTN","HLTF1",32,0)
 ;Merge data from a global array with one subscripts
"RTN","HLTF1",33,0)
 I ARAYTYPE="G",$G(SUB2)="" D
"RTN","HLTF1",34,0)
 . S X="",I=0
"RTN","HLTF1",35,0)
 . F  S X=$O(^TMP(SUB1,$J,X)) Q:'X  S I=I+1,X1=^TMP(SUB1,$J,X),HLCHAR=HLCHAR+$L(X1) S:$E(X1,1,3)="MSH" HLFS=$E(X1,4),$P(X1,HLFS,8)="",HLEVN=HLEVN+1 S ^HL(772,MTIEN,"IN",I,0)=X1
"RTN","HLTF1",36,0)
 ;
"RTN","HLTF1",37,0)
 ;Merge data from a local array with one subscript
"RTN","HLTF1",38,0)
 I ARAYTYPE="L" D
"RTN","HLTF1",39,0)
 . S X="",I=0
"RTN","HLTF1",40,0)
 . F  S X=$O(HLA(SUB1,X)) Q:'X  S I=I+1,X1=HLA(SUB1,X),HLCHAR=HLCHAR+$L(X1) S:$E(X1,1,3)="MSH" HLFS=$E(X1,4),$P(X1,HLFS,8)="",HLEVN=HLEVN+1 S ^HL(772,MTIEN,"IN",I,0)=X1
"RTN","HLTF1",41,0)
 ;
"RTN","HLTF1",42,0)
 ;-- update 0 node for message text
"RTN","HLTF1",43,0)
 S ^HL(772,MTIEN,"IN",0)="^^"_I_"^"_I_"^"_$$DT^XLFDT_"^"
"RTN","HLTF1",44,0)
 ;
"RTN","HLTF1",45,0)
 ;File message statistics
"RTN","HLTF1",46,0)
 D STATS^HLTF0(MTIEN,HLCHAR,HLEVN)
"RTN","HLTF1",47,0)
 ;
"RTN","HLTF1",48,0)
MRGE15X ;-- exit merge 
"RTN","HLTF1",49,0)
 Q
"RTN","HLTF1",50,0)
 ;
"RTN","HLTF1",51,0)
MERGE(ARAYTYPE,MTIEN,SUB1,SUB2) ;Merge Local/Global Array From Application into
"RTN","HLTF1",52,0)
 ;Message Text File
"RTN","HLTF1",53,0)
 ;
"RTN","HLTF1",54,0)
 ;This is a routine call with parameter passing.  There are no output
"RTN","HLTF1",55,0)
 ;parameters returned by this call.
"RTN","HLTF1",56,0)
 ;
"RTN","HLTF1",57,0)
 ;Required input parameters
"RTN","HLTF1",58,0)
 ;   MTIEN = The IEN from the Message Text file of the entry to be
"RTN","HLTF1",59,0)
 ;             updated
"RTN","HLTF1",60,0)
 ;  ARAYTYPE = Array type, G for global or L for local
"RTN","HLTF1",61,0)
 ;      SUB1 = The first level subscript of the array.  Must be
"RTN","HLTF1",62,0)
 ;               either HLS or HLA
"RTN","HLTF1",63,0)
 ;Optional input parameter
"RTN","HLTF1",64,0)
 ;      SUB2 = A second subscript associated with the array
"RTN","HLTF1",65,0)
 ;
"RTN","HLTF1",66,0)
 ;Check for required parameters
"RTN","HLTF1",67,0)
 I "GL"'[$G(ARAYTYPE)!($G(SUB1)']"")!('$G(MTIEN)) G MERGEX
"RTN","HLTF1",68,0)
 ;
"RTN","HLTF1",69,0)
 N HLCHAR,HLEVN,HLFS,I,X,X1,X2,X3 S (HLCHAR,HLEVN,X)=0
"RTN","HLTF1",70,0)
 ;
"RTN","HLTF1",71,0)
 ; patch HL*1.6*122: MPI-client/server
"RTN","HLTF1",72,0)
 F  L +^HL(772,+$G(MTIEN)):10 Q:$T  H 1
"RTN","HLTF1",73,0)
 ;
"RTN","HLTF1",74,0)
 ;Merge data from a global array with two subscript
"RTN","HLTF1",75,0)
 I ARAYTYPE="G",$G(SUB2)'="" D
"RTN","HLTF1",76,0)
 . S X="",I=0
"RTN","HLTF1",77,0)
 . F  S X=$O(^TMP(SUB1,$J,SUB2,X)) Q:'X  S I=I+1,X1=^TMP(SUB1,$J,SUB2,X),HLCHAR=HLCHAR+$L(X1) S:$E(X1,1,3)="MSH" HLFS=$E(X1,4),$P(X1,HLFS,8)="",HLEVN=HLEVN+1 S ^HL(772,MTIEN,"IN",I,0)=X1,X2=$D(^TMP(SUB1,$J,SUB2,X)) D
"RTN","HLTF1",78,0)
 .. I X2=11 S X3="" F  S X3=$O(^TMP(SUB1,$J,SUB2,X,X3)) Q:'X3  D
"RTN","HLTF1",79,0)
 ... S I=I+1,X1=$G(^TMP(SUB1,$J,SUB2,X,X3)),HLCHAR=HLCHAR+$L(X1),^HL(772,MTIEN,"IN",I,0)=X1
"RTN","HLTF1",80,0)
 .. S I=I+1,^HL(772,MTIEN,"IN",I,0)="" Q
"RTN","HLTF1",81,0)
 ;
"RTN","HLTF1",82,0)
 ;Merge data from a global array with one subscripts
"RTN","HLTF1",83,0)
 I ARAYTYPE="G",$G(SUB2)="" D
"RTN","HLTF1",84,0)
 . S X="",I=0
"RTN","HLTF1",85,0)
 . F  S X=$O(^TMP(SUB1,$J,X)) Q:'X  S I=I+1,X1=^TMP(SUB1,$J,X),HLCHAR=HLCHAR+$L(X1) S:$E(X1,1,3)="MSH" HLFS=$E(X1,4),$P(X1,HLFS,8)="",HLEVN=HLEVN+1 S ^HL(772,MTIEN,"IN",I,0)=X1,X2=$D(^TMP(SUB1,$J,X)) D
"RTN","HLTF1",86,0)
 .. I X2=11 S X3="" F  S X3=$O(^TMP(SUB1,$J,X,X3)) Q:'X3  D
"RTN","HLTF1",87,0)
 ... S I=I+1,X1=$G(^TMP(SUB1,$J,X,X3)),HLCHAR=HLCHAR+$L(X1),^HL(772,MTIEN,"IN",I,0)=X1
"RTN","HLTF1",88,0)
 .. S I=I+1,^HL(772,MTIEN,"IN",I,0)="" Q
"RTN","HLTF1",89,0)
 ;
"RTN","HLTF1",90,0)
 ;Merge data from a local array with one subscript
"RTN","HLTF1",91,0)
 I ARAYTYPE="L" D
"RTN","HLTF1",92,0)
 . S X="",I=0
"RTN","HLTF1",93,0)
 . F  S X=$O(HLA(SUB1,X)) Q:'X  S I=I+1,X1=HLA(SUB1,X),HLCHAR=HLCHAR+$L(X1) S:$E(X1,1,3)="MSH" HLFS=$E(X1,4),$P(X1,HLFS,8)="",HLEVN=HLEVN+1 S ^HL(772,MTIEN,"IN",I,0)=X1,X2=$D(HLA(SUB1,X)) D
"RTN","HLTF1",94,0)
 .. I X2=11 S X3="" F  S X3=$O(HLA(SUB1,X,X3)) Q:'X3  D
"RTN","HLTF1",95,0)
 ... S I=I+1,X1=$G(HLA(SUB1,X,X3)),HLCHAR=HLCHAR+$L(X1),^HL(772,MTIEN,"IN",I,0)=X1
"RTN","HLTF1",96,0)
 .. S I=I+1,^HL(772,MTIEN,"IN",I,0)="" Q
"RTN","HLTF1",97,0)
 ;
"RTN","HLTF1",98,0)
 S:HLEVN=0 HLEVN=1
"RTN","HLTF1",99,0)
 ;X=ien in file 773 for TCP messages
"RTN","HLTF1",100,0)
 S X=+$O(^HLMA("B",MTIEN,0))
"RTN","HLTF1",101,0)
 ;batch message type
"RTN","HLTF1",102,0)
 I X,$P($G(^HLMA(X,0)),U,5)="B" D BTS
"RTN","HLTF1",103,0)
 I 'X,$P(^HL(772,MTIEN,0),U,8),$P(^HL(772,$P(^(0),U,8),0),U,14)="B" D BTS
"RTN","HLTF1",104,0)
 ;
"RTN","HLTF1",105,0)
 ;-- update 0 node for message text
"RTN","HLTF1",106,0)
 S ^HL(772,MTIEN,"IN",0)="^^"_I_"^"_I_"^"_$$DT^XLFDT_"^"
"RTN","HLTF1",107,0)
 ;
"RTN","HLTF1",108,0)
 ; patch HL*1.6*122: MPI-client/server
"RTN","HLTF1",109,0)
 L -^HL(772,+$G(MTIEN))
"RTN","HLTF1",110,0)
 ;
"RTN","HLTF1",111,0)
 ;File message statistics
"RTN","HLTF1",112,0)
 D STATS^HLTF0(MTIEN,HLCHAR,HLEVN)
"RTN","HLTF1",113,0)
 ;
"RTN","HLTF1",114,0)
MERGEX ;-- exit merge 
"RTN","HLTF1",115,0)
 Q
"RTN","HLTF1",116,0)
 ;
"RTN","HLTF1",117,0)
BTS ; create batch trailer seg (BTS)
"RTN","HLTF1",118,0)
 ;HL*1.6*78 to obtain and insert FIELD SEPARATOR, HLFS
"RTN","HLTF1",119,0)
 N HLFS,HLSAN
"RTN","HLTF1",120,0)
 S HLFS=$G(HL("FS")) ; obtain from HL array
"RTN","HLTF1",121,0)
 ; or obtain from sending application; default to "^"
"RTN","HLTF1",122,0)
 I HLFS="" D  S:HLFS="" HLFS="^"
"RTN","HLTF1",123,0)
 . S HLSAN=$P($G(^HL(772,MTIEN,0)),U,2)
"RTN","HLTF1",124,0)
 . S:HLSAN HLFS=$G(^HL(771,HLSAN,"FS"))
"RTN","HLTF1",125,0)
 S I=I+1,^HL(772,MTIEN,"IN",I,0)="BTS"_HLFS_HLEVN,I=I+1,^HL(772,MTIEN,"IN",I,0)=""
"RTN","HLTF1",126,0)
 Q
"RTN","HLTF1",127,0)
 ;
"RTN","HLTF1",128,0)
MRGINT(MTOUT,MTIN,HDR) ;Merge Internal to Internal Message from the
"RTN","HLTF1",129,0)
 ; Outbound message in 772 (MTOUT) to an Inbound entry (MTIN). The process
"RTN","HLTF1",130,0)
 ; will involve Moving the Header and Text into 772.
"RTN","HLTF1",131,0)
 ;
"RTN","HLTF1",132,0)
 ;Required input parameters
"RTN","HLTF1",133,0)
 ;  MTOUT= Internal entry number of the Outbound message
"RTN","HLTF1",134,0)
 ;  MTIN = Internal entry number of the Inbound  message
"RTN","HLTF1",135,0)
 ;  HDR  = Name of the array that contains HL7 Header segment
"RTN","HLTF1",136,0)
 ;         format: HLHDR - Used with indirection to build message in out
"RTN","HLTF1",137,0)
 ;                         queue
"RTN","HLTF1",138,0)
 ;  This routine will first take the header information in the array
"RTN","HLTF1",139,0)
 ;  specified by HDR and merge into the Message Text field of file 870.
"RTN","HLTF1",140,0)
 ;  Then it will move the message contained in 772 (MTIEN) into 870.
"RTN","HLTF1",141,0)
 ;
"RTN","HLTF1",142,0)
 ;Check for required parameters
"RTN","HLTF1",143,0)
 I '$G(MTOUT)!('$G(MTIN))!(HDR="") Q
"RTN","HLTF1",144,0)
 ;
"RTN","HLTF1",145,0)
 ;-- initilize 
"RTN","HLTF1",146,0)
 N I,X
"RTN","HLTF1",147,0)
 S I=0
"RTN","HLTF1",148,0)
 ;
"RTN","HLTF1",149,0)
 ;-- move header into 772 from HDR array
"RTN","HLTF1",150,0)
 S X="" F  S X=$O(@HDR@(X)) Q:'X  D
"RTN","HLTF1",151,0)
 . S I=I+1,^HL(772,MTIN,"IN",I,0)=@HDR@(X)
"RTN","HLTF1",152,0)
 S I=I+1,^HL(772,MTIN,"IN",I,0)=""
"RTN","HLTF1",153,0)
 ;
"RTN","HLTF1",154,0)
 ;Move data from Message Text (MTOUT) file TO Message Text 772 (MTIN)
"RTN","HLTF1",155,0)
 S X=0 F  S X=$O(^HL(772,MTOUT,"IN",X)) Q:X=""  S I=I+1 D
"RTN","HLTF1",156,0)
 . S ^HL(772,MTIN,"IN",I,0)=$G(^HL(772,MTOUT,"IN",X,0))
"RTN","HLTF1",157,0)
 ;
"RTN","HLTF1",158,0)
 ;-- update 0 node of message and format arrays
"RTN","HLTF1",159,0)
 S ^HL(772,MTIN,"IN",0)="^^"_I_"^"_I_"^"_$$DT^XLFDT_"^"
"RTN","HLTF1",160,0)
 ;
"RTN","HLTF1",161,0)
 Q
"RTN","HLTF2")
0^34^B40999444^B9975068
"RTN","HLTF2",1,0)
HLTF2 ;AISC/SAW/MTC-Process Message Text File Entries (Cont'd) ;10/17/2007  09:44
"RTN","HLTF2",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**25,122**;Oct 13, 1995;Build 14
"RTN","HLTF2",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLTF2",4,0)
 ;
"RTN","HLTF2",5,0)
MERGEIN(LLD0,LLD1,MTIEN,HDR,MSA) ;Merge Data From Communication Server
"RTN","HLTF2",6,0)
 ;Module Logical Link File into Message Text File
"RTN","HLTF2",7,0)
 ;
"RTN","HLTF2",8,0)
 ;This is a subroutine call with parameter passing.  The output
"RTN","HLTF2",9,0)
 ;parameters HDR (and optionally) MSA are returned by this call.
"RTN","HLTF2",10,0)
 ;
"RTN","HLTF2",11,0)
 ;Required input parameters
"RTN","HLTF2",12,0)
 ;  LLD0 = Internal entry number where message is stored in Logical Link
"RTN","HLTF2",13,0)
 ;            file or XM if message is stored in MailMan
"RTN","HLTF2",14,0)
 ;  LLD1 = Internal entry number of IN QUEUE multiple entry in Logical
"RTN","HLTF2",15,0)
 ;           Link file (Only required for messages stored in Logical
"RTN","HLTF2",16,0)
 ;           Link file)
"RTN","HLTF2",17,0)
 ;  MTIEN = Internal entry number where message is to be copied to in
"RTN","HLTF2",18,0)
 ;            Message Text file
"RTN","HLTF2",19,0)
 ;    HDR = The variable in which the message header segment will
"RTN","HLTF2",20,0)
 ;            be returned
"RTN","HLTF2",21,0)
 ;    MSA = The variable in which the message acknowledgement segment
"RTN","HLTF2",22,0)
 ;            will be returned, if one exists for this message
"RTN","HLTF2",23,0)
 ;
"RTN","HLTF2",24,0)
 ;Check for required parameters
"RTN","HLTF2",25,0)
 I $G(LLD0)']""!('$G(MTIEN)) Q
"RTN","HLTF2",26,0)
 I LLD0'="XM",'$G(LLD1) Q
"RTN","HLTF2",27,0)
 N FLG,HLCHAR,HLEVN,HLFS,I,X,X1,HLDONE
"RTN","HLTF2",28,0)
 S (FLG,HLCHAR,HLEVN,X)=0
"RTN","HLTF2",29,0)
 ;
"RTN","HLTF2",30,0)
 ; patch HL*1.6*122: MPI-client/server
"RTN","HLTF2",31,0)
 F  L +^HL(772,+$G(MTIEN)):10 Q:$T  H 1
"RTN","HLTF2",32,0)
 ;
"RTN","HLTF2",33,0)
 ;Move data from Logical Link file to Message Text file
"RTN","HLTF2",34,0)
 I LLD0'="XM" D
"RTN","HLTF2",35,0)
 .S I=0 F  S X=$O(^HLCS(870,LLD0,1,LLD1,1,X)) Q:X'>0  S X1=$G(^(X,0)) S:"FHS,BHS,MSH"[$E(X1,1,3) FLG=1 I FLG S HLCHAR=HLCHAR+$L(X1) D
"RTN","HLTF2",36,0)
 ..;If header segment, process it and set HDR equal to it
"RTN","HLTF2",37,0)
 ..I X1'="","FHS,BHS,MSH"[$E(X1,1,3) D
"RTN","HLTF2",38,0)
 ...I '$D(HDR) S HDR=X1,HLFS=$E(X1,4) I $E(HDR,1,3)="BHS" S MSA="MSA"_HLFS_$P($P(HDR,HLFS,10),$E(HDR,5),1)_HLFS_$P(HDR,HLFS,12)_HLFS_$P($P(HDR,HLFS,10),$E(HDR,5),2)
"RTN","HLTF2",39,0)
 ...S $P(X1,HLFS,8)=""
"RTN","HLTF2",40,0)
 ...S:$E(X1,1,3)="MSH" HLEVN=HLEVN+1
"RTN","HLTF2",41,0)
 ..;If acknowledgement segment, set MSA equal to it
"RTN","HLTF2",42,0)
 ..I $E(X1,1,3)="MSA",'$D(MSA),$E($G(HDR),1,3)="MSH" S MSA=X1
"RTN","HLTF2",43,0)
 ..S I=I+1,^HL(772,MTIEN,"IN",I,0)=X1
"RTN","HLTF2",44,0)
 ;
"RTN","HLTF2",45,0)
 ;Move data from MailMan Message file to Message Text file
"RTN","HLTF2",46,0)
 I LLD0="XM" D
"RTN","HLTF2",47,0)
 .S I=0 F  X XMREC Q:XMER<0  S:"FHS,BHS,MSH"[$E(XMRG,1,3) FLG=1 I FLG S HLCHAR=HLCHAR+$L(XMRG) D  Q:XMER<0
"RTN","HLTF2",48,0)
 ..;If header segment, process it and set HDR equal to it
"RTN","HLTF2",49,0)
 ..I XMRG'="","FHS,BHS,MSH"[$E(XMRG,1,3) D
"RTN","HLTF2",50,0)
 ...I '$D(HDR) S HDR=XMRG,HLFS=$E(XMRG,4) I $E(HDR,1,3)="BHS" S MSA="MSA"_HLFS_$P($P(HDR,HLFS,10),$E(HDR,5),1)_HLFS_$P(HDR,HLFS,12)_HLFS_$P($P(HDR,HLFS,10),$E(HDR,5),2)
"RTN","HLTF2",51,0)
 ...S $P(XMRG,HLFS,8)=""
"RTN","HLTF2",52,0)
 ...S:$E(XMRG,1,3)="MSH" HLEVN=HLEVN+1
"RTN","HLTF2",53,0)
 ..;If acknowledgement segment, set MSA equal to it
"RTN","HLTF2",54,0)
 ..I $E(XMRG,1,3)="MSA",'$D(MSA),$E($G(HDR),1,3)="MSH" S MSA=XMRG
"RTN","HLTF2",55,0)
 ..S I=I+1,^HL(772,MTIEN,"IN",I,0)=XMRG
"RTN","HLTF2",56,0)
 S ^HL(772,MTIEN,"IN",0)="^^"_I_"^"_I_"^"_$$DT^XLFDT_"^"
"RTN","HLTF2",57,0)
 ;Update statistics in Message Text file for this entry
"RTN","HLTF2",58,0)
 ;
"RTN","HLTF2",59,0)
 ; patch HL*1.6*122: MPI-client/server
"RTN","HLTF2",60,0)
 L -^HL(772,+$G(MTIEN))
"RTN","HLTF2",61,0)
 ;
"RTN","HLTF2",62,0)
 D STATS^HLTF0(MTIEN,HLCHAR,HLEVN)
"RTN","HLTF2",63,0)
 Q
"RTN","HLTF2",64,0)
MERGEOUT(MTIEN,LLD0,LLD1,HDR) ;Merge Text in Message Text File into
"RTN","HLTF2",65,0)
 ;Communication Server Module Logical Link File
"RTN","HLTF2",66,0)
 ;
"RTN","HLTF2",67,0)
 ;This is a routine call with parameter passing.  There are no output
"RTN","HLTF2",68,0)
 ;parameters returned by this call.
"RTN","HLTF2",69,0)
 ;
"RTN","HLTF2",70,0)
 ;Required input parameters
"RTN","HLTF2",71,0)
 ;  MTIEN = Internal entry number where message is stored in Message
"RTN","HLTF2",72,0)
 ;            Text file
"RTN","HLTF2",73,0)
 ;  LLD0 = Internal entry number where message is to be copied to in
"RTN","HLTF2",74,0)
 ;            Logical Link file
"RTN","HLTF2",75,0)
 ;  LLD1 = Internal entry number of IN QUEUE multiple entry in Logical
"RTN","HLTF2",76,0)
 ;          Link file
"RTN","HLTF2",77,0)
 ;  HDR  = Name of the array that contains HL7 Header segment
"RTN","HLTF2",78,0)
 ;         format: HLHDR - Used with indirection to build message in out
"RTN","HLTF2",79,0)
 ;                         queue
"RTN","HLTF2",80,0)
 ;  This routine will first take the header information in the array
"RTN","HLTF2",81,0)
 ;  specified by HDR and merge into the Message Text field of file 870.
"RTN","HLTF2",82,0)
 ;  Then it will move the message contained in 772 (MTIEN) into 870.
"RTN","HLTF2",83,0)
 ;
"RTN","HLTF2",84,0)
 ;Check for required parameters
"RTN","HLTF2",85,0)
 I '$G(MTIEN)!('$G(LLD0))!('$G(LLD1))!(HDR="") Q
"RTN","HLTF2",86,0)
 ;
"RTN","HLTF2",87,0)
 ;-- initilize 
"RTN","HLTF2",88,0)
 N I,X
"RTN","HLTF2",89,0)
 S I=0
"RTN","HLTF2",90,0)
 ;
"RTN","HLTF2",91,0)
 ; patch HL*1.6*122: MPI-client/server
"RTN","HLTF2",92,0)
 F  L +^HLCS(870,+$G(LLD0),2,+$G(LLD1)):10 Q:$T  H 1
"RTN","HLTF2",93,0)
 ;
"RTN","HLTF2",94,0)
 ;-- move header into 870 from HDR array
"RTN","HLTF2",95,0)
 S X="" F  S X=$O(@HDR@(X)) Q:'X  D
"RTN","HLTF2",96,0)
 . S I=I+1,^HLCS(870,LLD0,2,LLD1,1,I,0)=@HDR@(X)
"RTN","HLTF2",97,0)
 S I=I+1,^HLCS(870,LLD0,2,LLD1,1,I,0)=""
"RTN","HLTF2",98,0)
 ;
"RTN","HLTF2",99,0)
 ;Move data from Message Text file to Logical Link file
"RTN","HLTF2",100,0)
 S X=0 F  S X=$O(^HL(772,MTIEN,"IN",X)) Q:X=""  D
"RTN","HLTF2",101,0)
 . S I=I+1,^HLCS(870,LLD0,2,LLD1,1,I,0)=$G(^HL(772,MTIEN,"IN",X,0))
"RTN","HLTF2",102,0)
 ;
"RTN","HLTF2",103,0)
 ;-- update 0 node of message and format arrays
"RTN","HLTF2",104,0)
 S ^HLCS(870,LLD0,2,LLD1,1,0)="^^"_I_"^"_I_"^"_$$DT^XLFDT_"^"
"RTN","HLTF2",105,0)
 ;
"RTN","HLTF2",106,0)
 ; patch HL*1.6*122: MPI-client/server
"RTN","HLTF2",107,0)
 L -^HLCS(870,+$G(LLD0),2,+$G(LLD1))
"RTN","HLTF2",108,0)
 ;
"RTN","HLTF2",109,0)
 Q
"RTN","HLTF2",110,0)
OUT(HLDA,HLMID,HLMTN) ;File Data in Message Text File for Outgoing Message
"RTN","HLTF2",111,0)
 ;Version 1.5 Interface Only
"RTN","HLTF2",112,0)
 ;
"RTN","HLTF2",113,0)
 ; patch HL*1.6*122: HLTF routine splitted, moves sub-routines,
"RTN","HLTF2",114,0)
 ; OUT, IN, and ACK to HLTF2 routine.
"RTN","HLTF2",115,0)
 ; 
"RTN","HLTF2",116,0)
 Q:'$D(HLFS)
"RTN","HLTF2",117,0)
 ;
"RTN","HLTF2",118,0)
 I HLMTN="ACK"!(HLMTN="MCF")!(HLMTN="ORR") Q:'$D(HLMSA)  D ACK(HLMSA,"I") Q
"RTN","HLTF2",119,0)
 ;
"RTN","HLTF2",120,0)
 ;-- if message contained MSA find inbound message
"RTN","HLTF2",121,0)
 I $D(HLMSA),$D(HLNDAP),$P(HLMSA,HLFS,3)]"" D
"RTN","HLTF2",122,0)
 . N HLDAI
"RTN","HLTF2",123,0)
 . S HLDAI=0
"RTN","HLTF2",124,0)
 . F  S HLDAI=$O(^HL(772,"AH",+$P($G(HLNDAP0),U,12),$P(HLMSA,HLFS,3),HLDAI)) Q:'HLDAI!($P($G(^HL(772,+HLDAI,0)),U,4)="I")
"RTN","HLTF2",125,0)
 . I 'HLDAI K HLDAI
"RTN","HLTF2",126,0)
 ;
"RTN","HLTF2",127,0)
 D STUFF^HLTF0("O")
"RTN","HLTF2",128,0)
 ;
"RTN","HLTF2",129,0)
 N HLAC S HLAC=$S($D(HLERR):4,'$P(HLNDAP0,"^",10):1,1:2) D STATUS^HLTF0(HLDA,HLAC,$G(HLMSG))
"RTN","HLTF2",130,0)
 D:$D(HLCHAR) STATS^HLTF0(HLDA,HLCHAR,$G(HLEVN))
"RTN","HLTF2",131,0)
 ;
"RTN","HLTF2",132,0)
 ;-- update status if MSA and found inbound message
"RTN","HLTF2",133,0)
 I $D(HLMSA),$D(HLDAI) D
"RTN","HLTF2",134,0)
 .N HLERR,HLMSG I $P(HLMSA,HLFS,4)]"" S HLERR=$P(HLMSA,HLFS,4)
"RTN","HLTF2",135,0)
 .S HLAC=$P(HLMSA,HLFS,2)
"RTN","HLTF2",136,0)
 .I HLAC'="AA" S HLMSG=$S(HLAC="AR":"Application Reject",HLAC="AE":"Application Error",1:"")_" - "_HLERR
"RTN","HLTF2",137,0)
 .S HLAC=$S(HLAC'="AA":4,1:3) D STATUS^HLTF0(HLDAI,HLAC,$G(HLMSG))
"RTN","HLTF2",138,0)
 Q
"RTN","HLTF2",139,0)
 ;
"RTN","HLTF2",140,0)
IN(HLMTN,HLMID,HLTIME) ;File Data in Message Text File for Incoming Message
"RTN","HLTF2",141,0)
 ;Version 1.5 Interface Only
"RTN","HLTF2",142,0)
 ;
"RTN","HLTF2",143,0)
 ; patch HL*1.6*122: HLTF routine splitted, moves sub-routines,
"RTN","HLTF2",144,0)
 ; OUT, IN, and ACK to HLTF2 routine.
"RTN","HLTF2",145,0)
 ; 
"RTN","HLTF2",146,0)
 Q:'$D(HLFS)
"RTN","HLTF2",147,0)
 I HLMTN="ACK"!(HLMTN="MCF")!(HLMTN="ORR") Q:'$D(HLMSA)  D ACK(HLMSA,"O",$G(HLDA)) Q
"RTN","HLTF2",148,0)
 ;
"RTN","HLTF2",149,0)
 N HLDAI S HLDA=0
"RTN","HLTF2",150,0)
 I $D(HLNDAP),HLMID]"" D
"RTN","HLTF2",151,0)
 .F  S HLDA=+$O(^HL(772,"AH",+$P($G(HLNDAP0),U,12),HLMID,HLDA)) Q:'HLDA!($P($G(^HL(772,+HLDA,0)),U,4)="I")
"RTN","HLTF2",152,0)
 .I HLDA D
"RTN","HLTF2",153,0)
 ..S HLDT=+$P($G(^HL(772,HLDA,0)),"^"),HLDT1=$$HLDATE^HLFNC(HLDT)
"RTN","HLTF2",154,0)
 ..K ^HL(772,HLDA,"IN")
"RTN","HLTF2",155,0)
 .I $D(HLMSA),$P(HLMSA,HLFS,3)]"" D
"RTN","HLTF2",156,0)
 ..S HLDAI=0
"RTN","HLTF2",157,0)
 ..F  S HLDAI=$O(^HL(772,"AH",+$P($G(HLNDAP0),U,12),$P(HLMSA,HLFS,3),HLDAI)) Q:'HLDAI!($P($G(^HL(772,+HLDAI,0)),U,4)="O")
"RTN","HLTF2",158,0)
 ..I 'HLDAI K HLDAI
"RTN","HLTF2",159,0)
 ;
"RTN","HLTF2",160,0)
 ; patch HL*1.6*122: MPI-client/server
"RTN","HLTF2",161,0)
 ; I 'HLDA D CREATE(.HLMID,.HLDA,.HLDT,.HLDT1) K HLZ
"RTN","HLTF2",162,0)
 I 'HLDA D CREATE^HLTF(.HLMID,.HLDA,.HLDT,.HLDT1) K HLZ
"RTN","HLTF2",163,0)
 ;
"RTN","HLTF2",164,0)
 D STUFF^HLTF0("I")
"RTN","HLTF2",165,0)
 N HLAC S HLAC=$S($D(HLERR):4,1:1) D STATUS^HLTF0(HLDA,HLAC,$G(HLMSG))
"RTN","HLTF2",166,0)
 ;
"RTN","HLTF2",167,0)
 D MERGE15^HLTF1("G",HLDA,"HLR",HLTIME)
"RTN","HLTF2",168,0)
 ;
"RTN","HLTF2",169,0)
 I '$D(HLERR),$D(HLMSA),$D(HLDAI) D
"RTN","HLTF2",170,0)
 .N HLAC,HLERR,HLMSG I $P(HLMSA,HLFS,4)]"" S HLERR=$P(HLMSA,HLFS,4)
"RTN","HLTF2",171,0)
 .S HLAC=$P(HLMSA,HLFS,2) I HLAC'="AA" S HLMSG=$S(HLAC="AR":"Application Reject",1:"Application Error")_" - "_HLERR
"RTN","HLTF2",172,0)
 .S HLAC=$S(HLAC'="AA":4,1:3) D STATUS^HLTF0(HLDAI,HLAC,$G(HLMSG))
"RTN","HLTF2",173,0)
 Q
"RTN","HLTF2",174,0)
 ;
"RTN","HLTF2",175,0)
ACK(HLMSA,HLIO,HLDA) ;Process 'ACK' Message Type - Version 1.5 Interface Only
"RTN","HLTF2",176,0)
 ;
"RTN","HLTF2",177,0)
 ; patch HL*1.6*122: HLTF routine splitted, moves sub-routines,
"RTN","HLTF2",178,0)
 ; OUT, IN, and ACK to HLTF2 routine.
"RTN","HLTF2",179,0)
 ; 
"RTN","HLTF2",180,0)
 ; To determine the correct message to link the ACK, HLIO is used.
"RTN","HLTF2",181,0)
 ; For an ack from DHCP (original message from remote system) then
"RTN","HLTF2",182,0)
 ; HLIO should be "I" so that the correct inbound message is ack-ed. For
"RTN","HLTF2",183,0)
 ; an inbound ack (original message outbound from DHCP) HLIO should be
"RTN","HLTF2",184,0)
 ; "O". This distinction must be made due to the possible duplicate
"RTN","HLTF2",185,0)
 ; message ids from a bi-direction interface.
"RTN","HLTF2",186,0)
 ;
"RTN","HLTF2",187,0)
 ; Input : MSA - MSA from ACK message.
"RTN","HLTF2",188,0)
 ;         HLIO - Either "I" or "O" : See note above.
"RTN","HLTF2",189,0)
 ;Output : None
"RTN","HLTF2",190,0)
 ;
"RTN","HLTF2",191,0)
 N HLAC,HLMIDI
"RTN","HLTF2",192,0)
 ;-- set up required vars
"RTN","HLTF2",193,0)
 S HLAC=$P(HLMSA,HLFS,2),HLMIDI=$P(HLMSA,HLFS,3)
"RTN","HLTF2",194,0)
 ;-- quit
"RTN","HLTF2",195,0)
 Q:HLMIDI']""!(HLAC']"")!('$D(HLNDAP))
"RTN","HLTF2",196,0)
 ;-- find message to ack
"RTN","HLTF2",197,0)
 I '$G(HLDA) S HLDA=0 D
"RTN","HLTF2",198,0)
 . F  S HLDA=+$O(^HL(772,"AH",+$P($G(HLNDAP0),U,12),HLMIDI,HLDA)) Q:'HLDA!($P($G(^HL(772,+HLDA,0)),U,4)=HLIO)
"RTN","HLTF2",199,0)
 ;-- quit if no message
"RTN","HLTF2",200,0)
 Q:'$D(^HL(772,+HLDA,0))
"RTN","HLTF2",201,0)
 ;-- check for error
"RTN","HLTF2",202,0)
 I $P(HLMSA,HLFS,4)]"" N HLERR S HLERR=$P(HLMSA,HLFS,4)
"RTN","HLTF2",203,0)
 I $D(HLERR),'$D(HLMSG) N HLMSG S HLMSG="Error During Receipt of Acknowledgement Message"_$S(HLAC="AR":" - Application Reject",HLAC="AE":" - Application Error",1:"")_" - "_HLERR
"RTN","HLTF2",204,0)
 ;-- update status
"RTN","HLTF2",205,0)
 S HLAC=$S(HLMTN="MCF":2,HLAC'="AA":4,1:3)
"RTN","HLTF2",206,0)
 D STATUS^HLTF0(HLDA,HLAC,$G(HLMSG))
"RTN","HLTF2",207,0)
 Q
"RTN","HLTF2",208,0)
 ;
"RTN","HLTP3")
0^27^B75102682^B73884339
"RTN","HLTP3",1,0)
HLTP3 ;SFIRMFO/RSD - Transaction Processor for TCP ;10/05/2007  15:17
"RTN","HLTP3",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**19,43,57,58,59,66,69,109,115,108,116,117,125,120,133,122**;Oct 13, 1995;Build 14
"RTN","HLTP3",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLTP3",4,0)
 ;
"RTN","HLTP3",5,0)
 Q
"RTN","HLTP3",6,0)
NEW(X) ;process new msg. ien in 773^ien in 772
"RTN","HLTP3",7,0)
 ;HLMTIENS=ien in #773; HLMTIEN=ien in #772
"RTN","HLTP3",8,0)
 ;HLHDRO=original header;  HLHDR=response header
"RTN","HLTP3",9,0)
 ;set error trap
"RTN","HLTP3",10,0)
 N $ETRAP,$ESTACK S $ETRAP="D ERROR^HLTP3"
"RTN","HLTP3",11,0)
 N HL,HLEID,HLEIDS,HLERR,HLHDR,HLHDRO,HLMTIEN,HLMTIENS,HLJ,HLMSA,HLQUIT,HLNODE,HLNEXT,HLRESLTA,HLDONE1,HLASTRSP,HLRESLT
"RTN","HLTP3",12,0)
 S HLRESLT=""
"RTN","HLTP3",13,0)
 D INIT^HLTP3A
"RTN","HLTP3",14,0)
 ;error with header, return commit/app reject
"RTN","HLTP3",15,0)
 I $G(HLRESLT) D  Q
"RTN","HLTP3",16,0)
 . ;set status & unlock record
"RTN","HLTP3",17,0)
 . D STATUS^HLTF0(HLMTIENS,4,,,1),EXIT
"RTN","HLTP3",18,0)
 . ;quit if no commit or app ack
"RTN","HLTP3",19,0)
 . I $G(HL("ACAT"))="NE",$G(HL("APAT"))="NE" Q
"RTN","HLTP3",20,0)
 . S X=$S($G(HL("ACAT"))="AL":"CR",1:"AR")
"RTN","HLTP3",21,0)
 . ;HLTCP=ien of acknowledgment msg. from ACK^HLTP4
"RTN","HLTP3",22,0)
 . D ACK^HLTP4(X,$P(HLRESLT,U,2)) Q:'$G(HLTCP)
"RTN","HLTP3",23,0)
 . ;write ack back
"RTN","HLTP3",24,0)
 . S X=$$WRITE^HLCSTCP2(HLTCP)
"RTN","HLTP3",25,0)
 . ;update counter to sent
"RTN","HLTP3",26,0)
 . D LLCNT^HLCSTCP(HLDP,4)
"RTN","HLTP3",27,0)
 . ;update status of ack
"RTN","HLTP3",28,0)
 . D STATUS^HLTF0(HLTCP,3,,,1)
"RTN","HLTP3",29,0)
 ;
"RTN","HLTP3",30,0)
 ;check for duplicate msg., use rec. app and msg. id x-ref
"RTN","HLTP3",31,0)
 ; patch HL*1.6*120
"RTN","HLTP3",32,0)
 I $G(HL("MID"))]"",$G(HL("RAP")) S X=$O(^HLMA("AH",HL("RAP"),HL("MID"),0)) D  Q:'$D(HLMTIENS)
"RTN","HLTP3",33,0)
 . ;HLASTMSG=last ien received during this connection
"RTN","HLTP3",34,0)
 . ;if no duplicate, save msg. ien and quit
"RTN","HLTP3",35,0)
 . I X=HLMTIENS!'X S HLASTMSG=HLMTIENS Q
"RTN","HLTP3",36,0)
 . N MSH,OIENS
"RTN","HLTP3",37,0)
 . S (OIENS,Y)=X D  S Y=HLMTIENS D
"RTN","HLTP3",38,0)
 .. ;combine MSH into single string
"RTN","HLTP3",39,0)
 .. S MSH(Y)="",I=0 F  S I=$O(^HLMA(Y,"MSH",I)) Q:'I  S MSH(Y)=MSH(Y)_$G(^(I,0))
"RTN","HLTP3",40,0)
 .; patch 117 & 125, check if identical
"RTN","HLTP3",41,0)
 .I MSH(HLMTIENS)'=MSH(OIENS) S HLASTMSG=HLMTIENS Q
"RTN","HLTP3",42,0)
 .;
"RTN","HLTP3",43,0)
 . ;msg is duplicate, set status
"RTN","HLTP3",44,0)
 . D STATUS^HLTF0(HLMTIENS,4,109,"Duplicate with ien "_OIENS,1),EXIT
"RTN","HLTP3",45,0)
 . ;msg was resent, ignore it.
"RTN","HLTP3",46,0)
 . I HLASTMSG=HLMTIENS K HLMTIENS Q
"RTN","HLTP3",47,0)
 . ;find original response and send back
"RTN","HLTP3",48,0)
 . S HLASTRSP=$O(^HLMA("AF",OIENS,OIENS))
"RTN","HLTP3",49,0)
 ;
"RTN","HLTP3",50,0)
 ;Quit if this is ack to ack
"RTN","HLTP3",51,0)
 I $G(HL("ACK")) D  Q
"RTN","HLTP3",52,0)
 . ;Update status of original ack message
"RTN","HLTP3",53,0)
 . D STATUS^HLTF0(HL("MTIENS"),3,,,1),STATUS^HLTF0(HLMTIENS,3,,,1)
"RTN","HLTP3",54,0)
 . ;unlock record
"RTN","HLTP3",55,0)
 . D EXIT
"RTN","HLTP3",56,0)
 ;
"RTN","HLTP3",57,0)
 ;enhance ack., send commit, quit if not an ack, msg will be processed by filer
"RTN","HLTP3",58,0)
 I $G(HL("ACAT"))="AL" D  Q:'$G(HL("MTIENS"))
"RTN","HLTP3",59,0)
 . ;msg is a resend, HLASTRSP=ien of original response
"RTN","HLTP3",60,0)
 .I $G(HLASTRSP) D
"RTN","HLTP3",61,0)
 ..S HLTCP=HLASTRSP
"RTN","HLTP3",62,0)
 ..D LLCNT^HLCSTCP(HLDP,3)
"RTN","HLTP3",63,0)
 . E  D  Q:'$G(HLTCP)
"RTN","HLTP3",64,0)
 ..D ACK^HLTP4("CA") ;**109** LLCNT^HLCSTCP(HLDP,3) called in ACK^HLTP4
"RTN","HLTP3",65,0)
 . S X=$$WRITE^HLCSTCP2(HLTCP)
"RTN","HLTP3",66,0)
 . D LLCNT^HLCSTCP(HLDP,4),STATUS^HLTF0(HLTCP,3,,,1):'$G(HLASTRSP)
"RTN","HLTP3",67,0)
 . S HLTCP=""
"RTN","HLTP3",68,0)
 . ;if not an ack, set status to awaiting processing **109** and put on in queue
"RTN","HLTP3",69,0)
 . I '$G(HL("MTIENS")),'$G(HLASTRSP) D STATUS^HLTF0(HLMTIENS,9),EXIT,SETINQUE^HLTP31
"RTN","HLTP3",70,0)
 ;
"RTN","HLTP3",71,0)
 ;enhance ack., no commit & no app ack
"RTN","HLTP3",72,0)
 I $G(HL("ACAT"))="NE",$G(HL("APAT"))="NE" D  Q
"RTN","HLTP3",73,0)
 . ;set status to awaiting processing, **109** and put on in queue
"RTN","HLTP3",74,0)
 . I '$G(HLASTRSP) D STATUS^HLTF0(HLMTIENS,9),EXIT,SETINQUE^HLTP31
"RTN","HLTP3",75,0)
 ;
"RTN","HLTP3",76,0)
 ; patch HL*1.6*120 start
"RTN","HLTP3",77,0)
 ;resending old response, msg is a resend
"RTN","HLTP3",78,0)
 ; do not re-send duplicate when $G(HL("ACAT"))="AL"
"RTN","HLTP3",79,0)
 I $G(HLASTRSP),$G(HL("ACAT"))'="AL" S HLTCP=HLASTRSP G ACK
"RTN","HLTP3",80,0)
 ; quit if duplicate
"RTN","HLTP3",81,0)
 Q:$G(HLASTRSP)
"RTN","HLTP3",82,0)
 ; patch HL*1.6*120 end
"RTN","HLTP3",83,0)
 ;
"RTN","HLTP3",84,0)
CONT ;continue processing an enhance ack msg. called from DEFACK
"RTN","HLTP3",85,0)
 ;Set special HL variables for processing rtn
"RTN","HLTP3",86,0)
 S HLQUIT=0,HLNODE="",HLNEXT="D HLNEXT^HLCSUTL"
"RTN","HLTP3",87,0)
 ;
"RTN","HLTP3",88,0)
 ; message is an acknowledgement, HLMSA=ack code^id^text
"RTN","HLTP3",89,0)
 I ($G(HLMSA)]"") D  Q
"RTN","HLTP3",90,0)
 . ;X=1 if ack ok, 0=reject of error
"RTN","HLTP3",91,0)
 . S X=$E(HLMSA,2)="A"
"RTN","HLTP3",92,0)
 . ;Update status of original message and remove it from the queue
"RTN","HLTP3",93,0)
 . D STATUS^HLTF0(HL("MTIENS"),$S(X:3,1:4),"",$S(X:"",1:$P(HLMSA,HL("FS"),3)),1)
"RTN","HLTP3",94,0)
 . D DEQUE^HLCSREP($P($G(^HLMA(HL("MTIENS"),0)),"^",7),"O",HL("MTIENS"))
"RTN","HLTP3",95,0)
 . D
"RTN","HLTP3",96,0)
 .. N HLTCP ;variable to update status in file #772.
"RTN","HLTP3",97,0)
 ..;
"RTN","HLTP3",98,0)
 ..;**108**
"RTN","HLTP3",99,0)
 .. N TEMP
"RTN","HLTP3",100,0)
 .. S TEMP=HLMTIENS
"RTN","HLTP3",101,0)
 .. N HLMTIENS
"RTN","HLTP3",102,0)
 .. S HLMTIENS=TEMP
"RTN","HLTP3",103,0)
 ..;**END 108**
"RTN","HLTP3",104,0)
 ..;
"RTN","HLTP3",105,0)
 .. D PROCACK^HLTP2(HLMTIEN,HL("EID"),.HLRESLT,.HL)
"RTN","HLTP3",106,0)
 . ;update status of incoming & unlock
"RTN","HLTP3",107,0)
 . D STATUS^HLTF0(HLMTIENS,$S($G(HLRESLT):4,1:3),$S($G(HLRESLT):+$G(HLRESLT),1:""),$S($G(HLRESLT):$P(HLRESLT,U,2),1:""),1),EXIT
"RTN","HLTP3",108,0)
 ;
"RTN","HLTP3",109,0)
 ;get entry action, exit action and processing routine
"RTN","HLTP3",110,0)
 K HLHDR,HLLD0,HLLD1,HLMSA
"RTN","HLTP3",111,0)
 I HL("EIDS")="",$G(HLEIDS)]"" S HL("EIDS")=HLEIDS ;**CIRN**
"RTN","HLTP3",112,0)
 D EVENT^HLUTIL1(HL("EIDS"),"15,20,771",.HLN)
"RTN","HLTP3",113,0)
 S HLENROU=$G(HLN(20)),HLEXROU=$G(HLN(15)),HLPROU=$G(HLN(771))
"RTN","HLTP3",114,0)
 ;quit if no processing routine,update status and quit
"RTN","HLTP3",115,0)
 I HLPROU']"" S HLRESLT="10^"_$G(^HL(771.7,10,0)) D STATUS^HLTF0(HLMTIENS,3,,,1),EXIT Q
"RTN","HLTP3",116,0)
 ;HLORNOD=subscriber protocol for Fileman auditing, ien;global ref
"RTN","HLTP3",117,0)
 N HLORNODD S HLORNOD=HL("EIDS")_";ORD(101,"
"RTN","HLTP3",118,0)
 ;Execute entry action of client protocol
"RTN","HLTP3",119,0)
 X:HLENROU]"" HLENROU K HLENROU,HLDONE1
"RTN","HLTP3",120,0)
 ;
"RTN","HLTP3",121,0)
 ;Execute processing routine
"RTN","HLTP3",122,0)
 X HLPROU S HLRESLT=0 S:($D(HLERR)) HLRESLT="9^"_HLERR
"RTN","HLTP3",123,0)
 ;update status of incoming to complete & unlock
"RTN","HLTP3",124,0)
 D STATUS^HLTF0(HLMTIENS,$S(HLRESLT:4,1:3),$S(HLRESLT:+HLRESLT,1:""),$S(HLRESLT:$P(HLRESLT,U,2),1:""),1,$S($G(HLERR("SKIP_EVENT"))=1:1,1:0)),EXIT
"RTN","HLTP3",125,0)
 ;HLTCPO=link open, HLTCP=ien of ack msg. from GENACK
"RTN","HLTP3",126,0)
ACK I $G(HLTCPO),$G(HLTCP) D  Q
"RTN","HLTP3",127,0)
 . D LLCNT^HLCSTCP(HLDP,3)
"RTN","HLTP3",128,0)
 . ;write ack back over open tcp link
"RTN","HLTP3",129,0)
 . S X=$$WRITE^HLCSTCP2(HLTCP)
"RTN","HLTP3",130,0)
 . ;update status of ack to complete
"RTN","HLTP3",131,0)
 . D:'$G(HLASTRSP) STATUS^HLTF0(HLTCP,3,,,1)
"RTN","HLTP3",132,0)
 . D LLCNT^HLCSTCP(HLDP,4)
"RTN","HLTP3",133,0)
 Q
"RTN","HLTP3",134,0)
 ;
"RTN","HLTP3",135,0)
DEFACK(HLDP,X) ;process the deferred application ack, called from HLCSIN
"RTN","HLTP3",136,0)
 ;HLDP=logical link, X=ien in file 773
"RTN","HLTP3",137,0)
 ;
"RTN","HLTP3",138,0)
 ; patch HL*1.6*120 start
"RTN","HLTP3",139,0)
 ; clean non-Kernel variables
"RTN","HLTP3",140,0)
 D
"RTN","HLTP3",141,0)
 . ; protect variables defined in STARTIN^HLCSIN
"RTN","HLTP3",142,0)
 . N HLFLG,HLEXIT,HLPTRFLR
"RTN","HLTP3",143,0)
 . ; protect variables defined in DEFACK^HLCSIN
"RTN","HLTP3",144,0)
 . N HLXX,HLD0,HLPCT
"RTN","HLTP3",145,0)
 . ; protect input parameters of this sub-routine
"RTN","HLTP3",146,0)
 . N HLDP,X
"RTN","HLTP3",147,0)
 . D KILL^XUSCLEAN
"RTN","HLTP3",148,0)
 ; patch HL*1.6*120 end
"RTN","HLTP3",149,0)
 ;
"RTN","HLTP3",150,0)
 ;set error trap
"RTN","HLTP3",151,0)
 N $ETRAP,$ESTACK S $ETRAP="D ERROR^HLTP3"
"RTN","HLTP3",152,0)
 N HLERR     ;patch HL*1.6*109
"RTN","HLTP3",153,0)
 Q:'$G(HLDP)!'$G(X)  Q:'$G(^HLMA(X,0))
"RTN","HLTP3",154,0)
 Q:'$D(^HLMA("AC","I",HLDP,X))
"RTN","HLTP3",155,0)
 ;
"RTN","HLTP3",156,0)
 N HL,HLA,HLD0,HLEID,HLEIDS,HLHDR,HLHDRO,HLMTIEN,HLMTIENS,HLJ,HLMSA,HLN,HLQUIT,HLNODE,HLNEXT,HLRESLT,HLRESLTA,HLTCP,HLXX,Z,HLDONE1
"RTN","HLTP3",157,0)
 S HLMTIENS=X,X=^HLMA(HLMTIENS,0),HLMTIEN=+$P(X,U),HL("MID")=$P(X,U,2),HL("MTIENS")=$P(X,U,10),HL("LL")=$P(X,U,7),HLTCP="",HL("Q")=""""""
"RTN","HLTP3",158,0)
 S HL("EIDS")=$P(X,U,8),HL("SAP")=$P(X,U,11),HL("RAP")=$P(X,U,12),HL("MTP")=$P(X,U,13),HL("ETP")=$P(X,U,14)
"RTN","HLTP3",159,0)
 S:$P(X,U,15) HL("MTP_ETP")=$P(X,U,15)
"RTN","HLTP3",160,0)
 S:HL("SAP") HL("SAN")=$P($G(^HL(771,HL("SAP"),0)),U) S:HL("RAP") HL("RAN")=$P($G(^HL(771,HL("RAP"),0)),U)
"RTN","HLTP3",161,0)
 S:HL("MTP") HL("MTN")=$P($G(^HL(771.2,HL("MTP"),0)),U) S:HL("ETP") HL("ETN")=$P($G(^HL(779.001,HL("ETP"),0)),U)
"RTN","HLTP3",162,0)
 S:$G(HL("MTP_ETP")) HL("MTN_ETN")=$P($G(^HL(779.005,HL("MTP_ETP"),0)),U)
"RTN","HLTP3",163,0)
 S HL("EID")=$P($G(^HL(772,HLMTIEN,0)),U,10)
"RTN","HLTP3",164,0)
 M HLHDRO=^HLMA(HLMTIENS,"MSH")
"RTN","HLTP3",165,0)
 ; if no header quit
"RTN","HLTP3",166,0)
 Q:'$O(HLHDRO(0))
"RTN","HLTP3",167,0)
 ;
"RTN","HLTP3",168,0)
 S HL("FS")=$E(HLHDRO(1,0),4),HL("ECH")=$$P^HLTPCK2(.HLHDRO,2),HL("SFN")=$$P^HLTPCK2(.HLHDRO,4),HL("RFN")=$$P^HLTPCK2(.HLHDRO,6),HL("DTM")=$$P^HLTPCK2(.HLHDRO,7)
"RTN","HLTP3",169,0)
 ;
"RTN","HLTP3",170,0)
 ; quit if ien of #772 is not defined
"RTN","HLTP3",171,0)
 Q:'HLMTIEN
"RTN","HLTP3",172,0)
 ; quit if field separator is not defined
"RTN","HLTP3",173,0)
 Q:HL("FS")=""
"RTN","HLTP3",174,0)
 ;
"RTN","HLTP3",175,0)
 S X=$$P^HLTPCK2(.HLHDRO,1)
"RTN","HLTP3",176,0)
 ;
"RTN","HLTP3",177,0)
 ; patch HL*1.6*120 start
"RTN","HLTP3",178,0)
 I X="MSH" D
"RTN","HLTP3",179,0)
 . S HL("PID")=$$P^HLTPCK2(.HLHDRO,11),HL("VER")=$$P^HLTPCK2(.HLHDRO,12),HL("APAT")=$$P^HLTPCK2(.HLHDRO,16),HL("CC")=$$P^HLTPCK2(.HLHDRO,17)
"RTN","HLTP3",180,0)
 . ;
"RTN","HLTP3",181,0)
 . ; 2nd component is Processing mode
"RTN","HLTP3",182,0)
 . S HL("PMOD")=$P(HL("PID"),$E(HL("ECH"),1),2)
"RTN","HLTP3",183,0)
 . ; first component is Processing id
"RTN","HLTP3",184,0)
 . S HL("PID")=$P(HL("PID"),$E(HL("ECH"),1))
"RTN","HLTP3",185,0)
 ;
"RTN","HLTP3",186,0)
 I X'="MSH" D
"RTN","HLTP3",187,0)
 . S X=$$P^HLTPCK2(.HLHDRO,9),Z=$E(HL("ECH")),HL("PID")=$P(X,Z,2),HL("VER")=$P(X,Z,4)
"RTN","HLTP3",188,0)
 . ;
"RTN","HLTP3",189,0)
 . ; original code incorrectly treats repetition separator as
"RTN","HLTP3",190,0)
 . ; subcomponent separator
"RTN","HLTP3",191,0)
 . I $E(HL("ECH"),2)]"",X[$E(HL("ECH"),2) D
"RTN","HLTP3",192,0)
 .. S HL("SUB-COMPONENT")=$E(HL("ECH"),2)
"RTN","HLTP3",193,0)
 . ; if subcomponent separator is correctly applied
"RTN","HLTP3",194,0)
 . I $E(HL("ECH"),4)]"",X[$E(HL("ECH"),4) D
"RTN","HLTP3",195,0)
 .. S HL("SUB-COMPONENT")=$E(HL("ECH"),4)
"RTN","HLTP3",196,0)
 . ;
"RTN","HLTP3",197,0)
 . I $D(HL("SUB-COMPONENT")),HL("PID")[HL("SUB-COMPONENT") D
"RTN","HLTP3",198,0)
 .. ; 2nd sub-component is Processing mode
"RTN","HLTP3",199,0)
 .. S HL("PMOD")=$P(HL("PID"),HL("SUB-COMPONENT"),2)
"RTN","HLTP3",200,0)
 .. ; first sub-component is Processing id
"RTN","HLTP3",201,0)
 .. S HL("PID")=$P(HL("PID"),HL("SUB-COMPONENT"))
"RTN","HLTP3",202,0)
 . ; patch HL*1.6*120 end
"RTN","HLTP3",203,0)
 . ;
"RTN","HLTP3",204,0)
 . Q:$$P^HLTPCK2(.HLHDRO,10)=""
"RTN","HLTP3",205,0)
 . ;HLMSA=ack code^id^text
"RTN","HLTP3",206,0)
 . S HLMSA=$P($$P^HLTPCK2(.HLHDRO,10),$E(HL("ECH")),1),$P(HLMSA,HL("FS"),2)=$$P^HLTPCK2(.HLHDRO,12),$P(HLMSA,HL("FS"),3)=$P($$P^HLTPCK2(.HLHDRO,10),$E(HL("ECH")),2),HL("MSAID")=$P(HLMSA,HL("FS"),2)
"RTN","HLTP3",207,0)
 ;
"RTN","HLTP3",208,0)
 ; quit if this is a commit ack
"RTN","HLTP3",209,0)
 I $P($G(^HL(772,HLMTIEN,"IN",1,0)),HL("FS"),1)="MSA",$E($P($G(^HL(772,HLMTIEN,"IN",1,0)),HL("FS"),2))="C" Q
"RTN","HLTP3",210,0)
 ;
"RTN","HLTP3",211,0)
 ;**  HL*1.6*117 **
"RTN","HLTP3",212,0)
 K HLL("SET FOR APP ACK"),HLL("LINKS")
"RTN","HLTP3",213,0)
 ;
"RTN","HLTP3",214,0)
 D CONT
"RTN","HLTP3",215,0)
 Q
"RTN","HLTP3",216,0)
 ;
"RTN","HLTP3",217,0)
MSA(Y) ;Y=ien in 772, returns MSA segment
"RTN","HLTP3",218,0)
 ;ack code^msg being ack id^text
"RTN","HLTP3",219,0)
 ; patch HL*1.6*122
"RTN","HLTP3",220,0)
 ; for HL7 v2.5 and beyond with MSA as 3rd segment
"RTN","HLTP3",221,0)
 N X,SUBIEN,DATA,DONE
"RTN","HLTP3",222,0)
 S X=$G(^HL(772,Y,"IN",1,0)),X=$S($E(X,1,3)="MSA":$E(X,5,999),1:"")
"RTN","HLTP3",223,0)
 Q:X]"" X
"RTN","HLTP3",224,0)
 ;
"RTN","HLTP3",225,0)
 S DONE=0
"RTN","HLTP3",226,0)
 S SUBIEN=1
"RTN","HLTP3",227,0)
 F  S SUBIEN=$O(^HL(772,Y,"IN",SUBIEN)) Q:'SUBIEN  D  Q:DONE
"RTN","HLTP3",228,0)
 . S DATA=$G(^HL(772,Y,"IN",SUBIEN,0)) I DATA="" D
"RTN","HLTP3",229,0)
 .. S DONE=1
"RTN","HLTP3",230,0)
 .. S SUBIEN=$O(^HL(772,Y,"IN",SUBIEN)) Q:'SUBIEN
"RTN","HLTP3",231,0)
 .. S X=$G(^HL(772,Y,"IN",SUBIEN,0)),X=$S($E(X,1,3)="MSA":$E(X,5,999),1:"")
"RTN","HLTP3",232,0)
 ; patch HL*1.6*122 end
"RTN","HLTP3",233,0)
 ;
"RTN","HLTP3",234,0)
 Q X
"RTN","HLTP3",235,0)
 ;
"RTN","HLTP3",236,0)
ERROR ;error trap
"RTN","HLTP3",237,0)
 D ^%ZTER
"RTN","HLTP3",238,0)
 I $G(HLMTIENS),$D(^HLMA(HLMTIENS,0)) D STATUS^HLTF0(HLMTIENS,4,,,1),EXIT
"RTN","HLTP3",239,0)
 ; release locks created by inbound filer
"RTN","HLTP3",240,0)
 L -^HLMA("AC","I",+$G(HLXX))
"RTN","HLTP3",241,0)
 G UNWIND^%ZTER
"RTN","HLTP3",242,0)
 ;
"RTN","HLTP3",243,0)
 ;
"RTN","HLTP3",244,0)
EXIT ;unlock
"RTN","HLTP3",245,0)
 I $G(HLMTIENS) L -^HLMA(HLMTIENS)
"RTN","HLTP3",246,0)
 Q
"RTN","HLTP3",247,0)
 ;
"RTN","HLTP3",248,0)
ONAC(IEN773) ;
"RTN","HLTP3",249,0)
 ;Returns 1 if the message is on the "AC","I" xref
"RTN","HLTP3",250,0)
 ;Returns 0 otherwise
"RTN","HLTP3",251,0)
 ;
"RTN","HLTP3",252,0)
 N LINK
"RTN","HLTP3",253,0)
 S LINK=$P($G(^HLMA(IEN773,0)),"^",17)
"RTN","HLTP3",254,0)
 Q:'LINK 0
"RTN","HLTP3",255,0)
 Q $D(^HLMA("AC","I",LINK,IEN773))
"RTN","HLTPCK2B")
0^26^B67329178^B64470063
"RTN","HLTPCK2B",1,0)
HLTPCK2B ;OIFO-O/RJH - Message Header Validation (Con't) ;10/04/2007  16:00
"RTN","HLTPCK2B",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**120,133,122**;Oct 13, 1995;Build 14
"RTN","HLTPCK2B",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLTPCK2B",4,0)
 ;
"RTN","HLTPCK2B",5,0)
 ; splitted from HLTPCK2A
"RTN","HLTPCK2B",6,0)
 ; to be called from HLTPCK2A
"RTN","HLTPCK2B",7,0)
 ;
"RTN","HLTPCK2B",8,0)
MS ;Check for Message Structure Code
"RTN","HLTPCK2B",9,0)
 I $G(ARY("MTN_ETN"))'="" D
"RTN","HLTPCK2B",10,0)
 . S ARY("MTP_ETP")=0
"RTN","HLTPCK2B",11,0)
 . S ARY("MTP_ETP")=+$O(^HL(779.005,"B",ARY("MTN_ETN"),0))
"RTN","HLTPCK2B",12,0)
 . I ('ARY("MTP_ETP")) S:(ERR="") ERR="Invalid Message Structure Code" Q
"RTN","HLTPCK2B",13,0)
 ;
"RTN","HLTPCK2B",14,0)
 ;Get server and client Protocols
"RTN","HLTPCK2B",15,0)
MSA ;if ack, then get information and quit, we don't need to respond
"RTN","HLTPCK2B",16,0)
 I $G(MSA)]"" D  Q
"RTN","HLTPCK2B",17,0)
 . ;Message is an acknowledgement, find original message
"RTN","HLTPCK2B",18,0)
 . S ARY("MSAID")=$P(MSA,FS,2),ARY("MTIENS")=0
"RTN","HLTPCK2B",19,0)
 . I ARY("MSAID")="" S:(ERR="") ERR="Invalid Message Control ID in MSA Segment - No Message ID" Q
"RTN","HLTPCK2B",20,0)
 . F  S ARY("MTIENS")=+$O(^HLMA("AH",ARY("SAP"),ARY("MSAID"),ARY("MTIENS"))) Q:'ARY("MTIENS")!($P($G(^HLMA(ARY("MTIENS"),0)),U,3)="O")
"RTN","HLTPCK2B",21,0)
 . I 'ARY("MTIENS") S:(ERR="") ERR="Invalid Message Control ID in MSA Segment - No message IEN in ""AH"" x-ref" Q
"RTN","HLTPCK2B",22,0)
 . ;get subscriber protocol and ack. to (show if this is an ack to an ack)
"RTN","HLTPCK2B",23,0)
 . S X=$G(^HLMA(ARY("MTIENS"),0)),ARY("EIDS")=$P(X,U,8),ARY("ACK")=$P(X,U,10)
"RTN","HLTPCK2B",24,0)
 . ;if no subscriber protocol then response msg. is invalid
"RTN","HLTPCK2B",25,0)
 . ;
"RTN","HLTPCK2B",26,0)
 . ; patch HL*1.6*122 start
"RTN","HLTPCK2B",27,0)
 . ; comment out the following code: for patch 109- dynamic addressing
"RTN","HLTPCK2B",28,0)
 . ; I ('ARY("EIDS")) S:(ERR="") ERR="Invalid Message Control ID in MSA Segment - No Subscr. IEN in 773" Q
"RTN","HLTPCK2B",29,0)
 . ;get message text ien in file 772 and server protocol, 'EID'
"RTN","HLTPCK2B",30,0)
 . S ARY("MTIEN")=+X,X=$G(^HL(772,+X,0)),ARY("EID")=$P(X,U,10)
"RTN","HLTPCK2B",31,0)
 . I ('ARY("EID")) S:(ERR="") ERR="Event Protocol not found" Q
"RTN","HLTPCK2B",32,0)
 . ; D EVENT^HLUTIL1(ARY("EIDS"),"770,773",.HLN)
"RTN","HLTPCK2B",33,0)
 . I ARY("EIDS") D EVENT^HLUTIL1(ARY("EIDS"),"770,773",.HLN)
"RTN","HLTPCK2B",34,0)
 . ; patch HL*1.6*122 end
"RTN","HLTPCK2B",35,0)
 ;
"RTN","HLTPCK2B",36,0)
 ;Find Server Protocol - based on sending application, message type,
"RTN","HLTPCK2B",37,0)
 ;event type and version ID
"RTN","HLTPCK2B",38,0)
 I ARY("ETP") S ARY("EID")=+$O(^ORD(101,"AHL1",ARY("SAP"),ARY("MTP"),ARY("ETP"),ARY("VEP"),0))
"RTN","HLTPCK2B",39,0)
 ;
"RTN","HLTPCK2B",40,0)
 ;Find Server Protocol - based on sending application, message type,
"RTN","HLTPCK2B",41,0)
 ;and version ID
"RTN","HLTPCK2B",42,0)
 I 'ARY("ETP") S ARY("EID")=+$O(^ORD(101,"AHL21",ARY("SAP"),ARY("MTP"),ARY("VEP"),0))
"RTN","HLTPCK2B",43,0)
 ;
"RTN","HLTPCK2B",44,0)
 I ('ARY("EID")) S:(ERR="") ERR="Event Protocol not found" Q
"RTN","HLTPCK2B",45,0)
 ;Find Client Protocol - in ITEM multiple of Server Protocol
"RTN","HLTPCK2B",46,0)
 S ARY("EIDS")=0
"RTN","HLTPCK2B",47,0)
 F  S ARY("EIDS")=+$O(^ORD(101,ARY("EID"),775,"B",ARY("EIDS"))) Q:'ARY("EIDS")!($P($G(^ORD(101,ARY("EIDS"),770)),U,2)=ARY("RAP"))
"RTN","HLTPCK2B",48,0)
 I 'ARY("EIDS") S ERR="Invalid Receiving Application for this Event" Q
"RTN","HLTPCK2B",49,0)
 D EVENT^HLUTIL1(ARY("EIDS"),"770,773",.HLN)
"RTN","HLTPCK2B",50,0)
 ;
"RTN","HLTPCK2B",51,0)
LLP ;Get logical link pointer
"RTN","HLTPCK2B",52,0)
 S ARY("LL")=$P($G(HLN(770)),"^",7)
"RTN","HLTPCK2B",53,0)
 ;
"RTN","HLTPCK2B",54,0)
FAC ;Get sending/rec facility, validate if necessary
"RTN","HLTPCK2B",55,0)
 ;
"RTN","HLTPCK2B",56,0)
 S HLCS=$E(ECH,1) ;Get component separator
"RTN","HLTPCK2B",57,0)
 S ARY("RAF")=$$P^HLTPCK2(.HDR,6) ;Receiving Facility
"RTN","HLTPCK2B",58,0)
 S ARY("SAF")=$$P^HLTPCK2(.HDR,4) ;Sending Facility
"RTN","HLTPCK2B",59,0)
 ;Get sending/receiving facility from Application Parameter file(771)
"RTN","HLTPCK2B",60,0)
 S HL771SF=$P($G(^HL(771,ARY("SAP"),0)),U,3)
"RTN","HLTPCK2B",61,0)
 S HL771RF=$P($G(^HL(771,ARY("RAP"),0)),U,3)
"RTN","HLTPCK2B",62,0)
 ;Sending/Receiving facility required?
"RTN","HLTPCK2B",63,0)
 S X=$G(^ORD(101,ARY("EIDS"),773))
"RTN","HLTPCK2B",64,0)
 S HLSFREQ=+X,HLRFREQ=+$P(X,U,2)
"RTN","HLTPCK2B",65,0)
RF ;Validate Receiving Facility
"RTN","HLTPCK2B",66,0)
 I HLRFREQ D
"RTN","HLTPCK2B",67,0)
 .I ARY("RAF")="" S:ERR="" ERR="Missing required receiving facility"
"RTN","HLTPCK2B",68,0)
 .I HL771RF]"" D  Q
"RTN","HLTPCK2B",69,0)
 ..;Facility data in 771 overrides data in site paramter file
"RTN","HLTPCK2B",70,0)
 ..Q
"RTN","HLTPCK2B",71,0)
 .;Check against local default value (site parameters)
"RTN","HLTPCK2B",72,0)
 .Q:ARY("RAF")=(HLINSTN_HLCS_HLDOM_HLCS_"DNS")
"RTN","HLTPCK2B",73,0)
 .;
"RTN","HLTPCK2B",74,0)
 .; patch HL*1.6*120 start
"RTN","HLTPCK2B",75,0)
 .; I $P(ARY("RAF"),HLCS)=HLINSTN,$P(ARY("RAF"),HLCS,3)="DNS" D  Q
"RTN","HLTPCK2B",76,0)
 . I $P(ARY("RAF"),HLCS,3)="DNS" D  Q
"RTN","HLTPCK2B",77,0)
 .. N ERROR,HLDOMP1,HLDOMP2
"RTN","HLTPCK2B",78,0)
 .. ; S HLDOMP1=$P(ARY("RAF"),HLCS,2),HLDOMP1=$$FIND1^DIC(4.2,"","BMX",HLDOMP1,"B^C","","ERROR")
"RTN","HLTPCK2B",79,0)
 .. S HLDOMP1=$P(ARY("RAF"),HLCS,2)
"RTN","HLTPCK2B",80,0)
 .. ;
"RTN","HLTPCK2B",81,0)
 .. ; assume the format is <domain>:<port #>
"RTN","HLTPCK2B",82,0)
 .. I HLDOMP1[":" S ARY("RAF-PORT")=$P(HLDOMP1,":",2)
"RTN","HLTPCK2B",83,0)
 .. S HLDOMP1=$P(HLDOMP1,":")
"RTN","HLTPCK2B",84,0)
 .. S ARY("RAF-DOMAIN")=HLDOMP1
"RTN","HLTPCK2B",85,0)
 .. ;
"RTN","HLTPCK2B",86,0)
 .. ; if first piece of domain is "HL7." or "MPI.", remove it
"RTN","HLTPCK2B",87,0)
 .. I ($E(HLDOMP1,1,4)="HL7.")!($E(HLDOMP1,1,4)="MPI.") D
"RTN","HLTPCK2B",88,0)
 ... S HLDOMP1=$P(HLDOMP1,".",2,99)
"RTN","HLTPCK2B",89,0)
 .. S HLDOMP1=$$FIND1^DIC(4.2,"","BMX",HLDOMP1,"B^C","","ERROR")
"RTN","HLTPCK2B",90,0)
 .. S HLDOMP2=HLDOM,HLDOMP2=$$FIND1^DIC(4.2,"","BMX",HLDOMP2,"B^C","","ERROR")
"RTN","HLTPCK2B",91,0)
 .. I HLDOMP1&HLDOMP2&(HLDOMP1=HLDOMP2) Q
"RTN","HLTPCK2B",92,0)
 .. ;
"RTN","HLTPCK2B",93,0)
 .. ; check DNS domain and ip address
"RTN","HLTPCK2B",94,0)
 .. ;initialize variable, HLDOMP("FLAG")
"RTN","HLTPCK2B",95,0)
 .. S HLDOMP("FLAG")=0
"RTN","HLTPCK2B",96,0)
 .. I ARY("RAF-DOMAIN")]"" D
"RTN","HLTPCK2B",97,0)
 ... ;
"RTN","HLTPCK2B",98,0)
 ... ; match DNS domain
"RTN","HLTPCK2B",99,0)
 ... I $D(^HLCS(870,"DNS",ARY("RAF-DOMAIN"))) D  Q
"RTN","HLTPCK2B",100,0)
 .... S HLDOMP("FLAG")=1
"RTN","HLTPCK2B",101,0)
 .... S ARY("RAF-LL")=+$O(^HLCS(870,"DNS",ARY("RAF-DOMAIN"),0))
"RTN","HLTPCK2B",102,0)
 ... I $D(^HLCS(870,"DNS",$$UP^XLFSTR(ARY("RAF-DOMAIN")))) D  Q
"RTN","HLTPCK2B",103,0)
 .... S HLDOMP("FLAG")=1
"RTN","HLTPCK2B",104,0)
 .... S ARY("RAF-LL")=+$O(^HLCS(870,"DNS",$$UP^XLFSTR(ARY("RAF-DOMAIN")),0))
"RTN","HLTPCK2B",105,0)
 ... I $D(^HLCS(870,"DNS",$$LOW^XLFSTR(ARY("RAF-DOMAIN")))) D  Q
"RTN","HLTPCK2B",106,0)
 .... S HLDOMP("FLAG")=1
"RTN","HLTPCK2B",107,0)
 .... S ARY("RAF-LL")=+$O(^HLCS(870,"DNS",$$LOW^XLFSTR(ARY("RAF-DOMAIN")),0))
"RTN","HLTPCK2B",108,0)
 ... ;
"RTN","HLTPCK2B",109,0)
 ... ; match ip address
"RTN","HLTPCK2B",110,0)
 ... I $D(^HLCS(870,"IP",ARY("RAF-DOMAIN"))) D  Q
"RTN","HLTPCK2B",111,0)
 .... S HLDOMP("FLAG")=1
"RTN","HLTPCK2B",112,0)
 .... S ARY("RAF-LL")=+$O(^HLCS(870,"IP",ARY("RAF-DOMAIN"),0))
"RTN","HLTPCK2B",113,0)
 .. Q:HLDOMP("FLAG")=1
"RTN","HLTPCK2B",114,0)
 .. I $P(ARY("RAF"),HLCS)=HLINSTN Q
"RTN","HLTPCK2B",115,0)
 .. ;
"RTN","HLTPCK2B",116,0)
 .. S:ERR="" ERR="Receiving Facility mismatch."
"RTN","HLTPCK2B",117,0)
 . I $P(ARY("RAF"),HLCS)=HLINSTN Q
"RTN","HLTPCK2B",118,0)
 . S:ERR="" ERR="Receiving Facility mismatch."
"RTN","HLTPCK2B",119,0)
 ; patch HL*1.6*120 end
"RTN","HLTPCK2B",120,0)
 ;
"RTN","HLTPCK2B",121,0)
SF ;Validate Sending Facility
"RTN","HLTPCK2B",122,0)
 I HLSFREQ D
"RTN","HLTPCK2B",123,0)
 .I ARY("SAF")="" S:ERR="" ERR="Missing required sending facility"
"RTN","HLTPCK2B",124,0)
 .I HL771SF]"" D  Q
"RTN","HLTPCK2B",125,0)
 ..;Check for facility data in 771
"RTN","HLTPCK2B",126,0)
 ..Q
"RTN","HLTPCK2B",127,0)
 .;If default value was sent, validate that DOMAIN RESOLVES TO LOGICAL LINK
"RTN","HLTPCK2B",128,0)
 .;If so, use this instead of Protocol definition for return path
"RTN","HLTPCK2B",129,0)
 .;
"RTN","HLTPCK2B",130,0)
 .; patch HL*1.6*120 start
"RTN","HLTPCK2B",131,0)
 . N HLDOMP
"RTN","HLTPCK2B",132,0)
 . ; S HLDOMP=$P(ARY("SAF"),HLCS,2),HLDOMP=$$FIND1^DIC(4.2,"","BMX",HLDOMP,"B^C","","ERROR")
"RTN","HLTPCK2B",133,0)
 . S HLDOMP=$P(ARY("SAF"),HLCS,2)
"RTN","HLTPCK2B",134,0)
 . ;
"RTN","HLTPCK2B",135,0)
 . ; assume the format is <domain>:<port #>
"RTN","HLTPCK2B",136,0)
 . I HLDOMP[":" S ARY("SAF-PORT")=$P(HLDOMP,":",2)
"RTN","HLTPCK2B",137,0)
 . S HLDOMP=$P(HLDOMP,":")
"RTN","HLTPCK2B",138,0)
 . S ARY("SAF-DOMAIN")=HLDOMP
"RTN","HLTPCK2B",139,0)
 . ;
"RTN","HLTPCK2B",140,0)
 . ; if first piece of domain is "HL7." or "MPI.", remove it
"RTN","HLTPCK2B",141,0)
 . I ($E(HLDOMP,1,4)="HL7.")!($E(HLDOMP,1,4)="MPI.") D
"RTN","HLTPCK2B",142,0)
 .. S HLDOMP=$P(HLDOMP,".",2,99)
"RTN","HLTPCK2B",143,0)
 . S HLDOMP=$$FIND1^DIC(4.2,"","BMX",HLDOMP,"B^C","","ERROR")
"RTN","HLTPCK2B",144,0)
 .;Note: This expects a unique domain in domain file. Multiple entries will fail
"RTN","HLTPCK2B",145,0)
 . ; I 'HLDOMP S:ERR="" ERR="Unrecognized/ambiguous domain in sending facility"
"RTN","HLTPCK2B",146,0)
 . ;
"RTN","HLTPCK2B",147,0)
 . ; check DNS domain and ip address
"RTN","HLTPCK2B",148,0)
 . I 'HLDOMP D
"RTN","HLTPCK2B",149,0)
 .. ;
"RTN","HLTPCK2B",150,0)
 .. ;initialize variable, HLDOMP("FLAG")
"RTN","HLTPCK2B",151,0)
 .. S HLDOMP("FLAG")=0
"RTN","HLTPCK2B",152,0)
 .. I ARY("SAF-DOMAIN")]"" D
"RTN","HLTPCK2B",153,0)
 ... ;
"RTN","HLTPCK2B",154,0)
 ... ; match DNS domain
"RTN","HLTPCK2B",155,0)
 ... I $D(^HLCS(870,"DNS",ARY("SAF-DOMAIN"))) D  Q
"RTN","HLTPCK2B",156,0)
 .... S HLDOMP("FLAG")=1
"RTN","HLTPCK2B",157,0)
 .... S ARY("SAF-LL")=+$O(^HLCS(870,"DNS",ARY("SAF-DOMAIN"),0))
"RTN","HLTPCK2B",158,0)
 ... I $D(^HLCS(870,"DNS",$$UP^XLFSTR(ARY("SAF-DOMAIN")))) D  Q
"RTN","HLTPCK2B",159,0)
 .... S HLDOMP("FLAG")=1
"RTN","HLTPCK2B",160,0)
 .... S ARY("SAF-LL")=+$O(^HLCS(870,"DNS",$$UP^XLFSTR(ARY("SAF-DOMAIN")),0))
"RTN","HLTPCK2B",161,0)
 ... I $D(^HLCS(870,"DNS",$$LOW^XLFSTR(ARY("SAF-DOMAIN")))) D  Q
"RTN","HLTPCK2B",162,0)
 .... S HLDOMP("FLAG")=1
"RTN","HLTPCK2B",163,0)
 .... S ARY("SAF-LL")=+$O(^HLCS(870,"DNS",$$LOW^XLFSTR(ARY("SAF-DOMAIN")),0))
"RTN","HLTPCK2B",164,0)
 ... ;
"RTN","HLTPCK2B",165,0)
 ... ; match ip address
"RTN","HLTPCK2B",166,0)
 ... I $D(^HLCS(870,"IP",ARY("SAF-DOMAIN"))) D  Q
"RTN","HLTPCK2B",167,0)
 .... S HLDOMP("FLAG")=1
"RTN","HLTPCK2B",168,0)
 .... S ARY("SAF-LL")=+$O(^HLCS(870,"IP",ARY("SAF-DOMAIN"),0))
"RTN","HLTPCK2B",169,0)
 .. Q:HLDOMP("FLAG")=1
"RTN","HLTPCK2B",170,0)
 .. ; quit if 1st component defined
"RTN","HLTPCK2B",171,0)
 .. S ARY("SAF-COMPONENT1")=$P(ARY("SAF"),HLCS,1)
"RTN","HLTPCK2B",172,0)
 .. Q:ARY("SAF-COMPONENT1")]""
"RTN","HLTPCK2B",173,0)
 .. S:ERR="" ERR="Receiving Facility mismatch."
"RTN","HLTPCK2B",174,0)
 . ; patch HL*1.6*120 end
"RTN","HLTPCK2B",175,0)
 . ;
"RTN","HLTPCK2B",176,0)
 .Q:HLDOMP=$P(HLPARAM,U)  ;This is local app to app
"RTN","HLTPCK2B",177,0)
 .I HLDOMP N HLNK S HLNK=+$O(^HLCS(870,"D",HLDOMP,0))
"RTN","HLTPCK2B",178,0)
 .I $G(HLNK) S ARY("LL")=HLNK
"RTN","HLTPCK2B",179,0)
 ;
"RTN","HLTPCK2B",180,0)
PID ;Validate processing ID
"RTN","HLTPCK2B",181,0)
 I ("DTP"'[ARY("PID")) S:(ERR="") ERR="Invalid HL7 Processing ID"
"RTN","HLTPCK2B",182,0)
 S HLPID=$P(HLPARAM,U,3) ;site param
"RTN","HLTPCK2B",183,0)
 S X=$G(^ORD(101,ARY("EID"),770)),X=$P(X,U,6) ;event driver
"RTN","HLTPCK2B",184,0)
 ;If message is 'debug' then event driver must be 'debug.'
"RTN","HLTPCK2B",185,0)
 ;If message is 'test' or 'production', then site param must match
"RTN","HLTPCK2B",186,0)
 I ARY("PID")="D"&(X'="D") S:ERR="" ERR="Processing ID Mismatch with Event Driver"
"RTN","HLTPCK2B",187,0)
 I ARY("PID")'="D"&(HLPID'=ARY("PID")) S:ERR="" ERR="Processing ID Mismatch with Site Parameters"
"RTN","HLTPCK2B",188,0)
 ;
"RTN","HLTPCK2B",189,0)
SEC ;Validate security field - access code and electronic signature
"RTN","HLTPCK2B",190,0)
 I ($P($G(HLN(773)),"^",3)) D
"RTN","HLTPCK2B",191,0)
 .S X=$P($$P^HLTPCK2(.HDR,8),$E(ECH))
"RTN","HLTPCK2B",192,0)
 .S X=$$UPPER^HLFNC(X)
"RTN","HLTPCK2B",193,0)
 .D ^XUSHSH
"RTN","HLTPCK2B",194,0)
 .I X="",(MSA="") S:(ERR="") ERR="Invalid access code" Q
"RTN","HLTPCK2B",195,0)
 .S ARY("DUZ")=0
"RTN","HLTPCK2B",196,0)
 .S:(X'="") ARY("DUZ")=+$O(^VA(200,"A",X,0))
"RTN","HLTPCK2B",197,0)
 .I ('ARY("DUZ")) S:(ERR="") ERR="Invalid access code" Q
"RTN","HLTPCK2B",198,0)
 .I (($P($G(^VA(200,ARY("DUZ"),.1)),"^")="")&('$D(MSA))) S ARY("DUZ")=0 S:(ERR="") ERR="Invalid access code" Q
"RTN","HLTPCK2B",199,0)
 .S X=$P($$P^HLTPCK2(.HDR,8),$E(ECH),3) I (X'="") D
"RTN","HLTPCK2B",200,0)
 ..S X1=$G(^VA(200,ARY("DUZ"),20))
"RTN","HLTPCK2B",201,0)
 ..I (X1="") S:(ERR="") ERR="No Signature Code on File" Q
"RTN","HLTPCK2B",202,0)
 ..S X=$$UPPER^HLFNC(X)
"RTN","HLTPCK2B",203,0)
 ..D HASH^XUSHSHP
"RTN","HLTPCK2B",204,0)
 ..I ((X'=$P(X1,"^",4))!($P(X1,"^",2)="")) S:(ERR="") ERR="Invalid Electronic Signature Code" Q
"RTN","HLTPCK2B",205,0)
 ..S ARY("ESIG")=$P(X1,"^",2)
"RTN","HLTPCK2B",206,0)
 I $D(ARY) M HLREC=ARY
"RTN","HLTPCK2B",207,0)
 Q
"VER")
8.0^22.0
"^DD",772,772,6,0)
MESSAGE ID^F^^0;6^K:$L(X)>60!($L(X)<1) X
"^DD",772,772,6,1,0)
^.1^^-1
"^DD",772,772,6,1,2,0)
772^AH^MUMPS
"^DD",772,772,6,1,2,1)
S:$P(^HL(772,DA,0),"^",3) ^HL(772,"AH",$P(^(0),"^",3),X,DA)=""
"^DD",772,772,6,1,2,2)
K:$P(^HL(772,DA,0),"^",3) ^HL(772,"AH",$P(^(0),"^",3),X,DA)
"^DD",772,772,6,1,2,"%D",0)
^^3^3^2930514^
"^DD",772,772,6,1,2,"%D",1,0)
This cross reference is used in conjunction with the 'AG' cross reference
"^DD",772,772,6,1,2,"%D",2,0)
on the Non-DHCP Application field (#3) to look up and link initial HL7
"^DD",772,772,6,1,2,"%D",3,0)
messages with reply/acknowledgement messages.
"^DD",772,772,6,1,2,"DT")
2930202
"^DD",772,772,6,3)
Answer must be 1-60 characters in length
"^DD",772,772,6,21,0)
^^1^1^2930505^
"^DD",772,772,6,21,1,0)
The unique ID for this HL7 message.
"^DD",772,772,6,"DT")
3070801
"^DD",773,773,2,0)
MESSAGE ID^F^^0;2^K:$L(X)>60!($L(X)<1) X
"^DD",773,773,2,1,0)
^.1^^-1
"^DD",773,773,2,1,2,0)
773^AH^MUMPS
"^DD",773,773,2,1,2,1)
S:$P(^HLMA(DA,0),U,12) ^HLMA("AH",+$P(^(0),U,12),X,DA)=""
"^DD",773,773,2,1,2,2)
K:$P(^HLMA(DA,0),U,12) ^HLMA("AH",+$P(^(0),U,12),X,DA)
"^DD",773,773,2,1,2,3)
This x-reference is used in conjunction with the 'AG' x-ref on field 205
"^DD",773,773,2,1,2,"%D",0)
^^2^2^2980811^^^
"^DD",773,773,2,1,2,"%D",1,0)
This x-reference is used to look up the original message when processing
"^DD",773,773,2,1,2,"%D",2,0)
a response.
"^DD",773,773,2,1,2,"DT")
2980811
"^DD",773,773,2,3)
Answer must be 1-60 characters in length
"^DD",773,773,2,21,0)
^^1^1^2980414^^
"^DD",773,773,2,21,1,0)
This is an unique identifier associated with a message.
"^DD",773,773,2,"DT")
3070801
"^DD",869.3,869.3,0)
FIELD^^93^26
"^DD",869.3,869.3,0,"DDA")
N
"^DD",869.3,869.3,0,"DT")
3070130
"^DD",869.3,869.3,0,"IX","B",869.3,.01)

"^DD",869.3,869.3,0,"NM","HL COMMUNICATION SERVER PARAMETERS")

"^DD",869.3,869.3,0,"VRPK")
HL
"^DD",869.3,869.3,.01,0)
ONE^RNJ1,0^^0;1^K:+X'=X!(X>1)!(X<1)!(X?.E1"."1N.N) X
"^DD",869.3,869.3,.01,1,0)
^.1
"^DD",869.3,869.3,.01,1,1,0)
869.3^B
"^DD",869.3,869.3,.01,1,1,1)
S ^HLCS(869.3,"B",$E(X,1,30),DA)=""
"^DD",869.3,869.3,.01,1,1,2)
K ^HLCS(869.3,"B",$E(X,1,30),DA)
"^DD",869.3,869.3,.01,3)
Enter the number 1 (only one entry is allowed)
"^DD",869.3,869.3,.01,21,0)
^^1^1^2950515^^
"^DD",869.3,869.3,.01,21,1,0)
Stub field used to create one [and only one] entry
"^DD",869.3,869.3,.01,"DT")
2950515
"^DD",869.3,869.3,.02,0)
DOMAIN^P4.2'^DIC(4.2,^0;2^Q
"^DD",869.3,869.3,.02,3)
Enter the Domain Name of this environment
"^DD",869.3,869.3,.02,21,0)
^^4^4^2980427^
"^DD",869.3,869.3,.02,21,1,0)
The domain name for this environment must be unique to all environments
"^DD",869.3,869.3,.02,21,2,0)
running at your site. For example, if your production domain is
"^DD",869.3,869.3,.02,21,3,0)
SITE.MED.VA.GOV and this is your test system, you must have an entry in
"^DD",869.3,869.3,.02,21,4,0)
your domain file that is different such as TEST.SITE.MED.VA.GOV.
"^DD",869.3,869.3,.02,"DT")
2980427
"^DD",869.3,869.3,.03,0)
DEFAULT PROCESSING ID^RS^P:production;T:training;^0;3^Q
"^DD",869.3,869.3,.03,3)
Enter the default PROCESSING ID for this account.
"^DD",869.3,869.3,.03,21,0)
^^14^14^2991207^
"^DD",869.3,869.3,.03,21,1,0)
What type of environment is this account? The messaging system will not
"^DD",869.3,869.3,.03,21,2,0)
permit messages to be sent from one type of environment to a different
"^DD",869.3,869.3,.03,21,3,0)
type. The third Processing ID used by HL7 is DEBUG. This mode must be
"^DD",869.3,869.3,.03,21,4,0)
defined on the EVENT DRIVER protocol on both the sending and receiving
"^DD",869.3,869.3,.03,21,5,0)
systems.
"^DD",869.3,869.3,.03,21,6,0)
 
"^DD",869.3,869.3,.03,21,7,0)
An error will be logged when the PID for an inbound message is
"^DD",869.3,869.3,.03,21,8,0)
inappropriate for the receiving system.
"^DD",869.3,869.3,.03,21,9,0)
 
"^DD",869.3,869.3,.03,21,10,0)
Note: Ideally, TRAINING and PRODUCTION designations are maintained in
"^DD",869.3,869.3,.03,21,11,0)
separate accounts. Application processing routines should be aware of the
"^DD",869.3,869.3,.03,21,12,0)
PID field when processing a message. Routines designed for a production
"^DD",869.3,869.3,.03,21,13,0)
environment will probably want to process messages differently when
"^DD",869.3,869.3,.03,21,14,0)
TRAINING or DEBUG mode is set.
"^DD",869.3,869.3,.03,"DT")
2991207
"^DD",869.3,869.3,.04,0)
INSTITUTION^P4'^DIC(4,^0;4^Q
"^DD",869.3,869.3,.04,21,0)
^^3^3^2980428^
"^DD",869.3,869.3,.04,21,1,0)
This entry will be used in the sending facility field of HL7 message
"^DD",869.3,869.3,.04,21,2,0)
headers unless the application overrides this function by defining a
"^DD",869.3,869.3,.04,21,3,0)
facility in the Application Parameter file.
"^DD",869.3,869.3,.04,"DT")
2980428
"^DD",869.3,869.3,.05,0)
MAIL GROUP^P3.8^XMB(3.8,^0;5^Q
"^DD",869.3,869.3,.05,3)
To be used for alerts and notifications
"^DD",869.3,869.3,.05,21,0)
^^3^3^2980430^
"^DD",869.3,869.3,.05,21,1,0)
This mail group should contain local IRM staff responsible for monitoring
"^DD",869.3,869.3,.05,21,2,0)
the messaging system. This group will be used for delivery of alerts or
"^DD",869.3,869.3,.05,21,3,0)
notification of significant events related to Messaging System operations.
"^DD",869.3,869.3,.05,"DT")
2980430
"^DD",869.3,869.3,11,0)
DEFAULT NUMBER INCOMING FILERS^NJ2,0^^1;1^K:+X'=X!(X>99)!(X<1)!(X?.E1"."1N.N) X
"^DD",869.3,869.3,11,3)
Enter the default number of incoming filers
"^DD",869.3,869.3,11,21,0)
^^1^1^2950515^
"^DD",869.3,869.3,11,21,1,0)
This is the default number of background filers that will be started
"^DD",869.3,869.3,11,"DT")
2950515
"^DD",869.3,869.3,12,0)
DEFAULT NUMBER OUTGOING FILERS^NJ2,0^^1;2^K:+X'=X!(X>99)!(X<1)!(X?.E1"."1N.N) X
"^DD",869.3,869.3,12,3)
Enter the default number of outgoing filers
"^DD",869.3,869.3,12,21,0)
^^1^1^2950522^^
"^DD",869.3,869.3,12,21,1,0)
This is the default number of outgoing filers that will be started
"^DD",869.3,869.3,12,"DT")
2950522
"^DD",869.3,869.3,20,0)
INCOMING FILER TASK NUMBER^869.32^^2;0
"^DD",869.3,869.3,30,0)
OUTGOING FILER TASK NUMBER^869.33^^3;0
"^DD",869.3,869.3,41,0)
PURGE COMPLETED MESSAGES^NJ3,0^^4;1^K:+X'=X!(X>300)!(X<1)!(X?.E1"."1N.N) X
"^DD",869.3,869.3,41,3)
Type a Number to represent the days kept for "Successfully Completed" messages.  The default number of days is 7.
"^DD",869.3,869.3,41,21,0)
^.001^4^4^3010907^^^
"^DD",869.3,869.3,41,21,1,0)
The number of days "Successfully Completed" messages are retained before
"^DD",869.3,869.3,41,21,2,0)
they are purged.  If no value is entered, the default is 7 days.  Used as
"^DD",869.3,869.3,41,21,3,0)
the actual value when the "Purge Messages" option is scheduled through
"^DD",869.3,869.3,41,21,4,0)
TaskMan, and as the default when run interactively.
"^DD",869.3,869.3,41,"DT")
2990304
"^DD",869.3,869.3,42,0)
PURGE AWAITING ACK MESSAGES^NJ3,0^^4;2^K:+X'=X!(X>300)!(X<1)!(X?.E1"."1N.N) X
"^DD",869.3,869.3,42,3)
Type a Number representing the days kept for "AWAITING APPLICATION ACKNOWLEDGEMENT" messages. The default number of days is 30.
"^DD",869.3,869.3,42,21,0)
^^4^4^2990616^
"^DD",869.3,869.3,42,21,1,0)
The number of days "Awaiting Application Acknowledgement" messages are
"^DD",869.3,869.3,42,21,2,0)
retained before they are purged.  If no value is entered, the default
"^DD",869.3,869.3,42,21,3,0)
is 30 days.  Used as the actual value when the "Purge Messages" option is
"^DD",869.3,869.3,42,21,4,0)
scheduled through TaskMan, and as the default when run interactively.
"^DD",869.3,869.3,42,"DT")
2990304
"^DD",869.3,869.3,43,0)
PURGE ALL MESSAGES^NJ3,0^^4;3^K:+X'=X!(X>300)!(X<1)!(X?.E1"."1N.N) X
"^DD",869.3,869.3,43,3)
Type a Number representing the days kept for all messages regardless of status(except for ERROR status messages).  The default number of days is 90.
"^DD",869.3,869.3,43,21,0)
^^5^5^2990616^
"^DD",869.3,869.3,43,21,1,0)
The number of days that any status message are retained before they are
"^DD",869.3,869.3,43,21,2,0)
purged(except for ERROR status messages).  If no value is entered, the
"^DD",869.3,869.3,43,21,3,0)
default is 90 days.  Used as the actual value when the "Purge Messages"
"^DD",869.3,869.3,43,21,4,0)
option is scheduled through TaskMan, and as the default when run
"^DD",869.3,869.3,43,21,5,0)
interactively.
"^DD",869.3,869.3,43,"DT")
2990304
"^DD",869.3,869.3,44,0)
PURGE ERROR STATUS MESSAGES^NJ3,0^^4;4^K:+X'=X!(X>999)!(X<1)!(X?.E1"."1N.N) X
"^DD",869.3,869.3,44,3)
Type a Number to represent the days to keep error status messages messages.  The default number of days is 90.
"^DD",869.3,869.3,44,21,0)
^^4^4^3030210^
"^DD",869.3,869.3,44,21,1,0)
The number of days error status messages are retained before they are 
"^DD",869.3,869.3,44,21,2,0)
purged.  90 days is used as the actual value when the "Purge Messages" 
"^DD",869.3,869.3,44,21,3,0)
option is scheduled through TaskMan, and as the default when run 
"^DD",869.3,869.3,44,21,4,0)
interactively.
"^DD",869.3,869.3,44,"DT")
3030210
"^DD",869.3,869.3,51,0)
DEFAULT RETENTION^NJ6,0^^5;1^K:+X'=X!(X>999999)!(X<0)!(X?.E1"."1N.N) X
"^DD",869.3,869.3,51,3)
Type a Number between 0 and 999999, 0 Decimal Digits
"^DD",869.3,869.3,51,21,0)
^^14^14^2990614^^^^
"^DD",869.3,869.3,51,21,1,0)
Used by the TCP/IP Link Manager. The maximum time, in seconds,
"^DD",869.3,869.3,51,21,2,0)
in which the process supporting a non-persistent TCP/IP client
"^DD",869.3,869.3,51,21,3,0)
logical link will wait for new messages before terminating.
"^DD",869.3,869.3,51,21,4,0)
Upon expiration of the retention time, the process will terminate, 
"^DD",869.3,869.3,51,21,5,0)
and the logical link will become inactive and remain inactive
"^DD",869.3,869.3,51,21,6,0)
until further messages are queued.
"^DD",869.3,869.3,51,21,7,0)
 
"^DD",869.3,869.3,51,21,8,0)
The value entered here is the DEFAULT RETENTION time.  This value will
"^DD",869.3,869.3,51,21,9,0)
be used if the RETENTION field (#400.05) in the HL LOWER LEVEL PROTOCOL PARAMETER
"^DD",869.3,869.3,51,21,10,0)
file (#869.2) is not valued for a given LLP.
"^DD",869.3,869.3,51,21,11,0)
 
"^DD",869.3,869.3,51,21,12,0)
If no value has been entered in both DEFAULT RETENTION and RETENTION
"^DD",869.3,869.3,51,21,13,0)
fields for a given non-persistent LLP, a default time of 15 seconds
"^DD",869.3,869.3,51,21,14,0)
will be used as the retention time.
"^DD",869.3,869.3,51,"DT")
2990601
"^DD",869.3,869.3,52,0)
LINK MANAGER TASK NUMBER^NJ15,0^^5;2^K:+X'=X!(X>999999999999999)!(X<1)!(X?.E1"."1N.N) X
"^DD",869.3,869.3,52,3)
Type a Number between 1 and 999999999999999, 0 Decimal Digits
"^DD",869.3,869.3,52,21,0)
^^3^3^2990615^^
"^DD",869.3,869.3,52,21,1,0)
This field is internally edited by the Link Manager.  When the Link Manager
"^DD",869.3,869.3,52,21,2,0)
starts, this field is updated with the value of the Link Manager's task
"^DD",869.3,869.3,52,21,3,0)
number.
"^DD",869.3,869.3,52,"DT")
2990614
"^DD",869.3,869.3,53,0)
STOP LINK MANAGER^S^0:NO;1:YES;^5;3^Q
"^DD",869.3,869.3,53,3)
Enter YES if the Link Manager should be stopped
"^DD",869.3,869.3,53,21,0)
^^5^5^2990615^^^^
"^DD",869.3,869.3,53,21,1,0)
Flag indicating whether the Link Manager should be stopped.
"^DD",869.3,869.3,53,21,2,0)
This field is updated by the TCP/IP Link Manager as well
"^DD",869.3,869.3,53,21,3,0)
as through the TCP/IP Link Manager Start/Stop option.
"^DD",869.3,869.3,53,21,4,0)
Use this option rather than directly editing this field to
"^DD",869.3,869.3,53,21,5,0)
start/stop the TCP/IP Link Manager.
"^DD",869.3,869.3,53,"DT")
2990614
"^DD",869.3,869.3,54,0)
LM LAST KNOWN $H^F^^5;4^K:$L(X)>13!($L(X)<1)!'(X?1.7N1","1.5N) X
"^DD",869.3,869.3,54,3)
Answer must be 1-13 characters in length.
"^DD",869.3,869.3,54,21,0)
^^6^6^2990712^
"^DD",869.3,869.3,54,21,1,0)
This field is updated periodically by the Link Manager with the $Horolog
"^DD",869.3,869.3,54,21,2,0)
value at the time of the update.  The Systems Link Monitor uses
"^DD",869.3,869.3,54,21,3,0)
this information along with the LINK MANAGER TASK NUMBER
"^DD",869.3,869.3,54,21,4,0)
to determine whether the Link Manager is running.
"^DD",869.3,869.3,54,21,5,0)
Therefore, the use of this field should be restricted for internal use only
"^DD",869.3,869.3,54,21,6,0)
and should not edited.
"^DD",869.3,869.3,54,"DT")
2990706
"^DD",869.3,869.3,60,0)
LINK MONITOR VIEWS^869.31^^6;0
"^DD",869.3,869.3,60,21,0)
^^3^3^3000612^
"^DD",869.3,869.3,60,21,1,0)
Use this multiple to define VIEWS that can be used in the System Link
"^DD",869.3,869.3,60,21,2,0)
Monitor option.  A VIEW is a list of Logical Links to display in the
"^DD",869.3,869.3,60,21,3,0)
System Link Monitor.
"^DD",869.3,869.3,60,"DT")
3000530
"^DD",869.3,869.3,70,0)
PING IP^869.34^^7;0
"^DD",869.3,869.3,70,"DT")
3070130
"^DD",869.3,869.3,80,0)
PING DOMAIN (PARTIAL)^869.35^^8;0
"^DD",869.3,869.3,80,"DT")
3070130
"^DD",869.3,869.3,90,0)
DON'T PING PORT^869.36^^9;0
"^DD",869.3,869.3,91,0)
DON'T PING LINK NAME (PARTIAL)^869.391^^10;0
"^DD",869.3,869.3,91,"DT")
3070130
"^DD",869.3,869.3,92,0)
DON'T PING IP^869.392^^11;0
"^DD",869.3,869.3,93,0)
DON'T PING DOMAIN (FULL)^869.393^^12;0
"^DD",869.3,869.3,772,0)
LAST IEN, FILE 772^NJ10,0^^772;1^K:+X'=X!(X>9999999999)!(X<0)!(X?.E1"."1.N) X
"^DD",869.3,869.3,772,3)
Enter the last ien used for file 772.
"^DD",869.3,869.3,772,21,0)
^^2^2^3031104^
"^DD",869.3,869.3,772,21,1,0)
The node 772 should have no other fields.  It is used as a counter to assign
"^DD",869.3,869.3,772,21,2,0)
an ien to a new record.
"^DD",869.3,869.3,772,"DT")
3031104
"^DD",869.3,869.3,773,0)
LAST IEN, FILE 773^NJ10,0^^773;1^K:+X'=X!(X>9999999999)!(X<0)!(X?.E1"."1.N) X
"^DD",869.3,869.3,773,3)
Enter the last ien used for file 773.
"^DD",869.3,869.3,773,21,0)
^^2^2^3031104^
"^DD",869.3,869.3,773,21,1,0)
The node 773 should have no other fields.  It is used as a counter to assign
"^DD",869.3,869.3,773,21,2,0)
an ien to a new record.
"^DD",869.3,869.3,773,"DT")
3031104
"^DD",869.3,869.31,0)
LINK MONITOR VIEWS SUB-FIELD^^1^2
"^DD",869.3,869.31,0,"DT")
3000530
"^DD",869.3,869.31,0,"IX","B",869.31,.01)

"^DD",869.3,869.31,0,"NM","LINK MONITOR VIEWS")

"^DD",869.3,869.31,0,"UP")
869.3
"^DD",869.3,869.31,.01,0)
LINK MONITOR VIEWS^MF^^0;1^K:$L(X)>20!($L(X)<3) X
"^DD",869.3,869.31,.01,1,0)
^.1
"^DD",869.3,869.31,.01,1,1,0)
869.31^B
"^DD",869.3,869.31,.01,1,1,1)
S ^HLCS(869.3,DA(1),6,"B",$E(X,1,30),DA)=""
"^DD",869.3,869.31,.01,1,1,2)
K ^HLCS(869.3,DA(1),6,"B",$E(X,1,30),DA)
"^DD",869.3,869.31,.01,3)
Answer must be 3-20 characters in length
"^DD",869.3,869.31,.01,21,0)
^.001^2^2^3000530^^
"^DD",869.3,869.31,.01,21,1,0)
This multiple contains views of Logicial Links to be used with the
"^DD",869.3,869.31,.01,21,2,0)
System Link Monitor.
"^DD",869.3,869.31,.01,"DT")
3000601
"^DD",869.3,869.31,1,0)
LOGICAL LINK^869.311PA^^1;0
"^DD",869.3,869.311,0)
LOGICAL LINK SUB-FIELD^^1^2
"^DD",869.3,869.311,0,"DT")
3000530
"^DD",869.3,869.311,0,"IX","B",869.311,.01)

"^DD",869.3,869.311,0,"NM","LOGICAL LINK")

"^DD",869.3,869.311,0,"UP")
869.31
"^DD",869.3,869.311,.01,0)
LOGICAL LINK^MRP870'X^HLCS(870,^0;1^S DINUM=+X
"^DD",869.3,869.311,.01,1,0)
^.1
"^DD",869.3,869.311,.01,1,1,0)
869.311^B
"^DD",869.3,869.311,.01,1,1,1)
S ^HLCS(869.3,DA(2),6,DA(1),1,"B",$E(X,1,30),DA)=""
"^DD",869.3,869.311,.01,1,1,2)
K ^HLCS(869.3,DA(2),6,DA(1),1,"B",$E(X,1,30),DA)
"^DD",869.3,869.311,.01,"DT")
3000530
"^DD",869.3,869.311,1,0)
DISPLAY ORDER^NJ4,1^^0;2^K:+X'=X!(X>99)!(X<1)!(X?.E1"."2N.N) X
"^DD",869.3,869.311,1,1,0)
^.1^^0
"^DD",869.3,869.311,1,3)
Type a Number between 1 and 99, 1 Decimal Digit
"^DD",869.3,869.311,1,21,0)
^^2^2^3000530^
"^DD",869.3,869.311,1,21,1,0)
This field determines the order to display the Logical Links in the System
"^DD",869.3,869.311,1,21,2,0)
Link Monitor.
"^DD",869.3,869.311,1,"DT")
3000530
"^DD",869.3,869.32,0)
INCOMING FILER TASK NUMBER SUB-FIELD^^.03^3
"^DD",869.3,869.32,0,"DT")
2950522
"^DD",869.3,869.32,0,"IX","B",869.32,.01)

"^DD",869.3,869.32,0,"NM","INCOMING FILER TASK NUMBER")

"^DD",869.3,869.32,0,"UP")
869.3
"^DD",869.3,869.32,.01,0)
INCOMING FILER TASK NUMBER^MNJ15,0^^0;1^K:+X'=X!(X>999999999999999)!(X<1)!(X?.E1"."1N.N) X
"^DD",869.3,869.32,.01,1,0)
^.1
"^DD",869.3,869.32,.01,1,1,0)
869.32^B
"^DD",869.3,869.32,.01,1,1,1)
S ^HLCS(869.3,DA(1),2,"B",$E(X,1,30),DA)=""
"^DD",869.3,869.32,.01,1,1,2)
K ^HLCS(869.3,DA(1),2,"B",$E(X,1,30),DA)
"^DD",869.3,869.32,.01,3)
Enter the task number of an incoming filer
"^DD",869.3,869.32,.01,21,0)
^^1^1^2950515^
"^DD",869.3,869.32,.01,21,1,0)
This is the task number of an incoming filer
"^DD",869.3,869.32,.01,"DT")
2950515
"^DD",869.3,869.32,.02,0)
STOP FILER^S^0:NO;1:YES;^0;2^Q
"^DD",869.3,869.32,.02,3)
Enter YES if this filer should be stopped
"^DD",869.3,869.32,.02,21,0)
^^2^2^2950522^^
"^DD",869.3,869.32,.02,21,1,0)
Flag indicating if the incoming filer associated with this entry should
"^DD",869.3,869.32,.02,21,2,0)
stop
"^DD",869.3,869.32,.02,"DT")
2950515
"^DD",869.3,869.32,.03,0)
LAST KNOWN $H^F^^0;3^K:$L(X)>13!($L(X)<1)!'(X?1.7N1","1.5N) X
"^DD",869.3,869.32,.03,3)
Enter a value for $H
"^DD",869.3,869.32,.03,21,0)
^^2^2^2950522^^
"^DD",869.3,869.32,.03,21,1,0)
This is the last value of $H that the incoming filer associated with this
"^DD",869.3,869.32,.03,21,2,0)
entry recognized
"^DD",869.3,869.32,.03,"DT")
2950522
"^DD",869.3,869.33,0)
OUTGOING FILER TASK NUMBER SUB-FIELD^^.03^3
"^DD",869.3,869.33,0,"DT")
2950522
"^DD",869.3,869.33,0,"IX","B",869.33,.01)

"^DD",869.3,869.33,0,"NM","OUTGOING FILER TASK NUMBER")

"^DD",869.3,869.33,0,"UP")
869.3
"^DD",869.3,869.33,.01,0)
OUTGOING FILER TASK NUMBER^MNJ15,0^^0;1^K:+X'=X!(X>999999999999999)!(X<1)!(X?.E1"."1N.N) X
"^DD",869.3,869.33,.01,1,0)
^.1
"^DD",869.3,869.33,.01,1,1,0)
869.33^B
"^DD",869.3,869.33,.01,1,1,1)
S ^HLCS(869.3,DA(1),3,"B",$E(X,1,30),DA)=""
"^DD",869.3,869.33,.01,1,1,2)
K ^HLCS(869.3,DA(1),3,"B",$E(X,1,30),DA)
"^DD",869.3,869.33,.01,3)
Enter the task number of an outgoing filer
"^DD",869.3,869.33,.01,21,0)
^^1^1^2950516^
"^DD",869.3,869.33,.01,21,1,0)
This is the task number of an outgoing filer
"^DD",869.3,869.33,.01,"DT")
2950516
"^DD",869.3,869.33,.02,0)
STOP FILER^S^0:NO;1:YES;^0;2^Q
"^DD",869.3,869.33,.02,3)
Enter YES if this filer should be stopped
"^DD",869.3,869.33,.02,21,0)
^^2^2^2950516^
"^DD",869.3,869.33,.02,21,1,0)
Flag indicating if the outgoing filer associated with this entry should
"^DD",869.3,869.33,.02,21,2,0)
stop
"^DD",869.3,869.33,.02,"DT")
2950516
"^DD",869.3,869.33,.03,0)
LAST KNOWN $H^F^^0;3^K:$L(X)>13!($L(X)<1)!'(X?1.7N1","1.5N) X
"^DD",869.3,869.33,.03,3)
Enter a value for $H
"^DD",869.3,869.33,.03,21,0)
^^2^2^2950522^^
"^DD",869.3,869.33,.03,21,1,0)
This is the last value of $H that the outgoing filer associated with this
"^DD",869.3,869.33,.03,21,2,0)
entry recognized
"^DD",869.3,869.33,.03,"DT")
2950522
"^DD",869.3,869.34,0)
PING IP SUB-FIELD^^.01^1
"^DD",869.3,869.34,0,"DT")
3070129
"^DD",869.3,869.34,0,"IX","B",869.34,.01)

"^DD",869.3,869.34,0,"NM","PING IP")

"^DD",869.3,869.34,0,"UP")
869.3
"^DD",869.3,869.34,.01,0)
PING IP^MF^^0;1^K:$L(X)>240!($L(X)<7) X
"^DD",869.3,869.34,.01,1,0)
^.1
"^DD",869.3,869.34,.01,1,1,0)
869.34^B
"^DD",869.3,869.34,.01,1,1,1)
S ^HLCS(869.3,DA(1),7,"B",$E(X,1,30),DA)=""
"^DD",869.3,869.34,.01,1,1,2)
K ^HLCS(869.3,DA(1),7,"B",$E(X,1,30),DA)
"^DD",869.3,869.34,.01,3)
Multiple IP addresses may be entered, separated by "," as delimiter.
"^DD",869.3,869.34,.01,21,0)
^^8^8^3070130^
"^DD",869.3,869.34,.01,21,1,0)
Use this multiple to enter the IP address which is allowed to "ping,"
"^DD",869.3,869.34,.01,21,2,0)
using the "Ping (TCP Only)" option, for pinging Vista site with Vista HL7 
"^DD",869.3,869.34,.01,21,3,0)
installed. Multiple IP addresses may be entered, separated by "," as
"^DD",869.3,869.34,.01,21,4,0)
delimiter.
"^DD",869.3,869.34,.01,21,5,0)
 
"^DD",869.3,869.34,.01,21,6,0)
It is not necessary to enter an IP address here for a link with a domain
"^DD",869.3,869.34,.01,21,7,0)
containing the partial domain which has been entered in the "PING DOMAIN
"^DD",869.3,869.34,.01,21,8,0)
(PARTIAL)" multiple. 
"^DD",869.3,869.34,.01,"DT")
3070130
"^DD",869.3,869.35,0)
PING DOMAIN (PARTIAL) SUB-FIELD^^.01^1
"^DD",869.3,869.35,0,"DT")
3070129
"^DD",869.3,869.35,0,"IX","B",869.35,.01)

"^DD",869.3,869.35,0,"NM","PING DOMAIN (PARTIAL)")

"^DD",869.3,869.35,0,"UP")
869.3
"^DD",869.3,869.35,.01,0)
PING DOMAIN (PARTIAL)^MF^^0;1^K:$L(X)>240!($L(X)<7) X
"^DD",869.3,869.35,.01,1,0)
^.1
"^DD",869.3,869.35,.01,1,1,0)
869.35^B
"^DD",869.3,869.35,.01,1,1,1)
S ^HLCS(869.3,DA(1),8,"B",$E(X,1,30),DA)=""
"^DD",869.3,869.35,.01,1,1,2)
K ^HLCS(869.3,DA(1),8,"B",$E(X,1,30),DA)
"^DD",869.3,869.35,.01,3)
Multiple partial or full domain names may be entered, separated by "," as delimiter.
"^DD",869.3,869.35,.01,21,0)
^.001^6^6^3070130^^
"^DD",869.3,869.35,.01,21,1,0)
Use this multiple to enter the partial or full domain name, such as
"^DD",869.3,869.35,.01,21,2,0)
"MED.VA.GOV" which is allowed to "ping," using the "Ping (TCP Only)"
"^DD",869.3,869.35,.01,21,3,0)
option, for pinging Vista site with Vista HL7 installed.
"^DD",869.3,869.35,.01,21,4,0)
 
"^DD",869.3,869.35,.01,21,5,0)
Multiple partial or full domain names may be entered, separated by "," as
"^DD",869.3,869.35,.01,21,6,0)
delimiter.
"^DD",869.3,869.35,.01,"DT")
3070130
"^DD",869.3,869.36,0)
DON'T PING PORT SUB-FIELD^^.01^1
"^DD",869.3,869.36,0,"DT")
3070130
"^DD",869.3,869.36,0,"IX","B",869.36,.01)

"^DD",869.3,869.36,0,"NM","DON'T PING PORT")

"^DD",869.3,869.36,0,"UP")
869.3
"^DD",869.3,869.36,.01,0)
DON'T PING PORT^MF^^0;1^K:$L(X)>240!($L(X)<1) X
"^DD",869.3,869.36,.01,1,0)
^.1
"^DD",869.3,869.36,.01,1,1,0)
869.36^B
"^DD",869.3,869.36,.01,1,1,1)
S ^HLCS(869.3,DA(1),9,"B",$E(X,1,30),DA)=""
"^DD",869.3,869.36,.01,1,1,2)
K ^HLCS(869.3,DA(1),9,"B",$E(X,1,30),DA)
"^DD",869.3,869.36,.01,3)
Multiple port numbers may be entered, separated by "," as delimiter.
"^DD",869.3,869.36,.01,21,0)
^^4^4^3070130^
"^DD",869.3,869.36,.01,21,1,0)
Use this multiple to enter the port number, for those links which are not
"^DD",869.3,869.36,.01,21,2,0)
allowed to "ping," using the "Ping (TCP Only)" option.
"^DD",869.3,869.36,.01,21,3,0)
 
"^DD",869.3,869.36,.01,21,4,0)
Multiple port numbers may be entered, separated by "," as delimiter.
"^DD",869.3,869.36,.01,"DT")
3070130
"^DD",869.3,869.391,0)
DON'T PING LINK NAME (PARTIAL) SUB-FIELD^^.01^1
"^DD",869.3,869.391,0,"DT")
3070130
"^DD",869.3,869.391,0,"IX","B",869.391,.01)

"^DD",869.3,869.391,0,"NM","DON'T PING LINK NAME (PARTIAL)")

"^DD",869.3,869.391,0,"UP")
869.3
"^DD",869.3,869.391,.01,0)
DON'T PING LINK NAME (PARTIAL)^MF^^0;1^K:$L(X)>240!($L(X)<3) X
"^DD",869.3,869.391,.01,1,0)
^.1
"^DD",869.3,869.391,.01,1,1,0)
869.391^B
"^DD",869.3,869.391,.01,1,1,1)
S ^HLCS(869.3,DA(1),10,"B",$E(X,1,30),DA)=""
"^DD",869.3,869.391,.01,1,1,2)
K ^HLCS(869.3,DA(1),10,"B",$E(X,1,30),DA)
"^DD",869.3,869.391,.01,3)
Multiple partial or full link names may be entered, separated by "," as delimiter.
"^DD",869.3,869.391,.01,21,0)
^^5^5^3070130^
"^DD",869.3,869.391,.01,21,1,0)
Use this multiple to enter the partial or full link name, for those links
"^DD",869.3,869.391,.01,21,2,0)
which are not allowed to "ping," using the "Ping (TCP Only)" option.
"^DD",869.3,869.391,.01,21,3,0)
 
"^DD",869.3,869.391,.01,21,4,0)
Multiple partial or full link names may be entered, separated by "," as
"^DD",869.3,869.391,.01,21,5,0)
delimiter.
"^DD",869.3,869.391,.01,"DT")
3070130
"^DD",869.3,869.392,0)
DON'T PING IP SUB-FIELD^^.01^1
"^DD",869.3,869.392,0,"DT")
3070130
"^DD",869.3,869.392,0,"IX","B",869.392,.01)

"^DD",869.3,869.392,0,"NM","DON'T PING IP")

"^DD",869.3,869.392,0,"UP")
869.3
"^DD",869.3,869.392,.01,0)
DON'T PING IP^MF^^0;1^K:$L(X)>240!($L(X)<7) X
"^DD",869.3,869.392,.01,1,0)
^.1
"^DD",869.3,869.392,.01,1,1,0)
869.392^B
"^DD",869.3,869.392,.01,1,1,1)
S ^HLCS(869.3,DA(1),11,"B",$E(X,1,30),DA)=""
"^DD",869.3,869.392,.01,1,1,2)
K ^HLCS(869.3,DA(1),11,"B",$E(X,1,30),DA)
"^DD",869.3,869.392,.01,3)
Multiple IP addresses may be entered, separated by "," as delimiter.
"^DD",869.3,869.392,.01,21,0)
^^4^4^3070130^
"^DD",869.3,869.392,.01,21,1,0)
Use this multiple to enter the IP address, for those links which are not
"^DD",869.3,869.392,.01,21,2,0)
allowed to "ping," using the "Ping (TCP Only)" option.
"^DD",869.3,869.392,.01,21,3,0)
 
"^DD",869.3,869.392,.01,21,4,0)
Multiple IP addresses may be entered, separated by "," as delimiter.    
"^DD",869.3,869.392,.01,"DT")
3070130
"^DD",869.3,869.393,0)
DON'T PING DOMAIN (FULL) SUB-FIELD^^.01^1
"^DD",869.3,869.393,0,"DT")
3070130
"^DD",869.3,869.393,0,"IX","B",869.393,.01)

"^DD",869.3,869.393,0,"NM","DON'T PING DOMAIN (FULL)")

"^DD",869.3,869.393,0,"UP")
869.3
"^DD",869.3,869.393,.01,0)
DON'T PING DOMAIN (FULL)^MF^^0;1^K:$L(X)>240!($L(X)<7) X
"^DD",869.3,869.393,.01,1,0)
^.1
"^DD",869.3,869.393,.01,1,1,0)
869.393^B
"^DD",869.3,869.393,.01,1,1,1)
S ^HLCS(869.3,DA(1),12,"B",$E(X,1,30),DA)=""
"^DD",869.3,869.393,.01,1,1,2)
K ^HLCS(869.3,DA(1),12,"B",$E(X,1,30),DA)
"^DD",869.3,869.393,.01,3)
Multiple full domain names may be entered, separated by "," as delimiter.
"^DD",869.3,869.393,.01,21,0)
^^4^4^3070130^
"^DD",869.3,869.393,.01,21,1,0)
Use this multiple to enter full domain name, for those links which are not
"^DD",869.3,869.393,.01,21,2,0)
allowed to "ping," using the "Ping (TCP Only)" option.
"^DD",869.3,869.393,.01,21,3,0)
 
"^DD",869.3,869.393,.01,21,4,0)
Multiple full domain names may be entered, separated by "," as delimiter.
"^DD",869.3,869.393,.01,"DT")
3070130
"^DD",870,870,0)
FIELD^^1^51
"^DD",870,870,0,"DDA")
N
"^DD",870,870,0,"DT")
3070801
"^DD",870,870,0,"IX","AISTAT",870.019,1)

"^DD",870,870,0,"IX","ALLP",870,2)

"^DD",870,870,0,"IX","B",870,.01)

"^DD",870,870,0,"IX","C",870,.02)

"^DD",870,870,0,"IX","D",870,.03)

"^DD",870,870,0,"IX","E",870,400.03)

"^DD",870,870,0,"NM","HL LOGICAL LINK")

"^DD",870,870,0,"PT",101,770.7)

"^DD",870,870,0,"PT",772,11)

"^DD",870,870,0,"PT",773,7)

"^DD",870,870,0,"PT",773,17)

"^DD",870,870,0,"PT",774.01,3)

"^DD",870,870,0,"PT",774.02,.02)

"^DD",870,870,0,"PT",779.1,.1)

"^DD",870,870,0,"PT",779.2,.09)

"^DD",870,870,0,"PT",779.41,.02)

"^DD",870,870,0,"PT",869.311,.01)

"^DD",870,870,0,"VRPK")
HL
"^DD",870,870,.01,0)
NODE^RF^^0;1^K:$L(X)>10!($L(X)<3)!'(X'?1P.E) X
"^DD",870,870,.01,1,0)
^.1^^-1
"^DD",870,870,.01,1,1,0)
870^B
"^DD",870,870,.01,1,1,1)
S ^HLCS(870,"B",$E(X,1,30),DA)=""
"^DD",870,870,.01,1,1,2)
K ^HLCS(870,"B",$E(X,1,30),DA)
"^DD",870,870,.01,3)
Enter the name of the logical link (3-10 characters)
"^DD",870,870,.01,21,0)
^^5^5^2990217^^^^
"^DD",870,870,.01,21,1,0)
This is the name of the logical link that data will be communicated on.
"^DD",870,870,.01,21,2,0)
It is this name that will be displayed in the "NODE" column of the
"^DD",870,870,.01,21,3,0)
SYSTEMS LINK MONITOR display option.
"^DD",870,870,.01,21,4,0)
It is suggested that this name be the same name as the commercial
"^DD",870,870,.01,21,5,0)
application e.g. KURZWEIL1,KURZWEIL2,COPATH, or SUNQUEST1.
"^DD",870,870,.01,"DT")
3050308
"^DD",870,870,.02,0)
INSTITUTION^P4'X^DIC(4,^0;2^K:$O(^HLCS(870,"C",X,0)) X
"^DD",870,870,.02,1,0)
^.1
"^DD",870,870,.02,1,1,0)
870^C
"^DD",870,870,.02,1,1,1)
S ^HLCS(870,"C",$E(X,1,30),DA)=""
"^DD",870,870,.02,1,1,2)
K ^HLCS(870,"C",$E(X,1,30),DA)
"^DD",870,870,.02,1,1,"DT")
2970123
"^DD",870,870,.02,3)
Select an institution that has not been associated with another link.
"^DD",870,870,.02,21,0)
^^5^5^2990804^
"^DD",870,870,.02,21,1,0)
It may be necessary for an application to determine the appropriate link
"^DD",870,870,.02,21,2,0)
to use when the only information it has is the institution. This field is
"^DD",870,870,.02,21,3,0)
used to associate a link with that institution. There is a 1:1
"^DD",870,870,.02,21,4,0)
correspondence between institution and logical link. An institution cannot
"^DD",870,870,.02,21,5,0)
be associated with more than one logical link.
"^DD",870,870,.02,"DT")
3040528
"^DD",870,870,.03,0)
MAILMAN DOMAIN^P4.2'X^DIC(4.2,^0;7^K:$O(^HLCS(870,"D",X,0)) X
"^DD",870,870,.03,1,0)
^.1^^-1
"^DD",870,870,.03,1,1,0)
870^D
"^DD",870,870,.03,1,1,1)
S ^HLCS(870,"D",$E(X,1,30),DA)=""
"^DD",870,870,.03,1,1,2)
K ^HLCS(870,"D",$E(X,1,30),DA)
"^DD",870,870,.03,1,1,"DT")
2980321
"^DD",870,870,.03,3)
Enter the Mailman domain corresponding to this link.
"^DD",870,870,.03,21,0)
^^2^2^3040528^^
"^DD",870,870,.03,21,1,0)
Either this field or the OTHER DOMAIN field should have a value.  The domain is
"^DD",870,870,.03,21,2,0)
used to formulate the RECEIVING FACILITY field of the message header.
"^DD",870,870,.03,"DT")
3050308
"^DD",870,870,.08,0)
DNS DOMAIN^FX^^0;8^K:$L(X)>70!($L(X)<4) X S HLIP=$$ADDRESS^XLFNSLK(X) K:('HLIP)&($P($G(^HLCS(869.3,1,0)),"^",3)="P")&($P($$SITE^VASITE,"^",3)) X I HLIP S HLIP=$$IP^HLMA3(DA,HLIP)
"^DD",870,870,.08,3)
Enter the full domain name as registered with DNS.
"^DD",870,870,.08,21,0)
^.001^1^1^3041221^^^
"^DD",870,870,.08,21,1,0)
The domain name as registered with DNS.
"^DD",870,870,.08,"DT")
3050309
"^DD",870,870,1,0)
DESCRIPTION^870.02^^3;0
"^DD",870,870,1,3)
Enter a description for this link
"^DD",870,870,1,21,0)
^^1^1^3070629^
"^DD",870,870,1,21,1,0)
This field contains a brief explanation of this link.
"^DD",870,870,2,0)
LLP TYPE^RP869.1'^HLCS(869.1,^0;3^Q
"^DD",870,870,2,1,0)
^.1^^-1
"^DD",870,870,2,1,1,0)
870^ALLP
"^DD",870,870,2,1,1,1)
S ^HLCS(870,"ALLP",$E(X,1,30),DA)=""
"^DD",870,870,2,1,1,2)
K ^HLCS(870,"ALLP",$E(X,1,30),DA)
"^DD",870,870,2,1,1,"%D",0)
^^3^3^2950227^
"^DD",870,870,2,1,1,"%D",1,0)
This cross-reference is used to link the HL Lower Layer Parameter
"^DD",870,870,2,1,1,"%D",2,0)
file (#869.2) with the HL Logical Link file. Using this x-ref you can
"^DD",870,870,2,1,1,"%D",3,0)
locate the parameter associated with this link.
"^DD",870,870,2,1,1,"DT")
2950227
"^DD",870,870,2,3)
Enter the  LLP used for this logical link.
"^DD",870,870,2,21,0)
^.001^4^4^3040826^^
"^DD",870,870,2,21,1,0)
Enter the type of Lower Level Protocol for this logical link. Selection of
"^DD",870,870,2,21,2,0)
TCP implies that the MLLP protocol will be used. Each of the supported
"^DD",870,870,2,21,3,0)
LLP's are described in detail in Appendix C of the HL7 Implementation
"^DD",870,870,2,21,4,0)
Guide.
"^DD",870,870,2,"DT")
3050308
"^DD",870,870,3,0)
DEVICE TYPE^S^PC:Persistent Client;NC:Non-Persistent Client;SS:Single-threaded Server;MS:Multi-threaded Server;SH:Serial HLLP;SX:Serial X3.28;MM:MailMan;^0;4^Q
"^DD",870,870,3,1,0)
^.1^^0
"^DD",870,870,3,3)
Not editable from any user option. See field description.
"^DD",870,870,3,21,0)
^.001^3^3^3040826^^^^
"^DD",870,870,3,21,1,0)
This field is not editable from any user option. It is used purely
"^DD",870,870,3,21,2,0)
for display purposes in the DEVICE TYPE column of the SYSTEMS LINK
"^DD",870,870,3,21,3,0)
MONITOR display option.
"^DD",870,870,3,"DT")
3030710
"^DD",870,870,4,0)
STATE^F^^0;5^K:$L(X)>60!($L(X)<1) X
"^DD",870,870,4,3)
Answer must be 1-60 characters in length
"^DD",870,870,4,21,0)
^^3^3^3070801^
"^DD",870,870,4,21,1,0)
This field is not editable from any user option. It is used purely for
"^DD",870,870,4,21,2,0)
display purposes in the STATE column of the SYSTEMS LINK MONITOR
"^DD",870,870,4,21,3,0)
display option.
"^DD",870,870,4,"DT")
3070801
"^DD",870,870,4.5,0)
AUTOSTART^S^0:Disabled;1:Enabled;^0;6^Q
"^DD",870,870,4.5,21,0)
^^2^2^2980831^^
"^DD",870,870,4.5,21,1,0)
This field permits the link to be restarted by Taskman after a system
"^DD",870,870,4.5,21,2,0)
reboot. If disabled, the link will not be restarted.
"^DD",870,870,4.5,"DT")
2961120
"^DD",870,870,4.9,0)
STOP PROCESSING IN-QUEUE^S^0:NO;1:YES;^0;9^Q
"^DD",870,870,4.9,3)
Setting this field to 'Y' prevents the incoming filer from processing the incoming messages queued in this link. 
"^DD",870,870,4.9,21,0)
^.001^2^2^3060718^^
"^DD",870,870,4.9,21,1,0)
Setting this field to 'Y' prevents the incoming filer from processing the 
"^DD",870,870,4.9,21,2,0)
incoming messages queued in this link.
"^DD",870,870,4.9,"DT")
3060718
"^DD",870,870,5,0)
IN QUEUE FRONT POINTER^NJ14,0^^IN QUEUE FRONT POINTER;1^K:+X'=X!(X>99999999999999)!(X<0)!(X?.E1"."1N.N) X
"^DD",870,870,5,3)
This field is not editable from any user option. See Field Description.
"^DD",870,870,5,21,0)
^^2^2^3041221^
"^DD",870,870,5,21,1,0)
The queue structure relies on two queues, INcoming and OUTgoing.
"^DD",870,870,5,21,2,0)
This pointer is used to point to the first message in the FIFO queue.
"^DD",870,870,5,"DT")
3041221
"^DD",870,870,6,0)
IN QUEUE BACK POINTER^NJ14,0^^IN QUEUE BACK POINTER;1^K:+X'=X!(X>99999999999999)!(X<0)!(X?.E1"."1N.N) X
"^DD",870,870,6,3)
Type a Number between 0 and 99999999999999, 0 Decimal Digits
"^DD",870,870,6,21,0)
^^2^2^3041221^
"^DD",870,870,6,21,1,0)
The queue structure relies on two queues-INcoming and OUTgoing.
"^DD",870,870,6,21,2,0)
This pointer points to the last message in the FIFO queue.
"^DD",870,870,6,"DT")
3041221
"^DD",870,870,7,0)
OUT QUEUE FRONT POINTER^NJ14,0^^OUT QUEUE FRONT POINTER;1^K:+X'=X!(X>99999999999999)!(X<0)!(X?.E1"."1N.N) X
"^DD",870,870,7,3)
This field is not editable from any user option. See Field Description.
"^DD",870,870,7,21,0)
^^2^2^3041221^
"^DD",870,870,7,21,1,0)
The queue structure relies on two queues-INcoming and OUTgoing.
"^DD",870,870,7,21,2,0)
This pointer points to the first message in the FIFO queue.
"^DD",870,870,7,"DT")
3041221
"^DD",870,870,8,0)
OUT QUEUE BACK POINTER^NJ14,0^^OUT QUEUE BACK POINTER;1^K:+X'=X!(X>99999999999999)!(X<0)!(X?.E1"."1N.N) X
"^DD",870,870,8,3)
This field is not editable from any user option. See field description.
"^DD",870,870,8,21,0)
^^2^2^3041221^
"^DD",870,870,8,21,1,0)
The queue structure relies on two queues, INcoming and OUTgoing.
"^DD",870,870,8,21,2,0)
This pointer points to the last message in the FIFO queue.
"^DD",870,870,8,"DT")
3041221
"^DD",870,870,9,0)
TIME STARTED^D^^0;10^S %DT="EST" D ^%DT S X=Y K:Y<1 X
"^DD",870,870,9,3)
This field is not editable from any user option. See Field Description.
"^DD",870,870,9,21,0)
^^3^3^2950222^^^^
"^DD",870,870,9,21,1,0)
This field contains the Date/Time the Lower Layer Protocol was
"^DD",870,870,9,21,2,0)
last launched for the Logical Link. Only applicable to Lower Layer
"^DD",870,870,9,21,3,0)
Protocols, not Mailman.
"^DD",870,870,9,"DT")
2941006
"^DD",870,870,10,0)
TIME STOPPED^D^^0;11^S %DT="EST" D ^%DT S X=Y K:Y<1 X
"^DD",870,870,10,3)
This field is not editable from any user option. See Field Description.
"^DD",870,870,10,21,0)
^^3^3^2941212^^^
"^DD",870,870,10,21,1,0)
This field contains the Date/Time the Lower Layer Protocol was
"^DD",870,870,10,21,2,0)
last shutdown for the Logical Link. Only applicable to Lower Layer
"^DD",870,870,10,21,3,0)
Protocols, not Mailman.
"^DD",870,870,10,"DT")
2941006
"^DD",870,870,11,0)
TASK NUMBER^NJ15,0^^0;12^K:+X'=X!(X>999999999999999)!(X<1)!(X?.E1"."1N.N) X
"^DD",870,870,11,3)
This field is not editable from any user option. See Field Description.
"^DD",870,870,11,21,0)
^^2^2^2941212^^^
"^DD",870,870,11,21,1,0)
This is the task number assigned by TaskMan when the Lower Layer Protocol
"^DD",870,870,11,21,2,0)
is launched in the background.
"^DD",870,870,11,"DT")
2941006
"^DD",870,870,14,0)
SHUTDOWN LLP ?^S^0:NO;1:YES;^0;15^Q
"^DD",870,870,14,3)
Setting this field to 'Y' through the STOP HYBRID LLP option, shuts down the lower layer protocol and closes the device.
"^DD",870,870,14,21,0)
^^3^3^2950222^^^^
"^DD",870,870,14,21,1,0)
This field is editable through the STOP HYBRID LLP option. When the
"^DD",870,870,14,21,2,0)
Lower Layer Protocol is running, and this field is set to 'Y' the
"^DD",870,870,14,21,3,0)
Lower Layer Protocol will shutdown and close the device.
"^DD",870,870,14,"DT")
2950222
"^DD",870,870,16,0)
SHUTDOWN OUTGOING HLO MESSAGES^S^0:NO;1:YES;^0;16^Q
"^DD",870,870,16,3)
Enter YES to stop HLO messages from being transmitted to this destinations.
"^DD",870,870,16,21,0)
^^2^2^3050914^
"^DD",870,870,16,21,1,0)
This field affects only HLO messages.
"^DD",870,870,16,21,2,0)

"^DD",870,870,16,"DT")
3050914
"^DD",870,870,18,0)
GROSS COMMUNICATIONS ERROR^P771.7'^HL(771.7,^0;19^Q
"^DD",870,870,18,3)
This field contains the most recent communications error which has occured on a particular link.
"^DD",870,870,18,21,0)
^^10^10^2941213^^^^
"^DD",870,870,18,21,1,0)
This field contains the most recent gross communications error. It
"^DD",870,870,18,21,2,0)
serves a two purposes. It is a flag for the SYSTEMS LINK MONITOR.
"^DD",870,870,18,21,3,0)
In other words, if this field is defined it means a communications
"^DD",870,870,18,21,4,0)
error has occured on the link. This is indicated by the NODE field
"^DD",870,870,18,21,5,0)
flashing on the SYSTEMS LINK MONITOR. 
"^DD",870,870,18,21,6,0)
The error can be viewed by using the SHOW COMMUNICATION ERROR option.
"^DD",870,870,18,21,7,0)
The error can be cleared by using the CLEAR COMMUNICATION ERROR option.
"^DD",870,870,18,21,8,0)
If set, an error occurred while transmitting (timeout for example).
"^DD",870,870,18,21,9,0)
This field can be viewed using the 'Show Gross LLP Error' and cleared
"^DD",870,870,18,21,10,0)
using the 'Clear Gross LLP Error' options.
"^DD",870,870,18,"DT")
2941213
"^DD",870,870,19,0)
IN QUEUE^870.019^^1;0
"^DD",870,870,19,21,0)
^^1^1^3050414^
"^DD",870,870,19,21,1,0)
This multiple contains the queue for incoming messages.
"^DD",870,870,19,"DT")
3041012
"^DD",870,870,20,0)
OUT QUEUE^870.01A^^2;0
"^DD",870,870,20,21,0)
^^1^1^3050414^
"^DD",870,870,20,21,1,0)
This multiple contains the queue for outgoing messages.
"^DD",870,870,20,"DT")
3041012
"^DD",870,870,21,0)
QUEUE SIZE^NJ6,0^^0;21^K:+X'=X!(X>100000)!(X<2)!(X?.E1"."1N.N) X
"^DD",870,870,21,3)
Type a Number between 2 and 100000, 0 Decimal Digits
"^DD",870,870,21,21,0)
^^3^3^3041221^
"^DD",870,870,21,21,1,0)
This is the steady-state size of the queue. The queue may dynamically
"^DD",870,870,21,21,2,0)
grow beyond this size, under certain conditions. See Users Manual, for
"^DD",870,870,21,21,3,0)
more information.
"^DD",870,870,21,"DT")
3041221
"^DD",870,870,100.01,0)
MAIL GROUP^P3.8^XMB(3.8,^100;1^Q
"^DD",870,870,100.01,3)
Enter the mail group that messages should be sent to.
"^DD",870,870,100.01,21,0)
^^10^10^2990707^
"^DD",870,870,100.01,21,1,0)
If you are building a logical link that will use Mailman as a transport,
"^DD",870,870,100.01,21,2,0)
you must define a mail group that contains the remote member, 
"^DD",870,870,100.01,21,3,0)
 
"^DD",870,870,100.01,21,4,0)
S.HL V16 SERVER@your target domain
"^DD",870,870,100.01,21,5,0)
 
"^DD",870,870,100.01,21,6,0)
The HL7 package will place outbound messages in file 870's outque. The
"^DD",870,870,100.01,21,7,0)
link must be running for messages to be handed off to Mailman.
"^DD",870,870,100.01,21,8,0)
 
"^DD",870,870,100.01,21,9,0)
Inbound messages that are received by the server option are placed
"^DD",870,870,100.01,21,10,0)
directly in file 772.
"^DD",870,870,100.01,"DT")
2990707
"^DD",870,870,200.01,0)
HLLP DEVICE^P3.5'^%ZIS(1,^200;1^Q
"^DD",870,870,200.01,3)
Enter the device to be used for the HLLP protocol.
"^DD",870,870,200.01,21,0)
^^3^3^2990707^
"^DD",870,870,200.01,21,1,0)
This is an entry in the Device file (#3.5). It is opened when this logical
"^DD",870,870,200.01,21,2,0)
link is started up and remains open until the link is shut down. Normally,
"^DD",870,870,200.01,21,3,0)
Vista will initiate and the connection with this serial device.
"^DD",870,870,200.01,"DT")
3050308
"^DD",870,870,200.02,0)
RE-TRANSMISSION ATTEMPTS^NJ3,0^^200;2^K:+X'=X!(X>999)!(X<0)!(X?.E1"."1N.N) X
"^DD",870,870,200.02,3)
Type a Number between 0 and 999, 0 Decimal Digits
"^DD",870,870,200.02,21,0)
^^3^3^2990707^
"^DD",870,870,200.02,21,1,0)
Enter the number of times to re-try sending a message.  The default is 5
"^DD",870,870,200.02,21,2,0)
tries if this field is left blank. If a single message exceeds this value
"^DD",870,870,200.02,21,3,0)
an Alert is sent to the HL7 mail group and the link is shutdown.
"^DD",870,870,200.02,"DT")
2990707
"^DD",870,870,200.021,0)
EXCEED RE-TRANSMIT ACTION^S^I:ignore;R:restart;S:shutdown;^200;10^Q
"^DD",870,870,200.021,21,0)
^^5^5^2990820^
"^DD",870,870,200.021,21,1,0)
This field determines what to do when a message exceeds the number of
"^DD",870,870,200.021,21,2,0)
 retry attempts for this Logical Link.  Actions are:
"^DD",870,870,200.021,21,3,0)
  Ignore   = send alert once and keep trying to resend
"^DD",870,870,200.021,21,4,0)
  Restart  = send alert once and shutdown link then start link
"^DD",870,870,200.021,21,5,0)
  Shutdown = send alert once and shutdown link
"^DD",870,870,200.021,"DT")
2990820
"^DD",870,870,200.022,0)
CLOSE BEFORE RE-TRANSMISSION^S^1:YES;^200;11^Q
"^DD",870,870,200.022,3)
Enter YES if the TCP device should always be closed and re-opened before another re-transmission attempt.
"^DD",870,870,200.022,21,0)
^^6^6^3060629^^
"^DD",870,870,200.022,21,1,0)
Re-transmitting a message over the same open connection may cause a
"^DD",870,870,200.022,21,2,0)
synchronization problem for some applications.  Setting this field to YES
"^DD",870,870,200.022,21,3,0)
will cause the TCP connection to always be closed after a READ timeout or other
"^DD",870,870,200.022,21,4,0)
communication failure.  Instead, a new connection will be opened before
"^DD",870,870,200.022,21,5,0)
attempting to re-transmit the message.
"^DD",870,870,200.022,21,6,0)

"^DD",870,870,200.022,"DT")
3060629
"^DD",870,870,200.03,0)
BLOCK SIZE^NJ3,0^^200;3^K:+X'=X!(X>512)!(X<9)!(X?.E1"."1N.N) X
"^DD",870,870,200.03,3)
Type a Number between 9 and 512, 0 Decimal Digits245 is the recommended default.
"^DD",870,870,200.03,"DT")
2990707
"^DD",870,870,200.04,0)
READ TIMEOUT^NJ3,0^^200;4^K:+X'=X!(X>600)!(X<1)!(X?.E1"."1N.N) X
"^DD",870,870,200.04,3)
Type a Number between 1 and 600, 0 Decimal Digits
"^DD",870,870,200.04,21,0)
^^3^3^2990708^
"^DD",870,870,200.04,21,1,0)
Enter the number of seconds the Lower Layer Protocol remains in a read
"^DD",870,870,200.04,21,2,0)
state for data to come in on the link. The default is 10 seconds if this
"^DD",870,870,200.04,21,3,0)
field is left blank.
"^DD",870,870,200.04,"DT")
2990708
"^DD",870,870,200.05,0)
ACK TIMEOUT^NJ3,0^^200;5^K:+X'=X!(X>600)!(X<0)!(X?.E1"."1N.N) X
"^DD",870,870,200.05,3)
Type a Number between 0 and 600, 0 Decimal Digits
"^DD",870,870,200.05,21,0)
^^4^4^3000418^^
"^DD",870,870,200.05,21,1,0)
The number of seconds the Lower Layer Protocol waits for an
"^DD",870,870,200.05,21,2,0)
acknowledgement from the receiving application. The default
"^DD",870,870,200.05,21,3,0)
is 60.  If this field is less than the READ TIMEOUT field, 
"^DD",870,870,200.05,21,4,0)
the READ TIMEOUT value will be used.
"^DD",870,870,200.05,"DT")
3000418
"^DD",870,870,200.06,0)
LLP START BLOCK^NJ3,0^^200;6^K:+X'=X!(X>300)!(X<1)!(X?.E1"."1N.N) X
"^DD",870,870,200.06,3)
Type a Number between 1 and 300, 0 Decimal Digits
"^DD",870,870,200.06,21,0)
^^5^5^2990709^
"^DD",870,870,200.06,21,1,0)
Enter the numeric value of the control character used by the HLLP
"^DD",870,870,200.06,21,2,0)
communications protocol as a START BLOCK CHARACTER. While this character
"^DD",870,870,200.06,21,3,0)
is negotiable, the HL7 implementation guide recommends the use of the 'VT'
"^DD",870,870,200.06,21,4,0)
character. If this field is left blank, the default value of 11 will be
"^DD",870,870,200.06,21,5,0)
used.
"^DD",870,870,200.06,"DT")
2990709
"^DD",870,870,200.07,0)
LLP END BLOCK^NJ3,0^^200;7^K:+X'=X!(X>300)!(X<1)!(X?.E1"."1N.N) X
"^DD",870,870,200.07,3)
Type a Number between 1 and 300, 0 Decimal Digits
"^DD",870,870,200.07,21,0)
^^4^4^2990709^
"^DD",870,870,200.07,21,1,0)
Enter the numeric value of the control character defined in the HLLP
"^DD",870,870,200.07,21,2,0)
specification as the END BLOCK CHARACTER. The recommended value is 28. If
"^DD",870,870,200.07,21,3,0)
this field is left blank, the default value will be 28 for the 'FS'
"^DD",870,870,200.07,21,4,0)
character.
"^DD",870,870,200.07,"DT")
2990709
"^DD",870,870,200.08,0)
PROTOCOL ID VERSION^S^21:2.1;22:2.2;23:2.3;^200;8^Q
"^DD",870,870,200.08,3)
Enter the version of HLLP as specified by the lates HL7 Implementation Guide
"^DD",870,870,200.08,21,0)
^^3^3^2990709^
"^DD",870,870,200.08,21,1,0)
The latest specification for the HLLP communications protocol is
"^DD",870,870,200.08,21,2,0)
identified by a version number, which may be different from the HL7
"^DD",870,870,200.08,21,3,0)
standard itself.
"^DD",870,870,200.08,"DT")
2990805
"^DD",870,870,200.09,0)
UNI-DIRECTIONAL WAIT^NJ2,0^^200;9^K:+X'=X!(X>10)!(X<0)!(X?.E1"."1N.N) X
"^DD",870,870,200.09,3)
Type a Number between 0 and 10, 0 Decimal Digits
"^DD",870,870,200.09,21,0)
^^3^3^2990709^
"^DD",870,870,200.09,21,1,0)
The number of seconds the Lower Layer Protocol waits after sending a
"^DD",870,870,200.09,21,2,0)
messages.  This is only used if the message doesn't want an
"^DD",870,870,200.09,21,3,0)
acknowledgment.  
"^DD",870,870,200.09,"DT")
2990709
"^DD",870,870,300.01,0)
X3.28 DEVICE^P3.5^%ZIS(1,^300;1^Q
"^DD",870,870,300.01,3)
Enter the device from the Device File.
"^DD",870,870,300.01,21,0)
^^4^4^2990709^
"^DD",870,870,300.01,21,1,0)
X3.28 is a serial protocol like HLLP. It requires the remote system be
"^DD",870,870,300.01,21,2,0)
configured as a device (bi-directional) in the Device and terminal type
"^DD",870,870,300.01,21,3,0)
files. The Vista system will normally open and maintain the connection.
"^DD",870,870,300.01,21,4,0)
See the HL7 Implementation Guide for details of this protocol.
"^DD",870,870,300.01,"DT")
2990709
"^DD",870,870,300.02,0)
MAXIMUM MESSAGE SIZE^NJ7,0^^300;2^K:+X'=X!(X>9999999)!(X<1)!(X?.E1"."1N.N) X
"^DD",870,870,300.02,3)
Type a Number between 1 and 9999999, 0 Decimal Digits
"^DD",870,870,300.02,21,0)
^^1^1^2990709^
"^DD",870,870,300.02,21,1,0)
See the HL7 Implementation Guide for details of the x3.28 protcol.
"^DD",870,870,300.02,"DT")
2990709
"^DD",870,870,300.03,0)
MAXIMUM BLOCK SIZE^NJ3,0^^300;3^K:+X'=X!(X>245)!(X<9)!(X?.E1"."1N.N) X
"^DD",870,870,300.03,3)
Type a Number between 9 and 245, 0 Decimal Digits
"^DD",870,870,300.03,21,0)
^.001^1^1^3010312^^
"^DD",870,870,300.03,21,1,0)
See the HL7 Implementation Guide for details of the x3.28 protcol.
"^DD",870,870,300.03,"DT")
2990709
"^DD",870,870,300.04,0)
TIMER A^NJ2,0^^300;4^K:+X'=X!(X>60)!(X<1)!(X?.E1"."1N.N) X
"^DD",870,870,300.04,3)
Type a Number between 1 and 60, 0 Decimal Digits
"^DD",870,870,300.04,21,0)
^^2^2^2990709^
"^DD",870,870,300.04,21,1,0)
Enter the time in seconds for the Response Timer. The default is 6 seconds
"^DD",870,870,300.04,21,2,0)
if no time is entered.
"^DD",870,870,300.04,"DT")
2990709
"^DD",870,870,300.05,0)
TIMER B^NJ2,0^^300;5^K:+X'=X!(X>60)!(X<1)!(X?.E1"."1N.N) X
"^DD",870,870,300.05,3)
Type a Number between 1 and 60, 0 Decimal Digits
"^DD",870,870,300.05,21,0)
^^2^2^2990709^
"^DD",870,870,300.05,21,1,0)
Enter the time in seconds for the Receive Timer. The default is 3 seconds
"^DD",870,870,300.05,21,2,0)
if no time is entered.
"^DD",870,870,300.05,"DT")
2990709
"^DD",870,870,300.06,0)
TIMER D^NJ2,0^^300;6^K:+X'=X!(X>60)!(X<1)!(X?.E1"."1N.N) X
"^DD",870,870,300.06,3)
Type a Number between 1 and 60, 0 Decimal Digits
"^DD",870,870,300.06,21,0)
^^2^2^2990709^
"^DD",870,870,300.06,21,1,0)
Enter the time for the Inter-Block timer. The default is 30 seconds if no
"^DD",870,870,300.06,21,2,0)
time is specified.
"^DD",870,870,300.06,"DT")
2990709
"^DD",870,870,300.07,0)
TIMER E^NJ3,0^^300;7^K:+X'=X!(X>600)!(X<1)!(X?.E1"."1N.N) X
"^DD",870,870,300.07,3)
Type a Number between 1 and 600, 0 Decimal Digits
"^DD",870,870,300.07,21,0)
^^2^2^2990709^
"^DD",870,870,300.07,21,1,0)
Enter the time for the Line Check Timer. The default is 180 seconds is no
"^DD",870,870,300.07,21,2,0)
time is specified.
"^DD",870,870,300.07,"DT")
2990709
"^DD",870,870,400.01,0)
TCP/IP ADDRESS^F^^400;1^K:$L(X)>40!($L(X)<7) X
"^DD",870,870,400.01,3)
Answer must be 7-40 characters in length.
"^DD",870,870,400.01,21,0)
^^1^1^2990709^
"^DD",870,870,400.01,21,1,0)
Enter the numeric address of the remote site using the syntax, nn.nn.nn.nn
"^DD",870,870,400.01,"DT")
3041012
"^DD",870,870,400.02,0)
TCP/IP PORT^NJ5,0^^400;2^K:+X'=X!(X>65535)!(X<1)!(X?.E1"."1N.N) X
"^DD",870,870,400.02,3)
Type a Number between 1 and 65535, 0 Decimal Digits
"^DD",870,870,400.02,21,0)
^^3^3^2990709^
"^DD",870,870,400.02,21,1,0)
This is the port over which the HL7 service will create a socket for
"^DD",870,870,400.02,21,2,0)
message exchange. In VA, this port will be 5000 between production
"^DD",870,870,400.02,21,3,0)
systems.
"^DD",870,870,400.02,"DT")
2990709
"^DD",870,870,400.03,0)
TCP/IP SERVICE TYPE^S^C:CLIENT (SENDER);S:SINGLE LISTENER;M:MULTI LISTENER;^400;3^Q
"^DD",870,870,400.03,1,0)
^.1
"^DD",870,870,400.03,1,1,0)
870^E
"^DD",870,870,400.03,1,1,1)
S ^HLCS(870,"E",$E(X,1,30),DA)=""
"^DD",870,870,400.03,1,1,2)
K ^HLCS(870,"E",$E(X,1,30),DA)
"^DD",870,870,400.03,1,1,"DT")
3030710
"^DD",870,870,400.03,3)
Does this link send a connection request or receive connection requests?
"^DD",870,870,400.03,21,0)
^.001^12^12^3040826^^
"^DD",870,870,400.03,21,1,0)
This field determines if the Logical Link is the client (sender) or a
"^DD",870,870,400.03,21,2,0)
listener (server) of a message.  Choose from:
"^DD",870,870,400.03,21,3,0)
 
"^DD",870,870,400.03,21,4,0)
                                
"^DD",870,870,400.03,21,5,0)
 CLIENT (SENDER): Indicates that this Logical Link connects to a target
"^DD",870,870,400.03,21,6,0)
system, with the current system acting as the sender.
"^DD",870,870,400.03,21,7,0)
 
"^DD",870,870,400.03,21,8,0)
 SINGLE LISTENER: Designates that the current system is a server
"^DD",870,870,400.03,21,9,0)
(listener), using a single M process to do the listening.
"^DD",870,870,400.03,21,10,0)
                                 
"^DD",870,870,400.03,21,11,0)
 MULTI LISTENER: Designates that the current system is a server
"^DD",870,870,400.03,21,12,0)
(listener), creating multiple background processes.
"^DD",870,870,400.03,"DT")
3050308
"^DD",870,870,400.04,0)
PERSISTENT^S^Y:YES;N:NO;^400;4^Q
"^DD",870,870,400.04,21,0)
^^5^5^2990709^
"^DD",870,870,400.04,21,1,0)
Enter 'YES' if this connection needs to remain open even if there are no
"^DD",870,870,400.04,21,2,0)
messages to send. The connection will remain open until it is disconnected
"^DD",870,870,400.04,21,3,0)
by either side via shutting-down the logical link.  A setting of 'YES' is
"^DD",870,870,400.04,21,4,0)
appropriate for connecting to a COTS device with a high volume of
"^DD",870,870,400.04,21,5,0)
messages.  
"^DD",870,870,400.04,"DT")
2990709
"^DD",870,870,400.05,0)
RETENTION^NJ6,0^^400;5^K:+X'=X!(X>999999)!(X<0)!(X?.E1"."1N.N) X
"^DD",870,870,400.05,3)
Type a Number between 0 and 999999, 0 Decimal Digits
"^DD",870,870,400.05,21,0)
^^6^6^2990709^
"^DD",870,870,400.05,21,1,0)
Retention is the maximum time in seconds in which a non-persistent LLP
"^DD",870,870,400.05,21,2,0)
will wait after the associated queue has been emptied.  If further
"^DD",870,870,400.05,21,3,0)
messages arrive in the queue before the retention time has expired, the
"^DD",870,870,400.05,21,4,0)
LLP will continue to dequeue and send messages. Otherwise, the LLP will
"^DD",870,870,400.05,21,5,0)
become inactive and will remain inactive until further messages are
"^DD",870,870,400.05,21,6,0)
queued.  
"^DD",870,870,400.05,"DT")
2990709
"^DD",870,870,400.06,0)
STARTUP NODE^P14.7'^%ZIS(14.7,^400;6^Q
"^DD",870,870,400.06,3)
Enter the Taskman node to start this LLP on.
"^DD",870,870,400.06,21,0)
^^5^5^2990709^
"^DD",870,870,400.06,21,1,0)
This field is ONLY for VMS sites running Dual Taskman in DCL. This field
"^DD",870,870,400.06,21,2,0)
is used to specify what Taskman node you want to job the Lower Level
"^DD",870,870,400.06,21,3,0)
Protocol. It should only be used if you have two Taskmans running and only
"^DD",870,870,400.06,21,4,0)
want the LLP to run on a particular node.  It will only work if you are
"^DD",870,870,400.06,21,5,0)
running the dual Taskmans in DCL context on a VMS system.
"^DD",870,870,400.06,"DT")
2990709
"^DD",870,870,400.07,0)
SAY HELO^S^Y:YES;N:NO;^400;7^Q
"^DD",870,870,400.07,3)
Send initial HELO for Cache/NT TCP links?
"^DD",870,870,400.07,21,0)
^.001^6^6^3001103^^^^
"^DD",870,870,400.07,21,1,0)
This field is applicable only to Cache/NT sites with TCP links.
"^DD",870,870,400.07,21,2,0)
If you are not a Cache/NT site, or this is not a TCP link, this field
"^DD",870,870,400.07,21,3,0)
does not apply, AND will be ignored.
"^DD",870,870,400.07,21,4,0)

"^DD",870,870,400.07,21,5,0)
If this TCP link is for a VA site, answer YES.
"^DD",870,870,400.07,21,6,0)
If this TCP link is for a COTS system, answer NO.  This is the default.
"^DD",870,870,400.07,23,0)
^.001^4^4^3001103^^^
"^DD",870,870,400.07,23,1,0)
When sending HL7 transactions to other VA sites over TCP links, Cache/NT
"^DD",870,870,400.07,23,2,0)
sites must send an initial HELO to overcome buffering issues.  However,
"^DD",870,870,400.07,23,3,0)
the initial HELO is not part of the HL7 standard, and may cause a reject
"^DD",870,870,400.07,23,4,0)
error when sent to a COTS system.
"^DD",870,870,400.07,"DT")
3001102
"^DD",870,870,400.08,0)
TCP/IP PORT (OPTIMIZED)^NJ5,0^^400;8^K:+X'=X!(X>65535)!(X<1)!(X?.E1"."1N.N) X
"^DD",870,870,400.08,3)
Enter the port to use for the new HL7 'optimized' server, a number between 1 and 65535. 5001 is the default.
"^DD",870,870,400.08,21,0)
^.001^4^4^3050216^^^
"^DD",870,870,400.08,21,1,0)
The new HL7 'optimized' server will operate concurrently with the  old
"^DD",870,870,400.08,21,2,0)
HL7 1.6 server.  To  enable that, the two servers are assigned different ports
"^DD",870,870,400.08,21,3,0)
to listen on.  The default port for the old HL7 server is 5000, whereas 
"^DD",870,870,400.08,21,4,0)
the new optimized HL7 server uses port 5001.
"^DD",870,870,400.08,"DT")
3050216
"^DD",870,870,400.09,0)
TCP/IP OPENFAIL TIMEOUT^NJ2,0^^400;9^K:+X'=X!(X>60)!(X<1)!(X?.E1"."1N.N) X
"^DD",870,870,400.09,3)
Type a Number between 1 and 60, 0 Decimal Digits
"^DD",870,870,400.09,21,0)
^^2^2^3060802^
"^DD",870,870,400.09,21,1,0)
Enter the number of seconds for the TCP/IP Openfail Timeout. The default
"^DD",870,870,400.09,21,2,0)
is 5 seconds if this field is left blank.
"^DD",870,870,400.09,"DT")
3060802
"^DD",870,870.01,0)
OUT QUEUE SUB-FIELD^^6^7
"^DD",870,870.01,0,"DIK")
HL870
"^DD",870,870.01,0,"DT")
3041014
"^DD",870,870.01,0,"IX","B",870.01,.01)

"^DD",870,870.01,0,"NM","OUT QUEUE")

"^DD",870,870.01,0,"UP")
870
"^DD",870,870.01,.01,0)
MESSAGE NUMBER^NJ15,0^^0;1^K:+X'=X!(X>999999999999999)!(X<0)!(X?.E1"."1N.N) X
"^DD",870,870.01,.01,1,0)
^.1^^-1
"^DD",870,870.01,.01,1,1,0)
870.01^B
"^DD",870,870.01,.01,1,1,1)
S ^HLCS(870,DA(1),2,"B",$E(X,1,30),DA)=""
"^DD",870,870.01,.01,1,1,2)
K ^HLCS(870,DA(1),2,"B",$E(X,1,30),DA)
"^DD",870,870.01,.01,3)
Not editable from any user option. See Field Description.
"^DD",870,870.01,.01,21,0)
^^2^2^2941213^
"^DD",870,870.01,.01,21,1,0)
This is the number assigned to the message when it is enque'd into
"^DD",870,870.01,.01,21,2,0)
the FIFO queue.
"^DD",870,870.01,.01,"DT")
2941102
"^DD",870,870.01,1,0)
STATUS^S^P:PENDING;D:DONE PROCESSING;S:STUB RECORD;^0;2^Q
"^DD",870,870.01,1,1,0)
^.1^^0
"^DD",870,870.01,1,3)
This is the status of an individual message in the queue. These statuses control the flow and processing of the message.
"^DD",870,870.01,1,21,0)
^^6^6^2941213^^
"^DD",870,870.01,1,21,1,0)
Status of a particular message. Can be Stub, Pending, or Done. These
"^DD",870,870.01,1,21,2,0)
statuses control the processing of a message. For example, a stub
"^DD",870,870.01,1,21,3,0)
record is created when a message is enque'd, it cannot be processed
"^DD",870,870.01,1,21,4,0)
until it's status is changed from a 'stub' to 'pending', this is
"^DD",870,870.01,1,21,5,0)
the last thing HLCS1 does when dequeueing a message from file #772
"^DD",870,870.01,1,21,6,0)
and enqueueing it into file #870.
"^DD",870,870.01,1,"DT")
3000508
"^DD",870,870.01,2,0)
ERROR^S^A:LLP ACKNOWLEDGED NO ERROR;C:LLP CHAR COUNT WRONG;X:LLP XOR WRONG;B:DATA TOO LONG;G:OTHER LLP ERROR;^0;3^Q
"^DD",870,870.01,2,3)
This field is not editable from any user option. See field description.
"^DD",870,870.01,2,21,0)
^^3^3^2941213^
"^DD",870,870.01,2,21,1,0)
If this field contains a "C","X","B", or a "G" it means an error has
"^DD",870,870.01,2,21,2,0)
occured while attempting to send a message to another application.
"^DD",870,870.01,2,21,3,0)
This field is not editable from any user option.
"^DD",870,870.01,2,"DT")
2941117
"^DD",870,870.01,3,0)
MESSAGE TEXT^870.13^^1;0
"^DD",870,870.01,3,21,0)
^^1^1^2941213^
"^DD",870,870.01,3,21,1,0)
This field contains the text of the message.
"^DD",870,870.01,4,0)
dhcp-longtitudinal checksum^F^^0;4^K:$L(X)>5!($L(X)<1) X
"^DD",870,870.01,4,3)
Answer must be 1-5 characters in length.
"^DD",870,870.01,4,"DT")
2950113
"^DD",870,870.01,5,0)
dhcp-xor checksum^F^^0;5^K:$L(X)>3!($L(X)<1) X
"^DD",870,870.01,5,3)
Answer must be 1-3 characters in length.
"^DD",870,870.01,5,"DT")
2950113
"^DD",870,870.01,6,0)
IEN772 OutQ-Non-TCP^F^^0;6^K:$L(X)>30!($L(X)<1)!'(X?.N) X
"^DD",870,870.01,6,3)
Answer must be 1-30 numeric digits in length.
"^DD",870,870.01,6,21,0)
^^1^1^3041221^
"^DD",870,870.01,6,21,1,0)
The ien of file #772, where this sub-entry is copied from.
"^DD",870,870.01,6,"DT")
3041221
"^DD",870,870.019,0)
IN QUEUE SUB-FIELD^^9^10
"^DD",870,870.019,0,"DIK")
HL870
"^DD",870,870.019,0,"DT")
3041014
"^DD",870,870.019,0,"IX","B",870.019,.01)

"^DD",870,870.019,0,"NM","IN QUEUE")

"^DD",870,870.019,0,"UP")
870
"^DD",870,870.019,.01,0)
MESSAGE NUMBER^NJ15,0^^0;1^K:+X'=X!(X>999999999999999)!(X<0)!(X?.E1"."1N.N) X
"^DD",870,870.019,.01,1,0)
^.1^^-1
"^DD",870,870.019,.01,1,1,0)
870.019^B
"^DD",870,870.019,.01,1,1,1)
S ^HLCS(870,DA(1),1,"B",$E(X,1,30),DA)=""
"^DD",870,870.019,.01,1,1,2)
K ^HLCS(870,DA(1),1,"B",$E(X,1,30),DA)
"^DD",870,870.019,.01,3)
Not editable from any user option. See field description.
"^DD",870,870.019,.01,21,0)
^^2^2^2941213^^^
"^DD",870,870.019,.01,21,1,0)
This is the number assigned to the message when it is enqued into the
"^DD",870,870.019,.01,21,2,0)
FIFO queue.
"^DD",870,870.019,.01,"DT")
2941102
"^DD",870,870.019,1,0)
STATUS^S^P:PENDING;D:DONE PROCESSING;S:STUB RECORD;^0;2^Q
"^DD",870,870.019,1,1,0)
^.1
"^DD",870,870.019,1,1,1,0)
870^AISTAT
"^DD",870,870.019,1,1,1,1)
S ^HLCS(870,"AISTAT",$E(X,1,30),DA(1),DA)=""
"^DD",870,870.019,1,1,1,2)
K ^HLCS(870,"AISTAT",$E(X,1,30),DA(1),DA)
"^DD",870,870.019,1,1,1,"%D",0)
^.101^2^2^3001115^^^
"^DD",870,870.019,1,1,1,"%D",1,0)
Used to quickly identify links with messages in any status,
"^DD",870,870.019,1,1,1,"%D",2,0)
thus improving performance.
"^DD",870,870.019,1,1,1,"DT")
3000508
"^DD",870,870.019,1,3)
This is the status of an individual message in the queue. These statuses control the flow and processing of the message.
"^DD",870,870.019,1,21,0)
^.001^7^7^3001115^^^^
"^DD",870,870.019,1,21,1,0)
Status of a particular message. Can be Stub, Pending, or Done.
"^DD",870,870.019,1,21,2,0)
These statuses control the processing of a message. For example, a
"^DD",870,870.019,1,21,3,0)
stub record is created when a message is enqueued, and cannot be
"^DD",870,870.019,1,21,4,0)
processed until its status is changed from 'stub' to 'pending'.
"^DD",870,870.019,1,21,5,0)
Changing this status is the last thing the Low Layer Protocol does
"^DD",870,870.019,1,21,6,0)
after reading in a message.  Finally, once the message has been
"^DD",870,870.019,1,21,7,0)
processed, its status is changed to 'done'.
"^DD",870,870.019,1,"DT")
3000508
"^DD",870,870.019,2,0)
ERROR^S^A:LLP ACKNOWLEDGED NO ERROR;C:LLP CHAR COUNT WRONG;X:LLP XOR WRONG;B:DATA TOO LONG;G:OTHER LLP ERROR;^0;3^Q
"^DD",870,870.019,2,3)
This field is not editable from any user option. See Field Description.
"^DD",870,870.019,2,21,0)
^^3^3^2941213^^
"^DD",870,870.019,2,21,1,0)
If this field contains a "C","X","B", or a "G" it means an error has
"^DD",870,870.019,2,21,2,0)
ocurred while reading in a message. This field is not editable from
"^DD",870,870.019,2,21,3,0)
any user option.
"^DD",870,870.019,2,"DT")
2941027
"^DD",870,870.019,3,0)
MESSAGE TEXT^870.193^^1;0
"^DD",870,870.019,3,21,0)
^^1^1^2941213^^
"^DD",870,870.019,3,21,1,0)
This field contains the text of the message.
"^DD",870,870.019,4,0)
tvv^F^^0;4^K:$L(X)>3!($L(X)<3) X
"^DD",870,870.019,4,3)
Answer must be 3 characters in length.
"^DD",870,870.019,4,"DT")
2950112
"^DD",870,870.019,5,0)
ccccc^F^^0;5^K:$L(X)>5!($L(X)<1) X
"^DD",870,870.019,5,3)
Answer must be 1-5 characters in length.
"^DD",870,870.019,5,"DT")
2950113
"^DD",870,870.019,6,0)
xxx^F^^0;6^K:$L(X)>3!($L(X)<1) X
"^DD",870,870.019,6,3)
Answer must be 1-3 characters in length.
"^DD",870,870.019,6,"DT")
2950113
"^DD",870,870.019,7,0)
dhcp-longtitudinal checksum^F^^0;7^K:$L(X)>5!($L(X)<1) X
"^DD",870,870.019,7,3)
Answer must be 1-5 characters in length.
"^DD",870,870.019,7,"DT")
2950113
"^DD",870,870.019,8,0)
dhcp-xor checksum^F^^0;8^K:$L(X)>3!($L(X)<1) X
"^DD",870,870.019,8,3)
Answer must be 1-3 characters in length.
"^DD",870,870.019,8,"DT")
2950113
"^DD",870,870.019,9,0)
IEN772 InQ-Non-TCP^F^^0;9^K:$L(X)>30!($L(X)<1)!'(X?.N) X
"^DD",870,870.019,9,3)
Answer must be 1-30 numeric digits in length.
"^DD",870,870.019,9,21,0)
^^1^1^3041221^
"^DD",870,870.019,9,21,1,0)
The ien of file #772, where this sub-entry is copied to. 
"^DD",870,870.019,9,"DT")
3041221
"^DD",870,870.02,0)
DESCRIPTION SUB-FIELD^^.01^1
"^DD",870,870.02,0,"DT")
3070629
"^DD",870,870.02,0,"NM","DESCRIPTION")

"^DD",870,870.02,0,"UP")
870
"^DD",870,870.02,.01,0)
DESCRIPTION^W^^0;1^Q
"^DD",870,870.02,.01,3)
Enter a description for this link
"^DD",870,870.02,.01,21,0)
^.001^1^1^3070629^^
"^DD",870,870.02,.01,21,1,0)
This field contains a brief explanation of this link.
"^DD",870,870.02,.01,"DT")
3070629
"^DD",870,870.13,0)
MESSAGE TEXT SUB-FIELD^^.01^1
"^DD",870,870.13,0,"DT")
2941006
"^DD",870,870.13,0,"NM","MESSAGE TEXT")

"^DD",870,870.13,0,"UP")
870.01
"^DD",870,870.13,.01,0)
MESSAGE TEXT^WL^^0;1^Q
"^DD",870,870.13,.01,"DT")
2941006
"^DD",870,870.193,0)
MESSAGE TEXT SUB-FIELD^^.01^1
"^DD",870,870.193,0,"DT")
2941006
"^DD",870,870.193,0,"NM","MESSAGE TEXT")

"^DD",870,870.193,0,"UP")
870.019
"^DD",870,870.193,.01,0)
MESSAGE TEXT^WL^^0;1^Q
"^DD",870,870.193,.01,3)
This field contains the actual text of the message.
"^DD",870,870.193,.01,"DT")
2941006
"^DIC",869.3,869.3,0)
HL COMMUNICATION SERVER PARAMETERS^869.3
"^DIC",869.3,869.3,0,"GL")
^HLCS(869.3,
"^DIC",869.3,869.3,"%D",0)
^^1^1^2990303^^^^
"^DIC",869.3,869.3,"%D",1,0)
Parameter file used by the HL7 Communication Server
"^DIC",869.3,"B","HL COMMUNICATION SERVER PARAMETERS",869.3)

"^DIC",870,870,0)
HL LOGICAL LINK^870
"^DIC",870,870,0,"GL")
^HLCS(870,
"^DIC",870,870,"%",0)
^1.005^^0
"^DIC",870,870,"%D",0)
^^21^21^2990607^^^^
"^DIC",870,870,"%D",1,0)
This file serves two purposes. It is a fileman-compatible transmission
"^DIC",870,870,"%D",2,0)
log. The Low Layer Protocols write and read directly from this file.
"^DIC",870,870,"%D",3,0)
(See routines HLCSDR1 and HLCSDR2)
"^DIC",870,870,"%D",4,0)
 
"^DIC",870,870,"%D",5,0)
This file stores parameters that govern the behaviour of the Low Layer
"^DIC",870,870,"%D",6,0)
Protocols. Fields like: READ TIMEOUT, ACK TIMEOUT, LLP START BLOCK, and
"^DIC",870,870,"%D",7,0)
LLP END BLOCK, are fields that govern how long the finite state machine
"^DIC",870,870,"%D",8,0)
waits for data to come down the line (READ TIMEOUT), how long it waits
"^DIC",870,870,"%D",9,0)
for a lower level acknowledgement (ACK TIMEOUT), and which control
"^DIC",870,870,"%D",10,0)
characters define the beginning and end of a message (LLP START BLOCK
"^DIC",870,870,"%D",11,0)
and LLP END BLOCK).
"^DIC",870,870,"%D",12,0)
 
"^DIC",870,870,"%D",13,0)
This file also stores information that drives the SYSTEMS LINK MONITOR
"^DIC",870,870,"%D",14,0)
display option. Fields like, IN QUEUE FRONT POINTER, IN QUEUE BACK 
"^DIC",870,870,"%D",15,0)
POINTER are used to manage the data flow in the queues but they are
"^DIC",870,870,"%D",16,0)
also displayed on the SYSTEMS LINK MONITOR under the alias's MESSAGES
"^DIC",870,870,"%D",17,0)
PROCESSED and MESSAGES RECEIVED. Fields like STATE and DEVICE TYPE
"^DIC",870,870,"%D",18,0)
are also used to drive the SYSTEMS LINK MONITOR. These fields are
"^DIC",870,870,"%D",19,0)
updated by the lower layer protocols in order to give real-time feedback
"^DIC",870,870,"%D",20,0)
as to what is ocurring on a link. For example, when a message is 
"^DIC",870,870,"%D",21,0)
received (see HLCSDR1) the state transitions from "IDLE" to "READING".
"^DIC",870,"B","HL LOGICAL LINK",870)

"BLD",965,6)
^109
**END**
**END**
