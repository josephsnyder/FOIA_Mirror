Released HL*1.6*146 SEQ #117
Extracted from mail message
**KIDS**:HL*1.6*146^

**INSTALL NAME**
HL*1.6*146
"BLD",1205,0)
HL*1.6*146^HEALTH LEVEL SEVEN^0^3090824^y
"BLD",1205,1,0)
^^2^2^3090512^^
"BLD",1205,1,1,0)
See the National Patch Module on Forum for a complete description.
"BLD",1205,1,2,0)

"BLD",1205,4,0)
^9.64PA^779.4^1
"BLD",1205,4,779.4,0)
779.4
"BLD",1205,4,779.4,222)
y^n^f^^^^n
"BLD",1205,4,"B",779.4,779.4)

"BLD",1205,6.3)
16
"BLD",1205,"ABPKG")
n
"BLD",1205,"INI")
PRE^HLOP146
"BLD",1205,"INID")
^y^y
"BLD",1205,"INIT")
POST^HLOP146
"BLD",1205,"KRN",0)
^9.67PA^9002226^21
"BLD",1205,"KRN",.4,0)
.4
"BLD",1205,"KRN",.401,0)
.401
"BLD",1205,"KRN",.402,0)
.402
"BLD",1205,"KRN",.402,"NM",0)
^9.68A^4^4
"BLD",1205,"KRN",.402,"NM",1,0)
HLO DEACTIVATE OUT MSG    FILE #779.2^779.2^0
"BLD",1205,"KRN",.402,"NM",2,0)
HLO EDIT RECEIVING APPLICATION    FILE #779.2^779.2^0
"BLD",1205,"KRN",.402,"NM",3,0)
HLO EDIT SENDING APPLICATION    FILE #779.2^779.2^0
"BLD",1205,"KRN",.402,"NM",4,0)
HLO EDIT SUBSCRIPTION    FILE #779.4^779.4^0
"BLD",1205,"KRN",.402,"NM","B","HLO DEACTIVATE OUT MSG    FILE #779.2",1)

"BLD",1205,"KRN",.402,"NM","B","HLO EDIT RECEIVING APPLICATION    FILE #779.2",2)

"BLD",1205,"KRN",.402,"NM","B","HLO EDIT SENDING APPLICATION    FILE #779.2",3)

"BLD",1205,"KRN",.402,"NM","B","HLO EDIT SUBSCRIPTION    FILE #779.4",4)

"BLD",1205,"KRN",.403,0)
.403
"BLD",1205,"KRN",.5,0)
.5
"BLD",1205,"KRN",.84,0)
.84
"BLD",1205,"KRN",3.6,0)
3.6
"BLD",1205,"KRN",3.8,0)
3.8
"BLD",1205,"KRN",9.2,0)
9.2
"BLD",1205,"KRN",9.8,0)
9.8
"BLD",1205,"KRN",9.8,"NM",0)
^9.68A^33^22
"BLD",1205,"KRN",9.8,"NM",5,0)
HLOCNRT^^0^B16134592
"BLD",1205,"KRN",9.8,"NM",10,0)
HLOCLNT1^^0^B33784645
"BLD",1205,"KRN",9.8,"NM",11,0)
HLOTCP^^0^B85513944
"BLD",1205,"KRN",9.8,"NM",12,0)
HLOAPI^^0^B114629271
"BLD",1205,"KRN",9.8,"NM",13,0)
HLOAPI1^^0^B101211192
"BLD",1205,"KRN",9.8,"NM",14,0)
HLOAPI2^^0^B76422316
"BLD",1205,"KRN",9.8,"NM",15,0)
HLOAPI4^^0^B29813410
"BLD",1205,"KRN",9.8,"NM",16,0)
HLOASUB^^0^B34615650
"BLD",1205,"KRN",9.8,"NM",17,0)
HLOASUB1^^0^B91447015
"BLD",1205,"KRN",9.8,"NM",18,0)
HLOPRS^^0^B29241759
"BLD",1205,"KRN",9.8,"NM",19,0)
HLOPRS2^^0^B34053092
"BLD",1205,"KRN",9.8,"NM",20,0)
HLOTLNK^^0^B26226165
"BLD",1205,"KRN",9.8,"NM",21,0)
HLOTRACE^^0^B65294426
"BLD",1205,"KRN",9.8,"NM",23,0)
HLOT^^0^B3437824
"BLD",1205,"KRN",9.8,"NM",24,0)
HLOSRVR2^^0^B5350765
"BLD",1205,"KRN",9.8,"NM",25,0)
HLOSTRAC^^0^B33783349
"BLD",1205,"KRN",9.8,"NM",26,0)
HLOUSR^^0^B92223063
"BLD",1205,"KRN",9.8,"NM",29,0)
HLOAPI7^^0^B15001817
"BLD",1205,"KRN",9.8,"NM",30,0)
HLOUSR6^^0^B24863677
"BLD",1205,"KRN",9.8,"NM",31,0)
HLOPROC^^0^B26547261
"BLD",1205,"KRN",9.8,"NM",32,0)
HLOSRVR1^^0^B86429474
"BLD",1205,"KRN",9.8,"NM",33,0)
HLOPRSR2^^0^B77677817
"BLD",1205,"KRN",9.8,"NM","B","HLOAPI",12)

"BLD",1205,"KRN",9.8,"NM","B","HLOAPI1",13)

"BLD",1205,"KRN",9.8,"NM","B","HLOAPI2",14)

"BLD",1205,"KRN",9.8,"NM","B","HLOAPI4",15)

"BLD",1205,"KRN",9.8,"NM","B","HLOAPI7",29)

"BLD",1205,"KRN",9.8,"NM","B","HLOASUB",16)

"BLD",1205,"KRN",9.8,"NM","B","HLOASUB1",17)

"BLD",1205,"KRN",9.8,"NM","B","HLOCLNT1",10)

"BLD",1205,"KRN",9.8,"NM","B","HLOCNRT",5)

"BLD",1205,"KRN",9.8,"NM","B","HLOPROC",31)

"BLD",1205,"KRN",9.8,"NM","B","HLOPRS",18)

"BLD",1205,"KRN",9.8,"NM","B","HLOPRS2",19)

"BLD",1205,"KRN",9.8,"NM","B","HLOPRSR2",33)

"BLD",1205,"KRN",9.8,"NM","B","HLOSRVR1",32)

"BLD",1205,"KRN",9.8,"NM","B","HLOSRVR2",24)

"BLD",1205,"KRN",9.8,"NM","B","HLOSTRAC",25)

"BLD",1205,"KRN",9.8,"NM","B","HLOT",23)

"BLD",1205,"KRN",9.8,"NM","B","HLOTCP",11)

"BLD",1205,"KRN",9.8,"NM","B","HLOTLNK",20)

"BLD",1205,"KRN",9.8,"NM","B","HLOTRACE",21)

"BLD",1205,"KRN",9.8,"NM","B","HLOUSR",26)

"BLD",1205,"KRN",9.8,"NM","B","HLOUSR6",30)

"BLD",1205,"KRN",19,0)
19
"BLD",1205,"KRN",19,"NM",0)
^9.68A^14^12
"BLD",1205,"KRN",19,"NM",3,0)
HLO EDIT RECEIVING APPLICATION^^0
"BLD",1205,"KRN",19,"NM",4,0)
HLO EDIT SENDING APPLICATION^^0
"BLD",1205,"KRN",19,"NM",5,0)
HLO APPLICATION REGISTRY MENU^^0
"BLD",1205,"KRN",19,"NM",6,0)
HLO DEVELOPER MENU^^0
"BLD",1205,"KRN",19,"NM",7,0)
HLO SUBSCRIPTION REGISTRY^^0
"BLD",1205,"KRN",19,"NM",8,0)
HLO MAIN MENU^^0
"BLD",1205,"KRN",19,"NM",9,0)
HLO TERMINATE OUTGOING MESSAGE^^0
"BLD",1205,"KRN",19,"NM",10,0)
HLO MESSAGE STATISTICS^^0
"BLD",1205,"KRN",19,"NM",11,0)
HLO MESSAGE VIEWER^^0
"BLD",1205,"KRN",19,"NM",12,0)
HLO SYSTEM MONITOR^^0
"BLD",1205,"KRN",19,"NM",13,0)
HLO EDIT SYSTEM PARAMETERS^^0
"BLD",1205,"KRN",19,"NM",14,0)
HLO ERROR STATISTICS REPORT^^0
"BLD",1205,"KRN",19,"NM","B","HLO APPLICATION REGISTRY MENU",5)

"BLD",1205,"KRN",19,"NM","B","HLO DEVELOPER MENU",6)

"BLD",1205,"KRN",19,"NM","B","HLO EDIT RECEIVING APPLICATION",3)

"BLD",1205,"KRN",19,"NM","B","HLO EDIT SENDING APPLICATION",4)

"BLD",1205,"KRN",19,"NM","B","HLO EDIT SYSTEM PARAMETERS",13)

"BLD",1205,"KRN",19,"NM","B","HLO ERROR STATISTICS REPORT",14)

"BLD",1205,"KRN",19,"NM","B","HLO MAIN MENU",8)

"BLD",1205,"KRN",19,"NM","B","HLO MESSAGE STATISTICS",10)

"BLD",1205,"KRN",19,"NM","B","HLO MESSAGE VIEWER",11)

"BLD",1205,"KRN",19,"NM","B","HLO SUBSCRIPTION REGISTRY",7)

"BLD",1205,"KRN",19,"NM","B","HLO SYSTEM MONITOR",12)

"BLD",1205,"KRN",19,"NM","B","HLO TERMINATE OUTGOING MESSAGE",9)

"BLD",1205,"KRN",19.1,0)
19.1
"BLD",1205,"KRN",19.1,"NM",0)
^9.68A^^
"BLD",1205,"KRN",101,0)
101
"BLD",1205,"KRN",101,"NM",0)
^9.68A^1^1
"BLD",1205,"KRN",101,"NM",1,0)
HLO OUTBOUND DELETE^^0
"BLD",1205,"KRN",101,"NM","B","HLO OUTBOUND DELETE",1)

"BLD",1205,"KRN",409.61,0)
409.61
"BLD",1205,"KRN",409.61,"NM",0)
^9.68A^^
"BLD",1205,"KRN",771,0)
771
"BLD",1205,"KRN",779.2,0)
779.2
"BLD",1205,"KRN",870,0)
870
"BLD",1205,"KRN",8989.51,0)
8989.51
"BLD",1205,"KRN",8989.52,0)
8989.52
"BLD",1205,"KRN",8994,0)
8994
"BLD",1205,"KRN",9002226,0)
9002226
"BLD",1205,"KRN","B",.4,.4)

"BLD",1205,"KRN","B",.401,.401)

"BLD",1205,"KRN","B",.402,.402)

"BLD",1205,"KRN","B",.403,.403)

"BLD",1205,"KRN","B",.5,.5)

"BLD",1205,"KRN","B",.84,.84)

"BLD",1205,"KRN","B",3.6,3.6)

"BLD",1205,"KRN","B",3.8,3.8)

"BLD",1205,"KRN","B",9.2,9.2)

"BLD",1205,"KRN","B",9.8,9.8)

"BLD",1205,"KRN","B",19,19)

"BLD",1205,"KRN","B",19.1,19.1)

"BLD",1205,"KRN","B",101,101)

"BLD",1205,"KRN","B",409.61,409.61)

"BLD",1205,"KRN","B",771,771)

"BLD",1205,"KRN","B",779.2,779.2)

"BLD",1205,"KRN","B",870,870)

"BLD",1205,"KRN","B",8989.51,8989.51)

"BLD",1205,"KRN","B",8989.52,8989.52)

"BLD",1205,"KRN","B",8994,8994)

"BLD",1205,"KRN","B",9002226,9002226)

"BLD",1205,"QUES",0)
^9.62^^
"BLD",1205,"REQB",0)
^9.611^1^1
"BLD",1205,"REQB",1,0)
HL*1.6*143^2
"BLD",1205,"REQB","B","HL*1.6*143",1)

"FIA",779.4)
HLO SUBSCRIPTION REGISTRY
"FIA",779.4,0)
^HLD(779.4,
"FIA",779.4,0,0)
779.4
"FIA",779.4,0,1)
y^n^f^^^^n
"FIA",779.4,0,10)

"FIA",779.4,0,11)

"FIA",779.4,0,"RLRO")

"FIA",779.4,0,"VR")
1.6^HL
"FIA",779.4,779.4)
0
"FIA",779.4,779.41)
0
"INI")
PRE^HLOP146
"INIT")
POST^HLOP146
"IX",779.4,779.4,"AH",0)
779.4^AH^LOOKUP^MU^^R^IR^I^779.4^^^^^A
"IX",779.4,779.4,"AH",.1,0)
^^3^3^3070124^^^
"IX",779.4,779.4,"AH",.1,1,0)

"IX",779.4,779.4,"AH",.1,2,0)

"IX",779.4,779.4,"AH",.1,3,0)

"IX",779.4,779.4,"AH",1)
D SETAH1^HLOASUB1(DA,X(1),X(2),X(3),X(4),X(5),X(6),X(7))
"IX",779.4,779.4,"AH",2)
D KILLAH1^HLOASUB1(X(1),X(2),X(3),X(4),X(5),X(6),X(7))
"IX",779.4,779.4,"AH",2.5)
K ^HLD(779.4,"AH")
"IX",779.4,779.4,"AH",11.1,0)
^.114IA^7^7
"IX",779.4,779.4,"AH",11.1,1,0)
1^F^779.4^.02^^1^F
"IX",779.4,779.4,"AH",11.1,2,0)
2^F^779.4^3.01^^^F
"IX",779.4,779.4,"AH",11.1,3,0)
3^F^779.4^3.02^^^F
"IX",779.4,779.4,"AH",11.1,3,1)

"IX",779.4,779.4,"AH",11.1,4,0)
4^F^779.4^3.03^^^F
"IX",779.4,779.4,"AH",11.1,5,0)
5^F^779.4^3.04^^^F
"IX",779.4,779.4,"AH",11.1,6,0)
6^F^779.4^3.05^^^F
"IX",779.4,779.4,"AH",11.1,7,0)
7^F^779.4^3.06^^^F
"IX",779.4,779.4,"C",0)
779.4^C^Uniqueness Index for Key 'A' of File #779.4^R^^F^IR^I^779.4^^^^^LS
"IX",779.4,779.4,"C",1)
S ^HLD(779.4,"C",X,DA)=""
"IX",779.4,779.4,"C",2)
K ^HLD(779.4,"C",X,DA)
"IX",779.4,779.4,"C",2.5)
K ^HLD(779.4,"C")
"IX",779.4,779.4,"C",11.1,0)
^.114IA^1^1
"IX",779.4,779.4,"C",11.1,1,0)
1^F^779.4^.01^^1
"IX",779.4,779.41,"AC",0)
779.41.^AC^Used to find recipients who have not been terminated.^MU^^R^IR^I^779.41^^^^^S
"IX",779.4,779.41,"AC",1)
S ^HLD(779.4,DA(1),2,"AC",DA)=""
"IX",779.4,779.41,"AC",1.4)
S X=$S($G(X2(2)):0,1:1)
"IX",779.4,779.41,"AC",2)
K ^HLD(779.4,DA(1),2,"AC",DA)
"IX",779.4,779.41,"AC",2.4)
S X=1
"IX",779.4,779.41,"AC",11.1,0)
^.114IA^2^2
"IX",779.4,779.41,"AC",11.1,1,0)
1^F^779.41^1.01^^1^F
"IX",779.4,779.41,"AC",11.1,1,3)

"IX",779.4,779.41,"AC",11.1,2,0)
2^F^779.41^1.02^^^F
"IX",779.4,779.41,"AC",11.1,2,3)

"IX",779.4,779.41,"AD",0)
779.41^AD^Used to determine if the recipient is already on the subscription list.^MU^^F^IR^I^779.41^^^^^S
"IX",779.4,779.41,"AD",1)
S ^HLD(779.4,DA(1),2,"AD",X2(1),+X2(2),X2(3),DA)=""
"IX",779.4,779.41,"AD",1.4)

"IX",779.4,779.41,"AD",2)
K ^HLD(779.4,DA(1),2,"AD",X1(1),+X1(2),X1(3),DA)
"IX",779.4,779.41,"AD",2.4)

"IX",779.4,779.41,"AD",11.1,0)
^.114IA^3^3
"IX",779.4,779.41,"AD",11.1,1,0)
1^F^779.41^.01^^1^F
"IX",779.4,779.41,"AD",11.1,2,0)
2^C^^^10^2^F
"IX",779.4,779.41,"AD",11.1,2,1.5)
S X=$$TLINK^HLOASUB(DA(1),DA)
"IX",779.4,779.41,"AD",11.1,2,3)

"IX",779.4,779.41,"AD",11.1,3,0)
3^C^^^^3^F
"IX",779.4,779.41,"AD",11.1,3,1.5)
S X=$TR($P(^HLD(779.4,DA(1),2,DA,0),"^",3,5),"^","")
"IX",779.4,779.41,"AE",0)
779.41^AE^Used to determine if a subscriber is on the subscriber list.^MU^^F^IR^I^779.41^^^^^S
"IX",779.4,779.41,"AE",.1,0)
^^1^1^3090325^^
"IX",779.4,779.41,"AE",.1,1,0)

"IX",779.4,779.41,"AE",1)
S ^HLD(779.4,DA(1),2,"AE",X2(1),X2(2),X2(3),DA)=""
"IX",779.4,779.41,"AE",1.4)

"IX",779.4,779.41,"AE",2)
K ^HLD(779.4,DA(1),2,"AE",X1(1),X1(2),X1(3),DA)
"IX",779.4,779.41,"AE",2.4)

"IX",779.4,779.41,"AE",11.1,0)
^.114IA^3^3
"IX",779.4,779.41,"AE",11.1,1,0)
1^F^779.41^.01^30^1^F
"IX",779.4,779.41,"AE",11.1,2,0)
2^C^^^10^2^F
"IX",779.4,779.41,"AE",11.1,2,1.5)
S X=+$P($G(^HLD(779.4,DA(1),2,DA,0)),"^",6)
"IX",779.4,779.41,"AE",11.1,2,3)

"IX",779.4,779.41,"AE",11.1,3,0)
3^C^^^10^3^F
"IX",779.4,779.41,"AE",11.1,3,1.5)
S X=+$P($G(^HLD(779.4,DA(1),2,DA,0)),"^",2)
"IX",779.4,779.41,"AE",11.1,3,3)

"KEY",779.4,779.4,"A",0)
779.4^A^P^82
"KEY",779.4,779.4,"A",2,0)
^.312IA^1^1
"KEY",779.4,779.4,"A",2,1,0)
.01^779.4^1
"KEYPTR",779.4,779.4,"A")
779.4^C
"KRN",.402,107,-1)
0^1
"KRN",.402,107,0)
HLO DEACTIVATE OUT MSG^3090320.1226^@^779.2^^@^3090330
"KRN",.402,107,"DIAB",2,1,779.21,0)
.02;REQ
"KRN",.402,107,"DR",1,779.2)
.01;1;
"KRN",.402,107,"DR",2,779.21)
.01;.02R~;W !,"Enter a version only if this action applies only to a specific version of the message.";.06;.07;
"KRN",.402,108,-1)
0^3
"KRN",.402,108,0)
HLO EDIT SENDING APPLICATION^3090327.1243^@^779.2^^@^3090717
"KRN",.402,108,"DIAB",9,0,779.2,0)
.1;REQ
"KRN",.402,108,"DR",1,779.2)
.01;2;S:'$$ASKYESNO^HLOUSR2("Do you want to edit the setup for sequence queues","NO") Y="@10";.11;I X'="" S Y="@3";.1///@;S Y="@4";@3;.1R~;@4;.12;@10;
"KRN",.402,109,-1)
0^2
"KRN",.402,109,0)
HLO EDIT RECEIVING APPLICATION^3090327.1241^@^779.2^^@^3090520
"KRN",.402,109,"DIAB",2,0,779.2,2)
.03;"DEFAULT PRIVATE QUEUE (optional)"
"KRN",.402,109,"DIAB",2,0,779.2,3)
.02;"RETURN LINK FOR APPLICATION ACKNOWLEDGMENTS"
"KRN",.402,109,"DIAB",2,1,779.21,0)
.02;REQ
"KRN",.402,109,"DIAB",5,1,779.21,0)
.05;REQ
"KRN",.402,109,"DIAB",6,1,779.21,0)
.04;REQ
"KRN",.402,109,"DIAB",8,1,779.21,0)
.03;"PRIVATE QUEUE (optional)"
"KRN",.402,109,"DR",1,779.2)
.01;2;S:'$$ASKYESNO^HLOUSR2("Do you want to edit the setup for receiving batch messages","NO") Y="@1";.05;I X'="" S Y="@2";.04///@;.08///@;S Y="@1";@2;.04;W !,"If a private queue is used for batches its name must be namespaced!";
"KRN",.402,109,"DR",1,779.2,1)
.08;@1;1;S:'$$ASKYESNO^HLOUSR2("Do you want to edit the default action for non-specified messages types","NO") Y="@3";.07;I X'="" S Y="@4";.06///@;.03///@;S Y="@3";@4;.06;
"KRN",.402,109,"DR",1,779.2,2)
W !,"If you specify a private queue for the default action then its name must be namespaced!";.03DEFAULT PRIVATE QUEUE (optional)~;@3;
"KRN",.402,109,"DR",1,779.2,3)
W !,"If application acknowledgments are returned, and they must go through a",!,"specific link, enter it here. This applies if an interface engine or other",!,"middleware is used.";.02RETURN LINK FOR APPLICATION ACKNOWLEDGMENTS~;
"KRN",.402,109,"DR",2,779.21)
.01;.02R~;W !,"Enter a version only if this action applies only to a specific version of the",!,"message.";.06;.05R~;.04R~;W !,"If a private queue is used the name must be namespaced!";.03PRIVATE QUEUE (optional)~;
"KRN",.402,110,-1)
0^4
"KRN",.402,110,0)
HLO EDIT SUBSCRIPTION^3090401.1025^@^779.4^^@^3090401
"KRN",.402,110,"DIAB",3,1,779.41,0)
.021;"RECEIVING FACILITY LOGICAL LINK"
"KRN",.402,110,"DR",1,779.4)
.01;.02;.03;20;
"KRN",.402,110,"DR",2,779.41)
.01;.02;.021RECEIVING FACILITY LOGICAL LINK~;D ADDFAC^HLOASUB(DA(1),DA);1.02;
"KRN",19,1045,-1)
0^12
"KRN",19,1045,0)
HLO SYSTEM MONITOR^HLO SYSTEM MONITOR^^A^^HLOMGR^^^^^y^HEALTH LEVEL SEVEN^^1
"KRN",19,1045,1,0)
^19.06^1^1^3080415^^^^
"KRN",19,1045,1,1,0)
This option is for IRM folks to monitor the operational aspects of HLO.
"KRN",19,1045,20)
D EN^HLOUSR
"KRN",19,1045,"U")
HLO SYSTEM MONITOR
"KRN",19,1046,-1)
0^11
"KRN",19,1046,0)
HLO MESSAGE VIEWER^HLO MESSAGE VIEWER^^A^^^^^^^y^HEALTH LEVEL SEVEN^^1
"KRN",19,1046,1,0)
^19.06^2^2^3090323^^^^
"KRN",19,1046,1,1,0)
This option is for viewing messages.  It is a ListManager interface that provides
"KRN",19,1046,1,2,0)
a variety of methods for selecting messages for viewing.
"KRN",19,1046,20)
D EN^HLOUSR2
"KRN",19,1046,"U")
HLO MESSAGE VIEWER
"KRN",19,1047,-1)
0^8
"KRN",19,1047,0)
HLO MAIN MENU^HL7 (Optimized) MAIN MENU^^M^^HLOMAIN^^^^^y^HEALTH LEVEL SEVEN
"KRN",19,1047,1,0)
^19.06^1^1^3090520^^^^
"KRN",19,1047,1,1,0)
This menu contains all the options developed for HLO.
"KRN",19,1047,10,0)
^19.01IP^10^6
"KRN",19,1047,10,1,0)
1045^SM^1
"KRN",19,1047,10,1,"^")
HLO SYSTEM MONITOR
"KRN",19,1047,10,2,0)
1046^MV^2
"KRN",19,1047,10,2,"^")
HLO MESSAGE VIEWER
"KRN",19,1047,10,4,0)
1151^STAT^4
"KRN",19,1047,10,4,"^")
HLO MESSAGE STATISTICS
"KRN",19,1047,10,5,0)
1244^ES^5
"KRN",19,1047,10,5,"^")
HLO ERROR STATISTICS REPORT
"KRN",19,1047,10,8,0)
1395^SP
"KRN",19,1047,10,8,"^")
HLO EDIT SYSTEM PARAMETERS
"KRN",19,1047,10,10,0)
1414^DM^10
"KRN",19,1047,10,10,"^")
HLO DEVELOPER MENU
"KRN",19,1047,10.1)
HLO MAIN MENU
"KRN",19,1047,99)
61501,37833
"KRN",19,1047,99.1)
61597,3302
"KRN",19,1047,"U")
HL7 (OPTIMIZED) MAIN MENU
"KRN",19,1151,-1)
0^10
"KRN",19,1151,0)
HLO MESSAGE STATISTICS^HLO MESSAGE STATISTICS^^A^^^^^^^y^HEALTH LEVEL SEVEN^^1
"KRN",19,1151,1,0)
^^4^4^3051026^
"KRN",19,1151,1,1,0)
This option is a report that displays by period the counts of messgages sent
"KRN",19,1151,1,2,0)
and received via HLO.  The counts are sub-categorized by application and
"KRN",19,1151,1,3,0)
message type.
"KRN",19,1151,1,4,0)

"KRN",19,1151,10.1)
HLO MESSAGE STATISTICS REPORT
"KRN",19,1151,20)
D REPORT^HLOSTAT
"KRN",19,1151,"U")
HLO MESSAGE STATISTICS
"KRN",19,1244,-1)
0^14
"KRN",19,1244,0)
HLO ERROR STATISTICS REPORT^HLO ERROR STATISTICS^^A^^^^^^^y^HEALTH LEVEL SEVEN^^1
"KRN",19,1244,1,0)
^19.06^5^5^3070212^^^^
"KRN",19,1244,1,1,0)
This option is a report that displays by period the counts of messgage errors
"KRN",19,1244,1,2,0)
that occurred while sending and recieivng messages via HLO.  The counts are
"KRN",19,1244,1,3,0)
sub-categorized by application and message type.
"KRN",19,1244,1,4,0)

"KRN",19,1244,1,5,0)

"KRN",19,1244,10.1)
HLO MESSAGE STATISTICS REPORT
"KRN",19,1244,20)
D REPORT^HLOESTAT
"KRN",19,1244,"U")
HLO ERROR STATISTICS
"KRN",19,1395,-1)
0^13
"KRN",19,1395,0)
HLO EDIT SYSTEM PARAMETERS^EDIT HLO SYSTEM PARAMETERS^^A^^^^^^^y^HEALTH LEVEL SEVEN^^1
"KRN",19,1395,1,0)
^19.06^2^2^3080922^^
"KRN",19,1395,1,1,0)
Used to edit the HLO System Parmeters.
"KRN",19,1395,1,2,0)

"KRN",19,1395,20)
D EDITSITE^HLOUSR
"KRN",19,1395,"U")
EDIT HLO SYSTEM PARAMETERS
"KRN",19,1409,-1)
0^9
"KRN",19,1409,0)
HLO TERMINATE OUTGOING MESSAGE^INACTIVATE SENDING APPLICATION^^E^^^^^^^y^HEALTH LEVEL SEVEN
"KRN",19,1409,1,0)
^19.06^1^1^3090323^^^
"KRN",19,1409,1,1,0)
This option allows the user to deactivate specific message types.
"KRN",19,1409,10.1)
HLO DEACTIVATE OUT MSG
"KRN",19,1409,30)
HLD(779.2,
"KRN",19,1409,31)
AEMQL
"KRN",19,1409,50)
HLD(779.2,
"KRN",19,1409,51)
[HLO DEACTIVATE OUT MSG]
"KRN",19,1409,99)
61440,49732
"KRN",19,1409,"U")
INACTIVATE SENDING APPLICATION
"KRN",19,1410,-1)
0^4
"KRN",19,1410,0)
HLO EDIT SENDING APPLICATION^ADD/EDIT SENDING APPLICATION^^E^^^^^^^y^HEALTH LEVEL SEVEN
"KRN",19,1410,1,0)
^19.06^3^3^3090327^^^
"KRN",19,1410,1,1,0)
This option allows the user to add or edit an HLO sending application in the 
"KRN",19,1410,1,2,0)
HLO Application Registry.
"KRN",19,1410,1,3,0)

"KRN",19,1410,10.1)
ADD/EDIT SENDING APPLICATION
"KRN",19,1410,30)
HLD(779.2,
"KRN",19,1410,31)
AEMQL
"KRN",19,1410,50)
HLD(779.2,
"KRN",19,1410,51)
[HLO EDIT SENDING APPLICATION]
"KRN",19,1410,"U")
ADD/EDIT SENDING APPLICATION
"KRN",19,1411,-1)
0^3
"KRN",19,1411,0)
HLO EDIT RECEIVING APPLICATION^ADD/EDIT RECEIVING APPLICATION^^E^^^^^^^y^HEALTH LEVEL SEVEN
"KRN",19,1411,1,0)
^19.06^1^1^3090327^^
"KRN",19,1411,1,1,0)
This option allows the user to edit a HLO receiving application.
"KRN",19,1411,10.1)
HLO EDIT RECEIVE
"KRN",19,1411,30)
HLD(779.2,
"KRN",19,1411,31)
AEMQL
"KRN",19,1411,50)
HLD(779.2,
"KRN",19,1411,51)
[HLO EDIT RECEIVING APPLICATION]
"KRN",19,1411,99)
61440,48312
"KRN",19,1411,"U")
ADD/EDIT RECEIVING APPLICATION
"KRN",19,1412,-1)
0^5
"KRN",19,1412,0)
HLO APPLICATION REGISTRY MENU^APPLICATION REGISTRY MENU^^M^^^^^^^y^HEALTH LEVEL SEVEN
"KRN",19,1412,1,0)
^19.06^2^2^3090327^^^
"KRN",19,1412,1,1,0)
Contains an menu of options for maintaining the HLO Application Registry.
"KRN",19,1412,1,2,0)

"KRN",19,1412,10,0)
^19.01IP^3^3
"KRN",19,1412,10,1,0)
1409^STOP^1
"KRN",19,1412,10,1,"^")
HLO TERMINATE OUTGOING MESSAGE
"KRN",19,1412,10,2,0)
1410^SA^2
"KRN",19,1412,10,2,"^")
HLO EDIT SENDING APPLICATION
"KRN",19,1412,10,3,0)
1411^RA^3
"KRN",19,1412,10,3,"^")
HLO EDIT RECEIVING APPLICATION
"KRN",19,1412,99)
61447,46080
"KRN",19,1412,"U")
APPLICATION REGISTRY MENU
"KRN",19,1413,-1)
0^7
"KRN",19,1413,0)
HLO SUBSCRIPTION REGISTRY^ADD/EDIT SUBSCRIPTIONS^^E^^^^^^^y^HEALTH LEVEL SEVEN
"KRN",19,1413,1,0)
^19.06^3^3^3090702^^^^
"KRN",19,1413,1,1,0)
This option is used to create new entries in the HLO Subscription Registry
"KRN",19,1413,1,2,0)
and edit those subscriptions.
"KRN",19,1413,1,3,0)

"KRN",19,1413,10.1)
EDIT SUBSCRIPTION
"KRN",19,1413,30)
HLD(779.4,
"KRN",19,1413,31)
AEMQL
"KRN",19,1413,50)
HLD(779.4,
"KRN",19,1413,51)
[HLO EDIT SUBSCRIPTION]
"KRN",19,1413,"U")
ADD/EDIT SUBSCRIPTIONS
"KRN",19,1414,-1)
0^6
"KRN",19,1414,0)
HLO DEVELOPER MENU^HLO DEVELOPER MENU^^M^^^^^^^^HEALTH LEVEL SEVEN
"KRN",19,1414,1,0)
^19.06^2^2^3090629^^^^
"KRN",19,1414,1,1,0)
Contains options that are geared towards developing messaging applications.
"KRN",19,1414,1,2,0)

"KRN",19,1414,10,0)
^19.01IP^3^3
"KRN",19,1414,10,1,0)
1413^SR^2
"KRN",19,1414,10,1,"^")
HLO SUBSCRIPTION REGISTRY
"KRN",19,1414,10,3,0)
1412^AR
"KRN",19,1414,10,3,"^")
HLO APPLICATION REGISTRY MENU
"KRN",19,1414,10.1)
DEVELOPER MENU
"KRN",19,1414,99)
61450,36813
"KRN",19,1414,"U")
HLO DEVELOPER MENU
"KRN",101,514,-1)
0^1
"KRN",101,514,0)
HLO OUTBOUND DELETE^DEL QUE^^A^^^^^^^^HEALTH LEVEL SEVEN
"KRN",101,514,.1)
DELETE
"KRN",101,514,1,0)
^101.06^2^2^3071114^^^^
"KRN",101,514,1,1,0)
This action deletes messages from a specified queue.
"KRN",101,514,1,2,0)

"KRN",101,514,2,0)
^101.02A^2^1
"KRN",101,514,2,2,0)
DQ
"KRN",101,514,2,"B","DQ",2)

"KRN",101,514,15)
K QUETYP
"KRN",101,514,20)
S QUETYP="O" D LMQUES^HLOQUE1 S VALMBCK="R"
"KRN",101,514,99)
61206,27044
"MBREQ")
0
"ORD",7,.402)
.402;7;;;EDEOUT^DIFROMSO(.402,DA,"",XPDA);FPRE^DIFROMSI(.402,"",XPDA);EPRE^DIFROMSI(.402,DA,$E("N",$G(XPDNEW)),XPDA,"",OLDA);;EPOST^DIFROMSI(.402,DA,"",XPDA);DEL^DIFROMSK(.402,"",%)
"ORD",7,.402,0)
INPUT TEMPLATE
"ORD",15,101)
101;15;;;PRO^XPDTA;PROF1^XPDIA;PROE1^XPDIA;PROF2^XPDIA;;PRODEL^XPDIA
"ORD",15,101,0)
PROTOCOL
"ORD",18,19)
19;18;;;OPT^XPDTA;OPTF1^XPDIA;OPTE1^XPDIA;OPTF2^XPDIA;;OPTDEL^XPDIA
"ORD",18,19,0)
OPTION
"PKG",9,-1)
1^1
"PKG",9,0)
HEALTH LEVEL SEVEN^HL^DHCP IMPLEMENTATION OF HEALTH LEVEL SEVEN^
"PKG",9,20,0)
^9.402P^^
"PKG",9,22,0)
^9.49I^1^1
"PKG",9,22,1,0)
1.6^2980130^2980130^6
"PKG",9,22,1,"PAH",1,0)
146^3090824
"PKG",9,22,1,"PAH",1,1,0)
^^2^2^3090824
"PKG",9,22,1,"PAH",1,1,1,0)
See the National Patch Module on Forum for a complete description.
"PKG",9,22,1,"PAH",1,1,2,0)

"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
NO
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
NO
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
NO
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
23
"RTN","HLOAPI")
0^12^B114629271^B95686689
"RTN","HLOAPI",1,0)
HLOAPI ;ALB/CJM-HL7 - Developer API's for sending & receiving messages ;05/12/2009
"RTN","HLOAPI",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,133,138,139,146**;Oct 13, 1995;Build 16
"RTN","HLOAPI",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOAPI",4,0)
 ;
"RTN","HLOAPI",5,0)
NEWMSG(PARMS,HLMSTATE,ERROR) ;; Starts a new message.
"RTN","HLOAPI",6,0)
 ;;
"RTN","HLOAPI",7,0)
 ;;** External API **
"RTN","HLOAPI",8,0)
 ;;  
"RTN","HLOAPI",9,0)
 ;;Input: 
"RTN","HLOAPI",10,0)
 ;;   PARMS( *pass by reference*
"RTN","HLOAPI",11,0)
 ;;     "COUNTRY")=3 character country code (optional)
"RTN","HLOAPI",12,0)
 ;;     "CONTINUATION POINTER" -indicates a fragmented message
"RTN","HLOAPI",13,0)
 ;;     "EVENT")=3 character event type (required)
"RTN","HLOAPI",14,0)
 ;;     "FIELD SEPARATOR")=field separator (optional, defaults to "|")
"RTN","HLOAPI",15,0)
 ;;     "ENCODING CHARACTERS")= 4 HL7 encoding characters (optional,defaults to "^~\&")
"RTN","HLOAPI",16,0)
 ;;     "MESSAGE STRUCTURE" - MSH 9, component 3 - a code from the standard HL7 table (optional)
"RTN","HLOAPI",17,0)
 ;;     "MESSAGE TYPE")=3 character message type (required)
"RTN","HLOAPI",18,0)
 ;;     "PROCESSING MODE" - MSH 11, component 2 - a 1 character code (optional)
"RTN","HLOAPI",19,0)
 ;;     "VERSION")=the HL7 Version ID, for example, "2.4" (optional, defaults to 2.4)
"RTN","HLOAPI",20,0)
 ;;Output:
"RTN","HLOAPI",21,0)
 ;;  Function- returns 1 on success, 0 on failure
"RTN","HLOAPI",22,0)
 ;;  HLMSTATE() - (pass by reference, required) This array is used by the HL7 package to track the progress of the message.  The application MUST NOT touch it!
"RTN","HLOAPI",23,0)
 ;;  PARMS - left defined when the function returns
"RTN","HLOAPI",24,0)
 ;;  ERROR (optional, pass by reference) - returns an error message on failure
"RTN","HLOAPI",25,0)
 ;;
"RTN","HLOAPI",26,0)
 ;
"RTN","HLOAPI",27,0)
 N DATA,I,SYSTEM,SUCCESS
"RTN","HLOAPI",28,0)
 S SUCCESS=0
"RTN","HLOAPI",29,0)
 K ERROR,HLMSTATE
"RTN","HLOAPI",30,0)
 D
"RTN","HLOAPI",31,0)
 .I $L($G(PARMS("PROCESSING MODE"))),$L(PARMS("PROCESSING MODE"))'=1 S ERROR="INVALID PROCESSING MODE" Q
"RTN","HLOAPI",32,0)
 .I $L($G(PARMS("COUNTRY"))),$L(PARMS("COUNTRY"))'=3 S ERROR="INVALID COUNTRY CODE" Q
"RTN","HLOAPI",33,0)
 .I $L($G(PARMS("EVENT")))'=3 S ERROR="INVALID EVENT CODE" Q
"RTN","HLOAPI",34,0)
 .I $L($G(PARMS("MESSAGE TYPE")))'=3 S ERROR="INVALID MESSAGE TYPE" Q
"RTN","HLOAPI",35,0)
 .I $L($G(PARMS("ENCODING CHARACTERS"))),$L(PARMS("ENCODING CHARACTERS"))'=4 S ERROR="INVALID ENCODING CHARACTERS" Q
"RTN","HLOAPI",36,0)
 .I $L($G(PARMS("FIELD SEPARATOR"))),$L(PARMS("FIELD SEPARATOR"))'=1 S ERROR="INVALID FIELD SEPARATOR" Q
"RTN","HLOAPI",37,0)
 .I '$L($G(PARMS("FIELD SEPARATOR"))) S PARMS("FIELD SEPARATOR")="|"
"RTN","HLOAPI",38,0)
 .I '$L($G(PARMS("ENCODING CHARACTERS"))) S PARMS("ENCODING CHARACTERS")="^~\&"
"RTN","HLOAPI",39,0)
 .I $G(PARMS("VERSION"))="" S PARMS("VERSION")="2.4"
"RTN","HLOAPI",40,0)
 .I ($L($G(PARMS("VERSION")))>20) S ERROR="VERSION > 20 CHARACTERS" Q
"RTN","HLOAPI",41,0)
 .F I="MESSAGE TYPE","EVENT","COUNTRY","FIELD SEPARATOR","ENCODING CHARACTERS","VERSION","CONTINUATION POINTER","MESSAGE STRUCTURE","PROCESSING MODE" S HLMSTATE("HDR",I)=$G(PARMS(I))
"RTN","HLOAPI",42,0)
 .S HLMSTATE("BATCH")=0 ;not a batch
"RTN","HLOAPI",43,0)
 .S HLMSTATE("DIRECTION")="OUT"
"RTN","HLOAPI",44,0)
 .S HLMSTATE("IEN")=""
"RTN","HLOAPI",45,0)
 .S HLMSTATE("BODY")="" ;record not yet created
"RTN","HLOAPI",46,0)
 .S HLMSTATE("CURRENT SEGMENT")=0 ;no segments cached
"RTN","HLOAPI",47,0)
 .S HLMSTATE("UNSTORED LINES")=0 ;nothing in cache
"RTN","HLOAPI",48,0)
 .S HLMSTATE("LINE COUNT")=0
"RTN","HLOAPI",49,0)
 .D GETSYS(.HLMSTATE)
"RTN","HLOAPI",50,0)
 .S SUCCESS=1
"RTN","HLOAPI",51,0)
 Q SUCCESS
"RTN","HLOAPI",52,0)
 ;
"RTN","HLOAPI",53,0)
NEWBATCH(PARMS,HLMSTATE,ERROR) ;;Starts a new batch message.  
"RTN","HLOAPI",54,0)
 ;;Input: 
"RTN","HLOAPI",55,0)
 ;;  PARMS( *pass by reference*
"RTN","HLOAPI",56,0)
 ;;   "COUNTRY")=3 character country code (optional)
"RTN","HLOAPI",57,0)
 ;;   "FIELD SEPARATOR")=field separator (optional, defaults to "|")
"RTN","HLOAPI",58,0)
 ;;   "ENCODING CHARACTERS")= 4 HL7 encoding characters (optional,defaults to "^~\&") 
"RTN","HLOAPI",59,0)
 ;;   "VERSION")=the HL7 Version ID, for example, "2.4" (optional, defaults to 2.4)
"RTN","HLOAPI",60,0)
 ;;Output:
"RTN","HLOAPI",61,0)
 ;;  Function - returns 1 on success, 0 on failure
"RTN","HLOAPI",62,0)
 ;;  PARMS - left defined when the function returns
"RTN","HLOAPI",63,0)
 ;;  HLMSTATE() - (pass by reference, required) This array is used by the HL7 package to track the progress of the message.  The application MUST NOT touch it!
"RTN","HLOAPI",64,0)
 ;;  ERROR (optional, pass by reference) - returns an error message on failure
"RTN","HLOAPI",65,0)
 ;;
"RTN","HLOAPI",66,0)
 ;
"RTN","HLOAPI",67,0)
 N DATA,I,SYSTEM,SUCCESS
"RTN","HLOAPI",68,0)
 S SUCCESS=0
"RTN","HLOAPI",69,0)
 K ERROR,HLMSTATE
"RTN","HLOAPI",70,0)
 D
"RTN","HLOAPI",71,0)
 .I $L($G(PARMS("COUNTRY"))),$L(PARMS("COUNTRY"))'=3 S ERROR="INVALID COUNTRY CODE" Q
"RTN","HLOAPI",72,0)
 .I $L($G(PARMS("ENCODING CHARACTERS"))),$L(PARMS("ENCODING CHARACTERS"))'=4 S ERROR="INVALID ENCODING CHARACTERS" Q
"RTN","HLOAPI",73,0)
 .I $L($G(PARMS("FIELD SEPARATOR"))),$L(PARMS("FIELD SEPARATOR"))'=1 S ERROR="INVALID FIELD SEPARATOR" Q
"RTN","HLOAPI",74,0)
 .I '$L($G(PARMS("FIELD SEPARATOR"))) S PARMS("FIELD SEPARATOR")="|"
"RTN","HLOAPI",75,0)
 .I '$L($G(PARMS("ENCODING CHARACTERS"))) S PARMS("ENCODING CHARACTERS")="^~\&"
"RTN","HLOAPI",76,0)
 .I $G(PARMS("VERSION"))="" S PARMS("VERSION")="2.4"
"RTN","HLOAPI",77,0)
 .I ($L(PARMS("VERSION"))>20) S ERROR="VERSION > 20 CHARACTERS" Q
"RTN","HLOAPI",78,0)
 .F I="COUNTRY","FIELD SEPARATOR","ENCODING CHARACTERS","VERSION" S HLMSTATE("HDR",I)=$G(PARMS(I))
"RTN","HLOAPI",79,0)
 .S HLMSTATE("IEN")=""
"RTN","HLOAPI",80,0)
 .S HLMSTATE("BODY")="" ;msg not yet stored
"RTN","HLOAPI",81,0)
 .S HLMSTATE("BATCH")=1
"RTN","HLOAPI",82,0)
 .S HLMSTATE("DIRECTION")="OUT"
"RTN","HLOAPI",83,0)
 .S HLMSTATE("BATCH","CURRENT MESSAGE")=0 ;no messages in batch
"RTN","HLOAPI",84,0)
 .S HLMSTATE("CURRENT SEGMENT")=0 ;no segments in cache
"RTN","HLOAPI",85,0)
 .S HLMSTATE("UNSTORED LINES")=0 ;nothing in cache
"RTN","HLOAPI",86,0)
 .S HLMSTATE("LINE COUNT")=0 ;no lines within message stored
"RTN","HLOAPI",87,0)
 .D GETSYS(.HLMSTATE)
"RTN","HLOAPI",88,0)
 .S SUCCESS=1
"RTN","HLOAPI",89,0)
 Q SUCCESS
"RTN","HLOAPI",90,0)
 ;
"RTN","HLOAPI",91,0)
SET(SEG,VALUE,FIELD,COMP,SUBCOMP,REP) ;;Sets a value to the array SEG(), used for building segments.
"RTN","HLOAPI",92,0)
 ;;Input:
"RTN","HLOAPI",93,0)
 ;; SEG - (required, pass by reference) - this is the array where the segment is being built.
"RTN","HLOAPI",94,0)
 ;; VALUE - the individual value to be set into the segment
"RTN","HLOAPI",95,0)
 ;; FIELD - the sequence # of the field (optional, defaults to 0)
"RTN","HLOAPI",96,0)
 ;;     *NOTE: FIELD=0 is used to denote the segment type.
"RTN","HLOAPI",97,0)
 ;; COMP - the # of the component (optional, defaults to 1)
"RTN","HLOAPI",98,0)
 ;; SUBCOMP - the # of the subcomponent (optional, defaults to 1)
"RTN","HLOAPI",99,0)
 ;; REP - the occurrence# (optional, defaults to 1)  For a non-repeating field, the occurrence # need not be provided, because it would be 1.
"RTN","HLOAPI",100,0)
 ;;Output: 
"RTN","HLOAPI",101,0)
 ;;  SEG array
"RTN","HLOAPI",102,0)
 ;;
"RTN","HLOAPI",103,0)
 ;;  Example:
"RTN","HLOAPI",104,0)
 ;;    D SET(.SEG,"MSA",0) creates an MSA segment 
"RTN","HLOAPI",105,0)
 ;;    D SET(.SEG,"AE",1) will place the value into the array position
"RTN","HLOAPI",106,0)
 ;;    reserved for the 1st field,1st occurence,1st comp,1st subcomp
"RTN","HLOAPI",107,0)
 ;;
"RTN","HLOAPI",108,0)
 ;;Implementation Note - This format is used for the segment array built by calls to SET: SEGMENT(<SEQ #>,<occurrence #>,<component #>,<subcomponent #>)=<subcomponent value> 
"RTN","HLOAPI",109,0)
 ;
"RTN","HLOAPI",110,0)
 S:'$G(FIELD) FIELD=0
"RTN","HLOAPI",111,0)
 S:'$G(COMP) COMP=1
"RTN","HLOAPI",112,0)
 S:'$G(SUBCOMP) SUBCOMP=1
"RTN","HLOAPI",113,0)
 S:'$G(REP) REP=1
"RTN","HLOAPI",114,0)
 S SEG(FIELD,REP,COMP,SUBCOMP)=$G(VALUE)
"RTN","HLOAPI",115,0)
 Q
"RTN","HLOAPI",116,0)
 ;
"RTN","HLOAPI",117,0)
ADDSEG(HLMSTATE,SEG,ERROR,TOARY) ;; Adds a segment to the message.
"RTN","HLOAPI",118,0)
 ;;Input:
"RTN","HLOAPI",119,0)
 ;;  HLMSTATE() - (pass by reference, required) This array is a workspace for HLO.  The application MUST NOT touch it!
"RTN","HLOAPI",120,0)
 ;;  SEG() - (pass-by-reference, required) Contains the data.  It be created prior to calling $$ADDSEG.
"RTN","HLOAPI",121,0)
 ;;
"RTN","HLOAPI",122,0)
 ;;Note#1:  The message control segments, including the MSH and BHS segments, are added automatically.
"RTN","HLOAPI",123,0)
 ;;Note#2:  The 0th field must be a 3 character segment type
"RTN","HLOAPI",124,0)
 ;;Note#3: ***SEG is killed upon successfully adding the segment***
"RTN","HLOAPI",125,0)
 ;;
"RTN","HLOAPI",126,0)
 ;;Output:
"RTN","HLOAPI",127,0)
 ;;   HLMSTATE() - (pass-by-reference, required) This array is used by the HL7 package to track the progress of the message.
"RTN","HLOAPI",128,0)
 ;;  FUNCTION - returns 1 on success, 0 on failure
"RTN","HLOAPI",129,0)
 ;;  TOARY (optional, pass by reference) returns the built segment in
"RTN","HLOAPI",130,0)
 ;;        this format:
"RTN","HLOAPI",131,0)
 ;;         TOARY(1)
"RTN","HLOAPI",132,0)
 ;;         TOARY(2)
"RTN","HLOAPI",133,0)
 ;;         TOARY(3), etc.
"RTN","HLOAPI",134,0)
 ;;    If the segment fits on a single line, only TOARY(1) is returned.
"RTN","HLOAPI",135,0)
 ;;
"RTN","HLOAPI",136,0)
 ;;  ERROR (optional, pass by reference) - returns an error message on failure
"RTN","HLOAPI",137,0)
 ;;
"RTN","HLOAPI",138,0)
 ;
"RTN","HLOAPI",139,0)
 K ERROR
"RTN","HLOAPI",140,0)
 N TYPE
"RTN","HLOAPI",141,0)
 K TOARY
"RTN","HLOAPI",142,0)
 ;
"RTN","HLOAPI",143,0)
 S TYPE=$G(SEG(0,1,1,1)) ;segment type
"RTN","HLOAPI",144,0)
 ;
"RTN","HLOAPI",145,0)
 ;if a 'generic' app ack MSA was built, add it as the first segment before this one
"RTN","HLOAPI",146,0)
 I $D(HLMSTATE("MSA")) D
"RTN","HLOAPI",147,0)
 .I TYPE'="MSA" S TOARY(1)=HLMSTATE("MSA") D ADDSEG^HLOMSG(.HLMSTATE,.TOARY) K TOARY
"RTN","HLOAPI",148,0)
 .K HLMSTATE("MSA")
"RTN","HLOAPI",149,0)
 ;
"RTN","HLOAPI",150,0)
 I ($L(TYPE)'=3) S ERROR="INVALID SEGMENT TYPE" Q 0
"RTN","HLOAPI",151,0)
 I (TYPE="MSH")!(TYPE="BHS")!(TYPE="BTS")!(TYPE="FHS")!(TYPE="FTS") S ERROR="INVALID SEGMENT TYPE" Q 0
"RTN","HLOAPI",152,0)
 I HLMSTATE("BATCH"),'HLMSTATE("BATCH","CURRENT MESSAGE") S ERROR="NO MESSAGES IN BATCH, SO SEGMENTS NOT ALLOWED" Q 0
"RTN","HLOAPI",153,0)
 I $$BUILDSEG^HLOPBLD(.HLMSTATE,.SEG,.TOARY,.ERROR) D ADDSEG^HLOMSG(.HLMSTATE,.TOARY) K SEG Q 1
"RTN","HLOAPI",154,0)
 Q 0
"RTN","HLOAPI",155,0)
 ;
"RTN","HLOAPI",156,0)
 ;**P146 START CJM
"RTN","HLOAPI",157,0)
MOVESEG(HLMSTATE,SEG,ERROR) ;Adds a segment built in the 'traditional' way as an array of lines into the message.
"RTN","HLOAPI",158,0)
 ;;Input:
"RTN","HLOAPI",159,0)
 ;;  HLMSTATE() - (pass by reference, required) This array is a workspace for HLO. 
"RTN","HLOAPI",160,0)
 ;;  SEG() - (pass-by-reference, required) Contains the segment.  The segement.  If the segment is short enough it should consist of only SEG or SEG(1).  If longer, additional lines can be added as SEG(<n>). 
"RTN","HLOAPI",161,0)
 ;;
"RTN","HLOAPI",162,0)
 ;;Note#1:  The message control segments, including the MSH, BHS & FTS segments, are added automatically, so may not be added by MOVESEG.
"RTN","HLOAPI",163,0)
 ;;
"RTN","HLOAPI",164,0)
 ;;Output:
"RTN","HLOAPI",165,0)
 ;;   HLMSTATE() - (pass-by-reference, required) This array is the workspace used by HLO.
"RTN","HLOAPI",166,0)
 ;;  FUNCTION - returns 1 on success, 0 on failure
"RTN","HLOAPI",167,0)
 ;;
"RTN","HLOAPI",168,0)
 ;;  ERROR (optional, pass by reference) - returns an error message on failure
"RTN","HLOAPI",169,0)
 ;;
"RTN","HLOAPI",170,0)
 ;
"RTN","HLOAPI",171,0)
 K ERROR
"RTN","HLOAPI",172,0)
 N TYPE,NEWCOUNT,OLDCOUNT,TOARY
"RTN","HLOAPI",173,0)
 ;
"RTN","HLOAPI",174,0)
 S NEWCOUNT=1
"RTN","HLOAPI",175,0)
 I $L($G(SEG)) S TOARY(1)=SEG,NEWCOUNT=2
"RTN","HLOAPI",176,0)
 S OLDCOUNT=0
"RTN","HLOAPI",177,0)
 F  S OLDCOUNT=$O(SEG(OLDCOUNT)) Q:'OLDCOUNT  S TOARY(NEWCOUNT)=SEG(OLDCOUNT),NEWCOUNT=NEWCOUNT+1
"RTN","HLOAPI",178,0)
 S TYPE=$P($G(TOARY(1)),HLMSTATE("HDR","FIELD SEPARATOR")) ;segment type
"RTN","HLOAPI",179,0)
 ;
"RTN","HLOAPI",180,0)
 ;if a 'generic' app ack MSA was built, add it as the first segment before this one
"RTN","HLOAPI",181,0)
 I $D(HLMSTATE("MSA")) D
"RTN","HLOAPI",182,0)
 .I TYPE'="MSA" N TOARY S TOARY(1)=HLMSTATE("MSA") D ADDSEG^HLOMSG(.HLMSTATE,.TOARY)
"RTN","HLOAPI",183,0)
 .K HLMSTATE("MSA")
"RTN","HLOAPI",184,0)
 ;
"RTN","HLOAPI",185,0)
 I ($L(TYPE)'=3) S ERROR="INVALID SEGMENT TYPE" Q 0
"RTN","HLOAPI",186,0)
 I (TYPE="MSH")!(TYPE="BHS")!(TYPE="BTS")!(TYPE="FHS")!(TYPE="FTS") S ERROR="INVALID SEGMENT TYPE" Q 0
"RTN","HLOAPI",187,0)
 I HLMSTATE("BATCH"),'HLMSTATE("BATCH","CURRENT MESSAGE") S ERROR="NO MESSAGES IN BATCH, SO SEGMENTS NOT ALLOWED" Q 0
"RTN","HLOAPI",188,0)
 D ADDSEG^HLOMSG(.HLMSTATE,.TOARY)
"RTN","HLOAPI",189,0)
 Q 1
"RTN","HLOAPI",190,0)
 ;**P146 END CJM
"RTN","HLOAPI",191,0)
 ;
"RTN","HLOAPI",192,0)
ADDMSG(HLMSTATE,PARMS,ERROR) ;; Begins a new message in the batch.
"RTN","HLOAPI",193,0)
 ;;Input:
"RTN","HLOAPI",194,0)
 ;;  HLMSTATE() - (pass by reference, required) This array is used by the HL7 package to track the progress of the message.  The application MUST NOT touch it!
"RTN","HLOAPI",195,0)
 ;;  PARMS( *pass by reference*
"RTN","HLOAPI",196,0)
 ;;    "EVENT")=3 character event type (required)
"RTN","HLOAPI",197,0)
 ;;    "MESSAGE TYPE")=3 character message type (required)
"RTN","HLOAPI",198,0)
 ;;
"RTN","HLOAPI",199,0)
 ;;Output:
"RTN","HLOAPI",200,0)
 ;;   FUNCTION - returns 1 on success, 0 on failure
"RTN","HLOAPI",201,0)
 ;;   HLMSTATE() - (pass by reference, required) This array is used by the HL7 package to track the progress of the message.
"RTN","HLOAPI",202,0)
 ;;   PARMS - left defined when this function returns
"RTN","HLOAPI",203,0)
 ;;   ERROR (optional, pass by reference) - returns an error message on failure
"RTN","HLOAPI",204,0)
 ;;
"RTN","HLOAPI",205,0)
 N I
"RTN","HLOAPI",206,0)
 K ERROR
"RTN","HLOAPI",207,0)
 ;if a 'generic' app ack MSA was built, add it as the first segment before this one
"RTN","HLOAPI",208,0)
 I $D(HLMSTATE("MSA")) D
"RTN","HLOAPI",209,0)
 .N TOARY S TOARY(1)=HLMSTATE("MSA") D ADDSEG^HLOMSG(.HLMSTATE,.TOARY)
"RTN","HLOAPI",210,0)
 .K HLMSTATE("MSA")
"RTN","HLOAPI",211,0)
 I $L($G(PARMS("EVENT")))'=3 S ERROR="EVENT TYPE INVALID" Q 0
"RTN","HLOAPI",212,0)
 I $L($G(PARMS("MESSAGE TYPE")))'=3 S ERROR="MESSAGE TYPE INVALID" Q 0
"RTN","HLOAPI",213,0)
 D ADDMSG^HLOMSG(.HLMSTATE,.PARMS)
"RTN","HLOAPI",214,0)
 Q 1
"RTN","HLOAPI",215,0)
 ;
"RTN","HLOAPI",216,0)
GETSYS(HLMSTATE) ;
"RTN","HLOAPI",217,0)
 N SYS,SUB
"RTN","HLOAPI",218,0)
 D SYSPARMS^HLOSITE(.SYS)
"RTN","HLOAPI",219,0)
 F SUB="DOMAIN","STATION","PROCESSING ID","MAXSTRING","ERROR PURGE","NORMAL PURGE","PORT" S HLMSTATE("SYSTEM",SUB)=SYS(SUB)
"RTN","HLOAPI",220,0)
 S HLMSTATE("SYSTEM","BUFFER")=SYS("USER BUFFER")
"RTN","HLOAPI",221,0)
 Q
"RTN","HLOAPI",222,0)
 ;
"RTN","HLOAPI",223,0)
MOVEMSG(HLMSTATE,ARY) ;;
"RTN","HLOAPI",224,0)
 ;If a message was built in the 'old' way, and resides in an array, this  routine will move it into file 777 (HL7 Message Body)
"RTN","HLOAPI",225,0)
 ;Input:
"RTN","HLOAPI",226,0)
 ;  HLMSTATE (pass by reference) the array created by calling $$NEWMSG or $$NEWBATCH
"RTN","HLOAPI",227,0)
 ;  ARY - is the name of the array, local or global, where the message was built, used to reference the array by indirection.
"RTN","HLOAPI",228,0)
 ;Output:
"RTN","HLOAPI",229,0)
 ;  HLMSTATE (pass by reference) Is updated with information about the
"RTN","HLOAPI",230,0)
 ;            message.
"RTN","HLOAPI",231,0)
 ;;
"RTN","HLOAPI",232,0)
 N I S I=0
"RTN","HLOAPI",233,0)
 F  S I=$O(@ARY@(I)) Q:'I  D
"RTN","HLOAPI",234,0)
 .N SEG,J,J2
"RTN","HLOAPI",235,0)
 .S J=0,J2=1
"RTN","HLOAPI",236,0)
 .S SEG(J2)=@ARY@(I)
"RTN","HLOAPI",237,0)
 .F  S J=$O(@ARY@(I,J)) Q:'J  S J2=J2+1,SEG(J2)=@ARY@(I,J)
"RTN","HLOAPI",238,0)
 .I 'HLMSTATE("BATCH") D
"RTN","HLOAPI",239,0)
 ..D ADDSEG^HLOMSG(.HLMSTATE,.SEG)
"RTN","HLOAPI",240,0)
 .E  D
"RTN","HLOAPI",241,0)
 ..I $E(SEG(1),1,3)="MSH" D
"RTN","HLOAPI",242,0)
 ...D SPLITHDR^HLOSRVR1(.SEG)
"RTN","HLOAPI",243,0)
 ...D ADDMSG2^HLOMSG(.HLMSTATE,.SEG)
"RTN","HLOAPI",244,0)
 ..E  D ADDSEG^HLOMSG(.HLMSTATE,.SEG)
"RTN","HLOAPI",245,0)
 ;
"RTN","HLOAPI",246,0)
 ;signal SENDACK^HLOAPI2 that the application built its own msg
"RTN","HLOAPI",247,0)
 K HLMSTATE("MSA")
"RTN","HLOAPI",248,0)
 Q
"RTN","HLOAPI1")
0^13^B101211192^B49595357
"RTN","HLOAPI1",1,0)
HLOAPI1 ;;ALB/CJM-HL7 - Developer API's for sending & receiving messages(continued) ;06/10/2009
"RTN","HLOAPI1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,132,134,137,146**;Oct 13, 1995;Build 16
"RTN","HLOAPI1",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOAPI1",4,0)
 ;
"RTN","HLOAPI1",5,0)
SENDONE(HLMSTATE,PARMS,WHOTO,ERROR) ;Sends the message to a single receiving application.
"RTN","HLOAPI1",6,0)
 ;;
"RTN","HLOAPI1",7,0)
 ;;Input:
"RTN","HLOAPI1",8,0)
 ;;HLMSTATE() - (pass by reference, required) This array is used by the HL7 package to track the progress of the message.  The application MUST NOT touch it
"RTN","HLOAPI1",9,0)
 ;;PARMS( *pass by reference*
"RTN","HLOAPI1",10,0)
 ;;  "APP ACK RESPONSE")=<tag^routine> to call when the app ack is received (optional)
"RTN","HLOAPI1",11,0)
 ;;    (NOTE: For batch messages, HLO best supports returning application
"RTN","HLOAPI1",12,0)
 ;;     acknowledgments via a batch response.  However, non-VistA systems
"RTN","HLOAPI1",13,0)
 ;;     may return individual messages as application acknowledgments to
"RTN","HLOAPI1",14,0)
 ;;     messages within the original batch message, so for applications
"RTN","HLOAPI1",15,0)
 ;;     sending batch messages might best code the "APP ACK RESPONSE"
"RTN","HLOAPI1",16,0)
 ;;     routine to first check whether the response message is a batch.
"RTN","HLOAPI1",17,0)
 ;; 
"RTN","HLOAPI1",18,0)
 ;;  "ACCEPT ACK RESPONSE")=<tag^routine> to call when the commit ack is received (optional)
"RTN","HLOAPI1",19,0)
 ;;  "ACCEPT ACK TYPE") = <AL,NE> (optional, defaults to AL)
"RTN","HLOAPI1",20,0)
 ;;  "APP ACK TYPE") = <AL,NE> (optional, defaults to NE)
"RTN","HLOAPI1",21,0)
 ;;  "FAILURE RESPONSE" - <tag>^<routine> (optional) The sending application routine to execute when the transmission of the message fails, i.e., the message can not be sent or no commit ack is received.
"RTN","HLOAPI1",22,0)
 ;;  "QUEUE" - (optional) An application can name its own private queue - just a string up to 20 characters, it should be namespaced.
"RTN","HLOAPI1",23,0)
 ;;  "SECURITY")=security information to include in the header segment, SEQ 8 (optional)
"RTN","HLOAPI1",24,0)
 ;;  "SEQUENCE QUEUE") (optional) sequence queue to use, up to 30 characters, shoud lbe namespaced.  Requires that application acks be used.
"RTN","HLOAPI1",25,0)
 ;;  "SENDING APPLICATION")=name of sending app (required, 60 maximum length)
"RTN","HLOAPI1",26,0)
 ;;
"RTN","HLOAPI1",27,0)
 ;;  WHOTO (required,pass by reference) an array specifying a single recipient. These subscripts are allowed:
"RTN","HLOAPI1",28,0)
 ;;
"RTN","HLOAPI1",29,0)
 ;;    "RECEIVING APPLICATION" - (string, 60 char max, required)
"RTN","HLOAPI1",30,0)
 ;;
"RTN","HLOAPI1",31,0)
 ;;  EXACTLY ONE of these parameters must be provided to identify the Receiving Facility:
"RTN","HLOAPI1",32,0)
 ;;
"RTN","HLOAPI1",33,0)
 ;;   "FACILITY LINK IEN" - ien of the logical link 
"RTN","HLOAPI1",34,0)
 ;;   "FACILITY LINK NAME" - name of the logical link 
"RTN","HLOAPI1",35,0)
 ;;   "INSTITUTION IEN" - ptr to the INSTITUTION file
"RTN","HLOAPI1",36,0)
 ;;   "STATION NUMBER" -  station # with suffix
"RTN","HLOAPI1",37,0)
 ;;
"RTN","HLOAPI1",38,0)
 ;;  EXACTLY ONE of these MAY be provided - optionally - to identify the interface engine to route the message through:
"RTN","HLOAPI1",39,0)
 ;;
"RTN","HLOAPI1",40,0)
 ;;   *"IE LINK IEN" (obsolete)  ptr to a logical link for the interface engine 
"RTN","HLOAPI1",41,0)
 ;;   *"IE LINK NAME" (obsolete) name of the logical link for the interface engine
"RTN","HLOAPI1",42,0)
 ;;   "MIDDLEWARE LINK IEN" -  ptr to a logical link for the middleware 
"RTN","HLOAPI1",43,0)
 ;;   "MIDDLEWARE LINK NAME" - the name of the logical link for the middleware
"RTN","HLOAPI1",44,0)
 ;;
"RTN","HLOAPI1",45,0)
 ;;Output:
"RTN","HLOAPI1",46,0)
 ;;  Function returns the ien of the message in file 778 on success, 0 on failure
"RTN","HLOAPI1",47,0)
 ;;   HLMSTATE() - (pass by reference, required) This array is used by the HL7 package to track the progress of the message.  The application MUST NOT touch it!
"RTN","HLOAPI1",48,0)
 ;;   ERROR (pass by reference, optional) - on failure, will contain an error message
"RTN","HLOAPI1",49,0)
 ;;   PARMS - left undefined when the function returns
"RTN","HLOAPI1",50,0)
 ;;   WHOTO - left undefined when the function returns
"RTN","HLOAPI1",51,0)
 ;;
"RTN","HLOAPI1",52,0)
 ;;
"RTN","HLOAPI1",53,0)
 N SUCCESS,ERR1,ERR2
"RTN","HLOAPI1",54,0)
 S SUCCESS=0
"RTN","HLOAPI1",55,0)
 D
"RTN","HLOAPI1",56,0)
 .I '$G(HLMSTATE("BODY")),'$G(HLMSTATE("UNSTORED LINES")) S ERROR="MESSAGE NOT YET CREATED" Q
"RTN","HLOAPI1",57,0)
 .;;
"RTN","HLOAPI1",58,0)
 .I $$CHKPARMS^HLOAPI2(.HLMSTATE,.PARMS,.ERR1)&$$CHKWHO^HLOAPI2(.HLMSTATE,.WHOTO,.ERR2) D
"RTN","HLOAPI1",59,0)
 ..I $$SEND(.HLMSTATE,.ERROR) S SUCCESS=1
"RTN","HLOAPI1",60,0)
 .E  D
"RTN","HLOAPI1",61,0)
 ..S ERROR=$G(ERR1)_": "_$G(ERR2)
"RTN","HLOAPI1",62,0)
 ..D DONTSEND(.HLMSTATE,ERROR)
"RTN","HLOAPI1",63,0)
 K PARMS,WHOTO
"RTN","HLOAPI1",64,0)
 Q $S(SUCCESS:HLMSTATE("IEN"),1:0)
"RTN","HLOAPI1",65,0)
 ;;
"RTN","HLOAPI1",66,0)
SENDMANY(HLMSTATE,PARMS,WHOTO) ;;
"RTN","HLOAPI1",67,0)
 ;;Sends the message to a list of receiving applications
"RTN","HLOAPI1",68,0)
 ;;
"RTN","HLOAPI1",69,0)
 ;;Input: Same as for $$SENDONE, except WHOTO is a list.
"RTN","HLOAPI1",70,0)
 ;;  WHOTO (pass by reference)
"RTN","HLOAPI1",71,0)
 ;;    Specifies a list of recipients.  Each recipient should be on the
"RTN","HLOAPI1",72,0)
 ;;    list as WHOTO(i), where i=1,2,3,4, etc. for as many messages as to
"RTN","HLOAPI1",73,0)
 ;;    send.  At each subscript WHOTO(i), the same lower level subscripts
"RTN","HLOAPI1",74,0)
 ;;    may be defined as in the $$SENDONE API.  For example:
"RTN","HLOAPI1",75,0)
 ;;
"RTN","HLOAPI1",76,0)
 ;;      WHOTO(1,"FACILITY LINK NAME")="VAALB"
"RTN","HLOAPI1",77,0)
 ;;      WHOTO(1,"RECEIVING APPLICATION")="MPI"
"RTN","HLOAPI1",78,0)
 ;;      WHOTO(2,"STATION NUMBER")=500
"RTN","HLOAPI1",79,0)
 ;;      WHOTO(2,"RECEIVING APPLICATION")="MPI"
"RTN","HLOAPI1",80,0)
 ;;
"RTN","HLOAPI1",81,0)
 ;;
"RTN","HLOAPI1",82,0)
 ;;Output:
"RTN","HLOAPI1",83,0)
 ;;  Function returns 1 if a message is queued to be sent to each intended recipient, 0 otherwise
"RTN","HLOAPI1",84,0)
 ;;  PARMS - left undefined when the function returns
"RTN","HLOAPI1",85,0)
 ;;  WHOTO (pass by reference) returns the status of each message to be sent in the format:
"RTN","HLOAPI1",86,0)
 ;;    (<i>,"QUEUED")= <1 if queued to be sent, 0 otherwise)
"RTN","HLOAPI1",87,0)
 ;;   (<i>,"IEN")=<ien, file 778>
"RTN","HLOAPI1",88,0)
 ;;   (<i>,"ERROR")= error message if an error was encountered (status=0), not defined otherwise
"RTN","HLOAPI1",89,0)
 ;;
"RTN","HLOAPI1",90,0)
 ;;
"RTN","HLOAPI1",91,0)
 N ERROR,RETURN,WHO,STATE,I
"RTN","HLOAPI1",92,0)
 S RETURN=1
"RTN","HLOAPI1",93,0)
 I '$G(HLMSTATE("BODY")),'$G(HLMSTATE("UNSTORED LINES")) D  K PARMS Q 0
"RTN","HLOAPI1",94,0)
 .S ERROR="MESSAGE NOT YET CREATED"
"RTN","HLOAPI1",95,0)
 .S I=0 F  S I=$O(WHOTO(I)) Q:'I  S WHOTO(I,"QUEUED")=0,WHOTO(I,"IEN")=0,WHOTO(I,"ERROR")=ERROR
"RTN","HLOAPI1",96,0)
 ;;
"RTN","HLOAPI1",97,0)
 I '$$CHKPARMS^HLOAPI2(.HLMSTATE,.PARMS,.ERROR) D  K PARMS Q 0
"RTN","HLOAPI1",98,0)
 .S I=0 F  S I=$O(WHOTO(I)) Q:'I  D
"RTN","HLOAPI1",99,0)
 ..K WHO M WHO=WHOTO(I)
"RTN","HLOAPI1",100,0)
 ..K STATE M STATE=HLMSTATE S STATE("IEN")=""
"RTN","HLOAPI1",101,0)
 ..S WHOTO(I,"QUEUED")=0
"RTN","HLOAPI1",102,0)
 ..D DONTSEND(.STATE,$G(ERROR))
"RTN","HLOAPI1",103,0)
 ..S WHOTO(I,"IEN")=$G(STATE("IEN"))
"RTN","HLOAPI1",104,0)
 ..S WHOTO(I,"ERROR")=ERROR
"RTN","HLOAPI1",105,0)
 ;;
"RTN","HLOAPI1",106,0)
 S I=0 F  S I=$O(WHOTO(I)) Q:'I  D
"RTN","HLOAPI1",107,0)
 .K WHO M WHO=WHOTO(I)
"RTN","HLOAPI1",108,0)
 .K STATE M STATE=HLMSTATE S STATE("IEN")=""
"RTN","HLOAPI1",109,0)
 .S ERROR=""
"RTN","HLOAPI1",110,0)
 .I $$CHKWHO^HLOAPI2(.STATE,.WHO,.ERROR) D
"RTN","HLOAPI1",111,0)
 ..I $$SEND(.STATE,.ERROR) D
"RTN","HLOAPI1",112,0)
 ...S WHOTO(I,"QUEUED")=1
"RTN","HLOAPI1",113,0)
 ...S WHOTO(I,"IEN")=STATE("IEN")
"RTN","HLOAPI1",114,0)
 ...S WHOTO(I,"ERROR")=""
"RTN","HLOAPI1",115,0)
 ..E  D
"RTN","HLOAPI1",116,0)
 ...S WHOTO(I,"QUEUED")=0
"RTN","HLOAPI1",117,0)
 ...S WHOTO(I,"IEN")=$G(STATE("IEN"))
"RTN","HLOAPI1",118,0)
 ...S WHOTO(I,"ERROR")=$G(ERROR)
"RTN","HLOAPI1",119,0)
 ...S RETURN=0
"RTN","HLOAPI1",120,0)
 .E  D  ;;who not adequately determined
"RTN","HLOAPI1",121,0)
 ..S WHOTO(I,"QUEUED")=0,RETURN=0
"RTN","HLOAPI1",122,0)
 ..D DONTSEND(.STATE,$G(ERROR))
"RTN","HLOAPI1",123,0)
 ..S WHOTO(I,"IEN")=$G(STATE("IEN")),WHOTO(I,"ERROR")=$G(ERROR)
"RTN","HLOAPI1",124,0)
 K PARMS
"RTN","HLOAPI1",125,0)
 Q RETURN
"RTN","HLOAPI1",126,0)
 ;;
"RTN","HLOAPI1",127,0)
SENDSUB(HLMSTATE,PARMS,MESSAGES) ;;
"RTN","HLOAPI1",128,0)
 ;;Sends the message to a list of receiving applications based on the HL7 Subscription Registry
"RTN","HLOAPI1",129,0)
 ;;
"RTN","HLOAPI1",130,0)
 ;;Input:
"RTN","HLOAPI1",131,0)
 ;;  HLMSTATE (pass by reference, required) same as $$SENDMANY
"RTN","HLOAPI1",132,0)
 ;;  PARMS (pass by reference, required) same as $$SENDMANY, with one additional subscript:
"RTN","HLOAPI1",133,0)
 ;;    "SUBSCRIPTION IEN" - the ien of an entry in the HL7 Subscription Registry, defining the intended recipients of this message
"RTN","HLOAPI1",134,0)
 ;;
"RTN","HLOAPI1",135,0)
 ;;Output:
"RTN","HLOAPI1",136,0)
 ;;  Function returns 1 if a message is queued to be sent to each intended recipient, 0 otherwise
"RTN","HLOAPI1",137,0)
 ;;  PARMS - left undefined when the function returns
"RTN","HLOAPI1",138,0)
 ;;  MESSAGES (pass by reference) returns the status of each message to be sent in this format, where subien is the ien of the recipient in the RECIPEINTS subfile of the HL7 Subscription Registry
"RTN","HLOAPI1",139,0)
 ;;   (<subien>,"QUEUED")= <1 if queued to be sent, 0 otherwise)
"RTN","HLOAPI1",140,0)
 ;;   (<subien>,"IEN")=<ien, file 778>
"RTN","HLOAPI1",141,0)
 ;;   (<subien>,"ERROR")= error message if an error was encountered (status=0), not defined otherwise
"RTN","HLOAPI1",142,0)
 ;;
"RTN","HLOAPI1",143,0)
 ;;
"RTN","HLOAPI1",144,0)
 K MESSAGES
"RTN","HLOAPI1",145,0)
 N ERROR,RETURN,STATE,SUBIEN,WHO
"RTN","HLOAPI1",146,0)
 ;;
"RTN","HLOAPI1",147,0)
 S RETURN=1
"RTN","HLOAPI1",148,0)
 ;;
"RTN","HLOAPI1",149,0)
 ;;
"RTN","HLOAPI1",150,0)
 I '$G(HLMSTATE("BODY")),'$G(HLMSTATE("UNSTORED LINES")) S ERROR="MESSAGE NOT YET CREATED" K PARMS Q 0
"RTN","HLOAPI1",151,0)
 I '$G(PARMS("SUBSCRIPTION IEN")) S ERROR="SUBSCRIPTION REGISTRY IEN NOT PROVIDED" K PARMS Q 0
"RTN","HLOAPI1",152,0)
 ;;
"RTN","HLOAPI1",153,0)
 I '$$CHKPARMS^HLOAPI2(.HLMSTATE,.PARMS,.ERROR) D  K PARMS Q 0
"RTN","HLOAPI1",154,0)
 .S SUBIEN=0 F  S SUBIEN=$$NEXT^HLOASUB(PARMS("SUBSCRIPTION IEN"),.WHO) Q:'SUBIEN  D
"RTN","HLOAPI1",155,0)
 ..N SARY,HARY
"RTN","HLOAPI1",156,0)
 ..S HARY="STATE(""HDR"")"
"RTN","HLOAPI1",157,0)
 ..S SARY="STATE(""STATUS"")"
"RTN","HLOAPI1",158,0)
 ..K STATE M STATE=HLMSTATE S STATE("IEN")=""
"RTN","HLOAPI1",159,0)
 ..;;move parameters into HLMSTATE
"RTN","HLOAPI1",160,0)
 ..S @SARY@("LINK IEN")=WHO("LINK IEN")
"RTN","HLOAPI1",161,0)
 ..S @SARY@("LINK NAME")=WHO("LINK NAME")
"RTN","HLOAPI1",162,0)
 ..S @HARY@("RECEIVING APPLICATION")=WHO("RECEIVING APPLICATION")
"RTN","HLOAPI1",163,0)
 ..M @HARY@("RECEIVING FACILITY")=WHO("RECEIVING FACILITY")
"RTN","HLOAPI1",164,0)
 ..D DONTSEND(.STATE,$G(ERROR))
"RTN","HLOAPI1",165,0)
 ..S MESSAGES(SUBIEN,"QUEUED")=0
"RTN","HLOAPI1",166,0)
 ..S MESSAGES(SUBIEN,"IEN")=$G(STATE("IEN"))
"RTN","HLOAPI1",167,0)
 ..S MESSAGES(SUBIEN,"ERROR")=$G(ERROR)
"RTN","HLOAPI1",168,0)
 ;;
"RTN","HLOAPI1",169,0)
 F  S SUBIEN=$$NEXT^HLOASUB(PARMS("SUBSCRIPTION IEN"),.WHO) Q:'SUBIEN  D
"RTN","HLOAPI1",170,0)
 .N SARY,HARY
"RTN","HLOAPI1",171,0)
 .S HARY="STATE(""HDR"")"
"RTN","HLOAPI1",172,0)
 .S SARY="STATE(""STATUS"")"
"RTN","HLOAPI1",173,0)
 .K STATE M STATE=HLMSTATE S STATE("IEN")=""
"RTN","HLOAPI1",174,0)
 .;;move parameters into HLMSTATE
"RTN","HLOAPI1",175,0)
 .S @SARY@("LINK IEN")=WHO("LINK IEN")
"RTN","HLOAPI1",176,0)
 .S @SARY@("LINK NAME")=WHO("LINK NAME")
"RTN","HLOAPI1",177,0)
 .S @HARY@("RECEIVING APPLICATION")=WHO("RECEIVING APPLICATION")
"RTN","HLOAPI1",178,0)
 .M @HARY@("RECEIVING FACILITY")=WHO("RECEIVING FACILITY")
"RTN","HLOAPI1",179,0)
 .S ERROR=""
"RTN","HLOAPI1",180,0)
 .I $$SEND(.STATE,.ERROR) D
"RTN","HLOAPI1",181,0)
 ..S MESSAGES(SUBIEN,"QUEUED")=1
"RTN","HLOAPI1",182,0)
 .E  D
"RTN","HLOAPI1",183,0)
 ..S MESSAGES(SUBIEN,"QUEUED")=0,RETURN=0
"RTN","HLOAPI1",184,0)
 .S MESSAGES(SUBIEN,"IEN")=$G(STATE("IEN")),MESSAGES(SUBIEN,"ERROR")=$G(ERROR)
"RTN","HLOAPI1",185,0)
 K PARMS
"RTN","HLOAPI1",186,0)
 Q RETURN
"RTN","HLOAPI1",187,0)
 ;;
"RTN","HLOAPI1",188,0)
SEND(HLMSTATE,ERROR) ;
"RTN","HLOAPI1",189,0)
 ;;
"RTN","HLOAPI1",190,0)
 K ERROR
"RTN","HLOAPI1",191,0)
 I HLMSTATE("UNSTORED LINES"),'$$SAVEMSG^HLOF777(.HLMSTATE) S ERROR="$$SAVE^HLOF777 FAILED!" Q 0
"RTN","HLOAPI1",192,0)
 ;;
"RTN","HLOAPI1",193,0)
 I '$$SAVEMSG^HLOF778(.HLMSTATE) S ERROR="$$SAVE^HLOF778 FAILED!" Q 0
"RTN","HLOAPI1",194,0)
 I HLMSTATE("BATCH"),$L($G(HLMSTATE("STATUS","SEQUENCE QUEUE"))) S ERROR="SEQUENCE QUEUES NOT SUPPORTED FOR BATCH MESSAGES" Q 0
"RTN","HLOAPI1",195,0)
 I $L($G(HLMSTATE("STATUS","SEQUENCE QUEUE"))) D
"RTN","HLOAPI1",196,0)
 .S HLMSTATE("STATUS","MOVED TO OUT QUEUE")=$$SQUE^HLOQUE(HLMSTATE("STATUS","SEQUENCE QUEUE"),HLMSTATE("STATUS","LINK NAME"),$G(HLMSTATE("STATUS","PORT")),HLMSTATE("STATUS","QUEUE"),HLMSTATE("IEN")) D:HLMSTATE("STATUS","MOVED TO OUT QUEUE")
"RTN","HLOAPI1",197,0)
 ..S $P(^HLB(HLMSTATE("IEN"),5),"^",2)=1
"RTN","HLOAPI1",198,0)
 E  D
"RTN","HLOAPI1",199,0)
 .D OUTQUE^HLOQUE(HLMSTATE("STATUS","LINK NAME"),$G(HLMSTATE("STATUS","PORT")),HLMSTATE("STATUS","QUEUE"),HLMSTATE("IEN"))
"RTN","HLOAPI1",200,0)
 Q HLMSTATE("IEN")
"RTN","HLOAPI1",201,0)
 ;
"RTN","HLOAPI1",202,0)
DONTSEND(HLMSTATE,ERROR) ;
"RTN","HLOAPI1",203,0)
 ;;This procedure does NOT send a message.  Rather, it creates an entry in file 778 with the status ER.  
"RTN","HLOAPI1",204,0)
 ;;Input:
"RTN","HLOAPI1",205,0)
 ;;       HLMSTATE - pass-by-reference
"RTN","HLOAPI1",206,0)
 ;;       ERROR (optional, pass-by-value) error text to store with the message
"RTN","HLOAPI1",207,0)
 ;;Output: none
"RTN","HLOAPI1",208,0)
 ;;
"RTN","HLOAPI1",209,0)
 I HLMSTATE("UNSTORED LINES"),'$$SAVEMSG^HLOF777(.HLMSTATE) ;; just continue
"RTN","HLOAPI1",210,0)
 ;;
"RTN","HLOAPI1",211,0)
 S HLMSTATE("STATUS")="ER"
"RTN","HLOAPI1",212,0)
 S HLMSTATE("STATUS","PURGE")=$$FMADD^XLFDT(HLMSTATE("DT/TM CREATED"),HLMSTATE("SYSTEM","ERROR PURGE"))
"RTN","HLOAPI1",213,0)
 S HLMSTATE("STATUS","ERROR TEXT")=$G(ERROR)
"RTN","HLOAPI1",214,0)
 I '$$SAVEMSG^HLOF778(.HLMSTATE) ;;already reported an error to the app
"RTN","HLOAPI1",215,0)
 Q
"RTN","HLOAPI2")
0^14^B76422316^B70584205
"RTN","HLOAPI2",1,0)
HLOAPI2 ;ALB/CJM/OAK/RBN-HL7 - Developer API's for sending application acks ;05/12/2009
"RTN","HLOAPI2",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,131,133,134,137,138,146**;Oct 13, 1995;Build 16
"RTN","HLOAPI2",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOAPI2",4,0)
 ;
"RTN","HLOAPI2",5,0)
ACK(HLMSTATE,PARMS,ACK,ERROR) ;; Default behavior is to return a general
"RTN","HLOAPI2",6,0)
 ;;application ack. The application may optionally specify the message
"RTN","HLOAPI2",7,0)
 ;;type and event or call $$ADDSEG^HLOAPI to add segments.
"RTN","HLOAPI2",8,0)
 ;;A generic MSA segment (components 1-3) is added automatically IF the
"RTN","HLOAPI2",9,0)
 ;;application doesn't call $$ADDSEG^HLOAPI to add an MSA segment as the
"RTN","HLOAPI2",10,0)
 ;;FIRST segment following the header.
"RTN","HLOAPI2",11,0)
 ;;$$SENDACK must be called when the ack is completed. The return
"RTN","HLOAPI2",12,0)
 ;;destination is determined automatically from the original message
"RTN","HLOAPI2",13,0)
 ;;
"RTN","HLOAPI2",14,0)
 ;;This API should NOT be called for batch messages, use $$BATCHACK instead.
"RTN","HLOAPI2",15,0)
 ;;Input:
"RTN","HLOAPI2",16,0)
 ;;  HLMSTATE (pass by reference, required) the array obtained by calling $$STARTMSG^HLOPRS when parsing the original message 
"RTN","HLOAPI2",17,0)
 ;;  PARMS (pass by reference) These subscripts may be defined:
"RTN","HLOAPI2",18,0)
 ;;    "ACK CODE" (required) MSA1[ {AA,AE,AR}
"RTN","HLOAPI2",19,0)
 ;;    "ERROR MESSAGE" - MSA3, should be used only if AE or AR
"RTN","HLOAPI2",20,0)
 ;;    "ACCEPT ACK RESPONSE" - the <tag^routine> to call when the commit ack is received (optional)
"RTN","HLOAPI2",21,0)
 ;;    "ACCEPT ACK TYPE" - {AL,NE} (optional, defaults to AL)
"RTN","HLOAPI2",22,0)
 ;;    "CONTINUATION POINTER" (optional)indicates a fragmented message
"RTN","HLOAPI2",23,0)
 ;;    "COUNTRY" - the 3 character country code (optional)
"RTN","HLOAPI2",24,0)
 ;;    "EVENT" - the 3 character event type (optional, defaults to the event code of the original message)
"RTN","HLOAPI2",25,0)
 ;;    "ENCODING CHARACTERS" - the four HL7 encoding characters (optional,defaults to "^~\&"
"RTN","HLOAPI2",26,0)
 ;;    "FAILURE RESPONSE" (optional) the <tag>^<routine> that the sending application routine should execute if the transmission of the message fails, i.e., the message can not be sent or a requested commit ack is not received.
"RTN","HLOAPI2",27,0)
 ;;    "FIELD SEPARATOR" - field separator (optional, defaults to "|")
"RTN","HLOAPI2",28,0)
 ;;    "MESSAGE TYPE" - if not defined, ACK is used
"RTN","HLOAPI2",29,0)
 ;;    "MESSAGE STRUCTURE" (optional)
"RTN","HLOAPI2",30,0)
 ;;    "RETURN LINK NAME" (optional)
"RTN","HLOAPI2",31,0)
 ;;    "RETURN LINK IEN" (optional)
"RTN","HLOAPI2",32,0)
 ;;    "QUEUE" - (optional) An application can name its own private queue (a string under 20 characters,namespaced). The default is the name of the queue of the original message
"RTN","HLOAPI2",33,0)
 ;;    "SECURITY" (optional) security information to include in the header segment, SEQ 8 (optional)
"RTN","HLOAPI2",34,0)
 ;;    "VERSION" - the HL7 Version ID (optional, defaults to 2.4)
"RTN","HLOAPI2",35,0)
 ;;Output:
"RTN","HLOAPI2",36,0)
 ;;  Function returns 1 on success, 0 on failure
"RTN","HLOAPI2",37,0)
 ;;  PARMS - left undefined when the function returns
"RTN","HLOAPI2",38,0)
 ;;  ACK (pass by reference, required) the acknowledgment message being built.
"RTN","HLOAPI2",39,0)
 ;;  ERROR (pass by reference) error msg
"RTN","HLOAPI2",40,0)
 ;;  
"RTN","HLOAPI2",41,0)
 N I,SEG,TOLINK,SUCCESS
"RTN","HLOAPI2",42,0)
 S SUCCESS=0,(TOLINK,ERROR)=""
"RTN","HLOAPI2",43,0)
 ;
"RTN","HLOAPI2",44,0)
 D
"RTN","HLOAPI2",45,0)
 .N PORT S PORT=""
"RTN","HLOAPI2",46,0)
 .I $G(PARMS("ACK CODE"))'="AA",$G(PARMS("ACK CODE"))'="AE",$G(PARMS("ACK CODE"))'="AR" S ERROR="INVALID ACK CODE" Q
"RTN","HLOAPI2",47,0)
 .;
"RTN","HLOAPI2",48,0)
 .I '$G(HLMSTATE("IEN")) S ERROR="ORIGINAL MESSAGE TO ACKNOWLEDGE IS NOT IDENTIFIED" Q
"RTN","HLOAPI2",49,0)
 .I $G(HLMSTATE("BATCH")) S ERROR="BATCH ACKNOWLEDGMENTS MUST USE $$BATCHACK^HLOAPI3" Q
"RTN","HLOAPI2",50,0)
 .;
"RTN","HLOAPI2",51,0)
 .I $G(HLMSTATE("HDR","MESSAGE CONTROL ID"))="" S ERROR="MESSAGE CONTROL ID MUST EXIST TO RETURN AN APPLICATION ACK" Q
"RTN","HLOAPI2",52,0)
 .S PARMS("MESSAGE TYPE")=$G(PARMS("MESSAGE TYPE"),"ACK")
"RTN","HLOAPI2",53,0)
 .S:PARMS("MESSAGE TYPE")="ACK" PARMS("MESSAGE STRUCTURE")="ACK"
"RTN","HLOAPI2",54,0)
 .S PARMS("EVENT")=$G(PARMS("EVENT"),$G(HLMSTATE("HDR","EVENT")))
"RTN","HLOAPI2",55,0)
 .I $$NEWMSG^HLOAPI(.PARMS,.ACK)  ;can't fail!
"RTN","HLOAPI2",56,0)
 .;
"RTN","HLOAPI2",57,0)
 .;if the return link can not be determined, the HL Logical Link file has a problem that must be fixed at the site
"RTN","HLOAPI2",58,0)
 .I $G(PARMS("RETURN LINK IEN")) D
"RTN","HLOAPI2",59,0)
 ..S TOLINK=$P($G(^HLCS(870,PARMS("RETURN LINK IEN"),0)),"^")
"RTN","HLOAPI2",60,0)
 ..S PORT=$$PORT2^HLOTLNK(TOLINK)
"RTN","HLOAPI2",61,0)
 .E  I $L($G(PARMS("RETURN LINK NAME"))) D
"RTN","HLOAPI2",62,0)
 ..S TOLINK=PARMS("RETURN LINK NAME")
"RTN","HLOAPI2",63,0)
 ..S PORT=$$PORT2^HLOTLNK(TOLINK)
"RTN","HLOAPI2",64,0)
 .E  D
"RTN","HLOAPI2",65,0)
 ..S TOLINK=$$ACKLINK(.HLMSTATE,.PORT)
"RTN","HLOAPI2",66,0)
 .I (TOLINK="")!('PORT) S ERROR="TRANSMISSION LINK FOR APPLICATION ACK CANNOT BE DETERMINED" Q
"RTN","HLOAPI2",67,0)
 .;
"RTN","HLOAPI2",68,0)
 .S ACK("HDR","APP ACK TYPE")="NE"
"RTN","HLOAPI2",69,0)
 .S ACK("HDR","ACCEPT ACK TYPE")=$G(PARMS("ACCEPT ACK TYPE"),"AL")
"RTN","HLOAPI2",70,0)
 .S ACK("STATUS","QUEUE")=$G(PARMS("QUEUE"),$G(HLMSTATE("STATUS","QUEUE")))
"RTN","HLOAPI2",71,0)
 .S ACK("STATUS","PORT")=PORT
"RTN","HLOAPI2",72,0)
 .S ACK("HDR","SECURITY")=$G(PARMS("SECURITY"))
"RTN","HLOAPI2",73,0)
 .S ACK("HDR","SENDING APPLICATION")=$G(HLMSTATE("HDR","RECEIVING APPLICATION"))
"RTN","HLOAPI2",74,0)
 .S ACK("HDR","RECEIVING APPLICATION")=$G(HLMSTATE("HDR","SENDING APPLICATION"))
"RTN","HLOAPI2",75,0)
 .F I=1:1:3 S ACK("HDR","RECEIVING FACILITY",I)=$G(HLMSTATE("HDR","SENDING FACILITY",I))
"RTN","HLOAPI2",76,0)
 .S ACK("ACK TO","STATUS")=$S(PARMS("ACK CODE")="AA":"SU",1:"ER")
"RTN","HLOAPI2",77,0)
 .S ACK("ACK TO")=$G(HLMSTATE("HDR","MESSAGE CONTROL ID"))
"RTN","HLOAPI2",78,0)
 .S ACK("ACK TO","IEN")=HLMSTATE("IEN")
"RTN","HLOAPI2",79,0)
 .S ACK("STATUS","LINK NAME")=TOLINK
"RTN","HLOAPI2",80,0)
 .S ACK("LINE COUNT")=0
"RTN","HLOAPI2",81,0)
 . ;; Next line modified for HL*1.6*138 - RBN
"RTN","HLOAPI2",82,0)
 .;;S ACK("MSA")="MSA"_ACK("HDR","FIELD SEPARATOR")_PARMS("ACK CODE")_ACK("HDR","FIELD SEPARATOR")_$G(HLMSTATE("HDR","MESSAGE CONTROL ID"))_ACK("HDR","FIELD SEPARATOR")_$G(PARMS("ERROR MESSAGE"))
"RTN","HLOAPI2",83,0)
 .S ACK("MSA")="MSA"_ACK("HDR","FIELD SEPARATOR")_PARMS("ACK CODE")_ACK("HDR","FIELD SEPARATOR")_$G(HLMSTATE("HDR","MESSAGE CONTROL ID"))_ACK("HDR","FIELD SEPARATOR")_$$ESCAPE^HLOPBLD(.HLMSTATE,$G(PARMS("ERROR MESSAGE")))
"RTN","HLOAPI2",84,0)
 .S SUCCESS=1
"RTN","HLOAPI2",85,0)
 K PARMS
"RTN","HLOAPI2",86,0)
 K:'SUCCESS ACK
"RTN","HLOAPI2",87,0)
 Q SUCCESS
"RTN","HLOAPI2",88,0)
 ;
"RTN","HLOAPI2",89,0)
SENDACK(ACK,ERROR) ;;This is used to signal that an application acknowledgment is complete.
"RTN","HLOAPI2",90,0)
 ;;Input:
"RTN","HLOAPI2",91,0)
 ;;  ACK (pass by reference,required) An array that contains the acknowledgment msg
"RTN","HLOAPI2",92,0)
 ;;Output:
"RTN","HLOAPI2",93,0)
 ;; Function returns 1 on success, 0 on failure
"RTN","HLOAPI2",94,0)
 ;; ERROR (pass by reference) error msg
"RTN","HLOAPI2",95,0)
 ;;
"RTN","HLOAPI2",96,0)
 N SEG
"RTN","HLOAPI2",97,0)
 ;if the application added its own MSA, then the ACK("MSA") node was killed
"RTN","HLOAPI2",98,0)
 I $D(ACK("MSA")) S SEG(1)=ACK("MSA") D ADDSEG^HLOMSG(.ACK,.SEG)
"RTN","HLOAPI2",99,0)
 ;
"RTN","HLOAPI2",100,0)
 I $$SEND^HLOAPI1(.ACK,.ERROR) Q 1
"RTN","HLOAPI2",101,0)
 Q 0
"RTN","HLOAPI2",102,0)
 ;
"RTN","HLOAPI2",103,0)
ACKLINK(HLMSTATE,PORT) ; Finds the link & port to return the application ack to.
"RTN","HLOAPI2",104,0)
 N LINK
"RTN","HLOAPI2",105,0)
 S LINK=$$RTRNLNK^HLOAPP($G(HLMSTATE("HDR","RECEIVING APPLICATION")))
"RTN","HLOAPI2",106,0)
 I LINK]"" S PORT=$$PORT2^HLOTLNK(LINK) Q LINK
"RTN","HLOAPI2",107,0)
 S LINK=$$RTRNLNK^HLOTLNK($G(HLMSTATE("HDR","SENDING FACILITY",1)),$G(HLMSTATE("HDR","SENDING FACILITY",2)),$G(HLMSTATE("HDR","SENDING FACILITY",3)))
"RTN","HLOAPI2",108,0)
 S:$G(HLMSTATE("HDR","SENDING FACILITY",3))="DNS" PORT=$P(HLMSTATE("HDR","SENDING FACILITY",2),":",2)
"RTN","HLOAPI2",109,0)
 I LINK]"",'PORT S PORT=$$PORT2^HLOTLNK(LINK)
"RTN","HLOAPI2",110,0)
 Q LINK
"RTN","HLOAPI2",111,0)
 ;
"RTN","HLOAPI2",112,0)
CHKPARMS(HLMSTATE,PARMS,ERROR) ;
"RTN","HLOAPI2",113,0)
 N LEN,SARY,HARY
"RTN","HLOAPI2",114,0)
 ;
"RTN","HLOAPI2",115,0)
 ;shortcut to reference the header sub-array
"RTN","HLOAPI2",116,0)
 S HARY="HLMSTATE(""HDR"")"
"RTN","HLOAPI2",117,0)
 ;
"RTN","HLOAPI2",118,0)
 ;shortcut to reference the status sub-array
"RTN","HLOAPI2",119,0)
 S SARY="HLMSTATE(""STATUS"")"
"RTN","HLOAPI2",120,0)
 ;
"RTN","HLOAPI2",121,0)
 S ERROR=""
"RTN","HLOAPI2",122,0)
 I $G(PARMS("ACCEPT ACK TYPE"))="" S PARMS("ACCEPT ACK TYPE")="AL"
"RTN","HLOAPI2",123,0)
 I $G(PARMS("APP ACK TYPE"))="" S PARMS("APP ACK TYPE")="NE"
"RTN","HLOAPI2",124,0)
 I PARMS("ACCEPT ACK TYPE")'="NE",PARMS("ACCEPT ACK TYPE")'="AL" S ERROR="INVALID ACCEPT ACKNOWLEDGMENT TYPE"
"RTN","HLOAPI2",125,0)
 I PARMS("APP ACK TYPE")'="NE",PARMS("APP ACK TYPE")'="AL" S ERROR="INVALID APPLICATION ACKNOWLEDGMENT TYPE"
"RTN","HLOAPI2",126,0)
 S LEN=$L($G(PARMS("QUEUE")))
"RTN","HLOAPI2",127,0)
 I $G(PARMS("QUEUE"))["^" S ERROR="QUEUE NAME MAY NOT CONTAIN '^'"
"RTN","HLOAPI2",128,0)
 I LEN>20 S ERROR="QUEUE PARAMETER IS MAX 20 LENGTH",PARMS("QUEUE")=$E(PARMS("QUEUE"),1,20)
"RTN","HLOAPI2",129,0)
 I 'LEN S PARMS("QUEUE")="DEFAULT"
"RTN","HLOAPI2",130,0)
 D
"RTN","HLOAPI2",131,0)
 .N APPIEN
"RTN","HLOAPI2",132,0)
 .I $G(PARMS("SENDING APPLICATION"))="" D  Q
"RTN","HLOAPI2",133,0)
 ..S ERROR="SENDING APPLICATION IS REQUIRED"
"RTN","HLOAPI2",134,0)
 ..S PARMS("SENDING APPLICATION")=""
"RTN","HLOAPI2",135,0)
 .E  D  Q:'APPIEN
"RTN","HLOAPI2",136,0)
 ..S APPIEN=$$GETIEN^HLOAPP(PARMS("SENDING APPLICATION"))
"RTN","HLOAPI2",137,0)
 ..I 'APPIEN S ERROR="SENDING APPLICATION NOT FOUND IN THE HLO APPLICATION REGISTRY"
"RTN","HLOAPI2",138,0)
 .I $L($G(PARMS("SEQUENCE QUEUE"))) D
"RTN","HLOAPI2",139,0)
 ..I ($L(PARMS("SEQUENCE QUEUE"))>30) S ERROR="SEQUENCE QUEUE NAME > 30 CHARACTERS" Q
"RTN","HLOAPI2",140,0)
 ..I PARMS("SEQUENCE QUEUE")["^" S ERROR="SEQUENCE QUEUE NAME MAY NOT CONTAIN '^'" Q
"RTN","HLOAPI2",141,0)
 ..I $G(PARMS("APP ACK TYPE"))'="AL" S ERROR="SEQUENCE QUEUES REQUIRE AN APPLICATION ACKNOWLEDGMENT" Q
"RTN","HLOAPI2",142,0)
 ..I $G(PARMS("ACCEPT ACK TYPE"))'="AL" S ERROR="SEQUENCE QUEUES REQUIRE AN ACCEPT ACKNOWLEDGMENT" Q
"RTN","HLOAPI2",143,0)
 ;
"RTN","HLOAPI2",144,0)
 ;move parameters into HLMSTATE
"RTN","HLOAPI2",145,0)
 S @HARY@("ACCEPT ACK TYPE")=PARMS("ACCEPT ACK TYPE")
"RTN","HLOAPI2",146,0)
 S @HARY@("APP ACK TYPE")=PARMS("APP ACK TYPE")
"RTN","HLOAPI2",147,0)
 S @HARY@("SENDING APPLICATION")=$E(PARMS("SENDING APPLICATION"),1,60)
"RTN","HLOAPI2",148,0)
 S @HARY@("SECURITY")=$G(PARMS("SECURITY"))
"RTN","HLOAPI2",149,0)
 S @SARY@("APP ACK RESPONSE")=$G(PARMS("APP ACK RESPONSE"))
"RTN","HLOAPI2",150,0)
 S @SARY@("ACCEPT ACK RESPONSE")=$G(PARMS("ACCEPT ACK RESPONSE"))
"RTN","HLOAPI2",151,0)
 S @SARY@("FAILURE RESPONSE")=$G(PARMS("FAILURE RESPONSE"))
"RTN","HLOAPI2",152,0)
 S @SARY@("QUEUE")=PARMS("QUEUE")
"RTN","HLOAPI2",153,0)
 S @SARY@("SEQUENCE QUEUE")=$G(PARMS("SEQUENCE QUEUE"))
"RTN","HLOAPI2",154,0)
 Q:$L(ERROR) 0
"RTN","HLOAPI2",155,0)
 Q 1
"RTN","HLOAPI2",156,0)
 ;
"RTN","HLOAPI2",157,0)
 ;
"RTN","HLOAPI2",158,0)
SETCODE(SEG,VALUE,FIELD,COMP,REP) ; Implements SETCNE and SETCWE
"RTN","HLOAPI2",159,0)
 ;
"RTN","HLOAPI2",160,0)
 N SUB,VAR
"RTN","HLOAPI2",161,0)
 Q:'$G(FIELD)
"RTN","HLOAPI2",162,0)
 S:'$G(REP) REP=1
"RTN","HLOAPI2",163,0)
 I '$G(COMP) D
"RTN","HLOAPI2",164,0)
 .S VAR="COMP",SUB=1
"RTN","HLOAPI2",165,0)
 E  D
"RTN","HLOAPI2",166,0)
 .S VAR="SUB"
"RTN","HLOAPI2",167,0)
 S @VAR=1,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("ID"))
"RTN","HLOAPI2",168,0)
 S @VAR=2,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("TEXT"))
"RTN","HLOAPI2",169,0)
 S @VAR=3,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("SYSTEM"))
"RTN","HLOAPI2",170,0)
 S @VAR=4,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("ALTERNATE ID"))
"RTN","HLOAPI2",171,0)
 S @VAR=5,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("ALTERNATE TEXT"))
"RTN","HLOAPI2",172,0)
 S @VAR=6,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("ALTERNATE SYSTEM"))
"RTN","HLOAPI2",173,0)
 S @VAR=7,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("SYSTEM VERSION"))
"RTN","HLOAPI2",174,0)
 S @VAR=8,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("ALTERNATE SYSTEM VERSION"))
"RTN","HLOAPI2",175,0)
 S @VAR=9,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("ORIGINAL TEXT"))
"RTN","HLOAPI2",176,0)
 Q
"RTN","HLOAPI2",177,0)
 ;
"RTN","HLOAPI2",178,0)
CHKWHO(HLMSTATE,WHOTO,ERROR) ;
"RTN","HLOAPI2",179,0)
 N RETURN,I
"RTN","HLOAPI2",180,0)
 S RETURN=1
"RTN","HLOAPI2",181,0)
 I '$$CHECKWHO^HLOASUB1(.WHOTO,.RETURN,.ERROR) S RETURN=0
"RTN","HLOAPI2",182,0)
 ;
"RTN","HLOAPI2",183,0)
 ;move parameters into HLMSTATE
"RTN","HLOAPI2",184,0)
 S HLMSTATE("STATUS","LINK IEN")=$G(RETURN("LINK IEN"))
"RTN","HLOAPI2",185,0)
 S HLMSTATE("STATUS","LINK NAME")=$G(RETURN("LINK NAME"))
"RTN","HLOAPI2",186,0)
 S HLMSTATE("STATUS","PORT")=$P($G(RETURN("RECEIVING FACILITY",2)),":",2)
"RTN","HLOAPI2",187,0)
 S HLMSTATE("HDR","RECEIVING APPLICATION")=$G(RETURN("RECEIVING APPLICATION"))
"RTN","HLOAPI2",188,0)
 F I=1:1:3 S HLMSTATE("HDR","RECEIVING FACILITY",I)=$G(RETURN("RECEIVING FACILITY",I))
"RTN","HLOAPI2",189,0)
 Q RETURN
"RTN","HLOAPI4")
0^15^B29813410^B21664349
"RTN","HLOAPI4",1,0)
HLOAPI4 ;ALB/CJM-HL7 - Developer API's for sending & receiving messages(continued) ;08/19/2009
"RTN","HLOAPI4",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**131,134,146**;Oct 13, 1995;Build 16
"RTN","HLOAPI4",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOAPI4",4,0)
 ;
"RTN","HLOAPI4",5,0)
SETTS(SEG,VALUE,FIELD,COMP,REP) ;
"RTN","HLOAPI4",6,0)
 ;Sets a value that is a timestamp in FM format into the segment in HL7
"RTN","HLOAPI4",7,0)
 ;format. The degree of precision may be optionally specified. The
"RTN","HLOAPI4",8,0)
 ;inserted value will include the timezone if the input included the time.
"RTN","HLOAPI4",9,0)
 ;IF the component is specified, then the data type is 'demoted' to a component, and its components are 'demoted' to subcomponents.
"RTN","HLOAPI4",10,0)
 ;
"RTN","HLOAPI4",11,0)
 ;Input:
"RTN","HLOAPI4",12,0)
 ;  SEG - (required, pass by reference) The array where the seg is being built.
"RTN","HLOAPI4",13,0)
 ;  VALUE  (required)to be set into the segment
"RTN","HLOAPI4",14,0)
 ;  VALUE("PRECISION") (optional) If included, VALUE must be passed by
"RTN","HLOAPI4",15,0)
 ;       reference.  Allowed values are:
"RTN","HLOAPI4",16,0)
 ;           "S" - seconds (default value)
"RTN","HLOAPI4",17,0)
 ;           "M" - minutes
"RTN","HLOAPI4",18,0)
 ;           "H" - hours
"RTN","HLOAPI4",19,0)
 ;           "D" - days
"RTN","HLOAPI4",20,0)
 ;  FIELD - the sequence # of the field
"RTN","HLOAPI4",21,0)
 ;  COMP (optional) If specified, the data type is 'demoted' to a component value.
"RTN","HLOAPI4",22,0)
 ;  REP - the occurrence# (optional, defaults to 1)  For a non-repeating.
"RTN","HLOAPI4",23,0)
 ;Output: 
"RTN","HLOAPI4",24,0)
 ;   SEG array
"RTN","HLOAPI4",25,0)
 ;
"RTN","HLOAPI4",26,0)
 ;Example:
"RTN","HLOAPI4",27,0)
 ;    D SETTS^HLOAPI4(.SEG,$$NOW^XLFDT,1) will place the current date/time into the segment in the 1st field,1st occurence.  The timezone is included.
"RTN","HLOAPI4",28,0)
 ;
"RTN","HLOAPI4",29,0)
 ;
"RTN","HLOAPI4",30,0)
 N TIME
"RTN","HLOAPI4",31,0)
 Q:'$G(FIELD)
"RTN","HLOAPI4",32,0)
 Q:'$G(VALUE)
"RTN","HLOAPI4",33,0)
 S:'$G(REP) REP=1
"RTN","HLOAPI4",34,0)
 S:'$G(COMP) COMP=1
"RTN","HLOAPI4",35,0)
 S TIME=$$FMTHL7^XLFDT(VALUE)
"RTN","HLOAPI4",36,0)
 I $D(VALUE("PRECISION")) D
"RTN","HLOAPI4",37,0)
 .N TZ
"RTN","HLOAPI4",38,0)
 .S TZ=""
"RTN","HLOAPI4",39,0)
 .I TIME["+" S TZ="+"_$P(TIME,"+",2)
"RTN","HLOAPI4",40,0)
 .E  I TIME["-" S TZ="-"_$P(TIME,"-",2)
"RTN","HLOAPI4",41,0)
 .I VALUE("PRECISION")="D" D
"RTN","HLOAPI4",42,0)
 ..S TIME=$E(TIME,1,8)_TZ
"RTN","HLOAPI4",43,0)
 .E  I VALUE("PRECISION")="H" D
"RTN","HLOAPI4",44,0)
 ..S TIME=$E($$LJ^XLFSTR(+TIME,10,0),1,10)_TZ
"RTN","HLOAPI4",45,0)
 .E  I VALUE("PRECISION")="M" D
"RTN","HLOAPI4",46,0)
 ..S TIME=$E($$LJ^XLFSTR(+TIME,12,0),1,12)_TZ
"RTN","HLOAPI4",47,0)
 .E  I VALUE("PRECISION")="S" D
"RTN","HLOAPI4",48,0)
 ..S TIME=$E($$LJ^XLFSTR(+TIME,14,0),1,14)_TZ
"RTN","HLOAPI4",49,0)
 S SEG(FIELD,REP,COMP,1)=TIME
"RTN","HLOAPI4",50,0)
 Q
"RTN","HLOAPI4",51,0)
 ;
"RTN","HLOAPI4",52,0)
SETDT(SEG,VALUE,FIELD,COMP,REP) ;
"RTN","HLOAPI4",53,0)
 ;Sets a value that is a date in FM format into the segment in HL7 format.  The degree of precision may be optionally specified.
"RTN","HLOAPI4",54,0)
 ;IF the component is specified, then the data type is 'demoted' to a component, and its components are 'demoted' to subcomponents.
"RTN","HLOAPI4",55,0)
 ;
"RTN","HLOAPI4",56,0)
 ;Input:
"RTN","HLOAPI4",57,0)
 ;  SEG - (required, pass by reference) The array where the seg is being built.
"RTN","HLOAPI4",58,0)
 ;  VALUE  (required)the date to be set into the segment
"RTN","HLOAPI4",59,0)
 ;  VALUE("PRECISION") (optional) If included, VALUE must be passed by
"RTN","HLOAPI4",60,0)
 ;       reference.  Allowed values are:
"RTN","HLOAPI4",61,0)
 ;           "D" - day (default value)
"RTN","HLOAPI4",62,0)
 ;           "L" - month
"RTN","HLOAPI4",63,0)
 ;           "Y" - year
"RTN","HLOAPI4",64,0)
 ;  FIELD - the sequence # of the field
"RTN","HLOAPI4",65,0)
 ;  COMP (optional) If specified, the data type is 'demoted' to a component value.
"RTN","HLOAPI4",66,0)
 ;  REP - the occurrence# (optional, defaults to 1)  For a non-repeating.
"RTN","HLOAPI4",67,0)
 ;Output:
"RTN","HLOAPI4",68,0)
 ;   SEG - segment that is being built
"RTN","HLOAPI4",69,0)
 ;
"RTN","HLOAPI4",70,0)
 ;Example:
"RTN","HLOAPI4",71,0)
 ;    D SETDT^HLOAPI4(.SEG,$$TODAY^XLFDT,1) will place the current date into segment in the 1st field,1st occurence.
"RTN","HLOAPI4",72,0)
 ;
"RTN","HLOAPI4",73,0)
 ;
"RTN","HLOAPI4",74,0)
 N TIME
"RTN","HLOAPI4",75,0)
 Q:'$G(FIELD)
"RTN","HLOAPI4",76,0)
 S:'$G(REP) REP=1
"RTN","HLOAPI4",77,0)
 S:'$G(COMP) COMP=1
"RTN","HLOAPI4",78,0)
 S TIME=$$FMTHL7^XLFDT(VALUE)
"RTN","HLOAPI4",79,0)
 I $D(VALUE("PRECISION")) D
"RTN","HLOAPI4",80,0)
 .I VALUE("PRECISION")="Y" D
"RTN","HLOAPI4",81,0)
 ..S TIME=$E(TIME,1,4)
"RTN","HLOAPI4",82,0)
 .E  I VALUE("PRECISION")="L" D
"RTN","HLOAPI4",83,0)
 ..S TIME=$E(TIME,1,6)
"RTN","HLOAPI4",84,0)
 .E  I VALUE("PRECISION")="D" D
"RTN","HLOAPI4",85,0)
 ..S TIME=$E(TIME,1,8)
"RTN","HLOAPI4",86,0)
 S SEG(FIELD,REP,COMP,1)=TIME
"RTN","HLOAPI4",87,0)
 Q
"RTN","HLOAPI4",88,0)
 ;
"RTN","HLOAPI4",89,0)
SETCE(SEG,VALUE,FIELD,COMP,REP) ;
"RTN","HLOAPI4",90,0)
 ;Sets a value that is an HL7 Coded Element data type (HL7 Section Reference 2.9.3) into the segment in the specified field.
"RTN","HLOAPI4",91,0)
 ;IF the component is specified, then the data type is 'demoted' to a component, and its components are 'demoted' to subcomponents.
"RTN","HLOAPI4",92,0)
 ;
"RTN","HLOAPI4",93,0)
 ;Input:
"RTN","HLOAPI4",94,0)
 ;  SEG - (required, pass by reference) The array where the seg is being built.
"RTN","HLOAPI4",95,0)
 ;  VALUE  (required, pass-by-reference) These subscripts may be passed:
"RTN","HLOAPI4",96,0)
 ;    "ID" - the identifier
"RTN","HLOAPI4",97,0)
 ;    "TEXT" - 
"RTN","HLOAPI4",98,0)
 ;    "SYSTEM" - name of the code system
"RTN","HLOAPI4",99,0)
 ;    "ALTERNATE ID" - alternate identifier
"RTN","HLOAPI4",100,0)
 ;    "ALTERNATE TEXT"
"RTN","HLOAPI4",101,0)
 ;    "ALTERNATE SYSTEM" - name of the alternate coding system
"RTN","HLOAPI4",102,0)
 ;  FIELD (required) the sequence # of the field
"RTN","HLOAPI4",103,0)
 ;  COMP (optional) If specified, the data type is 'demoted' to a component value.
"RTN","HLOAPI4",104,0)
 ;  REP - the occurrence# (optional, defaults to 1)  For a non-repeating fields, this parameter is not necessary.
"RTN","HLOAPI4",105,0)
 ;Output: 
"RTN","HLOAPI4",106,0)
 ;   SEG - segment that is being built
"RTN","HLOAPI4",107,0)
 ;
"RTN","HLOAPI4",108,0)
 N SUB,VAR
"RTN","HLOAPI4",109,0)
 Q:'$G(FIELD)
"RTN","HLOAPI4",110,0)
 S:'$G(REP) REP=1
"RTN","HLOAPI4",111,0)
 I '$G(COMP) D
"RTN","HLOAPI4",112,0)
 .S VAR="COMP",SUB=1
"RTN","HLOAPI4",113,0)
 E  D
"RTN","HLOAPI4",114,0)
 .S VAR="SUB"
"RTN","HLOAPI4",115,0)
 S @VAR=1,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("ID"))
"RTN","HLOAPI4",116,0)
 S @VAR=2,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("TEXT"))
"RTN","HLOAPI4",117,0)
 S @VAR=3,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("SYSTEM"))
"RTN","HLOAPI4",118,0)
 S @VAR=4,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("ALTERNATE ID"))
"RTN","HLOAPI4",119,0)
 S @VAR=5,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("ALTERNATE TEXT"))
"RTN","HLOAPI4",120,0)
 S @VAR=6,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("ALTERNATE SYSTEM"))
"RTN","HLOAPI4",121,0)
 Q
"RTN","HLOAPI4",122,0)
 ;
"RTN","HLOAPI4",123,0)
SETHD(SEG,VALUE,FIELD,COMP,REP) ;
"RTN","HLOAPI4",124,0)
 ;Sets a value that is an HL7 Hierarchic Designator data type (HL7 Section Reference 2.9.21) into the segment in the specified field.
"RTN","HLOAPI4",125,0)
 ;IF the component is specified, then the data type is 'demoted' to a component, and its components are 'demoted' to subcomponents.
"RTN","HLOAPI4",126,0)
 ;
"RTN","HLOAPI4",127,0)
 ;Input:
"RTN","HLOAPI4",128,0)
 ;  SEG - (required, pass by reference) The array where the seg is being built.
"RTN","HLOAPI4",129,0)
 ;  VALUE  (required, pass-by-reference) These subscripts may be passed:
"RTN","HLOAPI4",130,0)
 ;    "NAMESPACE ID"
"RTN","HLOAPI4",131,0)
 ;    "UNIVERSAL ID"
"RTN","HLOAPI4",132,0)
 ;    "UNIVERSAL ID TYPE"
"RTN","HLOAPI4",133,0)
 ;  FIELD (required) the sequence # of the field
"RTN","HLOAPI4",134,0)
 ;  COMP (optional) If specified, the data type is 'demoted' to a component value.
"RTN","HLOAPI4",135,0)
 ;  REP - the occurrence# (optional, defaults to 1)  For a non-repeating fields, this parameter is not necessary.
"RTN","HLOAPI4",136,0)
 ;Output: 
"RTN","HLOAPI4",137,0)
 ;   SEG - segment that is being built
"RTN","HLOAPI4",138,0)
 ;
"RTN","HLOAPI4",139,0)
 N SUB,VAR
"RTN","HLOAPI4",140,0)
 Q:'$G(FIELD)
"RTN","HLOAPI4",141,0)
 S:'$G(REP) REP=1
"RTN","HLOAPI4",142,0)
 I '$G(COMP) D
"RTN","HLOAPI4",143,0)
 .S VAR="COMP",SUB=1
"RTN","HLOAPI4",144,0)
 E  D
"RTN","HLOAPI4",145,0)
 .S VAR="SUB"
"RTN","HLOAPI4",146,0)
 S @VAR=1,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("NAMESPACE ID"))
"RTN","HLOAPI4",147,0)
 S @VAR=2,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("UNIVERSAL ID"))
"RTN","HLOAPI4",148,0)
 S @VAR=3,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("UNIVERSAL ID TYPE"))
"RTN","HLOAPI4",149,0)
 Q
"RTN","HLOAPI4",150,0)
 ;
"RTN","HLOAPI4",151,0)
SETCNE(SEG,VALUE,FIELD,COMP,REP) ;
"RTN","HLOAPI4",152,0)
 ;Sets a value that is an HL7 Coded With No Exceptions  data type (HL7 Section Reference 2.9.8) into the segment in the specified field.
"RTN","HLOAPI4",153,0)
 ;IF the component is specified, then the data type is 'demoted' to a component, and its components are 'demoted' to subcomponents.
"RTN","HLOAPI4",154,0)
 ;
"RTN","HLOAPI4",155,0)
 ;Input:
"RTN","HLOAPI4",156,0)
 ;  SEG - (required, pass by reference) The array where the seg is being built.
"RTN","HLOAPI4",157,0)
 ;  VALUE  (required, pass-by-reference) These subscripts may be passed:
"RTN","HLOAPI4",158,0)
 ;    "ID" - the identifier
"RTN","HLOAPI4",159,0)
 ;    "TEXT" - 
"RTN","HLOAPI4",160,0)
 ;    "SYSTEM" - name of the code system
"RTN","HLOAPI4",161,0)
 ;    "ALTERNATE ID" - alternate identifier
"RTN","HLOAPI4",162,0)
 ;    "ALTERNATE TEXT"
"RTN","HLOAPI4",163,0)
 ;    "ALTERNATE SYSTEM" - name of the alternate coding system
"RTN","HLOAPI4",164,0)
 ;    "SYSTEM VERSION" - version ID of the coding system
"RTN","HLOAPI4",165,0)
 ;    "ALTERNATE SYSTEM VERSION" - version ID of the alternate coding system
"RTN","HLOAPI4",166,0)
 ;    "ORIGINAL TEXT"
"RTN","HLOAPI4",167,0)
 ;  FIELD (required) the sequence # of the field
"RTN","HLOAPI4",168,0)
 ;  COMP (optional) If specified, the data type is 'demoted' to a component value.
"RTN","HLOAPI4",169,0)
 ;  REP - the occurrence# (optional, defaults to 1)  For a non-repeating fields, this parameter is not necessary.
"RTN","HLOAPI4",170,0)
 ;Output: 
"RTN","HLOAPI4",171,0)
 ;   SEG - segment that is being built
"RTN","HLOAPI4",172,0)
 D SETCODE^HLOAPI2(.SEG,.VALUE,.FIELD,.COMP,.REP)
"RTN","HLOAPI4",173,0)
 Q
"RTN","HLOAPI4",174,0)
 ;
"RTN","HLOAPI4",175,0)
SETCWE(SEG,VALUE,FIELD,COMP,REP) ;
"RTN","HLOAPI4",176,0)
 ;Sets a value that is an HL7 Coded With Exceptions  data type (HL7 Section Reference 2.9.11) into the segment in the specified field.
"RTN","HLOAPI4",177,0)
 ;IF the component is specified, then the data type is 'demoted' to a component, and its components are 'demoted' to subcomponents.
"RTN","HLOAPI4",178,0)
 ;
"RTN","HLOAPI4",179,0)
 ;Input:
"RTN","HLOAPI4",180,0)
 ;  SEG - (required, pass by reference) The array where the seg is being built.
"RTN","HLOAPI4",181,0)
 ;  VALUE  (required, pass-by-reference) These subscripts may be passed:
"RTN","HLOAPI4",182,0)
 ;    "ID" - the identifier
"RTN","HLOAPI4",183,0)
 ;    "TEXT" - 
"RTN","HLOAPI4",184,0)
 ;    "SYSTEM" - name of the code system
"RTN","HLOAPI4",185,0)
 ;    "ALTERNATE ID" - alternate identifier
"RTN","HLOAPI4",186,0)
 ;    "ALTERNATE TEXT"
"RTN","HLOAPI4",187,0)
 ;    "ALTERNATE SYSTEM" - name of the alternate coding system
"RTN","HLOAPI4",188,0)
 ;    "SYSTEM VERSION" - version ID of the coding system
"RTN","HLOAPI4",189,0)
 ;    "ALTERNATE SYSTEM VERSION" - version ID of the alternate coding system
"RTN","HLOAPI4",190,0)
 ;    "ORIGINAL TEXT"
"RTN","HLOAPI4",191,0)
 ;  FIELD (required) the sequence # of the field
"RTN","HLOAPI4",192,0)
 ;  COMP (optional) If specified, the data type is 'demoted' to a component value.
"RTN","HLOAPI4",193,0)
 ;  REP - the occurrence# (optional, defaults to 1)  For a non-repeating fields, this parameter is not necessary.
"RTN","HLOAPI4",194,0)
 ;Output: 
"RTN","HLOAPI4",195,0)
 ;   SEG - segment that is being built
"RTN","HLOAPI4",196,0)
 D SETCODE^HLOAPI2(.SEG,.VALUE,.FIELD,.COMP,.REP)
"RTN","HLOAPI4",197,0)
 Q
"RTN","HLOAPI4",198,0)
 ;
"RTN","HLOAPI4",199,0)
SETAD(SEG,VALUE,FIELD,COMP,REP) ;
"RTN","HLOAPI4",200,0)
 ;Sets an AD data type (Address, HL7 Section Reference 2.9.1) into the segment in the specified field. It can also be used to set the 1st 8 components of the XAD (Extended Address) data type.
"RTN","HLOAPI4",201,0)
 ;IF the component is specified, then the data type is 'demoted' to a component, and its components are 'demoted' to subcomponents.
"RTN","HLOAPI4",202,0)
 ;
"RTN","HLOAPI4",203,0)
 ;Input:
"RTN","HLOAPI4",204,0)
 ;  SEG - (required, pass by reference) The array where the seg is being built.
"RTN","HLOAPI4",205,0)
 ;  VALUE  (required, pass-by-reference) These subscripts may be passed:
"RTN","HLOAPI4",206,0)
 ;    "STREET1" -street address
"RTN","HLOAPI4",207,0)
 ;    "STREET2" - other designation
"RTN","HLOAPI4",208,0)
 ;    "CITY"
"RTN","HLOAPI4",209,0)
 ;    "STATE" - state or province
"RTN","HLOAPI4",210,0)
 ;    "ZIP" - zip or postal code
"RTN","HLOAPI4",211,0)
 ;    "COUNTRY"
"RTN","HLOAPI4",212,0)
 ;    "TYPE"  - address type
"RTN","HLOAPI4",213,0)
 ;    "OTHER" - other geographic designation
"RTN","HLOAPI4",214,0)
 ;  FIELD (required) the sequence # of the field
"RTN","HLOAPI4",215,0)
 ;  COMP (optional) If specified, the data type is 'demoted' to a component value.
"RTN","HLOAPI4",216,0)
 ;  REP - the occurrence# (optional, defaults to 1)  For a non-repeating fields, this parameter is not necessary.
"RTN","HLOAPI4",217,0)
 ;Output: 
"RTN","HLOAPI4",218,0)
 ;   SEG - segment that is being built
"RTN","HLOAPI4",219,0)
 ;
"RTN","HLOAPI4",220,0)
 N SUB,VAR
"RTN","HLOAPI4",221,0)
 Q:'$G(FIELD)
"RTN","HLOAPI4",222,0)
 S:'$G(REP) REP=1
"RTN","HLOAPI4",223,0)
 I '$G(COMP) D
"RTN","HLOAPI4",224,0)
 .S VAR="COMP",SUB=1
"RTN","HLOAPI4",225,0)
 E  D
"RTN","HLOAPI4",226,0)
 .S VAR="SUB"
"RTN","HLOAPI4",227,0)
 S @VAR=1,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("STREET1"))
"RTN","HLOAPI4",228,0)
 S @VAR=2,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("STREET2"))
"RTN","HLOAPI4",229,0)
 S @VAR=3,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("CITY"))
"RTN","HLOAPI4",230,0)
 S @VAR=4,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("STATE"))
"RTN","HLOAPI4",231,0)
 S @VAR=5,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("ZIP"))
"RTN","HLOAPI4",232,0)
 S @VAR=6,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("COUNTRY"))
"RTN","HLOAPI4",233,0)
 S @VAR=7,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("TYPE"))
"RTN","HLOAPI4",234,0)
 S @VAR=8,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("OTHER"))
"RTN","HLOAPI4",235,0)
 Q
"RTN","HLOAPI4",236,0)
 ;
"RTN","HLOAPI4",237,0)
 ;** P146 START CJM
"RTN","HLOAPI4",238,0)
SETXPN(SEG,VALUE,FIELD,COMP,REP) ;
"RTN","HLOAPI4",239,0)
 ;Sets an XPN data type (extended person name) into the segment in the specified field.
"RTN","HLOAPI4",240,0)
 ;IF the component is specified, then the data type is 'demoted' to a component, and its components are 'demoted' to subcomponents.
"RTN","HLOAPI4",241,0)
 ;
"RTN","HLOAPI4",242,0)
 ;Input:
"RTN","HLOAPI4",243,0)
 ;  SEG - (required, pass by reference) The array where the seg is being built.
"RTN","HLOAPI4",244,0)
 ;  VALUE  (required, pass-by-reference) These subscripts may be passed:
"RTN","HLOAPI4",245,0)
 ;    "FAMILY"
"RTN","HLOAPI4",246,0)
 ;    "GIVEN" first name
"RTN","HLOAPI4",247,0)
 ;    "SECOND" second and further names or initials
"RTN","HLOAPI4",248,0)
 ;    "SUFFIX" (e.g., JR)
"RTN","HLOAPI4",249,0)
 ;    "PREFIX" (e.g., DR)
"RTN","HLOAPI4",250,0)
 ;    "DEGREE" (e.g., MD)
"RTN","HLOAPI4",251,0)
 ;  FIELD (required) the sequence # of the field
"RTN","HLOAPI4",252,0)
 ;  COMP (optional) If specified, the data type is 'demoted' to a component value.
"RTN","HLOAPI4",253,0)
 ;  REP - the occurrence# (optional, defaults to 1)  For a non-repeating fields, this parameter is not necessary.
"RTN","HLOAPI4",254,0)
 ;Output: 
"RTN","HLOAPI4",255,0)
 ;   SEG - segment that is being built
"RTN","HLOAPI4",256,0)
 ;
"RTN","HLOAPI4",257,0)
 N SUB,VAR
"RTN","HLOAPI4",258,0)
 Q:'$G(FIELD)
"RTN","HLOAPI4",259,0)
 S:'$G(REP) REP=1
"RTN","HLOAPI4",260,0)
 I '$G(COMP) D
"RTN","HLOAPI4",261,0)
 .S VAR="COMP",SUB=1
"RTN","HLOAPI4",262,0)
 E  D
"RTN","HLOAPI4",263,0)
 .S VAR="SUB"
"RTN","HLOAPI4",264,0)
 S @VAR=1,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("FAMILY"))
"RTN","HLOAPI4",265,0)
 S @VAR=2,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("GIVEN"))
"RTN","HLOAPI4",266,0)
 S @VAR=3,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("SECOND"))
"RTN","HLOAPI4",267,0)
 S @VAR=4,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("SUFFIX"))
"RTN","HLOAPI4",268,0)
 S @VAR=5,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("PREFIX"))
"RTN","HLOAPI4",269,0)
 S @VAR=6,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("DEGREE"))
"RTN","HLOAPI4",270,0)
 Q
"RTN","HLOAPI4",271,0)
 ;**P146 END CJM
"RTN","HLOAPI7")
0^29^B15001817^n/a
"RTN","HLOAPI7",1,0)
HLOAPI7 ;IRMFO-ALB/PIJ -API for retrieving HLO or HL7 information about a message;03/24/2004  14:43 ;06/04/2009
"RTN","HLOAPI7",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**146**;Oct 13, 1995;Build 16
"RTN","HLOAPI7",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOAPI7",4,0)
 ;
"RTN","HLOAPI7",5,0)
 Q
"RTN","HLOAPI7",6,0)
 ;
"RTN","HLOAPI7",7,0)
GETMSG(IEN,MSG,FLAG) ; Description:  This function allows the user to toggle
"RTN","HLOAPI7",8,0)
 ;between HL7 and HLO messages and to return message information in a local array or a global.
"RTN","HLOAPI7",9,0)
 ;I '$G(FLAG)  then MSG, IEN and file 778 are used for HLO messages.
"RTN","HLOAPI7",10,0)
 ;I $G(FLAG) then MSG, IEN and file 773 are used for HL7 messages.
"RTN","HLOAPI7",11,0)
 ;Input: 
"RTN","HLOAPI7",12,0)
 ;  IEN - The internal entry number of the message.
"RTN","HLOAPI7",13,0)
 ;  MSG - The array name used to return the message information.  Can be a local array or global.
"RTN","HLOAPI7",14,0)
 ;  FLAG - I '$G(FLAG)  use variables for HLO messages.
"RTN","HLOAPI7",15,0)
 ;  FLAG - I $G(FLAG) use variables for HL7 messages.
"RTN","HLOAPI7",16,0)
 ;Output:
"RTN","HLOAPI7",17,0)
 ;  Function returns 1 on success, 0 on failure.  Failure would indicate that the
"RTN","HLOAPI7",18,0)
 ;  message was not found or variable IEN or MSG was not passed
"RTN","HLOAPI7",19,0)
 ;  MSG(0)= IEN (HL7 or HLO)
"RTN","HLOAPI7",20,0)
 ; HLO...
"RTN","HLOAPI7",21,0)
 ;  MSG(1)= ^HLB(IEN,0)
"RTN","HLOAPI7",22,0)
 ;  MSG(2)= ^HLB(IEN,1)
"RTN","HLOAPI7",23,0)
 ;  MSG(3)= ^HLB(IEN,2)
"RTN","HLOAPI7",24,0)
 ;  MSG(4)= ^HLB(IEN,3)
"RTN","HLOAPI7",25,0)
 ;  MSG(5)= ^HLB(IEN,4)
"RTN","HLOAPI7",26,0)
 ;  MSG(6)=""
"RTN","HLOAPI7",27,0)
 ;  MSG(7)="^HLA(IEN,...
"RTN","HLOAPI7",28,0)
 ;  
"RTN","HLOAPI7",29,0)
 ; HL7...
"RTN","HLOAPI7",30,0)
 ; Multiple MSG(1) = ^HLMA(IEN,"MSH",I,0)
"RTN","HLOAPI7",31,0)
 ; Multiple MSG(i)= ^HL(772,R772,"IN",I,0)
"RTN","HLOAPI7",32,0)
 ;
"RTN","HLOAPI7",33,0)
 K DATA,@MSG
"RTN","HLOAPI7",34,0)
 N CTR,DATA,I,N1,N2,N3,R772,R777,STAT
"RTN","HLOAPI7",35,0)
 Q:'$G(IEN) 0
"RTN","HLOAPI7",36,0)
 Q:'$D(MSG) 0
"RTN","HLOAPI7",37,0)
 Q:MSG="FLAG" 0 ;  may not need...
"RTN","HLOAPI7",38,0)
 S (CTR,STAT)=1
"RTN","HLOAPI7",39,0)
 I '$G(FLAG) Q:'$D(^HLB(IEN)) 0  D  Q STAT
"RTN","HLOAPI7",40,0)
 . ;HLO
"RTN","HLOAPI7",41,0)
 . S N1=""
"RTN","HLOAPI7",42,0)
 . F  S N1=$O(^HLB(IEN,N1)) Q:N1=""  D
"RTN","HLOAPI7",43,0)
 . . I $D(^HLB(IEN,N1))=1 D
"RTN","HLOAPI7",44,0)
 . . . S DATA=^HLB(IEN,N1)
"RTN","HLOAPI7",45,0)
 . . . S:N1=0 R777=$P(DATA,U,2)
"RTN","HLOAPI7",46,0)
 . . . S @MSG@(CTR)=DATA
"RTN","HLOAPI7",47,0)
 . . . S CTR=CTR+1
"RTN","HLOAPI7",48,0)
 . . I $D(^HLB(IEN,N1))=10 D  ; this part is for Batch messages ^HLB(D0,3)
"RTN","HLOAPI7",49,0)
 . . . S N2=""
"RTN","HLOAPI7",50,0)
 . . . F  S N2=$O(^HLB(IEN,N1,N2)) Q:N2=""  D
"RTN","HLOAPI7",51,0)
 . . . . F I=0:1:2  I $D(^HLB(IEN,N1,N2,I))=1 S @MSG@(CTR)=^HLB(IEN,N1,N2,I),CTR=CTR+1
"RTN","HLOAPI7",52,0)
 . ; get Segments for HLO
"RTN","HLOAPI7",53,0)
 . I 'R777 S STAT=0 Q
"RTN","HLOAPI7",54,0)
 . S @MSG@(CTR)="",CTR=CTR+1  ; add blank line between message header and message body
"RTN","HLOAPI7",55,0)
 . S (N1,N2,N3)=""
"RTN","HLOAPI7",56,0)
 . F  S N1=$O(^HLA(R777,N1)) Q:N1=""  D
"RTN","HLOAPI7",57,0)
 . . I $D(^HLA(R777,N1))=1 D
"RTN","HLOAPI7",58,0)
 . . . S @MSG@(CTR)=^HLA(R777,N1)
"RTN","HLOAPI7",59,0)
 . . . S CTR=CTR+1
"RTN","HLOAPI7",60,0)
 . . I $D(^HLA(R777,N1))=10 D
"RTN","HLOAPI7",61,0)
 . . . S N2=""
"RTN","HLOAPI7",62,0)
 . . . F  S N2=$O(^HLA(R777,N1,N2)) Q:N2=""  D
"RTN","HLOAPI7",63,0)
 . . . . I $D(^HLA(R777,N1,N2))=1 D
"RTN","HLOAPI7",64,0)
 . . . . . S DATA=^HLA(R777,N1,N2)
"RTN","HLOAPI7",65,0)
 . . . . . S @MSG@(CTR)=^HLA(R777,N1,N2),CTR=CTR+1
"RTN","HLOAPI7",66,0)
 . . . . I $D(^HLA(R777,N1,N2,0))=1 D
"RTN","HLOAPI7",67,0)
 . . . . . S DATA=^HLA(R777,N1,N2,0)
"RTN","HLOAPI7",68,0)
 . . . . . S @MSG@(CTR)=^HLA(R777,N1,N2,0),CTR=CTR+1
"RTN","HLOAPI7",69,0)
 . . . . S N3=""
"RTN","HLOAPI7",70,0)
 . . . . F  S N3=$O(^HLA(R777,N1,N2,1,N3)) Q:N3=""  D
"RTN","HLOAPI7",71,0)
 . . . . . I $D(^HLA(R777,N1,N2,1,N3,0))=1 D
"RTN","HLOAPI7",72,0)
 . . . . . . S DATA=^HLA(R777,N1,N2,1,N3,0)
"RTN","HLOAPI7",73,0)
 . . . . . . S @MSG@(CTR)=^HLA(R777,N1,N2,1,N3,0),CTR=CTR+1
"RTN","HLOAPI7",74,0)
 ;
"RTN","HLOAPI7",75,0)
 ;HL7
"RTN","HLOAPI7",76,0)
 Q:'$D(^HLMA(IEN,0)) 0
"RTN","HLOAPI7",77,0)
 S DATA=^HLMA(IEN,0) Q:'DATA 0  D
"RTN","HLOAPI7",78,0)
 . S R772=$P(DATA,U,1)
"RTN","HLOAPI7",79,0)
 . I 'R772 S STAT=0 Q
"RTN","HLOAPI7",80,0)
 . ; get HL7 Message Header
"RTN","HLOAPI7",81,0)
 . S N1=""
"RTN","HLOAPI7",82,0)
 . F  S N1=$O(^HLMA(IEN,N1)) Q:N1=""  D
"RTN","HLOAPI7",83,0)
 . . I $D(^HLMA(IEN,N1))=1 D
"RTN","HLOAPI7",84,0)
 . . . S DATA=^HLMA(IEN,N1)
"RTN","HLOAPI7",85,0)
 . . . S @MSG@(CTR)=DATA
"RTN","HLOAPI7",86,0)
 . . . S CTR=CTR+1
"RTN","HLOAPI7",87,0)
 . . S N2=""
"RTN","HLOAPI7",88,0)
 . . F  S N2=$O(^HLMA(IEN,N1,N2)) Q:N2=""  D
"RTN","HLOAPI7",89,0)
 . . . I $D(^HLMA(IEN,N1,N2))=1 D
"RTN","HLOAPI7",90,0)
 . . . . S DATA=^HLMA(IEN,N1,N2)
"RTN","HLOAPI7",91,0)
 . . . . S @MSG@(CTR)=DATA
"RTN","HLOAPI7",92,0)
 . . . . S CTR=CTR+1
"RTN","HLOAPI7",93,0)
 . . . S N3=""
"RTN","HLOAPI7",94,0)
 . . . F  S N3=$O(^HLMA(IEN,N1,N2,N3)) Q:N3=""  D
"RTN","HLOAPI7",95,0)
 . . . . I $D(^HLMA(IEN,N1,N2,N3))=1 D
"RTN","HLOAPI7",96,0)
 . . . . . S DATA=^HLMA(IEN,N1,N2,N3)
"RTN","HLOAPI7",97,0)
 . . . . . S @MSG@(CTR)=DATA
"RTN","HLOAPI7",98,0)
 . . . . . S CTR=CTR+1
"RTN","HLOAPI7",99,0)
 . ; get HL7 Message Body
"RTN","HLOAPI7",100,0)
 . S @MSG@(CTR)="",CTR=CTR+1  ; add blank line between message header and message body
"RTN","HLOAPI7",101,0)
 . S N1=""
"RTN","HLOAPI7",102,0)
 . F  S N1=$O(^HL(772,R772,N1)) Q:N1=""  D
"RTN","HLOAPI7",103,0)
 . . I $D(^HL(772,R772,N1))=1 D
"RTN","HLOAPI7",104,0)
 . . . S DATA=^HL(772,R772,N1)
"RTN","HLOAPI7",105,0)
 . . . S @MSG@(CTR)=DATA
"RTN","HLOAPI7",106,0)
 . . . S CTR=CTR+1
"RTN","HLOAPI7",107,0)
 . . S N2=""
"RTN","HLOAPI7",108,0)
 . . F  S N2=$O(^HL(772,R772,N1,N2)) Q:N2=""  D
"RTN","HLOAPI7",109,0)
 . . . I $D(^HL(772,R772,N1,N2))=1 D
"RTN","HLOAPI7",110,0)
 . . . . S DATA=^HL(772,R772,N1,N2)
"RTN","HLOAPI7",111,0)
 . . . . S @MSG@(CTR)=DATA
"RTN","HLOAPI7",112,0)
 . . . . S CTR=CTR+1
"RTN","HLOAPI7",113,0)
 . . . S N3=""
"RTN","HLOAPI7",114,0)
 . . . F  S N3=$O(^HL(772,R772,N1,N2,N3)) Q:N3=""  D
"RTN","HLOAPI7",115,0)
 . . . . I $D(^HL(772,R772,N1,N2,N3))=1 D
"RTN","HLOAPI7",116,0)
 . . . . . S DATA=^HL(772,R772,N1,N2,N3)
"RTN","HLOAPI7",117,0)
 . . . . . S @MSG@(CTR)=DATA
"RTN","HLOAPI7",118,0)
 . . . . . S CTR=CTR+1
"RTN","HLOAPI7",119,0)
 Q STAT
"RTN","HLOASUB")
0^16^B34615650^B20309588
"RTN","HLOASUB",1,0)
HLOASUB ;IRMFO-ALB/CJM - Subscription Registry ;08/17/2009
"RTN","HLOASUB",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,146**;Oct 13, 1995;Build 16
"RTN","HLOASUB",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOASUB",4,0)
 ;
"RTN","HLOASUB",5,0)
CREATE(OWNER,DESCRIP,ERROR) ;
"RTN","HLOASUB",6,0)
 ;This API is used to create a new entry in the HLO Subscription Registry.
"RTN","HLOASUB",7,0)
 ;Input:
"RTN","HLOASUB",8,0)
 ;  OWNER - (required) The name of the owning application. The name of the owner. It should be prefixed with the package namespace to ensure uniqueness.
"RTN","HLOASUB",9,0)
 ;  DESCRIPTION - (optional) a brief (1 line) description
"RTN","HLOASUB",10,0)
 ;Output:
"RTN","HLOASUB",11,0)
 ;  Function returns new file 779.4 ien, or 0 if error
"RTN","HLOASUB",12,0)
 ;  ERROR (optional, pass by reference) an message on error
"RTN","HLOASUB",13,0)
 ;
"RTN","HLOASUB",14,0)
 N IEN,DATA
"RTN","HLOASUB",15,0)
 K ERROR
"RTN","HLOASUB",16,0)
 I '$L($G(OWNER)) S ERROR="OWNER NOT SPECIFIED" Q 0
"RTN","HLOASUB",17,0)
 L +^HLD(779.4,0):60
"RTN","HLOASUB",18,0)
 I '$T S ERROR="UNABLE TO LOCK THE HL7 SUBSCRIPTION REGISTRY" Q 0
"RTN","HLOASUB",19,0)
 S IEN=$O(^HLD(779.4,":"),-1),IEN=IEN+1
"RTN","HLOASUB",20,0)
 L -^HLD(779.4,0)
"RTN","HLOASUB",21,0)
 S DATA(.01)=IEN
"RTN","HLOASUB",22,0)
 S DATA(.02)=OWNER
"RTN","HLOASUB",23,0)
 S DATA(.03)=$G(DESCRIP)
"RTN","HLOASUB",24,0)
 Q $$ADD^HLOASUB1(779.4,,.DATA,.ERROR,IEN)
"RTN","HLOASUB",25,0)
 ;
"RTN","HLOASUB",26,0)
ONLIST(IEN,LINKIEN,APPNAME,FAC1,FAC2,FAC3) ;
"RTN","HLOASUB",27,0)
 ;Determines whether the recipient is already on the subscription list.
"RTN","HLOASUB",28,0)
 ;Input:
"RTN","HLOASUB",29,0)
 ;  IEN - (required) ien of the subscription list
"RTN","HLOASUB",30,0)
 ;  LINKIEN - ien of the logical link
"RTN","HLOASUB",31,0)
 ;  APPNAME - receiving application
"RTN","HLOASUB",32,0)
 ;  FAC1 -  component 1 of the receiving facility
"RTN","HLOASUB",33,0)
 ;  FAC2 - component 2
"RTN","HLOASUB",34,0)
 ;  FAC3 - component 3
"RTN","HLOASUB",35,0)
 ;Output:
"RTN","HLOASUB",36,0)
 ;  Function returns 0 if not found, otherwise the ien in the subfile
"RTN","HLOASUB",37,0)
 ;
"RTN","HLOASUB",38,0)
 Q +$O(^HLD(779.4,IEN,2,"AD",APPNAME,LINKIEN,FAC1_FAC2_FAC3,0))
"RTN","HLOASUB",39,0)
 ;
"RTN","HLOASUB",40,0)
ADD(IEN,WHO,ERROR) ;
"RTN","HLOASUB",41,0)
 ;Adds a new recipient to the list of recipients for this Subscription Registry Entry.
"RTN","HLOASUB",42,0)
 ;Input:
"RTN","HLOASUB",43,0)
 ;  IEN- the ien of the entry in the HL7 SUBSCRIPTION REGISTRY file.
"RTN","HLOASUB",44,0)
 ;  WHO (pass by reference) an array containing the information for a single new
"RTN","HLOASUB",45,0)
 ;    recipient to be added to the list. These subscripts are allowed:
"RTN","HLOASUB",46,0)
 ;
"RTN","HLOASUB",47,0)
 ;    "RECEIVING APPLICATION" - (string, 60 char max, required)
"RTN","HLOASUB",48,0)
 ;
"RTN","HLOASUB",49,0)
 ;  EXACTLY ONE of these parameters must be provided to identify the Receiving Facility:
"RTN","HLOASUB",50,0)
 ;
"RTN","HLOASUB",51,0)
 ;   "FACILITY LINK IEN" - ien of the logical link 
"RTN","HLOASUB",52,0)
 ;   "FACILITY LINK NAME" - name of the logical link 
"RTN","HLOASUB",53,0)
 ;   "INSTITUTION IEN" - ptr to the INSTITUTION file
"RTN","HLOASUB",54,0)
 ;   "STATION NUMBER" -  station # with suffix
"RTN","HLOASUB",55,0)
 ;
"RTN","HLOASUB",56,0)
 ;  EXACTLY ONE of these MAY be provided - optionally - to identify the interface engine to route the message through:
"RTN","HLOASUB",57,0)
 ;
"RTN","HLOASUB",58,0)
 ;   *"IE LINK IEN" (obsolete)  ptr to a logical link for the interface engine 
"RTN","HLOASUB",59,0)
 ;   *"IE LINK NAME" (obsolete) - name of the logical link for the interface engine
"RTN","HLOASUB",60,0)
 ;   "MIDDLEWARE LINK IEN" - a  ptr to a logical link for the middleware
"RTN","HLOASUB",61,0)
 ;   "MIDDLEWARE LINK NAME" - name of the logical link for the middleware
"RTN","HLOASUB",62,0)
 ;
"RTN","HLOASUB",63,0)
 ;
"RTN","HLOASUB",64,0)
 ;Output:
"RTN","HLOASUB",65,0)
 ;   Function returns on success the ien of the recipient on the RECIPIENTS multiple , or 0 on failure
"RTN","HLOASUB",66,0)
 ;   WHO - left undefined when this function returns
"RTN","HLOASUB",67,0)
 ;   ERROR (optional, pass by reference) These error messages may be returned:
"RTN","HLOASUB",68,0)
 ;SUBSCRIPTION REGISTRY ENTRY NOT FOUND
"RTN","HLOASUB",69,0)
 ;RECEIVING FACILTY LOGICAL LINK NOT FOUND
"RTN","HLOASUB",70,0)
 ;RECEIVING APPLICATION NOT FOUND
"RTN","HLOASUB",71,0)
 ;MIDDLEWARE ENGINE LOGICAL LINK PROVIDED BUT NOT FOUND
"RTN","HLOASUB",72,0)
 ;FAILED TO ACTIVATE SUBSCRIBER
"RTN","HLOASUB",73,0)
 ;
"RTN","HLOASUB",74,0)
 N PARMS,SUBIEN,DATA,DA,OK
"RTN","HLOASUB",75,0)
 K ERROR
"RTN","HLOASUB",76,0)
 S OK=0
"RTN","HLOASUB",77,0)
 D
"RTN","HLOASUB",78,0)
 .I '$G(IEN) S ERROR="SUBSCRIPITION REGISTRY ENTRY NOT FOUND" Q
"RTN","HLOASUB",79,0)
 .Q:'$$CHECKWHO^HLOASUB1(.WHO,.PARMS,.ERROR)
"RTN","HLOASUB",80,0)
 .S SUBIEN=$$ONLIST^HLOASUB1(IEN,.WHO)
"RTN","HLOASUB",81,0)
 .I SUBIEN S OK=1 D  Q
"RTN","HLOASUB",82,0)
 ..S DA=SUBIEN,DA(1)=IEN
"RTN","HLOASUB",83,0)
 ..I $P(^HLD(779.4,IEN,2,SUBIEN,1),"^",2) S DATA(1.01)=$$NOW^XLFDT,DATA(1.02)="" S OK=$$UPD^HLOASUB1(779.41,.DA,.DATA) I 'OK S ERROR="FAILED TO ACTIVATE SUBSCRIBER"
"RTN","HLOASUB",84,0)
 .;
"RTN","HLOASUB",85,0)
 .S DA(1)=IEN
"RTN","HLOASUB",86,0)
 .S DATA(.01)=PARMS("RECEIVING APPLICATION")
"RTN","HLOASUB",87,0)
 .S DATA(.021)=PARMS("RECEIVING FACILITY","LINK IEN")
"RTN","HLOASUB",88,0)
 .I PARMS("LINK IEN"),PARMS("LINK IEN")'=PARMS("RECEIVING FACILITY","LINK IEN") S DATA(.02)=PARMS("LINK IEN")
"RTN","HLOASUB",89,0)
 .S DATA(.03)=PARMS("RECEIVING FACILITY",1)
"RTN","HLOASUB",90,0)
 .S DATA(.04)=PARMS("RECEIVING FACILITY",2)
"RTN","HLOASUB",91,0)
 .S DATA(.05)=PARMS("RECEIVING FACILITY",3)
"RTN","HLOASUB",92,0)
 .S DATA(1.01)=$$NOW^XLFDT
"RTN","HLOASUB",93,0)
 .S OK=$$ADD^HLOASUB1(779.41,.DA,.DATA,.ERROR)
"RTN","HLOASUB",94,0)
 K WHO
"RTN","HLOASUB",95,0)
 Q OK
"RTN","HLOASUB",96,0)
 ;
"RTN","HLOASUB",97,0)
NEXT(IEN,RECIP) ;
"RTN","HLOASUB",98,0)
 ;gets the next recipient on the list. It ignores recipients
"RTN","HLOASUB",99,0)
 ;that have a value for the DT/TM DELETED field.
"RTN","HLOASUB",100,0)
 ;Input:
"RTN","HLOASUB",101,0)
 ;  IEN (required) - the IEN assigned to this subscription
"RTN","HLOASUB",102,0)
 ;  RECIP - if empty, it gets the first recipient on the list, else it uses the value of RECIP("SUBIEN") to find the next recipient
"RTN","HLOASUB",103,0)
 ;Output:
"RTN","HLOASUB",104,0)
 ;RECIP(pass by reference, required) - returns the next recipient on the list. These subscripts are returned:
"RTN","HLOASUB",105,0)
 ;  "LINK IEN" - IEN of link overwhich to transmit the message (could be middleware)
"RTN","HLOASUB",106,0)
 ;  "LINK NAME" - its name
"RTN","HLOASUB",107,0)
 ;  "RECEIVING APPLICATION" 
"RTN","HLOASUB",108,0)
 ; ("RECEIVING FACILITY",1)  - Component 1
"RTN","HLOASUB",109,0)
 ; ("RECEIVING FACILITY",2)  - Component 2
"RTN","HLOASUB",110,0)
 ; ("RECEIVING FACILITY",3)  - Component 2
"RTN","HLOASUB",111,0)
 ;  "SUBIEN" - the ien in the multiple, used to find the next on the list.  
"RTN","HLOASUB",112,0)
 ;Function Value - IEN in the subfile on success, 0 if there are no more recipients found on the list (in which case, set "SUBIEN"=-1, set all other subscripts to ""
"RTN","HLOASUB",113,0)
 ;
"RTN","HLOASUB",114,0)
 N LAST,NEXT,NODE,LINKIEN,OLD
"RTN","HLOASUB",115,0)
 S LAST=+$G(RECIP("SUBIEN"))
"RTN","HLOASUB",116,0)
 Q:(LAST=-1) 0
"RTN","HLOASUB",117,0)
 Q:'$G(IEN) 0
"RTN","HLOASUB",118,0)
 S NEXT=$O(^HLD(779.4,IEN,2,"AC",LAST))
"RTN","HLOASUB",119,0)
 I 'NEXT D  Q 0
"RTN","HLOASUB",120,0)
 .S RECIP("RECEIVING APPLICATION")=""
"RTN","HLOASUB",121,0)
 .S RECIP("LINK IEN")=""
"RTN","HLOASUB",122,0)
 .S RECIP("LINK NAME")=""
"RTN","HLOASUB",123,0)
 .S RECIP("RECEIVING FACILITY",1)=""
"RTN","HLOASUB",124,0)
 .S RECIP("RECEIVING FACILITY",2)=""
"RTN","HLOASUB",125,0)
 .S RECIP("RECEIVING FACILITY",3)=""
"RTN","HLOASUB",126,0)
 .S RECIP("SUBIEN")=-1
"RTN","HLOASUB",127,0)
 ;
"RTN","HLOASUB",128,0)
 S RECIP("SUBIEN")=NEXT
"RTN","HLOASUB",129,0)
 S NODE=$G(^HLD(779.4,IEN,2,NEXT,0))
"RTN","HLOASUB",130,0)
 S LINKIEN=+$P(NODE,"^",2)
"RTN","HLOASUB",131,0)
 I 'LINKIEN S LINKIEN=+$P(NODE,"^",6)
"RTN","HLOASUB",132,0)
 S RECIP("LINK IEN")=LINKIEN
"RTN","HLOASUB",133,0)
 S RECIP("LINK NAME")=$P($G(^HLCS(870,LINKIEN,0)),"^")
"RTN","HLOASUB",134,0)
 S RECIP("RECEIVING APPLICATION")=$P(NODE,"^")
"RTN","HLOASUB",135,0)
 ;
"RTN","HLOASUB",136,0)
 ;**P146 START CJM
"RTN","HLOASUB",137,0)
 ;the station #, domain, or port may have changed
"RTN","HLOASUB",138,0)
 S OLD("RECEIVING FACILITY",1)=$P(NODE,"^",3)
"RTN","HLOASUB",139,0)
 S OLD("RECEIVING FACILITY",2)=$P(NODE,"^",4)
"RTN","HLOASUB",140,0)
 S OLD("RECEIVING FACILITY",3)="DNS"
"RTN","HLOASUB",141,0)
 S LINKIEN=$P(NODE,"^",6)
"RTN","HLOASUB",142,0)
 I 'LINKIEN M RECIP=OLD Q NEXT
"RTN","HLOASUB",143,0)
 S RECIP("RECEIVING FACILITY",1)=$$STATNUM^HLOTLNK(LINKIEN)
"RTN","HLOASUB",144,0)
 S RECIP("RECEIVING FACILITY",2)=$$DOMAIN^HLOTLNK(LINKIEN)_":"_$$PORT^HLOTLNK(LINKIEN)
"RTN","HLOASUB",145,0)
 S RECIP("RECEIVING FACILITY",3)="DNS"
"RTN","HLOASUB",146,0)
 I (RECIP("RECEIVING FACILITY",1)'=OLD("RECEIVING FACILITY",1))!(RECIP("RECEIVING FACILITY",2)'=OLD("RECEIVING FACILITY",2)) D
"RTN","HLOASUB",147,0)
 .N DA,DATA
"RTN","HLOASUB",148,0)
 .S DATA(.03)=RECIP("RECEIVING FACILITY",1)
"RTN","HLOASUB",149,0)
 .S DATA(.04)=RECIP("RECEIVING FACILITY",2)
"RTN","HLOASUB",150,0)
 .S DATA(.05)="DNS"
"RTN","HLOASUB",151,0)
 .S DA=NEXT,DA(1)=IEN
"RTN","HLOASUB",152,0)
 .I $$UPD^HLOASUB1(779.41,.DA,.DATA)
"RTN","HLOASUB",153,0)
 ;**P146 END CJM
"RTN","HLOASUB",154,0)
 Q NEXT
"RTN","HLOASUB",155,0)
 ;
"RTN","HLOASUB",156,0)
END(IEN,WHO) ;will terminate a recipient from the list.The sub-record isn't
"RTN","HLOASUB",157,0)
 ;deleted, but the DATE/TIME TERMINATED field is entered with the current
"RTN","HLOASUB",158,0)
 ; date/time
"RTN","HLOASUB",159,0)
 ;Input:
"RTN","HLOASUB",160,0)
 ;  IEN - the ien of the HL7 Subscription Registry entry (required)
"RTN","HLOASUB",161,0)
 ;  WHO - (required, pass by reference)  If WHO("SUBIEN") is defined, then it should be the ien of the sub-record to be terminated.  Otherwise, set the parameters as per $$ADD.
"RTN","HLOASUB",162,0)
 ;Output: 
"RTN","HLOASUB",163,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOASUB",164,0)
 ;  WHO - left undefined when the function returns
"RTN","HLOASUB",165,0)
 ;
"RTN","HLOASUB",166,0)
 N SUBIEN,DATA,DA,OK
"RTN","HLOASUB",167,0)
 S OK=0
"RTN","HLOASUB",168,0)
 D
"RTN","HLOASUB",169,0)
 .S SUBIEN=0
"RTN","HLOASUB",170,0)
 .Q:'$G(IEN)
"RTN","HLOASUB",171,0)
 .I $G(WHO("SUBIEN")) D
"RTN","HLOASUB",172,0)
 ..S SUBIEN=WHO("SUBIEN")
"RTN","HLOASUB",173,0)
 .E  D
"RTN","HLOASUB",174,0)
 ..N PARMS
"RTN","HLOASUB",175,0)
 ..S:$$CHECKWHO^HLOASUB1(.WHO,.PARMS) SUBIEN=$$ONLIST^HLOASUB1(IEN,.WHO)
"RTN","HLOASUB",176,0)
 .I 'SUBIEN S OK=1 Q
"RTN","HLOASUB",177,0)
 .S DA(1)=IEN,DA=SUBIEN
"RTN","HLOASUB",178,0)
 .S DATA(1.02)=$$NOW^XLFDT
"RTN","HLOASUB",179,0)
 .S OK=$$UPD^HLOASUB1(779.41,.DA,.DATA)
"RTN","HLOASUB",180,0)
 K WHO
"RTN","HLOASUB",181,0)
 Q OK
"RTN","HLOASUB",182,0)
 ;
"RTN","HLOASUB",183,0)
DELETE(IEN) ;Deletes the entry in the HL7 Subscription Registry.
"RTN","HLOASUB",184,0)
 Q $$DELETE^HLOASUB1(779.4,$G(IEN))
"RTN","HLOASUB",185,0)
 ;
"RTN","HLOASUB",186,0)
 ;**P146 START CJM
"RTN","HLOASUB",187,0)
ADDFAC(IEN,SUBIEN) ;
"RTN","HLOASUB",188,0)
 ;Adds to the recipient sub-record components 1,2,3 of the Receiving
"RTN","HLOASUB",189,0)
 ;Facility field of the message header.
"RTN","HLOASUB",190,0)
 ;Input:
"RTN","HLOASUB",191,0)
 ;  IEN- the ien of the entry in the HL7 SUBSCRIPTION REGISTRY file.
"RTN","HLOASUB",192,0)
 ;  SUBIEN - ien in the multiple
"RTN","HLOASUB",193,0)
 ;
"RTN","HLOASUB",194,0)
 ;
"RTN","HLOASUB",195,0)
 N PARMS,WHO,DATA,DA,NODE
"RTN","HLOASUB",196,0)
 S NODE=$G(^HLD(779.4,+IEN,2,+SUBIEN,0))
"RTN","HLOASUB",197,0)
 S WHO("RECEIVING APPLICATION")=$P(NODE,"^",1)
"RTN","HLOASUB",198,0)
 S WHO("IE LINK IEN")=$P(NODE,"^",2)
"RTN","HLOASUB",199,0)
 S WHO("FACILITY LINK IEN")=$P(NODE,"^",6)
"RTN","HLOASUB",200,0)
 I '$$CHECKWHO^HLOASUB1(.WHO,.PARMS,.ERROR) W !,ERROR,! Q
"RTN","HLOASUB",201,0)
 S DA=SUBIEN,DA(1)=IEN
"RTN","HLOASUB",202,0)
 I '$P($G(^HLD(779.4,+IEN,2,+SUBIEN,1)),"^") S DATA(1.01)=$$NOW^XLFDT
"RTN","HLOASUB",203,0)
 S DATA(.03)=PARMS("RECEIVING FACILITY",1)
"RTN","HLOASUB",204,0)
 S DATA(.04)=PARMS("RECEIVING FACILITY",2)
"RTN","HLOASUB",205,0)
 S DATA(.05)=PARMS("RECEIVING FACILITY",3)
"RTN","HLOASUB",206,0)
 I '$$UPD^HLOASUB1(779.41,.DA,.DATA,.ERROR) W !,ERROR,!
"RTN","HLOASUB",207,0)
 Q
"RTN","HLOASUB",208,0)
 ;
"RTN","HLOASUB",209,0)
TLINK(IEN,SUBIEN) ;
"RTN","HLOASUB",210,0)
 ;returns the link overwhich to transmit for this subscriber
"RTN","HLOASUB",211,0)
 ;
"RTN","HLOASUB",212,0)
 N NODE,DLINK,MLINK
"RTN","HLOASUB",213,0)
 S NODE=$G(^HLD(779.4,IEN,2,SUBIEN,0))
"RTN","HLOASUB",214,0)
 S DLINK=$P(NODE,"^",6)
"RTN","HLOASUB",215,0)
 S MLINK=$P(NODE,"^",2)
"RTN","HLOASUB",216,0)
 I MLINK,MLINK'=DLINK Q +MLINK
"RTN","HLOASUB",217,0)
 Q +DLINK
"RTN","HLOASUB",218,0)
 ;**P146 END CJM
"RTN","HLOASUB1")
0^17^B91447015^B68656659
"RTN","HLOASUB1",1,0)
HLOASUB1 ;IRMFO-ALB/CJM/RBN - Subscription Registry (continued) ;06/10/2009
"RTN","HLOASUB1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,134,138,146**;Oct 13, 1995;Build 16
"RTN","HLOASUB1",3,0)
 ;Per VHA Directive 10-93-142, this routine should not be modified.
"RTN","HLOASUB1",4,0)
 ;
"RTN","HLOASUB1",5,0)
INDEX(IEN,PARMARY) ;
"RTN","HLOASUB1",6,0)
 ;Allows an application to optionally index its subscriptions.
"RTN","HLOASUB1",7,0)
 ;so that it can find find them without storing the ien.
"RTN","HLOASUB1",8,0)
 ;
"RTN","HLOASUB1",9,0)
 ;Input:
"RTN","HLOASUB1",10,0)
 ;  IEN - ien of the entry
"RTN","HLOASUB1",11,0)
 ;  PARMARY (pass by reference) An array of up to 6 lookup values with
"RTN","HLOASUB1",12,0)
 ;which to build the index.  The format is: PARMARY(1)=<first parameter>,
"RTN","HLOASUB1",13,0)
 ; up to PARMARY(6)
"RTN","HLOASUB1",14,0)
 ;Output:
"RTN","HLOASUB1",15,0)
 ;  function returns 1 on success, 0 otherwise
"RTN","HLOASUB1",16,0)
 ;  PARMARY - left undefined
"RTN","HLOASUB1",17,0)
 ;
"RTN","HLOASUB1",18,0)
 N OWNER,I,NODE
"RTN","HLOASUB1",19,0)
 Q:'$G(IEN) 0
"RTN","HLOASUB1",20,0)
 S OWNER=$P($G(^HLD(779.4,IEN,0)),"^",2)
"RTN","HLOASUB1",21,0)
 Q:'$L(OWNER) 0
"RTN","HLOASUB1",22,0)
 D KILLAH(IEN)
"RTN","HLOASUB1",23,0)
 F I=1:1:6 S:'$L($G(PARMARY(I))) PARMARY(I)=" "
"RTN","HLOASUB1",24,0)
 D SETAH(IEN,OWNER,.PARMARY)
"RTN","HLOASUB1",25,0)
 S NODE=""
"RTN","HLOASUB1",26,0)
 F I=1:1:6 S NODE=NODE_$G(PARMARY(I))_"^"
"RTN","HLOASUB1",27,0)
 S ^HLD(779.4,IEN,3)=NODE
"RTN","HLOASUB1",28,0)
 K PARMARY
"RTN","HLOASUB1",29,0)
 Q 1
"RTN","HLOASUB1",30,0)
 ;
"RTN","HLOASUB1",31,0)
SETAH(IEN,OWNER,PARMS) ;
"RTN","HLOASUB1",32,0)
 Q:'$G(IEN)
"RTN","HLOASUB1",33,0)
 Q:'$L($G(OWNER))
"RTN","HLOASUB1",34,0)
 N INDEX
"RTN","HLOASUB1",35,0)
 S INDEX="^HLD(779.4,""AH"",OWNER,"
"RTN","HLOASUB1",36,0)
 F I=1:1:6 D
"RTN","HLOASUB1",37,0)
 .S:'$L($G(PARMS(I))) PARMS(I)=" "
"RTN","HLOASUB1",38,0)
 .S INDEX=INDEX_""""_PARMS(I)_""","
"RTN","HLOASUB1",39,0)
 S INDEX=$E(INDEX,1,$L(INDEX)-1)_")"
"RTN","HLOASUB1",40,0)
 S @INDEX=IEN
"RTN","HLOASUB1",41,0)
 Q
"RTN","HLOASUB1",42,0)
 ;
"RTN","HLOASUB1",43,0)
SETAH1(DA,OWNER,X1,X2,X3,X4,X5,X6) ;
"RTN","HLOASUB1",44,0)
 Q:'$G(DA)
"RTN","HLOASUB1",45,0)
 Q:'$L($G(OWNER))
"RTN","HLOASUB1",46,0)
 N PARMS,I
"RTN","HLOASUB1",47,0)
 F I=1:1:6 I $L($G(@("X"_I))) S PARMS(I)=@("X"_I)
"RTN","HLOASUB1",48,0)
 D SETAH(DA,OWNER,.PARMS)
"RTN","HLOASUB1",49,0)
 Q
"RTN","HLOASUB1",50,0)
 ;
"RTN","HLOASUB1",51,0)
KILLAH1(OWNER,LOOKUP1,LOOKUP2,LOOKUP3,LOOKUP4,LOOKUP5,LOOKUP6) ;
"RTN","HLOASUB1",52,0)
 Q:'$L(OWNER)
"RTN","HLOASUB1",53,0)
 N I,INDEX
"RTN","HLOASUB1",54,0)
 S INDEX="^HLD(779.4,""AH"",OWNER"
"RTN","HLOASUB1",55,0)
 F I=1:1:6 D
"RTN","HLOASUB1",56,0)
 .S:'$L($G(@("LOOKUP"_I))) @("LOOKUP"_I)=" "
"RTN","HLOASUB1",57,0)
 .S INDEX=INDEX_","_""""_@("LOOKUP"_I)_""""
"RTN","HLOASUB1",58,0)
 S INDEX=INDEX_")"
"RTN","HLOASUB1",59,0)
 K @INDEX
"RTN","HLOASUB1",60,0)
 Q
"RTN","HLOASUB1",61,0)
 ;
"RTN","HLOASUB1",62,0)
KILLAH(IEN) ;kills the AH x~ref on file 779.4 for a particular subscription registry entry=ien
"RTN","HLOASUB1",63,0)
 Q:'$G(IEN)
"RTN","HLOASUB1",64,0)
 N OWNER,X1,X2,X3,X4,X5,X6,I,NODE
"RTN","HLOASUB1",65,0)
 S OWNER=$P($G(^HLD(779.4,IEN,0)),"^",2)
"RTN","HLOASUB1",66,0)
 Q:'$L(OWNER)
"RTN","HLOASUB1",67,0)
 S NODE=$G(^HLD(779.4,IEN,3))
"RTN","HLOASUB1",68,0)
 F I=1:1:6 I $L($P(NODE,"^",I)) S @("X"_I)=$P(NODE,"^",I)
"RTN","HLOASUB1",69,0)
 D KILLAH1(OWNER,.X1,.X2,.X3,.X4,.X5,.X6)
"RTN","HLOASUB1",70,0)
 Q
"RTN","HLOASUB1",71,0)
 ;
"RTN","HLOASUB1",72,0)
FIND(OWNER,PARMARY) ;
"RTN","HLOASUB1",73,0)
 ;Allows an application to find a subscription
"RTN","HLOASUB1",74,0)
 ;list.  The application must maintain a private index in order to
"RTN","HLOASUB1",75,0)
 ;utilize this function, via $$INDEX^HLOASUB()
"RTN","HLOASUB1",76,0)
 ;
"RTN","HLOASUB1",77,0)
 ;Input:
"RTN","HLOASUB1",78,0)
 ;  OWNER - owning application name
"RTN","HLOASUB1",79,0)
 ;  PARMARY  **pass by reference** an array of up to 6 lookup value with which the index was built.  The format is: PARMARY(1)=<first parameter>, PARMARY(2)=<second parameter>  If PARMARY(i)=null, the parameter will be ignored
"RTN","HLOASUB1",80,0)
 ;Output:
"RTN","HLOASUB1",81,0)
 ;  function returns the ien of the subscription list if found, 0 otherwise
"RTN","HLOASUB1",82,0)
 ; PARMARY - left undefined
"RTN","HLOASUB1",83,0)
 ;
"RTN","HLOASUB1",84,0)
 N OK S OK=0
"RTN","HLOASUB1",85,0)
 ;
"RTN","HLOASUB1",86,0)
 D
"RTN","HLOASUB1",87,0)
 .Q:'$D(PARMARY)
"RTN","HLOASUB1",88,0)
 .Q:'$L($G(OWNER))
"RTN","HLOASUB1",89,0)
 .N INDEX,I
"RTN","HLOASUB1",90,0)
 .S INDEX="^HLD(779.4,""AH"",OWNER"
"RTN","HLOASUB1",91,0)
 .F I=1:1:6 D
"RTN","HLOASUB1",92,0)
 ..S:'$L($G(PARMARY(I))) PARMARY(I)=" "
"RTN","HLOASUB1",93,0)
 ..S INDEX=INDEX_","_""""_PARMARY(I)_""""
"RTN","HLOASUB1",94,0)
 .S INDEX=INDEX_")"
"RTN","HLOASUB1",95,0)
 .S OK=+$G(@INDEX)
"RTN","HLOASUB1",96,0)
 K PARMARY
"RTN","HLOASUB1",97,0)
 Q OK
"RTN","HLOASUB1",98,0)
 ;
"RTN","HLOASUB1",99,0)
UPD(FILE,DA,DATA,ERROR) ;File data into an existing record.
"RTN","HLOASUB1",100,0)
 ; Input:
"RTN","HLOASUB1",101,0)
 ;   FILE - File or sub-file number
"RTN","HLOASUB1",102,0)
 ;   DA - Traditional DA array, with same meaning.
"RTN","HLOASUB1",103,0)
 ;            Pass by reference.
"RTN","HLOASUB1",104,0)
 ;   DATA - Data array to file (pass by reference)
"RTN","HLOASUB1",105,0)
 ;          Format: DATA(<field #>)=<value>
"RTN","HLOASUB1",106,0)
 ;
"RTN","HLOASUB1",107,0)
 ; Output:
"RTN","HLOASUB1",108,0)
 ;  Function Value -     0=error and 1=no error
"RTN","HLOASUB1",109,0)
 ;  ERROR - optional error message - if needed, pass by reference
"RTN","HLOASUB1",110,0)
 ;
"RTN","HLOASUB1",111,0)
 ; Example: To update a record in subfile 2.0361 in record with ien=353,
"RTN","HLOASUB1",112,0)
 ;          subrecord ien=68, with the field .01 value = 21:
"RTN","HLOASUB1",113,0)
 ;    S DATA(.01)=21,DA=68,DA(1)=353 I $$UPD(2.0361,.DA,.DATA,.ERROR) W !,"DONE"
"RTN","HLOASUB1",114,0)
 ;
"RTN","HLOASUB1",115,0)
 N FDA,FIELD,IENS,ERRORS
"RTN","HLOASUB1",116,0)
 ;
"RTN","HLOASUB1",117,0)
 ;IENS - Internal Entry Number String defined by FM
"RTN","HLOASUB1",118,0)
 ;FDA - the FDA array as defined by FM
"RTN","HLOASUB1",119,0)
 ;
"RTN","HLOASUB1",120,0)
 I '$G(DA) S ERROR="IEN OF RECORD TO BE UPDATED NOT SPECIFIED" Q 0
"RTN","HLOASUB1",121,0)
 S IENS=$$IENS^DILF(.DA)
"RTN","HLOASUB1",122,0)
 S FIELD=0
"RTN","HLOASUB1",123,0)
 F  S FIELD=$O(DATA(FIELD)) Q:'FIELD  D
"RTN","HLOASUB1",124,0)
 .S FDA(FILE,IENS,FIELD)=$G(DATA(FIELD))
"RTN","HLOASUB1",125,0)
 D FILE^DIE("","FDA","ERRORS(1)")
"RTN","HLOASUB1",126,0)
 I +$G(DIERR) D
"RTN","HLOASUB1",127,0)
 .S ERROR=$G(ERRORS(1,"DIERR",1,"TEXT",1))
"RTN","HLOASUB1",128,0)
 E  D
"RTN","HLOASUB1",129,0)
 .S ERROR=""
"RTN","HLOASUB1",130,0)
 ;
"RTN","HLOASUB1",131,0)
 D CLEAN^DILF
"RTN","HLOASUB1",132,0)
 Q $S(+$G(DIERR):0,1:1)
"RTN","HLOASUB1",133,0)
 ;
"RTN","HLOASUB1",134,0)
ADD(FILE,DA,DATA,ERROR,IEN) ;
"RTN","HLOASUB1",135,0)
 ;Description: Creates a new record and files the data.
"RTN","HLOASUB1",136,0)
 ; Input:
"RTN","HLOASUB1",137,0)
 ;   FILE - File or sub-file number
"RTN","HLOASUB1",138,0)
 ;   DA - Traditional FileMan DA array with same
"RTN","HLOASUB1",139,0)
 ;            meaning. Pass by reference.  Only needed if adding to a
"RTN","HLOASUB1",140,0)
 ;            subfile.
"RTN","HLOASUB1",141,0)
 ;   DATA - Data array to file, pass by reference
"RTN","HLOASUB1",142,0)
 ;          Format: DATA(<field #>)=<value>
"RTN","HLOASUB1",143,0)
 ;   IEN - internal entry number to use (optional)
"RTN","HLOASUB1",144,0)
 ;
"RTN","HLOASUB1",145,0)
 ; Output:
"RTN","HLOASUB1",146,0)
 ;   Function Value - If no error then it returns the ien of the created record, else returns NULL.
"RTN","HLOASUB1",147,0)
 ;  DA - returns the ien of the new record, NULL if none created.  If needed, pass by reference.
"RTN","HLOASUB1",148,0)
 ;  ERROR - optional error message - if needed, pass by reference
"RTN","HLOASUB1",149,0)
 ;
"RTN","HLOASUB1",150,0)
 ; Example: To add a record in subfile 2.0361 in the record with ien=353
"RTN","HLOASUB1",151,0)
 ;          with the field .01 value = 21:
"RTN","HLOASUB1",152,0)
 ;  S DATA(.01)=21,DA(1)=353 I $$ADD(2.0361,.DA,.DATA) W !,"DONE"
"RTN","HLOASUB1",153,0)
 ;
"RTN","HLOASUB1",154,0)
 ; Example: If creating a record not in a subfile, would look like this:
"RTN","HLOASUB1",155,0)
 ;          S DATA(.01)=21 I $$ADD(867,,.DATA) W !,"DONE"
"RTN","HLOASUB1",156,0)
 ;
"RTN","HLOASUB1",157,0)
 N FDA,FIELD,IENA,IENS,ERRORS
"RTN","HLOASUB1",158,0)
 ;
"RTN","HLOASUB1",159,0)
 ;IENS - Internal Entry Number String defined by FM
"RTN","HLOASUB1",160,0)
 ;IENA - the Internal Entry Number Array defined by FM
"RTN","HLOASUB1",161,0)
 ;FDA - the FDA array defined by FM
"RTN","HLOASUB1",162,0)
 ;IEN - the ien of the new record
"RTN","HLOASUB1",163,0)
 ;
"RTN","HLOASUB1",164,0)
 S DA="+1"
"RTN","HLOASUB1",165,0)
 S IENS=$$IENS^DILF(.DA)
"RTN","HLOASUB1",166,0)
 S FIELD=0
"RTN","HLOASUB1",167,0)
 F  S FIELD=$O(DATA(FIELD)) Q:'FIELD  D
"RTN","HLOASUB1",168,0)
 .S FDA(FILE,IENS,FIELD)=$G(DATA(FIELD))
"RTN","HLOASUB1",169,0)
 I $G(IEN) S IENA(1)=IEN
"RTN","HLOASUB1",170,0)
 D UPDATE^DIE("","FDA","IENA","ERRORS(1)")
"RTN","HLOASUB1",171,0)
 I +$G(DIERR) D
"RTN","HLOASUB1",172,0)
 .S ERROR=$G(ERRORS(1,"DIERR",1,"TEXT",1))
"RTN","HLOASUB1",173,0)
 .S IEN=""
"RTN","HLOASUB1",174,0)
 E  D
"RTN","HLOASUB1",175,0)
 .S IEN=IENA(1)
"RTN","HLOASUB1",176,0)
 .S ERROR=""
"RTN","HLOASUB1",177,0)
 D CLEAN^DILF
"RTN","HLOASUB1",178,0)
 S DA=IEN
"RTN","HLOASUB1",179,0)
 Q IEN
"RTN","HLOASUB1",180,0)
 ;
"RTN","HLOASUB1",181,0)
DELETE(FILE,DA,ERROR)   ;Delete an existing record.
"RTN","HLOASUB1",182,0)
 N DATA
"RTN","HLOASUB1",183,0)
 S DATA(.01)="@"
"RTN","HLOASUB1",184,0)
 Q $$UPD(FILE,.DA,.DATA,.ERROR)
"RTN","HLOASUB1",185,0)
 Q
"RTN","HLOASUB1",186,0)
 ;
"RTN","HLOASUB1",187,0)
STATNUM(IEN) ;
"RTN","HLOASUB1",188,0)
 ;Description:  Given an ien to the Institution file, returns as the function value the station number. If IEN is NOT passed in, it assumes the local site.  Returns "" on failure.
"RTN","HLOASUB1",189,0)
 ;
"RTN","HLOASUB1",190,0)
 N STATION,RETURN
"RTN","HLOASUB1",191,0)
 S RETURN=""
"RTN","HLOASUB1",192,0)
 I $G(IEN) D
"RTN","HLOASUB1",193,0)
 .Q:'$D(^DIC(4,IEN,0))
"RTN","HLOASUB1",194,0)
 .S STATION=$P($$NNT^XUAF4(IEN),"^",2)
"RTN","HLOASUB1",195,0)
 .S RETURN=$S(+STATION:STATION,1:"")
"RTN","HLOASUB1",196,0)
 E  D
"RTN","HLOASUB1",197,0)
 .S RETURN=$P($$SITE^VASITE(),"^",3)
"RTN","HLOASUB1",198,0)
 Q RETURN
"RTN","HLOASUB1",199,0)
 ;
"RTN","HLOASUB1",200,0)
CHECKWHO(WHO,PARMS,ERROR) ;
"RTN","HLOASUB1",201,0)
 ;Checks the parameters provided in WHO() (see $$ADD).  They must resolve
"RTN","HLOASUB1",202,0)
 ;the link, receiving app and receiving facility.
"RTN","HLOASUB1",203,0)
 ;INPUT:
"RTN","HLOASUB1",204,0)
 ;  WHO - (required, pass by reference) - see $$ADD.
"RTN","HLOASUB1",205,0)
 ;
"RTN","HLOASUB1",206,0)
 ;  WHO("PORT") - if this is valued, it will be used as the remote port
"RTN","HLOASUB1",207,0)
 ;    to connect with rather than the port associated with the link
"RTN","HLOASUB1",208,0)
 ;Output:
"RTN","HLOASUB1",209,0)
 ;  Function returns 1 if the input is resolved successfully, 0 otherwise
"RTN","HLOASUB1",210,0)
 ;    PARMS - (pass by reference)  These subscripts are returned:
"RTN","HLOASUB1",211,0)
 ;     "LINK IEN" - ien of the link overwhich to transmit (could be middleware)
"RTN","HLOASUB1",212,0)
 ;     "LINK NAME" - name of the link
"RTN","HLOASUB1",213,0)
 ;     "RECEIVING APPLICATION"  - name of the receiving app
"RTN","HLOASUB1",214,0)
 ;     "RECEIVING FACILITY",1)  - component 1
"RTN","HLOASUB1",215,0)
 ;     "RECEIVING FACILITY",2) - component 2
"RTN","HLOASUB1",216,0)
 ;     "RECEIVING FACILITY",3) - component 3
"RTN","HLOASUB1",217,0)
 ;     "RECEIVING FACILITY","LINK IEN") - ien of facility
"RTN","HLOASUB1",218,0)
 ;   ERROR - (pass by reference) - if unsuccessful, an error message is returned.
"RTN","HLOASUB1",219,0)
 ;
"RTN","HLOASUB1",220,0)
 N OK
"RTN","HLOASUB1",221,0)
 K ERROR
"RTN","HLOASUB1",222,0)
 S OK=1
"RTN","HLOASUB1",223,0)
 S PARMS("LINK IEN")="",PARMS("LINK NAME")=""
"RTN","HLOASUB1",224,0)
 ;must identify the receiving app
"RTN","HLOASUB1",225,0)
 ;
"RTN","HLOASUB1",226,0)
 D
"RTN","HLOASUB1",227,0)
 .N LEN
"RTN","HLOASUB1",228,0)
 .S LEN=$L($G(WHO("RECEIVING APPLICATION")))
"RTN","HLOASUB1",229,0)
 .I 'LEN S OK=0
"RTN","HLOASUB1",230,0)
 .E  I LEN>60 S OK=0
"RTN","HLOASUB1",231,0)
 .S:'OK ERROR="RECEIVING APPLICATION NOT VALID"
"RTN","HLOASUB1",232,0)
 .S PARMS("RECEIVING APPLICATION")=$G(WHO("RECEIVING APPLICATION"))
"RTN","HLOASUB1",233,0)
 ;
"RTN","HLOASUB1",234,0)
 ;find the station # if Institution ien known
"RTN","HLOASUB1",235,0)
 S:$G(WHO("INSTITUTION IEN")) WHO("STATION NUMBER")=$$STATNUM^HLOASUB1(WHO("INSTITUTION IEN"))
"RTN","HLOASUB1",236,0)
 ;
"RTN","HLOASUB1",237,0)
 ;if destination link specified by name, get its ien
"RTN","HLOASUB1",238,0)
 I '$G(WHO("FACILITY LINK IEN")),$L($G(WHO("FACILITY LINK NAME"))) S WHO("FACILITY LINK IEN")=$O(^HLCS(870,"B",WHO("FACILITY LINK NAME"),0))
"RTN","HLOASUB1",239,0)
 ;
"RTN","HLOASUB1",240,0)
 ;if destination link not specified, find it based on station #
"RTN","HLOASUB1",241,0)
 I $L($G(WHO("STATION NUMBER"))),'$G(WHO("FACILITY LINK IEN")) S WHO("FACILITY LINK IEN")=$$FINDLINK^HLOTLNK(WHO("STATION NUMBER"))
"RTN","HLOASUB1",242,0)
 ;
"RTN","HLOASUB1",243,0)
 ;if station # not known, find it based on destination link
"RTN","HLOASUB1",244,0)
 I '$L($G(WHO("STATION NUMBER"))),$G(WHO("FACILITY LINK IEN")) S WHO("STATION NUMBER")=$$STATNUM^HLOTLNK(WHO("FACILITY LINK IEN"))
"RTN","HLOASUB1",245,0)
 ;
"RTN","HLOASUB1",246,0)
 S PARMS("RECEIVING FACILITY",1)=$G(WHO("STATION NUMBER"))
"RTN","HLOASUB1",247,0)
 ;
"RTN","HLOASUB1",248,0)
 ;if the destination link is known, get the domain
"RTN","HLOASUB1",249,0)
 S PARMS("RECEIVING FACILITY",2)=$S($G(WHO("FACILITY LINK IEN")):$$DOMAIN^HLOTLNK(WHO("FACILITY LINK IEN")),1:"")
"RTN","HLOASUB1",250,0)
 ;
"RTN","HLOASUB1",251,0)
 ;**P146 START CJM
"RTN","HLOASUB1",252,0)
 S PARMS("RECEIVING FACILITY","LINK IEN")=$G(WHO("FACILITY LINK IEN"))
"RTN","HLOASUB1",253,0)
 ;**P146 END CJM
"RTN","HLOASUB1",254,0)
 ;
"RTN","HLOASUB1",255,0)
 S PARMS("RECEIVING FACILITY",3)="DNS"
"RTN","HLOASUB1",256,0)
 ;
"RTN","HLOASUB1",257,0)
 ;find the link to send over - need name & ien
"RTN","HLOASUB1",258,0)
 I $G(WHO("MIDDLEWARE LINK IEN")) S WHO("IE LINK IEN")=WHO("MIDDLEWARE LINK IEN")
"RTN","HLOASUB1",259,0)
 I $L($G(WHO("MIDDLEWARE LINK NAME"))) S WHO("IE LINK NAME")=WHO("MIDDLEWARE LINK NAME")
"RTN","HLOASUB1",260,0)
 I $G(WHO("IE LINK IEN")) D
"RTN","HLOASUB1",261,0)
 .S PARMS("LINK IEN")=WHO("IE LINK IEN")
"RTN","HLOASUB1",262,0)
 .S PARMS("LINK NAME")=$P($G(^HLCS(870,PARMS("LINK IEN"),0)),"^")
"RTN","HLOASUB1",263,0)
 .I OK,'$L(PARMS("LINK NAME")) S OK=0,ERROR="MIDDLEWARE LOGICAL LINK PROVIDED BUT NOT FOUND"
"RTN","HLOASUB1",264,0)
 E  I $L($G(WHO("IE LINK NAME"))) D
"RTN","HLOASUB1",265,0)
 .S PARMS("LINK NAME")=WHO("IE LINK NAME")
"RTN","HLOASUB1",266,0)
 .S PARMS("LINK IEN")=$O(^HLCS(870,"B",WHO("IE LINK NAME"),0))
"RTN","HLOASUB1",267,0)
 .I OK,'PARMS("LINK IEN") S OK=0,ERROR="MIDDLEWARE LOGICAL LINK PROVIDED BUT NOT FOUND"
"RTN","HLOASUB1",268,0)
 E  I $G(WHO("FACILITY LINK IEN")) D
"RTN","HLOASUB1",269,0)
 .S PARMS("LINK IEN")=WHO("FACILITY LINK IEN")
"RTN","HLOASUB1",270,0)
 .S PARMS("LINK NAME")=$P($G(^HLCS(870,PARMS("LINK IEN"),0)),"^")
"RTN","HLOASUB1",271,0)
 .I OK,'$L(PARMS("LINK NAME")) S OK=0,ERROR="RECEIVING FACILITY LOGICAL LINK NOT FOUND"
"RTN","HLOASUB1",272,0)
 E  I $L($G(WHO("FACILITY LINK NAME"))) D
"RTN","HLOASUB1",273,0)
 .S PARMS("LINK NAME")=WHO("FACILITY LINK NAME")
"RTN","HLOASUB1",274,0)
 .S PARMS("LINK IEN")=$O(^HLCS(870,"B",WHO("FACILITY LINK NAME"),0))
"RTN","HLOASUB1",275,0)
 .;; ** Start HL*1.6*138 - RBN **
"RTN","HLOASUB1",276,0)
 .;I OK,'PARMS("LINK IEN") S OK=0,ERROR="RECEIVING FACILITY LOGICAL LINK NOT FOUND"
"RTN","HLOASUB1",277,0)
 .I OK,'PARMS("LINK IEN") S OK=0,ERROR="NEITHER THE RECEIVING FACILITY STATION # NOR THE DOMAIN IS SPECIFIED. AT LEAST ONE OR THE OTHER MUST BE SPECIFIED."
"RTN","HLOASUB1",278,0)
 .;; ** Start HL*1.6*138 - RBN **
"RTN","HLOASUB1",279,0)
 I OK,(('PARMS("LINK IEN"))!(PARMS("LINK NAME")="")) S OK=0,ERROR="LOGICAL LINK TO TRANSMIT OVER NOT SPECIFIED"
"RTN","HLOASUB1",280,0)
 ;
"RTN","HLOASUB1",281,0)
 ;need the station # or domain for msg header
"RTN","HLOASUB1",282,0)
 I OK,'$L(PARMS("RECEIVING FACILITY",2)),'PARMS("RECEIVING FACILITY",1) S OK=0,ERROR="NEITHER THE RECEIVING FACILITY STATION # NOR THE DOMAIN IS SPECIFIED. AT LEAST ONE OR THE OTHER MUST BE SPECIFIED."
"RTN","HLOASUB1",283,0)
 ;
"RTN","HLOASUB1",284,0)
 ;append the port#
"RTN","HLOASUB1",285,0)
 I '$G(WHO("PORT")) S PARMS("RECEIVING FACILITY",2)=PARMS("RECEIVING FACILITY",2)_":"_$$PORT^HLOTLNK($G(WHO("FACILITY LINK IEN")))
"RTN","HLOASUB1",286,0)
 E  S PARMS("RECEIVING FACILITY",2)=PARMS("RECEIVING FACILITY",2)_":"_WHO("PORT")
"RTN","HLOASUB1",287,0)
 ;
"RTN","HLOASUB1",288,0)
 Q OK
"RTN","HLOASUB1",289,0)
 ;
"RTN","HLOASUB1",290,0)
 ;**P146 START CJM
"RTN","HLOASUB1",291,0)
ONLIST(IEN,WHO) ;
"RTN","HLOASUB1",292,0)
 ;Description:
"RTN","HLOASUB1",293,0)
 ;  Determines if a recipient is already on the subscriber list
"RTN","HLOASUB1",294,0)
 ;
"RTN","HLOASUB1",295,0)
 ;Input:
"RTN","HLOASUB1",296,0)
 ;  IEN - ien of subscription
"RTN","HLOASUB1",297,0)
 ;  WHO (pass by reference) Identifies the recipient. The allows
"RTN","HLOASUB1",298,0)
 ;      subscripts are the same as in ADD^HLOASUB.
"RTN","HLOASUB1",299,0)
 ;
"RTN","HLOASUB1",300,0)
 ;Output:
"RTN","HLOASUB1",301,0)
 ;   Function returns 0 if not on the subscription list, otherwise
"RTN","HLOASUB1",302,0)
 ;      returns the ien of the subscriber on the subscription list.
"RTN","HLOASUB1",303,0)
 ;
"RTN","HLOASUB1",304,0)
 N PARMS,SUBIEN,TLINK
"RTN","HLOASUB1",305,0)
 S SUBIEN=0
"RTN","HLOASUB1",306,0)
 ;
"RTN","HLOASUB1",307,0)
 ;resolve input parameters
"RTN","HLOASUB1",308,0)
 I '$$CHECKWHO(.WHO,.PARMS) Q 0
"RTN","HLOASUB1",309,0)
 ;
"RTN","HLOASUB1",310,0)
 ;check the "AE" xref
"RTN","HLOASUB1",311,0)
ZB S SUBIEN=$O(^HLD(779.4,IEN,2,"AE",PARMS("RECEIVING APPLICATION"),+$G(PARMS("RECEIVING FACILITY","LINK IEN")),+$G(PARMS("LINK IEN")),0))
"RTN","HLOASUB1",312,0)
 I SUBIEN Q SUBIEN
"RTN","HLOASUB1",313,0)
 I PARMS("RECEIVING FACILITY","LINK IEN")=PARMS("LINK IEN") S SUBIEN=$O(^HLD(779.4,IEN,2,"AE",PARMS("RECEIVING APPLICATION"),+$G(PARMS("RECEIVING FACILITY","LINK IEN")),0,0))
"RTN","HLOASUB1",314,0)
 I SUBIEN Q SUBIEN
"RTN","HLOASUB1",315,0)
 ;
"RTN","HLOASUB1",316,0)
 ;check the "AD" xref
"RTN","HLOASUB1",317,0)
 I PARMS("LINK IEN"),PARMS("LINK IEN")'=PARMS("RECEIVING FACILITY","LINK IEN") D
"RTN","HLOASUB1",318,0)
 .S TLINK=PARMS("LINK IEN")
"RTN","HLOASUB1",319,0)
 E  S TLINK=PARMS("RECEIVING FACILITY","LINK IEN")
"RTN","HLOASUB1",320,0)
 ;
"RTN","HLOASUB1",321,0)
 Q +$O(^HLD(779.4,IEN,2,"AD",PARMS("RECEIVING APPLICATION"),+TLINK,PARMS("RECEIVING FACILITY",1)_PARMS("RECEIVING FACILITY",2)_PARMS("RECEIVING FACILITY",3),0))
"RTN","HLOASUB1",322,0)
 ;
"RTN","HLOASUB1",323,0)
 ;**P146 END CJM
"RTN","HLOCLNT1")
0^10^B33784645^B32776376
"RTN","HLOCLNT1",1,0)
HLOCLNT1 ;IRMFO-ALB/CJM/RBN - Writing messages, reading acks;03/24/2004  14:43 ;04/28/2009
"RTN","HLOCLNT1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,130,131,134,137,139,146**;Oct 13, 1995;Build 16
"RTN","HLOCLNT1",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOCLNT1",4,0)
 ;
"RTN","HLOCLNT1",5,0)
 ;
"RTN","HLOCLNT1",6,0)
WRITEMSG(HLCSTATE,HLMSTATE) ;
"RTN","HLOCLNT1",7,0)
 ;Description:  This function uses the services offered by the transport layer to send a message over an open communication channel.
"RTN","HLOCLNT1",8,0)
 ;
"RTN","HLOCLNT1",9,0)
 ;Input:
"RTN","HLOCLNT1",10,0)
 ;  HLCSTATE (pass by reference, required) Defines the LLP & its state
"RTN","HLOCLNT1",11,0)
 ;  HLMSTATE (pass by reference, required) The message
"RTN","HLOCLNT1",12,0)
 ;Output:
"RTN","HLOCLNT1",13,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOCLNT1",14,0)
ZB6 ;
"RTN","HLOCLNT1",15,0)
 N SEG,QUIT,HDR
"RTN","HLOCLNT1",16,0)
 S QUIT=0
"RTN","HLOCLNT1",17,0)
 I '$G(HLMSTATE("IEN")) S QUIT=1 G ZB7
"RTN","HLOCLNT1",18,0)
 S HDR(1)=HLMSTATE("HDR",1),HDR(2)=HLMSTATE("HDR",2)
"RTN","HLOCLNT1",19,0)
 I '$$WRITEHDR^HLOT(.HLCSTATE,.HDR) S QUIT=1 G ZB7
"RTN","HLOCLNT1",20,0)
 I HLMSTATE("BATCH") D
"RTN","HLOCLNT1",21,0)
 .N LAST S LAST=0
"RTN","HLOCLNT1",22,0)
 .S HLMSTATE("BATCH","CURRENT MESSAGE")=0
"RTN","HLOCLNT1",23,0)
 .F  Q:'$$NEXTMSG^HLOMSG(.HLMSTATE,.SEG)  D  Q:QUIT
"RTN","HLOCLNT1",24,0)
 ..S LAST=HLMSTATE("BATCH","CURRENT MESSAGE")
"RTN","HLOCLNT1",25,0)
 ..I '$$WRITESEG^HLOT(.HLCSTATE,.SEG) S QUIT=1 Q
"RTN","HLOCLNT1",26,0)
 ..F  Q:'$$HLNEXT^HLOMSG(.HLMSTATE,.SEG)  D  Q:QUIT
"RTN","HLOCLNT1",27,0)
 ...I '$$WRITESEG^HLOT(.HLCSTATE,.SEG) S QUIT=1 Q
"RTN","HLOCLNT1",28,0)
 .K SEG S SEG(1)="BTS"_HLMSTATE("HDR","FIELD SEPARATOR")_LAST
"RTN","HLOCLNT1",29,0)
 .S:'$$WRITESEG^HLOT(.HLCSTATE,.SEG) QUIT=1
"RTN","HLOCLNT1",30,0)
 E  D
"RTN","HLOCLNT1",31,0)
 .F  Q:'$$HLNEXT^HLOMSG(.HLMSTATE,.SEG)  D  Q:QUIT
"RTN","HLOCLNT1",32,0)
 ..S:'$$WRITESEG^HLOT(.HLCSTATE,.SEG) QUIT=1
"RTN","HLOCLNT1",33,0)
 S:'$$ENDMSG^HLOT(.HLCSTATE) QUIT=1
"RTN","HLOCLNT1",34,0)
ZB7 ;
"RTN","HLOCLNT1",35,0)
 Q 'QUIT
"RTN","HLOCLNT1",36,0)
 ;
"RTN","HLOCLNT1",37,0)
READACK(HLCSTATE,HDR,MSA) ;
"RTN","HLOCLNT1",38,0)
 ;Description:  This function uses the services offered by the transport layer to read an accept ack.
"RTN","HLOCLNT1",39,0)
 ;
"RTN","HLOCLNT1",40,0)
 ;Input:
"RTN","HLOCLNT1",41,0)
 ;  HLCSTATE (pass by reference, required) Defines the communication channel and its state.
"RTN","HLOCLNT1",42,0)
 ;Output:
"RTN","HLOCLNT1",43,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOCLNT1",44,0)
 ;  HDR (pass by reference) the message header:
"RTN","HLOCLNT1",45,0)
 ;   HDR(1) is components 1-6
"RTN","HLOCLNT1",46,0)
 ;   HDR(2) is components 7-end
"RTN","HLOCLNT1",47,0)
 ;  MSA (pass by reference) the MSA segment as an unsubscripted variable
"RTN","HLOCLNT1",48,0)
 ;
"RTN","HLOCLNT1",49,0)
ZB8 ;
"RTN","HLOCLNT1",50,0)
 N SEG,SUCCESS
"RTN","HLOCLNT1",51,0)
 S SUCCESS=0
"RTN","HLOCLNT1",52,0)
 K HDR,MSA,MAX,I
"RTN","HLOCLNT1",53,0)
 S MAX=HLCSTATE("SYSTEM","MAXSTRING")-40 ;MAX is the maximum that can be safely stored on a node, leaving room for the other fields stored with MSA seg
"RTN","HLOCLNT1",54,0)
 G:'$$READHDR^HLOT(.HLCSTATE,.HDR) ZB9
"RTN","HLOCLNT1",55,0)
 F  Q:'$$READSEG^HLOT(.HLCSTATE,.SEG)  D
"RTN","HLOCLNT1",56,0)
 .I $E($E(SEG(1),1,3)_$E($G(SEG(2)),1,3),1,3)="MSA" D
"RTN","HLOCLNT1",57,0)
 ..S MSA=""
"RTN","HLOCLNT1",58,0)
 ..F I=1:1 Q:'$D(SEG(I))  S MSA=MSA_$S((MAX-$L(MSA))<1:"",1:$E(SEG(I),1,MAX))
"RTN","HLOCLNT1",59,0)
 I $D(MSA),HLCSTATE("MESSAGE ENDED") D  S SUCCESS=1
"RTN","HLOCLNT1",60,0)
 .D SPLITHDR^HLOSRVR1(.HDR)
"RTN","HLOCLNT1",61,0)
 .S HLCSTATE("COUNTS","ACKS")=$G(HLCSTATE("COUNTS","ACKS"))+1
"RTN","HLOCLNT1",62,0)
ZB9 Q SUCCESS
"RTN","HLOCLNT1",63,0)
 ;
"RTN","HLOCLNT1",64,0)
CONNECT(LINK,PORT,TIMEOUT,HLCSTATE) ;
"RTN","HLOCLNT1",65,0)
ZB1 ;sets up HLCSTATE() and opens a client connection
"RTN","HLOCLNT1",66,0)
 ;Input:
"RTN","HLOCLNT1",67,0)
 ;  LINK - name of the link to connect to
"RTN","HLOCLNT1",68,0)
 ;  PORT (optional) port # to connect to, defaults to that specified by the link
"RTN","HLOCLNT1",69,0)
 ;  TIMEOUT (optional) specifies the open timeout in seconds, defaults to 30
"RTN","HLOCLNT1",70,0)
 ;Output:
"RTN","HLOCLNT1",71,0)
 ;   HLCSTATE - array to hold the connection state
"RTN","HLOCLNT1",72,0)
 ;
"RTN","HLOCLNT1",73,0)
 I '$G(HLCSTATE("CONNECTED")) S HLCSTATE("CONNECTED")=0
"RTN","HLOCLNT1",74,0)
 I HLCSTATE("CONNECTED") D  G:HLCSTATE("CONNECTED") ZB2
"RTN","HLOCLNT1",75,0)
 .I $G(HLCSTATE("LINK","NAME"))]"",($G(HLCSTATE("LINK","NAME"))'=LINK) D CLOSE^HLOT(.HLCSTATE) Q
"RTN","HLOCLNT1",76,0)
 .I $G(HLCSTATE("LINK","NAME"))]"",$G(PORT),($G(HLCSTATE("LINK","PORT"))'=PORT) D CLOSE^HLOT(.HLCSTATE) Q
"RTN","HLOCLNT1",77,0)
 .I (HLCSTATE("SYSTEM","OS")="CACHE") D  Q
"RTN","HLOCLNT1",78,0)
 ..U HLCSTATE("DEVICE") S HLCSTATE("CONNECTED")=($ZA\8192#2)
"RTN","HLOCLNT1",79,0)
 ..I 'HLCSTATE("CONNECTED") D CLOSE^HLOT(.HLCSTATE)
"RTN","HLOCLNT1",80,0)
 .;D CLOSE^HLOT(.HLCSTATE)
"RTN","HLOCLNT1",81,0)
 K HLCSTATE
"RTN","HLOCLNT1",82,0)
 N ARY,NODE
"RTN","HLOCLNT1",83,0)
 I '$$GETLINK^HLOTLNK(LINK,.ARY) S HLCSTATE("LINK","NAME")=LINK,HLCSTATE("LINK","PORT")=$G(PORT) D LINKDOWN^HLOCLNT(.HLCSTATE) G ZB2
"RTN","HLOCLNT1",84,0)
 M HLCSTATE("LINK")=ARY
"RTN","HLOCLNT1",85,0)
ZB24 ;
"RTN","HLOCLNT1",86,0)
 I HLCSTATE("LINK","SHUTDOWN") S HLCSTATE("CONNECTED")=0 D LINKDOWN^HLOCLNT(.HLCSTATE) G ZB2
"RTN","HLOCLNT1",87,0)
 ;overlay the port if supplied from the queue
"RTN","HLOCLNT1",88,0)
 S:$G(PORT) HLCSTATE("LINK","PORT")=PORT
"RTN","HLOCLNT1",89,0)
 ;
"RTN","HLOCLNT1",90,0)
 ; *** Begin HL*1.6*146 - RBN ***
"RTN","HLOCLNT1",91,0)
 ;S HLCSTATE("READ TIMEOUT")=20
"RTN","HLOCLNT1",92,0)
 ;get the dynamic value of the client read timeout
"RTN","HLOCLNT1",93,0)
 D GETTIME^HLOTCP(.HLCSTATE)
"RTN","HLOCLNT1",94,0)
 ; *** End HL*1.6*146 - RBN ***
"RTN","HLOCLNT1",95,0)
 ; ;
"RTN","HLOCLNT1",96,0)
 S HLCSTATE("OPEN TIMEOUT")=$S($G(TIMEOUT):TIMEOUT,1:30)
"RTN","HLOCLNT1",97,0)
 S HLCSTATE("COUNTS")=0
"RTN","HLOCLNT1",98,0)
 S HLCSTATE("READ")="" ;where the reads are stored
"RTN","HLOCLNT1",99,0)
 ;
"RTN","HLOCLNT1",100,0)
 ;HLCSTATE("BUFFER",<seg>,<line>) serves as a write buffer so that a lot can be written all at once
"RTN","HLOCLNT1",101,0)
 S HLCSTATE("BUFFER","BYTE COUNT")=0 ;count of BYTES in buffer
"RTN","HLOCLNT1",102,0)
 S HLCSTATE("BUFFER","SEGMENT COUNT")=0 ;count of segments in buffer
"RTN","HLOCLNT1",103,0)
 ;
"RTN","HLOCLNT1",104,0)
 S HLCSTATE("MESSAGE ENDED")=0 ;end of message flag
"RTN","HLOCLNT1",105,0)
 S NODE=^%ZOSF("OS")
"RTN","HLOCLNT1",106,0)
 S HLCSTATE("SERVER")=0
"RTN","HLOCLNT1",107,0)
 S HLCSTATE("SYSTEM","OS")=$S(NODE["DSM":"DSM",NODE["OpenM":"CACHE",NODE["G.TM":"G.TM",1:"")
"RTN","HLOCLNT1",108,0)
 I HLCSTATE("SYSTEM","OS")="" D LINKDOWN^HLOCLNT(.HLCSTATE) G ZB2
"RTN","HLOCLNT1",109,0)
 D
"RTN","HLOCLNT1",110,0)
 .N SYS
"RTN","HLOCLNT1",111,0)
 .D SYSPARMS^HLOSITE(.SYS)
"RTN","HLOCLNT1",112,0)
 .S HLCSTATE("SYSTEM","BUFFER")=SYS("HL7 BUFFER")
"RTN","HLOCLNT1",113,0)
 .S HLCSTATE("SYSTEM","MAXSTRING")=SYS("MAXSTRING")
"RTN","HLOCLNT1",114,0)
 .S HLCSTATE("SYSTEM","NORMAL PURGE")=SYS("NORMAL PURGE")
"RTN","HLOCLNT1",115,0)
 .S HLCSTATE("SYSTEM","ERROR PURGE")=SYS("ERROR PURGE")
"RTN","HLOCLNT1",116,0)
 I HLCSTATE("LINK","LLP")="TCP" D
"RTN","HLOCLNT1",117,0)
 .S HLCSTATE("OPEN")="OPEN^HLOTCP"
"RTN","HLOCLNT1",118,0)
 E  ;no other LLP implemented
"RTN","HLOCLNT1",119,0)
 D OPEN^HLOT(.HLCSTATE)
"RTN","HLOCLNT1",120,0)
 ;
"RTN","HLOCLNT1",121,0)
 ;mark the failure time for the link so other processes know not to try for a while
"RTN","HLOCLNT1",122,0)
 I 'HLCSTATE("CONNECTED") D LINKDOWN^HLOCLNT(.HLCSTATE)
"RTN","HLOCLNT1",123,0)
ZB2 ;
"RTN","HLOCLNT1",124,0)
 Q HLCSTATE("CONNECTED")
"RTN","HLOCLNT1",125,0)
 ;
"RTN","HLOCLNT1",126,0)
BADMSGS(WORK) ;
"RTN","HLOCLNT1",127,0)
 ;finds messages that won't transmit after 8 hours of trying and takes them off the outgoing queue
"RTN","HLOCLNT1",128,0)
 N LINK
"RTN","HLOCLNT1",129,0)
 S LINK=""
"RTN","HLOCLNT1",130,0)
 F  S LINK=$O(^HLTMP("FAILING LINKS",LINK)) Q:LINK=""  D
"RTN","HLOCLNT1",131,0)
 .N TIME,QUE,COUNT
"RTN","HLOCLNT1",132,0)
 .S TIME=$G(^HLTMP("FAILING LINKS",LINK)) Q:TIME=""
"RTN","HLOCLNT1",133,0)
 .Q:$$HDIFF^XLFDT($H,TIME,2)<28800  ;8 hours
"RTN","HLOCLNT1",134,0)
 .Q:'$$IFOPEN^HLOUSR1(LINK)
"RTN","HLOCLNT1",135,0)
 .L +^HLB("QUEUE","OUT",LINK):0
"RTN","HLOCLNT1",136,0)
 .S QUE=""
"RTN","HLOCLNT1",137,0)
 .F  S QUE=$O(^HLB("QUEUE","OUT",LINK,QUE)) Q:QUE=""  D
"RTN","HLOCLNT1",138,0)
 ..N MSG S MSG=0
"RTN","HLOCLNT1",139,0)
 ..S MSG=$O(^HLB("QUEUE","OUT",LINK,QUE,MSG))
"RTN","HLOCLNT1",140,0)
 ..Q:'MSG
"RTN","HLOCLNT1",141,0)
 ..S COUNT=$G(^HLB(MSG,"TRIES"))
"RTN","HLOCLNT1",142,0)
 ..I COUNT>20 D
"RTN","HLOCLNT1",143,0)
 ...N NODE0,NODE1,NODE2,TIME,RAPP,SAPP,FS,CS,ACTION,MTYPE,EVENT
"RTN","HLOCLNT1",144,0)
 ...S NODE0=$G(^HLB(MSG,0))
"RTN","HLOCLNT1",145,0)
 ...Q:'$P(NODE0,"^",2)
"RTN","HLOCLNT1",146,0)
 ...S TIME=$$NOW^XLFDT
"RTN","HLOCLNT1",147,0)
 ...S NODE1=$G(^HLB(MSG,1))
"RTN","HLOCLNT1",148,0)
 ...S NODE2=$G(^HLB(MSG,2))
"RTN","HLOCLNT1",149,0)
 ...S FS=$E(NODE1,4)
"RTN","HLOCLNT1",150,0)
 ...Q:FS=""
"RTN","HLOCLNT1",151,0)
 ...S CS=$E(NODE1,5)
"RTN","HLOCLNT1",152,0)
 ...Q:CS=""
"RTN","HLOCLNT1",153,0)
 ...S SAPP=$P(NODE1,FS,3)
"RTN","HLOCLNT1",154,0)
 ...S:SAPP="" SAPP="UNKNOWN"
"RTN","HLOCLNT1",155,0)
 ...S RAPP=$P(NODE1,FS,5)
"RTN","HLOCLNT1",156,0)
 ...S MTYPE=$P($P(NODE2,FS,4),CS)
"RTN","HLOCLNT1",157,0)
 ...S EVENT=$P($P(NODE2,FS,4),CS,2)
"RTN","HLOCLNT1",158,0)
 ...S $P(^HLB(MSG,0),"^",21)=COUNT_" FAILED TRANSMISSIONS"
"RTN","HLOCLNT1",159,0)
 ...S $P(^HLB(MSG,0),"^",20)="TF"
"RTN","HLOCLNT1",160,0)
 ...S ^HLB("ERRORS",RAPP,TIME,MSG)=""
"RTN","HLOCLNT1",161,0)
 ...D COUNT^HLOESTAT("OUT",RAPP,SAPP,MTYPE,EVENT)
"RTN","HLOCLNT1",162,0)
 ...S ACTION=$P(NODE0,"^",14,15)
"RTN","HLOCLNT1",163,0)
 ...I ACTION'="^",ACTION]"" D INQUE^HLOQUE(LINK,QUE,MSG,ACTION,1)
"RTN","HLOCLNT1",164,0)
 ...D DEQUE^HLOQUE(LINK,QUE,"OUT",MSG)
"RTN","HLOCLNT1",165,0)
 .L -^HLB("QUEUE","OUT",LINK)
"RTN","HLOCLNT1",166,0)
 Q
"RTN","HLOCNRT")
0^5^B16134592^B12168721
"RTN","HLOCNRT",1,0)
HLOCNRT ;DAOU/ALA-Generate HL7 Optimized Message ;05/12/2009
"RTN","HLOCNRT",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,132,134,137,146**;Oct 13, 1995;Build 16
"RTN","HLOCNRT",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOCNRT",4,0)
 ;
"RTN","HLOCNRT",5,0)
 ;**Program Description**
"RTN","HLOCNRT",6,0)
 ;  This program uses the traditional protocol setup and hard-coded
"RTN","HLOCNRT",7,0)
 ;  message builders  of HL7 1.6 to send messages via HL7 Optimized code.
"RTN","HLOCNRT",8,0)
 Q
"RTN","HLOCNRT",9,0)
 ;
"RTN","HLOCNRT",10,0)
EN(HLOPRTCL,ARYTYP,HLP,HLL,RESULT) ;
"RTN","HLOCNRT",11,0)
 ;Input:
"RTN","HLOCNRT",12,0)
 ;   HLOPRTCL (required) Protocol IEN or Protocol Name
"RTN","HLOCNRT",13,0)
 ;   ARYTYP   (required) set to "GM" if the message is contained in the global array ^TMP("HLS",$J), or set to "LM" if the message is contained in the local array HLA("HLS").
"RTN","HLOCNRT",14,0)
 ;   HLP  (optional, pass-by-reference) Additional HL7 message
"RTN","HLOCNRT",15,0)
 ;        parameters. These optional subscripts to HLP are supported:
"RTN","HLOCNRT",16,0)
 ;             "APP ACK RESPONSE" = <tag^routine> to call when the app ack is received
"RTN","HLOCNRT",17,0)
 ;             "CONTPTR"
"RTN","HLOCNRT",18,0)
 ;             "SECURITY"
"RTN","HLOCNRT",19,0)
 ;             "SEQUENCE QUEUE" - A queue used to maintain the order of
"RTN","HLOCNRT",20,0)
 ;                   the messages via application acks. If used, the
"RTN","HLOCNRT",21,0)
 ;                   application MUST specify that both an accept ack
"RTN","HLOCNRT",22,0)
 ;                   and application ack be returned. 
"RTN","HLOCNRT",23,0)
 ;        
"RTN","HLOCNRT",24,0)
 ;   HLL  (optional, pass-by-reference) Used to dynamically add message
"RTN","HLOCNRT",25,0)
 ;        recipients.  The format is HLL("LINKS",<i>)=<destination protocol name or ien>^<destination link or ien>.
"RTN","HLOCNRT",26,0)
 ;       
"RTN","HLOCNRT",27,0)
 ;
"RTN","HLOCNRT",28,0)
 ;  Output
"RTN","HLOCNRT",29,0)
 ;    RESULT (pass-by-reference)
"RTN","HLOCNRT",30,0)
 ;            On success:
"RTN","HLOCNRT",31,0)
 ;                 <subscriber protocol ien>^<link ien>^<message id>^0
"RTN","HLOCNRT",32,0)
 ;            On failure:
"RTN","HLOCNRT",33,0)
 ;                 <subscriber protocol ien>^<link ien>^<message id>^<error code>^<optional error message>
"RTN","HLOCNRT",34,0)
 ;
"RTN","HLOCNRT",35,0)
 ;    RESULT("IEN")=the ien, file 778, if a message record in file 778
"RTN","HLOCNRT",36,0)
 ;                  was created, regardless of whether or not the message
"RTN","HLOCNRT",37,0)
 ;                  was successfully queued for transmission.
"RTN","HLOCNRT",38,0)
 ;
"RTN","HLOCNRT",39,0)
 ;            If the message was sent to more than 1 destination,
"RTN","HLOCNRT",40,0)
 ;            the addtional message statuses are returned as RESULT(1),
"RTN","HLOCNRT",41,0)
 ;            RESULT(2), etc., in the same format as above, as the iens
"RTN","HLOCNRT",42,0)
 ;            of message records created are returned as RESULT(1,"IEN"),
"RTN","HLOCNRT",43,0)
 ;            RESULT(2,"IEN"), etc.
"RTN","HLOCNRT",44,0)
 ;    ZTSTOP = Stop processing flag (used by HDR)
"RTN","HLOCNRT",45,0)
 ;    Function returns:
"RTN","HLOCNRT",46,0)
 ;            On success:  1
"RTN","HLOCNRT",47,0)
 ;            On failure:  ^<error code>^<error message>
"RTN","HLOCNRT",48,0)
 ;
"RTN","HLOCNRT",49,0)
 NEW HLORESL,HLMSTATE,APPARMS,WHOTO,ERROR,WHO
"RTN","HLOCNRT",50,0)
 S ZTSTOP=0,HLORESL=1,RESULT=""
"RTN","HLOCNRT",51,0)
 ;
"RTN","HLOCNRT",52,0)
 ;  Get IEN of protocol if name is passed
"RTN","HLOCNRT",53,0)
 I '$L(HLOPRTCL) S HLORESL="^99^HL7 1.6 Protocol not found",RESULT="^^"_HLORESL,ZTSTOP=1 Q HLORESL
"RTN","HLOCNRT",54,0)
 I ('HLOPRTCL)!(HLOPRTCL'=+HLOPRTCL) S HLOPRTCL=+$O(^ORD(101,"B",HLOPRTCL,0))
"RTN","HLOCNRT",55,0)
 I 'HLOPRTCL S HLORESL="^99^HL7 1.6 Protocol not found",RESULT="^^"_HLORESL,ZTSTOP=1 Q HLORESL
"RTN","HLOCNRT",56,0)
 I '$D(^ORD(101,HLOPRTCL)) S HLORESL="^99^HL7 1.6 Protocol not found",RESULT="^^"_HLORESL,ZTSTOP=1 Q HLORESL
"RTN","HLOCNRT",57,0)
 ;
"RTN","HLOCNRT",58,0)
 ;  If the VistA HL7 Protocol exists, call the Conversion Utility
"RTN","HLOCNRT",59,0)
 ;  to set up the APPARMS, WHOTO arrays from protocol logical link,
"RTN","HLOCNRT",60,0)
 ;   and the optional HLL and HLP arrays
"RTN","HLOCNRT",61,0)
 D APAR^HLOCVU(HLOPRTCL,.APPARMS,.WHO,.WHOTO,.HLP,.HLL)
"RTN","HLOCNRT",62,0)
 ;
"RTN","HLOCNRT",63,0)
 ; If special HLP parameters are defined, convert them
"RTN","HLOCNRT",64,0)
 I $D(HLP) D
"RTN","HLOCNRT",65,0)
 . I $G(HLP("SECURITY"))'="" S APPARMS("SECURITY")=HLP("SECURITY")
"RTN","HLOCNRT",66,0)
 . I $G(HLP("CONTPTR"))'="" S APPARMS("CONTINUATION POINTER")=HLP("CONTPTR")
"RTN","HLOCNRT",67,0)
 . I $G(HLP("QUEUE"))'="" S APPARMS("QUEUE")=HLP("QUEUE")
"RTN","HLOCNRT",68,0)
 . I $G(HLP("SEQUENCE QUEUE"))'="" S APPARMS("SEQUENCE QUEUE")=HLP("SEQUENCE QUEUE")
"RTN","HLOCNRT",69,0)
 . I $G(HLP("APP ACK RESPONSE"))'="" S APPARMS("APP ACK RESPONSE")=HLP("APP ACK RESPONSE")
"RTN","HLOCNRT",70,0)
 ;
"RTN","HLOCNRT",71,0)
 ;  Create HL Optimized message
"RTN","HLOCNRT",72,0)
 I '$$NEWMSG^HLOAPI(.APPARMS,.HLMSTATE,.ERROR) S HLORESL="^99^"_ERROR,ZTSTOP=1,RESULT="^^"_HLORESL Q HLORESL
"RTN","HLOCNRT",73,0)
 I $E(ARYTYP,1)="G" S HLOMESG="^TMP(""HLS"",$J)"
"RTN","HLOCNRT",74,0)
 I $E(ARYTYP,1)="L" S HLOMESG="HLA(""HLS"")"
"RTN","HLOCNRT",75,0)
 ;
"RTN","HLOCNRT",76,0)
 ;  Move the existing message from array into HL Optimized
"RTN","HLOCNRT",77,0)
 D MOVEMSG^HLOAPI(.HLMSTATE,HLOMESG)
"RTN","HLOCNRT",78,0)
 ; 
"RTN","HLOCNRT",79,0)
 ;  Send message via HL Optimized
"RTN","HLOCNRT",80,0)
 I $D(WHOTO) D
"RTN","HLOCNRT",81,0)
 .N COUNT
"RTN","HLOCNRT",82,0)
 .I '$$SENDMANY^HLOAPI1(.HLMSTATE,.APPARMS,.WHOTO) D
"RTN","HLOCNRT",83,0)
 ..S HLORESL="^99^Unable to send message",ZTSTOP=1
"RTN","HLOCNRT",84,0)
 .I $G(WHOTO(1,"IEN")) D
"RTN","HLOCNRT",85,0)
 ..S RESULT=WHO(1)_"^"_$P($G(^HLB(WHOTO(1,"IEN"),0)),"^")_"^"_$S($G(WHOTO(1,"QUEUED")):0,1:1)_"^"_$G(WHOTO(1,"ERROR"))
"RTN","HLOCNRT",86,0)
 ..;**P146 START CJM
"RTN","HLOCNRT",87,0)
 ..S RESULT("IEN")=WHOTO(1,"IEN")
"RTN","HLOCNRT",88,0)
 ..;**P146 END CJM
"RTN","HLOCNRT",89,0)
 .E  D
"RTN","HLOCNRT",90,0)
 ..S RESULT=$G(WH0(1))_"^^1^"_$G(WHOTO(1,"ERROR"))
"RTN","HLOCNRT",91,0)
 ..;**P146 START CJM
"RTN","HLOCNRT",92,0)
 ..S RESULT("IEN")=""
"RTN","HLOCNRT",93,0)
 ..;**P146 END CJM
"RTN","HLOCNRT",94,0)
 ..S HLORESL="^99^"_$G(WHOTO(1,"ERROR")),ZTSTOP=1
"RTN","HLOCNRT",95,0)
 .S COUNT=1
"RTN","HLOCNRT",96,0)
 .F  S COUNT=$O(WHOTO(COUNT)) Q:'COUNT  D
"RTN","HLOCNRT",97,0)
 ..I $G(WHOTO(COUNT,"IEN")) D
"RTN","HLOCNRT",98,0)
 ...S RESULT(COUNT-1)=WHO(COUNT)_"^"_$P($G(^HLB(WHOTO(COUNT,"IEN"),0)),"^")_"^"_$S($G(WHOTO(COUNT,"QUEUED")):0,1:1)_"^"_$G(WHOTO(COUNT,"ERROR"))
"RTN","HLOCNRT",99,0)
 ...;**P146 START CJM
"RTN","HLOCNRT",100,0)
 ...S RESULT(COUNT-1,"IEN")=WHOTO(COUNT,"IEN")
"RTN","HLOCNRT",101,0)
 ...;**P146 END CJM
"RTN","HLOCNRT",102,0)
 ..E  D
"RTN","HLOCNRT",103,0)
 ...S RESULT(COUNT-1)=WH0(COUNT)_"^^1^"_$G(WHOTO(COUNT,"ERROR"))
"RTN","HLOCNRT",104,0)
 ...;**P146 START CJM
"RTN","HLOCNRT",105,0)
 ...S RESULT(COUNT-1,"IEN")=""
"RTN","HLOCNRT",106,0)
 ...;**P146 END CJM
"RTN","HLOCNRT",107,0)
 ;
"RTN","HLOCNRT",108,0)
 E  S HLORESL="^99^Unable to send message",ZTSTOP=1,RESULT="^^"_HLORESL
"RTN","HLOCNRT",109,0)
 Q HLORESL
"RTN","HLOP146")
0^^B1485106^n/a
"RTN","HLOP146",1,0)
HLOP146 ;ALB/CJM-Pre & Post install ;06/04/2009
"RTN","HLOP146",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**146**;Oct 13, 1995;Build 16
"RTN","HLOP146",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOP146",4,0)
 ;
"RTN","HLOP146",5,0)
PRE ;
"RTN","HLOP146",6,0)
 ;
"RTN","HLOP146",7,0)
 N WORK
"RTN","HLOP146",8,0)
 L +^HLTMP("PROCESS MANAGER"):0
"RTN","HLOP146",9,0)
 I '$T D ABORT Q
"RTN","HLOP146",10,0)
 D CHKDEAD^HLOPROC1(.WORK)
"RTN","HLOP146",11,0)
 I $O(^HLTMP("HL7 RUNNING PROCESSES",""))'="" D ABORT
"RTN","HLOP146",12,0)
 L -^HLTMP("PROCESS MANAGER")
"RTN","HLOP146",13,0)
 Q
"RTN","HLOP146",14,0)
ABORT ;
"RTN","HLOP146",15,0)
 S XPDABORT=1
"RTN","HLOP146",16,0)
 D BMES^XPDUTL("HLO processes are still running and prevent this installation from completing")
"RTN","HLOP146",17,0)
 Q
"RTN","HLOP146",18,0)
POST ;post-install
"RTN","HLOP146",19,0)
 N OPTION
"RTN","HLOP146",20,0)
 F OPTION="HLO OUTBOUND DELETE","HLO SEQUENCE DELETE" D DELSYN(OPTION)
"RTN","HLOP146",21,0)
 Q
"RTN","HLOP146",22,0)
DELSYN(OPTION) ;delete options QD synonym
"RTN","HLOP146",23,0)
 S DA(1)=$O(^ORD(101,"B",OPTION,0))
"RTN","HLOP146",24,0)
 Q:'DA(1)
"RTN","HLOP146",25,0)
 S DA=$O(^ORD(101,DA(1),2,"B","QD",0))
"RTN","HLOP146",26,0)
 Q:'DA
"RTN","HLOP146",27,0)
 I $$DELETE^HLOASUB1(101.02,.DA)
"RTN","HLOP146",28,0)
 Q
"RTN","HLOPROC")
0^31^B26547261^B26319281
"RTN","HLOPROC",1,0)
HLOPROC ;ALB/CJM- Generic HL7 Process - 10/4/94 1pm ;06/10/2009
"RTN","HLOPROC",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,134,146**;Oct 13, 1995;Build 16
"RTN","HLOPROC",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOPROC",4,0)
 ;
"RTN","HLOPROC",5,0)
PROCESS ;queued entry point
"RTN","HLOPROC",6,0)
 ;
"RTN","HLOPROC",7,0)
 ;insure just one process manager
"RTN","HLOPROC",8,0)
 I PROCNAME="PROCESS MANAGER" N RUNNING L +^HLTMP(PROCNAME):1 S RUNNING='$T D  Q:RUNNING
"RTN","HLOPROC",9,0)
 .I 'RUNNING D
"RTN","HLOPROC",10,0)
 ..D SETNM^%ZOSV($E("HLOmgr:"_$J,1,17))
"RTN","HLOPROC",11,0)
 .E  D
"RTN","HLOPROC",12,0)
 ..L +HL7("COUNTING PROCESSES"):20
"RTN","HLOPROC",13,0)
 ..K:$D(ZTSK) ^HLTMP("HL7 QUEUED PROCESSES",ZTSK)
"RTN","HLOPROC",14,0)
 ..S ^HLC("HL7 PROCESS COUNTS","RUNNING","PROCESS MANAGER")=1
"RTN","HLOPROC",15,0)
 ..S ^HLC("HL7 PROCESS COUNTS","QUEUED","PROCESS MANAGER")=0
"RTN","HLOPROC",16,0)
 ..L -HL7("COUNTING PROCESSES")
"RTN","HLOPROC",17,0)
 ..S ZTREQ="@"
"RTN","HLOPROC",18,0)
 ;
"RTN","HLOPROC",19,0)
 ;invoke the framework process
"RTN","HLOPROC",20,0)
 D HL7PROC(PROCNAME)
"RTN","HLOPROC",21,0)
 ;
"RTN","HLOPROC",22,0)
 I PROCNAME="PROCESS MANAGER" L -^HLTMP(PROCNAME)
"RTN","HLOPROC",23,0)
 S ZTREQ="@"
"RTN","HLOPROC",24,0)
 Q
"RTN","HLOPROC",25,0)
 ;
"RTN","HLOPROC",26,0)
HL7PROC(PROCNAME) ;
"RTN","HLOPROC",27,0)
 ;This is the generic HL7 process used by all processes started under the HL7 Process Manager
"RTN","HLOPROC",28,0)
 ;Input:
"RTN","HLOPROC",29,0)
 ;  PROCNAME - the name of a process found in the HL7 Process Registry
"RTN","HLOPROC",30,0)
 ;  OUTPUT - none
"RTN","HLOPROC",31,0)
 ;
"RTN","HLOPROC",32,0)
 N PROCESS,HL7STOP,WORK
"RTN","HLOPROC",33,0)
 ;
"RTN","HLOPROC",34,0)
 S ^HL7TMP("HL7 PROCESS NAME",$J)=PROCNAME
"RTN","HLOPROC",35,0)
 ;
"RTN","HLOPROC",36,0)
 L +HL7("COUNTING PROCESSES"):20
"RTN","HLOPROC",37,0)
 I $D(ZTQUEUED) D
"RTN","HLOPROC",38,0)
 .K:$D(ZTSK) ^HLTMP("HL7 QUEUED PROCESSES",ZTSK)
"RTN","HLOPROC",39,0)
 .I $$INC^HLOSITE($NA(^HLC("HL7 PROCESS COUNTS","QUEUED",PROCNAME)),-1)<0,$$INC^HLOSITE($NA(^HLC("HL7 PROCESS COUNTS","QUEUED",PROCNAME)))
"RTN","HLOPROC",40,0)
 L +^HLTMP("HL7 RUNNING PROCESSES",$J):0
"RTN","HLOPROC",41,0)
 I $$INC^HLOSITE($NA(^HLC("HL7 PROCESS COUNTS","RUNNING",PROCNAME)))
"RTN","HLOPROC",42,0)
 S ^HLTMP("HL7 RUNNING PROCESSES",$J)=$H_"^"_$G(ZTSK)_"^"_PROCNAME
"RTN","HLOPROC",43,0)
 L -HL7("COUNTING PROCESSES")
"RTN","HLOPROC",44,0)
 ;
"RTN","HLOPROC",45,0)
 ;
"RTN","HLOPROC",46,0)
 I $$GETPROC(PROCNAME,.PROCESS),'$$CHK4STOP(.PROCESS) D
"RTN","HLOPROC",47,0)
 .S $P(^HLD(779.3,PROCESS("IEN"),0),"^",6)=$$NOW^XLFDT
"RTN","HLOPROC",48,0)
 .;
"RTN","HLOPROC",49,0)
 .;should this task be made persistent?
"RTN","HLOPROC",50,0)
 .I PROCESS("PERSISTENT"),$G(ZTQUEUED),$$PSET^%ZTLOAD(ZTQUEUED)
"RTN","HLOPROC",51,0)
 .;
"RTN","HLOPROC",52,0)
 .S HL7STOP=0
"RTN","HLOPROC",53,0)
 .F  D  Q:HL7STOP
"RTN","HLOPROC",54,0)
 ..N $ETRAP,$ESTACK S $ETRAP="G ERROR^HLOPROC"
"RTN","HLOPROC",55,0)
 ..N HL7TRIES,GOTWORK
"RTN","HLOPROC",56,0)
 ..F HL7TRIES=1:1 D  Q:GOTWORK  Q:$G(HL7STOP)
"RTN","HLOPROC",57,0)
 ...S GOTWORK=$$GETWORK(.PROCESS,.WORK)
"RTN","HLOPROC",58,0)
 ...Q:GOTWORK
"RTN","HLOPROC",59,0)
 ...;since there is no work, don't want another process starting
"RTN","HLOPROC",60,0)
 ...S $P(^HLD(779.3,PROCESS("IEN"),0),"^",6)=$$NOW^XLFDT
"RTN","HLOPROC",61,0)
 ...H PROCESS("HANG")
"RTN","HLOPROC",62,0)
 ...S HL7STOP=$$CHK4STOP(.PROCESS,HL7TRIES)
"RTN","HLOPROC",63,0)
 ..Q:$G(HL7STOP)
"RTN","HLOPROC",64,0)
 ..I GOTWORK D DOWORK(.PROCESS,.WORK) S HL7TRIES=0
"RTN","HLOPROC",65,0)
 ..S:'$G(HL7STOP) HL7STOP=$$CHK4STOP(.PROCESS,.HL7TRIES)
"RTN","HLOPROC",66,0)
 ;
"RTN","HLOPROC",67,0)
 S $P(^HLD(779.3,PROCESS("IEN"),0),"^",6)=$$NOW^XLFDT
"RTN","HLOPROC",68,0)
 ;
"RTN","HLOPROC",69,0)
END ;
"RTN","HLOPROC",70,0)
 S HL7STOP=1
"RTN","HLOPROC",71,0)
 K ^HL7TMP("HL7 PROCESS NAME",$J)
"RTN","HLOPROC",72,0)
 L +HL7("COUNTING PROCESSES"):20
"RTN","HLOPROC",73,0)
 K ^HLTMP("HL7 RUNNING PROCESSES",$J)
"RTN","HLOPROC",74,0)
 I $$INC^HLOSITE($NA(^HLC("HL7 PROCESS COUNTS","RUNNING",PROCNAME)),-1)<0,$$INC^HLOSITE($NA(^HLC("HL7 PROCESS COUNTS","RUNNING",PROCNAME)),1)
"RTN","HLOPROC",75,0)
 L -^HLTMP("HL7 RUNNING PROCESSES",$J)
"RTN","HLOPROC",76,0)
 L -HL7("COUNTING PROCESSES")
"RTN","HLOPROC",77,0)
 K ^TMP("HL7 ERRORS",$J)
"RTN","HLOPROC",78,0)
 ;
"RTN","HLOPROC",79,0)
 Q
"RTN","HLOPROC",80,0)
 ;
"RTN","HLOPROC",81,0)
ERROR ;error trap
"RTN","HLOPROC",82,0)
 ;
"RTN","HLOPROC",83,0)
 S $ETRAP="Q:$QUIT """" Q"
"RTN","HLOPROC",84,0)
 ;
"RTN","HLOPROC",85,0)
 ;while debugging always quit on error
"RTN","HLOPROC",86,0)
 I $G(^HLTMP("LOG ALL ERRORS"))!($ECODE["TOOMANYFILES")!($ECODE["EDITED") D  Q:$QUIT "" Q
"RTN","HLOPROC",87,0)
 .D ^%ZTER
"RTN","HLOPROC",88,0)
 .S:'$D(PROCNAME) PROCNAME=$G(^HL7TMP("HL7 PROCESS NAME",$J))
"RTN","HLOPROC",89,0)
 .D END
"RTN","HLOPROC",90,0)
 ;
"RTN","HLOPROC",91,0)
 ;a lot of errors of the same type may indicate an endless loop, so quit
"RTN","HLOPROC",92,0)
 ;to be on the safe side.  Decrement the process count.
"RTN","HLOPROC",93,0)
 N HOUR
"RTN","HLOPROC",94,0)
 S HOUR=$E($$NOW^XLFDT,1,10)
"RTN","HLOPROC",95,0)
 I $G(^TMP("HL7 ERRORS",$J,HOUR,$P($ECODE,",",2)))>30 D  Q:$QUIT "" Q
"RTN","HLOPROC",96,0)
 .;D ^%ZTER
"RTN","HLOPROC",97,0)
 .S:'$D(PROCNAME) PROCNAME=$G(^HL7TMP("HL7 PROCESS NAME",$J))
"RTN","HLOPROC",98,0)
 .D END
"RTN","HLOPROC",99,0)
 ;
"RTN","HLOPROC",100,0)
 ;can continue processing after logging the error
"RTN","HLOPROC",101,0)
 S ^TMP("HL7 ERRORS",$J,HOUR,$P($ECODE,",",2))=$G(^TMP("HL7 ERRORS",$J,HOUR,$P($ECODE,",",2)))+1
"RTN","HLOPROC",102,0)
 D ^%ZTER
"RTN","HLOPROC",103,0)
 D UNWIND^%ZTER
"RTN","HLOPROC",104,0)
 Q
"RTN","HLOPROC",105,0)
 ;
"RTN","HLOPROC",106,0)
GETPROC(PROCNAME,PROCESS) ;
"RTN","HLOPROC",107,0)
 ;using PROCNAME to find the entry in the HL7 Process Registry, returns the entry as a subscripted array in .PROCESS
"RTN","HLOPROC",108,0)
 ;
"RTN","HLOPROC",109,0)
 ;Output: Function returns 0 on failure, 1 on success
"RTN","HLOPROC",110,0)
 ;
"RTN","HLOPROC",111,0)
 N IEN,NODE
"RTN","HLOPROC",112,0)
 S IEN=$O(^HLD(779.3,"B",PROCNAME,0))
"RTN","HLOPROC",113,0)
 Q:'IEN 0
"RTN","HLOPROC",114,0)
 S PROCESS("NAME")=PROCNAME
"RTN","HLOPROC",115,0)
 S PROCESS("IEN")=IEN
"RTN","HLOPROC",116,0)
 S NODE=$G(^HLD(779.3,IEN,0))
"RTN","HLOPROC",117,0)
 S PROCESS("MINIMUM")=+$P(NODE,"^",3)
"RTN","HLOPROC",118,0)
 S PROCESS("MAXIMUM")=+$P(NODE,"^",4)
"RTN","HLOPROC",119,0)
 S PROCESS("HANG")=+$P(NODE,"^",7)
"RTN","HLOPROC",120,0)
 I 'PROCESS("HANG") S PROCESS("HANG")=1
"RTN","HLOPROC",121,0)
 S PROCESS("GET WORK")=$P(NODE,"^",8,9)
"RTN","HLOPROC",122,0)
 S PROCESS("DO WORK")=$P(NODE,"^",10,11)
"RTN","HLOPROC",123,0)
 S PROCESS("MAX TRIES")=$P(NODE,"^",12)
"RTN","HLOPROC",124,0)
 I 'PROCESS("MAX TRIES") S PROCESS("MAX TRIES")=999
"RTN","HLOPROC",125,0)
 S PROCESS("PERSISTENT")=+$P(NODE,"^",13)
"RTN","HLOPROC",126,0)
 S PROCESS("LINK")=$P(NODE,"^",14)
"RTN","HLOPROC",127,0)
 Q 1
"RTN","HLOPROC",128,0)
 ;
"RTN","HLOPROC",129,0)
GETWORK(PROCESS,WORK) ;
"RTN","HLOPROC",130,0)
 N RETURN,XECUTE
"RTN","HLOPROC",131,0)
 I PROCESS("LINK")]"" S WORK("LINK")=PROCESS("LINK")
"RTN","HLOPROC",132,0)
 S XECUTE="S RETURN=$$"_PROCESS("GET WORK")_"(.WORK)"
"RTN","HLOPROC",133,0)
 D
"RTN","HLOPROC",134,0)
 .N PROCESS
"RTN","HLOPROC",135,0)
 .X XECUTE
"RTN","HLOPROC",136,0)
 Q RETURN
"RTN","HLOPROC",137,0)
 ;
"RTN","HLOPROC",138,0)
DOWORK(PROCESS,WORK) ;
"RTN","HLOPROC",139,0)
 N XECUTE
"RTN","HLOPROC",140,0)
 M PARMS=WORK
"RTN","HLOPROC",141,0)
 S XECUTE="D "_PROCESS("DO WORK")_"(.WORK)"
"RTN","HLOPROC",142,0)
 D
"RTN","HLOPROC",143,0)
 .N PROCESS,HL7TRIES,PARMS,PROCNAME
"RTN","HLOPROC",144,0)
 .X XECUTE
"RTN","HLOPROC",145,0)
 M WORK=PARMS
"RTN","HLOPROC",146,0)
 Q
"RTN","HLOPROC",147,0)
 ;
"RTN","HLOPROC",148,0)
CHK4STOP(PROCESS,HL7TRIES) ;
"RTN","HLOPROC",149,0)
 ;Determines if the process should stop, returns 1 if yes, 0 if no
"RTN","HLOPROC",150,0)
 ;
"RTN","HLOPROC",151,0)
 Q:$$CHKSTOP 1
"RTN","HLOPROC",152,0)
 Q:'$P($G(^HLD(779.3,PROCESS("IEN"),0)),"^",2) 1
"RTN","HLOPROC",153,0)
 I $G(HL7TRIES)>(PROCESS("MAX TRIES")-1),PROCESS("MINIMUM")<$G(^HLC("HL7 PROCESS COUNTS","RUNNING",PROCESS("NAME"))) Q 1
"RTN","HLOPROC",154,0)
 Q:$G(^HLC("HL7 PROCESS COUNTS","RUNNING",PROCESS("NAME")))>PROCESS("MAXIMUM") 1
"RTN","HLOPROC",155,0)
 Q 0
"RTN","HLOPROC",156,0)
 ;
"RTN","HLOPROC",157,0)
CHKSTOP() ;has HL7 been requested to stop?
"RTN","HLOPROC",158,0)
 N RET
"RTN","HLOPROC",159,0)
 ;** P146 START CJM
"RTN","HLOPROC",160,0)
 ;Q '$P($G(^HLD(779.1,1,0)),"^",9)
"RTN","HLOPROC",161,0)
 S RET='$P($G(^HLD(779.1,1,0)),"^",9)
"RTN","HLOPROC",162,0)
ZB25 ;
"RTN","HLOPROC",163,0)
 Q RET
"RTN","HLOPROC",164,0)
 ;**P146 END CJM
"RTN","HLOPRS")
0^18^B29241759^B28621828
"RTN","HLOPRS",1,0)
HLOPRS ;IRMFO-ALB/CJM -RTNs for parsing messages;03/24/2004  14:43 ;05/12/2009
"RTN","HLOPRS",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**118,126,133,132,134,138,146**;Oct 13, 1995;Build 16
"RTN","HLOPRS",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOPRS",4,0)
 ;
"RTN","HLOPRS",5,0)
STARTMSG(MSG,IEN,HDR) ;
"RTN","HLOPRS",6,0)
 ;Description:  This function begins the parsing of the message, parsing
"RTN","HLOPRS",7,0)
 ;the header and returning the individual values in the array HDR().
"RTN","HLOPRS",8,0)
 ;Input: 
"RTN","HLOPRS",9,0)
 ;  IEN - The internal entry number of the message in file 778.
"RTN","HLOPRS",10,0)
 ;Output:
"RTN","HLOPRS",11,0)
 ;  Function returns 1 on success, 0 on failure.  Failure would indicate that the message was not found.
"RTN","HLOPRS",12,0)
 ;  MSG - (pass by reference, required) This array is used by the HL7 package to track the progress of parsing the message.  The application MUST NOT touch it!
"RTN","HLOPRS",13,0)
 ;  HDR (pass by reference, optional)   This array contains the results of parsing the message header.
"RTN","HLOPRS",14,0)
 K MSG,HDR
"RTN","HLOPRS",15,0)
 Q:'$G(IEN) 0
"RTN","HLOPRS",16,0)
 Q:'$$GETMSG^HLOMSG(IEN,.MSG) 0
"RTN","HLOPRS",17,0)
 M HDR=MSG("HDR")
"RTN","HLOPRS",18,0)
 Q:'$$PARSEHDR(.HDR) 0
"RTN","HLOPRS",19,0)
 M MSG("HDR")=HDR
"RTN","HLOPRS",20,0)
 Q 1
"RTN","HLOPRS",21,0)
 ;
"RTN","HLOPRS",22,0)
NEXTSEG(MSG,SEG) ;
"RTN","HLOPRS",23,0)
 ;Description:  Advances parsing to the next segment and returns the parsed values from that segment.
"RTN","HLOPRS",24,0)
 ;Input:
"RTN","HLOPRS",25,0)
 ;  MSG - (pass by reference, required) This array is used by the HL7 package to track the current position in the message.  The application MUST NOT touch it!
"RTN","HLOPRS",26,0)
 ;Output:
"RTN","HLOPRS",27,0)
 ;  Function  returns 1 on success, 0 if there are no more segments in this message.  For batch messages, a return value of 0 does not preclude the possibility that there are additional individual messages within the batch.
"RTN","HLOPRS",28,0)
 ;  MSG - (pass by reference, required)
"RTN","HLOPRS",29,0)
 ;  SEG - (pass by reference, required)  The segment is returned in this array.
"RTN","HLOPRS",30,0)
 ;
"RTN","HLOPRS",31,0)
 N TEMP,CODES
"RTN","HLOPRS",32,0)
 K SEG
"RTN","HLOPRS",33,0)
 I '$$HLNEXT^HLOMSG(.MSG,.TEMP) Q 0
"RTN","HLOPRS",34,0)
 S CODES=MSG("HDR","ENCODING CHARACTERS")
"RTN","HLOPRS",35,0)
 Q $$PARSE^HLOPRS1(MSG("HDR","FIELD SEPARATOR"),$E(CODES,2),$E(CODES,1),$E(CODES,4),$E(CODES,3),.TEMP,.SEG)
"RTN","HLOPRS",36,0)
 ;
"RTN","HLOPRS",37,0)
NEXTMSG(MSG,MSH) ;
"RTN","HLOPRS",38,0)
 ;Description:  Advances to the next message within the batch, with the MSH segment returned.
"RTN","HLOPRS",39,0)
 ;Input:
"RTN","HLOPRS",40,0)
 ; MSG (pass by reference, required) This array is used by the HL7 package to track the current position in the message.  The application MUST NOT touch it!
"RTN","HLOPRS",41,0)
 ;OUTPUT:
"RTN","HLOPRS",42,0)
 ;  Function returns 1 on success, 0 if there are no more messages
"RTN","HLOPRS",43,0)
 ;  MSG - (pass by reference)
"RTN","HLOPRS",44,0)
 ;  MSH - (pass by reference, required) Returns the parsed message header
"RTN","HLOPRS",45,0)
 ;
"RTN","HLOPRS",46,0)
 K MSH
"RTN","HLOPRS",47,0)
 N NODE
"RTN","HLOPRS",48,0)
 Q:'$$NEXTMSG^HLOMSG(.MSG,.MSH) 0
"RTN","HLOPRS",49,0)
 Q:'$$PARSEHDR(.MSH) 0
"RTN","HLOPRS",50,0)
 S MSG("BATCH","CURRENT MESSAGE","EVENT")=MSH("EVENT")
"RTN","HLOPRS",51,0)
 S MSG("BATCH","CURRENT MESSAGE","MESSAGE CONTROL ID")=MSH("MESSAGE CONTROL ID")
"RTN","HLOPRS",52,0)
 S NODE=$G(^HLB(MSG("IEN"),3,MSG("BATCH","CURRENT MESSAGE"),0))
"RTN","HLOPRS",53,0)
 S MSG("BATCH","CURRENT MESSAGE","ACK TO")=$P(NODE,"^",3)
"RTN","HLOPRS",54,0)
 S MSG("BATCH","CURRENT MESSAGE","ACK BY")=$P(NODE,"^",4)
"RTN","HLOPRS",55,0)
 ;
"RTN","HLOPRS",56,0)
 I MSG("BATCH","CURRENT MESSAGE","ACK TO")]"" S MSG("BATCH","CURRENT MESSAGE","ACK TO IEN")=$$ACKTOIEN^HLOMSG1(MSH("MESSAGE CONTROL ID"),MSG("BATCH","CURRENT MESSAGE","ACK TO"))
"RTN","HLOPRS",57,0)
 I MSG("BATCH","CURRENT MESSAGE","ACK BY")]"" S MSG("BATCH","CURRENT MESSAGE","ACK BY IEN")=$$ACKBYIEN^HLOMSG1(MSH("MESSAGE CONTROL ID"),MSG("BATCH","CURRENT MESSAGE","ACK BY"))
"RTN","HLOPRS",58,0)
 ;
"RTN","HLOPRS",59,0)
 Q 1
"RTN","HLOPRS",60,0)
 ;
"RTN","HLOPRS",61,0)
PARSEHDR(HDR) ;
"RTN","HLOPRS",62,0)
 ;Parses the segment (HDR, pass by reference) into the HDR() array using meaningful subscripts.
"RTN","HLOPRS",63,0)
 ;Input:
"RTN","HLOPRS",64,0)
 ;  HDR (pass by reference, required) contains the segment in the format HDR(1),HDR(2), etc..
"RTN","HLOPRS",65,0)
 ;Output:
"RTN","HLOPRS",66,0)
 ;  HDR (pass by reference, required) This array will contain all the individual values.  Also will contain HDR(1) with components 1-6 and HDR(2) with components 1-end
"RTN","HLOPRS",67,0)
 ;  Function - returns 1 if the segment is indeed an MSH or BHS segment, 0 otherwise
"RTN","HLOPRS",68,0)
 ;
"RTN","HLOPRS",69,0)
ZB25 ;
"RTN","HLOPRS",70,0)
 N VALUE,FS,CS,REP,SUBCOMP,ESCAPE
"RTN","HLOPRS",71,0)
 S VALUE=$E(HDR(1),1,3)
"RTN","HLOPRS",72,0)
 I VALUE'="MSH",VALUE'="BHS" Q 0
"RTN","HLOPRS",73,0)
 S HDR("SEGMENT TYPE")=VALUE
"RTN","HLOPRS",74,0)
 S FS=$E(HDR(1),4)
"RTN","HLOPRS",75,0)
 Q:FS="" 0
"RTN","HLOPRS",76,0)
 S HDR("ENCODING CHARACTERS")=$P(HDR(1),FS,2)
"RTN","HLOPRS",77,0)
 S CS=$E(HDR("ENCODING CHARACTERS"),1)
"RTN","HLOPRS",78,0)
 S REP=$E(HDR("ENCODING CHARACTERS"),2)
"RTN","HLOPRS",79,0)
 S ESCAPE=$E(HDR("ENCODING CHARACTERS"),3)
"RTN","HLOPRS",80,0)
 S SUBCOMP=$E(HDR("ENCODING CHARACTERS"),4)
"RTN","HLOPRS",81,0)
 Q:REP="" 0
"RTN","HLOPRS",82,0)
 S HDR("FIELD SEPARATOR")=FS
"RTN","HLOPRS",83,0)
 S HDR("COMPONENT SEPARATOR")=CS
"RTN","HLOPRS",84,0)
 S HDR("REPETITION SEPARATOR")=REP
"RTN","HLOPRS",85,0)
 S HDR("ESCAPE CHARACTER")=ESCAPE
"RTN","HLOPRS",86,0)
 S HDR("SUBCOMPONENT SEPARATOR")=SUBCOMP
"RTN","HLOPRS",87,0)
 S HDR("SENDING APPLICATION")=$$DESCAPE($P($P(HDR(1),FS,3),CS))
"RTN","HLOPRS",88,0)
 S VALUE=$P(HDR(1),FS,4)
"RTN","HLOPRS",89,0)
 S HDR("SENDING FACILITY",1)=$$DESCAPE($P(VALUE,CS))
"RTN","HLOPRS",90,0)
 S HDR("SENDING FACILITY",2)=$$DESCAPE($P(VALUE,CS,2))
"RTN","HLOPRS",91,0)
 S HDR("SENDING FACILITY",3)=$$DESCAPE($P(VALUE,CS,3))
"RTN","HLOPRS",92,0)
 S HDR("RECEIVING APPLICATION")=$$DESCAPE($P($P(HDR(1),FS,5),CS))
"RTN","HLOPRS",93,0)
 S VALUE=$P(HDR(1),FS,6)
"RTN","HLOPRS",94,0)
 S HDR("RECEIVING FACILITY",1)=$$DESCAPE($P(VALUE,CS))
"RTN","HLOPRS",95,0)
 S HDR("RECEIVING FACILITY",2)=$$DESCAPE($P(VALUE,CS,2))
"RTN","HLOPRS",96,0)
 S HDR("RECEIVING FACILITY",3)=$$DESCAPE($P(VALUE,CS,3))
"RTN","HLOPRS",97,0)
 S HDR("DT/TM OF MESSAGE")=$$FMDATE^HLFNC($$DESCAPE($P($P(HDR(2),FS,2),CS)))
"RTN","HLOPRS",98,0)
 S HDR("SECURITY")=$$DESCAPE($P($P(HDR(2),FS,3),CS))
"RTN","HLOPRS",99,0)
 ;
"RTN","HLOPRS",100,0)
 I HDR("SEGMENT TYPE")="MSH" D
"RTN","HLOPRS",101,0)
 .S VALUE=$P(HDR(2),FS,4)
"RTN","HLOPRS",102,0)
 .S HDR("MESSAGE TYPE")=$P(VALUE,CS)
"RTN","HLOPRS",103,0)
 .S HDR("EVENT")=$P(VALUE,CS,2)
"RTN","HLOPRS",104,0)
 .S HDR("MESSAGE STRUCTURE")=$$DESCAPE($P(VALUE,CS,3))
"RTN","HLOPRS",105,0)
 .S HDR("MESSAGE CONTROL ID")=$$DESCAPE($P($P(HDR(2),FS,5),CS))
"RTN","HLOPRS",106,0)
 .S VALUE=$P(HDR(2),FS,6)
"RTN","HLOPRS",107,0)
 .S HDR("PROCESSING ID")=$P(VALUE,CS)
"RTN","HLOPRS",108,0)
 .S HDR("PROCESSING MODE")=$$DESCAPE($P(VALUE,CS,2))
"RTN","HLOPRS",109,0)
 .S HDR("VERSION")=$$DESCAPE($P($P(HDR(2),FS,7),CS))
"RTN","HLOPRS",110,0)
 .S HDR("CONTINUATION POINTER")=$$DESCAPE($P($P(HDR(2),FS,9),CS))
"RTN","HLOPRS",111,0)
 .S HDR("ACCEPT ACK TYPE")=$P($P(HDR(2),FS,10),CS)
"RTN","HLOPRS",112,0)
 .S HDR("APP ACK TYPE")=$P($P(HDR(2),FS,11),CS)
"RTN","HLOPRS",113,0)
 .S HDR("COUNTRY")=$$DESCAPE($P($P(HDR(2),FS,12),CS))
"RTN","HLOPRS",114,0)
 ;
"RTN","HLOPRS",115,0)
 I HDR("SEGMENT TYPE")="BHS" D
"RTN","HLOPRS",116,0)
 .S VALUE=$P(HDR(2),FS,4)
"RTN","HLOPRS",117,0)
 .S HDR("BATCH NAME/ID/TYPE")=$$DESCAPE(VALUE)
"RTN","HLOPRS",118,0)
 .S HDR("PROCESSING ID")=$E($P(VALUE,"PROCESSING ID=",2),1)
"RTN","HLOPRS",119,0)
 .S HDR("ACCEPT ACK TYPE")=$E($P(VALUE,"ACCEPT ACK TYPE=",2),1,2)
"RTN","HLOPRS",120,0)
 .S HDR("APP ACK TYPE")=$E($P(VALUE,"APP ACK TYPE=",2),1,2)
"RTN","HLOPRS",121,0)
 .S HDR("BATCH COMMENT")=$$DESCAPE($P(HDR(2),FS,5))
"RTN","HLOPRS",122,0)
 .S HDR("BATCH CONTROL ID")=$$DESCAPE($P($P(HDR(2),FS,6),CS))
"RTN","HLOPRS",123,0)
 .S HDR("REFERENCE BATCH CONTROL ID")=$$DESCAPE($P($P(HDR(2),FS,7),CS))
"RTN","HLOPRS",124,0)
 .;
"RTN","HLOPRS",125,0)
ZB26 ;
"RTN","HLOPRS",126,0)
 Q 1
"RTN","HLOPRS",127,0)
 ;
"RTN","HLOPRS",128,0)
DESCAPE(VALUE) ;
"RTN","HLOPRS",129,0)
 Q $$DESCAPE^HLOPRS1(VALUE,FS,CS,SUBCOMP,REP,ESCAPE)
"RTN","HLOPRS",130,0)
 ;
"RTN","HLOPRS",131,0)
GET(SEG,FIELD,COMP,SUBCOMP,REP) ;
"RTN","HLOPRS",132,0)
 ;This function gets a specified value from a segment that was parsed by
"RTN","HLOPRS",133,0)
 ;$$NEXTSEG. The FIELD,COMP,SUBCOMP,REP parameters are optional - if not
"RTN","HLOPRS",134,0)
 ;specified, they default to 1.
"RTN","HLOPRS",135,0)
 ;  Example:
"RTN","HLOPRS",136,0)
 ;    $$GET^HLOPRS(.SEG,1) will return the value of the first field, first
"RTN","HLOPRS",137,0)
 ;  component, first subcomponent, in the first occurrence of field #1.  
"RTN","HLOPRS",138,0)
 ;Input:
"RTN","HLOPRS",139,0)
 ;SEG - (required, pass by reference) - this is the array where the parsed segment was placed by $$NEXTSEG
"RTN","HLOPRS",140,0)
 ;FIELD - the sequence # of the field (optional, defaults to 1)
"RTN","HLOPRS",141,0)
 ;COMP - the # of the component (optional, defaults to 1)
"RTN","HLOPRS",142,0)
 ;SUBCOMP - the # of the subcomponent (optional, defaults to 1)
"RTN","HLOPRS",143,0)
 ;REP - the occurrence# (optional, defaults to 1)  For a non-repeating field, the occurrence # need not be provided, because it would be 1.
"RTN","HLOPRS",144,0)
 ;Output:
"RTN","HLOPRS",145,0)
 ;  Function returns the requested value on success, "" if not valued.
"RTN","HLOPRS",146,0)
 ;
"RTN","HLOPRS",147,0)
 ;allow the segment type to be obtained via field #0 (shorthand)
"RTN","HLOPRS",148,0)
 I $D(FIELD),$G(FIELD)=0 Q $G(SEG("SEGMENT TYPE"))
"RTN","HLOPRS",149,0)
 S:'$G(FIELD) FIELD=1
"RTN","HLOPRS",150,0)
 ;
"RTN","HLOPRS",151,0)
 ;for MSH or BHS, SEQ#1 is the  field separator
"RTN","HLOPRS",152,0)
 I FIELD=1,$G(SEG("SEGMENT TYPE"))="MSH"!($G(SEG("SEGMENT TYPE"))="BHS"),$G(REP)<2,$G(COMP)<2,$G(SUBCOMP)<2 Q SEG("FIELD SEPARATOR")
"RTN","HLOPRS",153,0)
 I FIELD=1,$G(SEG("SEGMENT TYPE"))="MSH"!($G(SEG("SEGMENT TYPE"))="BHS") Q ""
"RTN","HLOPRS",154,0)
 ;
"RTN","HLOPRS",155,0)
 S:'$G(COMP) COMP=1
"RTN","HLOPRS",156,0)
 S:'$G(SUBCOMP) SUBCOMP=1
"RTN","HLOPRS",157,0)
 S:'$G(REP) REP=1
"RTN","HLOPRS",158,0)
 Q $G(SEG(FIELD,REP,COMP,SUBCOMP))
"RTN","HLOPRS",159,0)
 ;
"RTN","HLOPRS",160,0)
 ;**P146 START CJM
"RTN","HLOPRS",161,0)
MSGID(IEN) ;
"RTN","HLOPRS",162,0)
 ;Description:
"RTN","HLOPRS",163,0)
 ;        Given the IEN, this function returns the message id.
"RTN","HLOPRS",164,0)
 ;Input:  IEN=record number, file #778
"RTN","HLOPRS",165,0)
 ;Output: function returns the message id on success, "" on failure
"RTN","HLOPRS",166,0)
 ;
"RTN","HLOPRS",167,0)
 Q $P($G(^HLB(IEN,0)),"^")
"RTN","HLOPRS",168,0)
 ;**P146 END CJM
"RTN","HLOPRS2")
0^19^B34053092^B25178316
"RTN","HLOPRS2",1,0)
HLOPRS2 ;ALB/CJM-HL7 - Developer API's for parsing messages(continued) ;05/12/2009
"RTN","HLOPRS2",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**131,146**;Oct 13, 1995;Build 16
"RTN","HLOPRS2",3,0)
 ;
"RTN","HLOPRS2",4,0)
GETTS(SEG,VALUE,FIELD,COMP,REP) ;
"RTN","HLOPRS2",5,0)
 ;Gets a segment value that is a timestamp in HL7 format and converts it 
"RTN","HLOPRS2",6,0)
 ;to FileMan format. IF the segment value included the timezone, it is
"RTN","HLOPRS2",7,0)
 ;the timestamp is converted to local time.
"RTN","HLOPRS2",8,0)
 ;
"RTN","HLOPRS2",9,0)
 ;IF the component is specified, then the component is parsed for data type rather than at the higher field level.
"RTN","HLOPRS2",10,0)
 ;
"RTN","HLOPRS2",11,0)
 ;
"RTN","HLOPRS2",12,0)
 ;Input:
"RTN","HLOPRS2",13,0)
 ;  SEG - (required, pass by reference) The array returned by a  call to $$NEXTSEG^HLOPRS.
"RTN","HLOPRS2",14,0)
 ;  FIELD - The sequence # of the field.
"RTN","HLOPRS2",15,0)
 ;  COMP (optional) If specified, the data type is parsed as a component  value.
"RTN","HLOPRS2",16,0)
 ;  REP - The occurrence # (optional, defaults to 1).  For a non-repeating fields, this parameter is not necessary.
"RTN","HLOPRS2",17,0)
 ;Output:
"RTN","HLOPRS2",18,0)
 ;  VALUE  (pass-by-reference) The date/time in FileMan format.
"RTN","HLOPRS2",19,0)
 ;  VALUE("PRECISION") Expected values are:
"RTN","HLOPRS2",20,0)
 ;           "S" - second
"RTN","HLOPRS2",21,0)
 ;           "M" - minute
"RTN","HLOPRS2",22,0)
 ;           "H" - hour
"RTN","HLOPRS2",23,0)
 ;           "D" - day
"RTN","HLOPRS2",24,0)
 ;           "L" - month
"RTN","HLOPRS2",25,0)
 ;           "Y" - year
"RTN","HLOPRS2",26,0)
 ;           "" - precision not specified
"RTN","HLOPRS2",27,0)
 ;   Note:  FM does not allow greater precision than seconds, so this API will round off to the second.
"RTN","HLOPRS2",28,0)
 ;
"RTN","HLOPRS2",29,0)
 N TIME,PREC,VAR
"RTN","HLOPRS2",30,0)
 Q:'$G(FIELD)
"RTN","HLOPRS2",31,0)
 I '$G(COMP) D
"RTN","HLOPRS2",32,0)
 .S VAR="COMP",SUB=1
"RTN","HLOPRS2",33,0)
 E  D
"RTN","HLOPRS2",34,0)
 .S VAR="SUB"
"RTN","HLOPRS2",35,0)
 S:'$G(REP) REP=1
"RTN","HLOPRS2",36,0)
 S @VAR=1,TIME=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS2",37,0)
 S @VAR=2,PREC=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS2",38,0)
 S VALUE=$$HL7TFM^XLFDT(TIME)
"RTN","HLOPRS2",39,0)
 I '$L(PREC) D
"RTN","HLOPRS2",40,0)
 .I $L(+TIME)>12 S PREC="S" Q
"RTN","HLOPRS2",41,0)
 .I $L(+TIME)>10 S PREC="M" Q
"RTN","HLOPRS2",42,0)
 .I $L(+TIME)>8 S PREC="H" Q
"RTN","HLOPRS2",43,0)
 .I $L(+TIME)>6 S PREC="D" Q
"RTN","HLOPRS2",44,0)
 .I $L(+TIME)>4 S PREC="L" Q
"RTN","HLOPRS2",45,0)
 .I $L(+TIME)=4 S PREC="Y" Q
"RTN","HLOPRS2",46,0)
 S VALUE("PRECISION")=PREC
"RTN","HLOPRS2",47,0)
 Q
"RTN","HLOPRS2",48,0)
 ;
"RTN","HLOPRS2",49,0)
GETDT(SEG,VALUE,FIELD,COMP,REP) ;
"RTN","HLOPRS2",50,0)
 ;Gets a segment value that is a date in HL7 format and converts it to FileMan format.
"RTN","HLOPRS2",51,0)
 ;IF the component is specified, then the component is parsed for data type rather than at the higher field level.
"RTN","HLOPRS2",52,0)
 ;
"RTN","HLOPRS2",53,0)
 ;Input:
"RTN","HLOPRS2",54,0)
 ;  SEG - (required, pass by reference) The array returned by a  call to $$NEXTSEG^HLOPRS.
"RTN","HLOPRS2",55,0)
 ;  FIELD - The sequence # of the field.
"RTN","HLOPRS2",56,0)
 ;  COMP (optional) If specified, the data type is parsed as a component  value.
"RTN","HLOPRS2",57,0)
 ;  REP - the occurrence# (optional, defaults to 1)  For a non-repeating fields, this parameter is not necessary.
"RTN","HLOPRS2",58,0)
 ;Output:
"RTN","HLOPRS2",59,0)
 ;  VALUE  (pass-by-reference) The date/time in FileMan format.
"RTN","HLOPRS2",60,0)
 ;  VALUE("PRECISION") - Expected values are:
"RTN","HLOPRS2",61,0)
 ;           "S" - second (not valid for DT)
"RTN","HLOPRS2",62,0)
 ;           "M" - minute (not valid for DT)
"RTN","HLOPRS2",63,0)
 ;           "H" - hour (not valid for DT)
"RTN","HLOPRS2",64,0)
 ;           "D" - day
"RTN","HLOPRS2",65,0)
 ;           "L" - month
"RTN","HLOPRS2",66,0)
 ;           "Y" - year
"RTN","HLOPRS2",67,0)
 ;           "" - not specified
"RTN","HLOPRS2",68,0)
 ;
"RTN","HLOPRS2",69,0)
 N TIME,PREC,VAR
"RTN","HLOPRS2",70,0)
 Q:'$G(FIELD)
"RTN","HLOPRS2",71,0)
 I '$G(COMP) D
"RTN","HLOPRS2",72,0)
 .S VAR="COMP",SUB=1
"RTN","HLOPRS2",73,0)
 E  D
"RTN","HLOPRS2",74,0)
 .S VAR="SUB"
"RTN","HLOPRS2",75,0)
 S:'$G(REP) REP=1
"RTN","HLOPRS2",76,0)
 S @VAR=1,TIME=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS2",77,0)
 S VALUE=$$HL7TFM^XLFDT(TIME)
"RTN","HLOPRS2",78,0)
 S PREC=""
"RTN","HLOPRS2",79,0)
 D
"RTN","HLOPRS2",80,0)
 .I $L(+TIME)>12 S PREC="S" Q
"RTN","HLOPRS2",81,0)
 .I $L(+TIME)>10 S PREC="M" Q
"RTN","HLOPRS2",82,0)
 .I $L(+TIME)>8 S PREC="H" Q
"RTN","HLOPRS2",83,0)
 .I $L(+TIME)>6 S PREC="D" Q
"RTN","HLOPRS2",84,0)
 .I $L(+TIME)>4 S PREC="L" Q
"RTN","HLOPRS2",85,0)
 .I $L(+TIME)=4 S PREC="Y" Q
"RTN","HLOPRS2",86,0)
 S VALUE("PRECISION")=PREC
"RTN","HLOPRS2",87,0)
 Q
"RTN","HLOPRS2",88,0)
 ;
"RTN","HLOPRS2",89,0)
GETCE(SEG,VALUE,FIELD,COMP,REP) ;
"RTN","HLOPRS2",90,0)
 ;Gets an CE data type(Coded Element, HL7 Section Reference 2.9.8) from the specified field.
"RTN","HLOPRS2",91,0)
 ;IF the component is specified, then the component is parsed for data type rather than at the higher field level.
"RTN","HLOPRS2",92,0)
 ;
"RTN","HLOPRS2",93,0)
 ;Input:
"RTN","HLOPRS2",94,0)
 ;  SEG - (required, pass by reference) The array returned by a call to NEXTSEG^HLOPRS.
"RTN","HLOPRS2",95,0)
 ;  FIELD (required) The sequence # of the field.
"RTN","HLOPRS2",96,0)
 ;  COMP (optional) If specified, the data type is parsed as a component  value.
"RTN","HLOPRS2",97,0)
 ;  REP - The occurrence # (optional, defaults to 1).  For a non-repeating fields, this parameter is not necessary.
"RTN","HLOPRS2",98,0)
 ;Output:
"RTN","HLOPRS2",99,0)
 ;  VALUE  (required, pass-by-reference) These subscripts are returned:
"RTN","HLOPRS2",100,0)
 ;    "ID" - the identifier
"RTN","HLOPRS2",101,0)
 ;    "TEXT" - 
"RTN","HLOPRS2",102,0)
 ;    "SYSTEM" - name of the code system
"RTN","HLOPRS2",103,0)
 ;    "ALTERNATE ID" - alternate identifier
"RTN","HLOPRS2",104,0)
 ;    "ALTERNATE TEXT"
"RTN","HLOPRS2",105,0)
 ;    "ALTERNATE SYSTEM" - name of the alternate coding system
"RTN","HLOPRS2",106,0)
 ;
"RTN","HLOPRS2",107,0)
 N SUB,VAR
"RTN","HLOPRS2",108,0)
 Q:'$G(FIELD)
"RTN","HLOPRS2",109,0)
 S:'$G(REP) REP=1
"RTN","HLOPRS2",110,0)
 I '$G(COMP) D
"RTN","HLOPRS2",111,0)
 .S VAR="COMP",SUB=1
"RTN","HLOPRS2",112,0)
 E  D
"RTN","HLOPRS2",113,0)
 .S VAR="SUB"
"RTN","HLOPRS2",114,0)
 S @VAR=1,VALUE("ID")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS2",115,0)
 S @VAR=2,VALUE("TEXT")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS2",116,0)
 S @VAR=3,VALUE("SYSTEM")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS2",117,0)
 S @VAR=4,VALUE("ALTERNATE ID")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS2",118,0)
 S @VAR=5,VALUE("ALTERNATE TEXT")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS2",119,0)
 S @VAR=6,VALUE("ALTERNATE SYSTEM")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS2",120,0)
 Q
"RTN","HLOPRS2",121,0)
 ;
"RTN","HLOPRS2",122,0)
GETHD(SEG,VALUE,FIELD,COMP,REP) ;
"RTN","HLOPRS2",123,0)
 ;Gets an HD data type (Hierarchic Designator, HL7 Section Reference 2.9.21) from the specified field.
"RTN","HLOPRS2",124,0)
 ;IF the component is specified, then the component is parsed for data type rather than at the higher field level.
"RTN","HLOPRS2",125,0)
 ;
"RTN","HLOPRS2",126,0)
 ;Input:
"RTN","HLOPRS2",127,0)
 ;  SEG - (required, pass by reference) The array returned by a call to NEXTSEG^HLOPRS.
"RTN","HLOPRS2",128,0)
 ;  FIELD (required) The sequence # of the field.
"RTN","HLOPRS2",129,0)
 ;  COMP (optional) If specified, the data type is parsed as a component  value.
"RTN","HLOPRS2",130,0)
 ;  REP - The occurrence # (optional, defaults to 1).  For a non-repeating fields, this parameter is not necessary.
"RTN","HLOPRS2",131,0)
 ;Output:
"RTN","HLOPRS2",132,0)
 ;  VALUE  (required, pass-by-reference) These subscripts are returned:
"RTN","HLOPRS2",133,0)
 ;    "NAMESPACE ID"
"RTN","HLOPRS2",134,0)
 ;    "UNIVERSAL ID"
"RTN","HLOPRS2",135,0)
 ;    "UNIVERSAL ID TYPE"
"RTN","HLOPRS2",136,0)
 ;
"RTN","HLOPRS2",137,0)
 N SUB,VAR
"RTN","HLOPRS2",138,0)
 Q:'$G(FIELD)
"RTN","HLOPRS2",139,0)
 S:'$G(REP) REP=1
"RTN","HLOPRS2",140,0)
 I '$G(COMP) D
"RTN","HLOPRS2",141,0)
 .S VAR="COMP",SUB=1
"RTN","HLOPRS2",142,0)
 E  D
"RTN","HLOPRS2",143,0)
 .S VAR="SUB"
"RTN","HLOPRS2",144,0)
 S @VAR=1,VALUE("NAMESPACE ID")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS2",145,0)
 S @VAR=2,VALUE("UNIVERSAL ID")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS2",146,0)
 S @VAR=3,VALUE("UNIVERSAL ID TYPE")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS2",147,0)
 Q
"RTN","HLOPRS2",148,0)
 ;
"RTN","HLOPRS2",149,0)
GETCNE(SEG,VALUE,FIELD,COMP,REP) ;
"RTN","HLOPRS2",150,0)
 ;Gets an CNE data type (Coded With No Exceptions, HL7 Section Reference 2.9.8) from the specified field.
"RTN","HLOPRS2",151,0)
 ;IF the component is specified, then the component is parsed for data type rather than at the higher field level.
"RTN","HLOPRS2",152,0)
 ;
"RTN","HLOPRS2",153,0)
 ;Input:
"RTN","HLOPRS2",154,0)
 ;  SEG - (required, pass by reference) The array returned by a call to NEXTSEG^HLOPRS.
"RTN","HLOPRS2",155,0)
 ;  FIELD (required) The sequence # of the field.
"RTN","HLOPRS2",156,0)
 ;  COMP (optional) If specified, the data type is parsed as a component  value.
"RTN","HLOPRS2",157,0)
 ;  REP - The occurrence # (optional, defaults to 1).  For a non-repeating fields, this parameter is not necessary.
"RTN","HLOPRS2",158,0)
 ;Output:
"RTN","HLOPRS2",159,0)
 ;  VALUE  (required, pass-by-reference) These subscripts are returned:
"RTN","HLOPRS2",160,0)
 ;    "ID" - the identifier
"RTN","HLOPRS2",161,0)
 ;    "TEXT" - 
"RTN","HLOPRS2",162,0)
 ;    "SYSTEM" - name of the code system
"RTN","HLOPRS2",163,0)
 ;    "ALTERNATE ID" - alternate identifier
"RTN","HLOPRS2",164,0)
 ;    "ALTERNATE TEXT"
"RTN","HLOPRS2",165,0)
 ;    "ALTERNATE SYSTEM" - name of the alternate coding system
"RTN","HLOPRS2",166,0)
 ;    "SYSTEM VERSION" - version ID of the coding system
"RTN","HLOPRS2",167,0)
 ;    "ALTERNATE SYSTEM VERSION" - version ID of the alternate coding system
"RTN","HLOPRS2",168,0)
 ;    "ORIGINAL TEXT"
"RTN","HLOPRS2",169,0)
 ;
"RTN","HLOPRS2",170,0)
 D GETCODE^HLOPRS1(.SEG,.VALUE,.FIELD,.COMP,.REP)
"RTN","HLOPRS2",171,0)
 Q
"RTN","HLOPRS2",172,0)
 ;
"RTN","HLOPRS2",173,0)
GETCWE(SEG,VALUE,FIELD,COMP,REP) ;
"RTN","HLOPRS2",174,0)
 ;Gets an CWE data type (Coded With Exceptions, HL7 Section Reference 2.9.11) from the specified field.
"RTN","HLOPRS2",175,0)
 ;IF the component is specified, then the component is parsed for the data type rather than at the higher field level.
"RTN","HLOPRS2",176,0)
 ;
"RTN","HLOPRS2",177,0)
 ;Input:
"RTN","HLOPRS2",178,0)
 ;  SEG - (required, pass by reference) The array returned by a call to NEXTSEG^HLOPRS.
"RTN","HLOPRS2",179,0)
 ;  FIELD (required) The sequence # of the field.
"RTN","HLOPRS2",180,0)
 ;  COMP (optional) If specified, the data type is parsed as a component  value.
"RTN","HLOPRS2",181,0)
 ;  REP - The occurrence # (optional, defaults to 1).  For a non-repeating fields, this parameter is not necessary.
"RTN","HLOPRS2",182,0)
 ;Output:
"RTN","HLOPRS2",183,0)
 ;  VALUE  (required, pass-by-reference) These subscripts are returned:
"RTN","HLOPRS2",184,0)
 ;    "ID" - the identifier
"RTN","HLOPRS2",185,0)
 ;    "TEXT" - 
"RTN","HLOPRS2",186,0)
 ;    "SYSTEM" - name of the code system
"RTN","HLOPRS2",187,0)
 ;    "ALTERNATE ID" - alternate identifier
"RTN","HLOPRS2",188,0)
 ;    "ALTERNATE TEXT"
"RTN","HLOPRS2",189,0)
 ;    "ALTERNATE SYSTEM" - name of the alternate coding system
"RTN","HLOPRS2",190,0)
 ;    "SYSTEM VERSION" - version ID of the coding system
"RTN","HLOPRS2",191,0)
 ;    "ALTERNATE SYSTEM VERSION" - version ID of the alternate coding system
"RTN","HLOPRS2",192,0)
 ;    "ORIGINAL TEXT"
"RTN","HLOPRS2",193,0)
 D GETCODE^HLOPRS1(.SEG,.VALUE,.FIELD,.COMP,.REP)
"RTN","HLOPRS2",194,0)
 Q
"RTN","HLOPRS2",195,0)
 ;
"RTN","HLOPRS2",196,0)
GETAD(SEG,VALUE,FIELD,COMP,REP) ;
"RTN","HLOPRS2",197,0)
 ;Gets an AD data type (Address, HL7 Section Reference 2.9.1) from the specified field. It can also be used to get the 1st 8 components of the XAD (Extended Address) data type.
"RTN","HLOPRS2",198,0)
 ;IF the component is specified, then the component is parsed for the address rather than at the higher field level.
"RTN","HLOPRS2",199,0)
 ;
"RTN","HLOPRS2",200,0)
 ;Input:
"RTN","HLOPRS2",201,0)
 ;  SEG - (required, pass by reference) The array returned by a call to NEXTSEG^HLOPRS.
"RTN","HLOPRS2",202,0)
 ;  FIELD (required) The sequence # of the field.
"RTN","HLOPRS2",203,0)
 ;  COMP (optional) If specified, the data type is parsed as a component  value.
"RTN","HLOPRS2",204,0)
 ;  REP - The occurrence # (optional, defaults to 1).  For a non-repeating fields, this parameter is not necessary.
"RTN","HLOPRS2",205,0)
 ;Output:
"RTN","HLOPRS2",206,0)
 ;  VALUE  (required, pass-by-reference) These subscripts are returned:
"RTN","HLOPRS2",207,0)
 ;    "STREET1" -street address
"RTN","HLOPRS2",208,0)
 ;    "STREET2" - other designation
"RTN","HLOPRS2",209,0)
 ;    "CITY"
"RTN","HLOPRS2",210,0)
 ;    "STATE" - state or province
"RTN","HLOPRS2",211,0)
 ;    "ZIP" - zip or postal code
"RTN","HLOPRS2",212,0)
 ;    "COUNTRY"
"RTN","HLOPRS2",213,0)
 ;    "TYPE"  - address type
"RTN","HLOPRS2",214,0)
 ;    "OTHER" - other geographic designation
"RTN","HLOPRS2",215,0)
 ;
"RTN","HLOPRS2",216,0)
 N SUB,VAR
"RTN","HLOPRS2",217,0)
 Q:'$G(FIELD)
"RTN","HLOPRS2",218,0)
 I '$G(COMP) D
"RTN","HLOPRS2",219,0)
 .S VAR="COMP",SUB=1
"RTN","HLOPRS2",220,0)
 E  D
"RTN","HLOPRS2",221,0)
 .S VAR="SUB"
"RTN","HLOPRS2",222,0)
 S:'$G(REP) REP=1
"RTN","HLOPRS2",223,0)
 S @VAR=1,VALUE("STREET1")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS2",224,0)
 S @VAR=2,VALUE("STREET2")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS2",225,0)
 S @VAR=3,VALUE("CITY")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS2",226,0)
 S @VAR=4,VALUE("STATE")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS2",227,0)
 S @VAR=5,VALUE("ZIP")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS2",228,0)
 S @VAR=6,VALUE("COUNTRY")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS2",229,0)
 S @VAR=7,VALUE("TYPE")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS2",230,0)
 S @VAR=8,VALUE("OTHER")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS2",231,0)
 Q
"RTN","HLOPRS2",232,0)
 ;
"RTN","HLOPRS2",233,0)
 ;**P146 START CJM
"RTN","HLOPRS2",234,0)
GETXPN(SEG,VALUE,FIELD,COMP,REP) ;
"RTN","HLOPRS2",235,0)
 ;Gets an XPN data type (Extended Persons Name, HL7 Section Reference 2.9.1) from the specified field.
"RTN","HLOPRS2",236,0)
 ;IF the component is specified, then the component is parsed for the address rather than at the higher field level.
"RTN","HLOPRS2",237,0)
 ;
"RTN","HLOPRS2",238,0)
 ;Input:
"RTN","HLOPRS2",239,0)
 ;  SEG - (required, pass by reference) The array returned by a call to NEXTSEG^HLOPRS.
"RTN","HLOPRS2",240,0)
 ;  FIELD (required) The sequence # of the field.
"RTN","HLOPRS2",241,0)
 ;  COMP (optional) If specified, the data type is parsed as a component  value.
"RTN","HLOPRS2",242,0)
 ;  REP - The occurrence # (optional, defaults to 1).  For a non-repeating fields, this parameter is not necessary.
"RTN","HLOPRS2",243,0)
 ;Output:
"RTN","HLOPRS2",244,0)
 ;  VALUE  (required, pass-by-reference) These subscripts are returned:
"RTN","HLOPRS2",245,0)
 ;    "FAMILY"
"RTN","HLOPRS2",246,0)
 ;    "GIVEN" first name
"RTN","HLOPRS2",247,0)
 ;    "SECOND" second and further names or initials
"RTN","HLOPRS2",248,0)
 ;    "SUFFIX" (e.g., JR)
"RTN","HLOPRS2",249,0)
 ;    "PREFIX" (e.g., DR)
"RTN","HLOPRS2",250,0)
 ;    "DEGREE" (e.g., MD)
"RTN","HLOPRS2",251,0)
 ;
"RTN","HLOPRS2",252,0)
 N SUB,VAR
"RTN","HLOPRS2",253,0)
 Q:'$G(FIELD)
"RTN","HLOPRS2",254,0)
 I '$G(COMP) D
"RTN","HLOPRS2",255,0)
 .S VAR="COMP",SUB=1
"RTN","HLOPRS2",256,0)
 E  D
"RTN","HLOPRS2",257,0)
 .S VAR="SUB"
"RTN","HLOPRS2",258,0)
 S:'$G(REP) REP=1
"RTN","HLOPRS2",259,0)
 S @VAR=1,VALUE("FAMILY")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS2",260,0)
 S @VAR=2,VALUE("GIVEN")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS2",261,0)
 S @VAR=3,VALUE("SECOND")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS2",262,0)
 S @VAR=4,VALUE("SUFFIX")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS2",263,0)
 S @VAR=5,VALUE("PREFIX")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS2",264,0)
 S @VAR=6,VALUE("DEGREE")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS2",265,0)
 Q
"RTN","HLOPRS2",266,0)
 ;** P146 END CJM
"RTN","HLOPRSR2")
0^33^B77677817^B77395727
"RTN","HLOPRSR2",1,0)
HLOPRSR2 ;ALB/CJM - Visual Parser 12 JUN 1997 10:00 am ;08/17/2009
"RTN","HLOPRSR2",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**138,139,146**;Oct 13, 1995;Build 16
"RTN","HLOPRSR2",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOPRSR2",4,0)
 ;
"RTN","HLOPRSR2",5,0)
 ;
"RTN","HLOPRSR2",6,0)
WRITELN(LINE,Y) ;writes one line to the screen
"RTN","HLOPRSR2",7,0)
 D WRITELN^HLOPRSR1(.LINE,.Y)
"RTN","HLOPRSR2",8,0)
 Q
"RTN","HLOPRSR2",9,0)
 ;
"RTN","HLOPRSR2",10,0)
RIGHT ;
"RTN","HLOPRSR2",11,0)
 N CHAR,LINE,QUIT
"RTN","HLOPRSR2",12,0)
 K VALUE
"RTN","HLOPRSR2",13,0)
 S (QUIT,VALUE)=""
"RTN","HLOPRSR2",14,0)
 ;
"RTN","HLOPRSR2",15,0)
 ;header segments are a special case
"RTN","HLOPRSR2",16,0)
 I ((SEGTYPE="MSH")!(SEGTYPE="BHS")),(+POS("CURRENT DELIMITER")=$$SEGSTART($$SEG)),$P(POS("CURRENT DELIMITER"),"^",2)=0 D  G GORIGHT
"RTN","HLOPRSR2",17,0)
 .S POS("CURRENT DELIMITER")=$$LINE_"^4"
"RTN","HLOPRSR2",18,0)
 .S POS("NEXT DELIMITER")=$$LINE_"^"_($F($G(@MSG@($$LINE)),FLD,5)-1)
"RTN","HLOPRSR2",19,0)
 .S VALUE=FLD_$P($G(@MSG@($$LINE)),FLD,2)
"RTN","HLOPRSR2",20,0)
 .S VALUE("START")=$$LINE_"^4"
"RTN","HLOPRSR2",21,0)
 .S VALUE("END")=$$LINE_"^"_($L(VALUE)+3)
"RTN","HLOPRSR2",22,0)
 .I $$X(4),$$FLD(2),$$REP(1),$$COMP(1),$$SUB(1)
"RTN","HLOPRSR2",23,0)
 .S LASTPART(1)=1,LASTPART(1,1)=1,LASTPART(1,1,1)=1
"RTN","HLOPRSR2",24,0)
 .S LASTPART(2)=1,LASTPART(2,1)=1,LASTPART(2,1,1)=1
"RTN","HLOPRSR2",25,0)
 .;
"RTN","HLOPRSR2",26,0)
 ;
"RTN","HLOPRSR2",27,0)
 S POS("CURRENT DELIMITER")=POS("NEXT DELIMITER")
"RTN","HLOPRSR2",28,0)
 I '(+POS("CURRENT DELIMITER"))!'$P(POS("CURRENT DELIMITER"),"^",2) D DOWN Q  ;at segment end so go to next segment
"RTN","HLOPRSR2",29,0)
 ;
"RTN","HLOPRSR2",30,0)
 I $$LINE(+POS("CURRENT DELIMITER")),$$X($P(POS("CURRENT DELIMITER"),"^",2)) ;set current position to current delimiter
"RTN","HLOPRSR2",31,0)
 ;
"RTN","HLOPRSR2",32,0)
 S CHAR=$$GETCHAR
"RTN","HLOPRSR2",33,0)
 D  ;what is the next position in the segment?
"RTN","HLOPRSR2",34,0)
 .I CHAR=FLD D  Q
"RTN","HLOPRSR2",35,0)
 ..I $$FLD("+"),$$REP(1),$$COMP(1),$$SUB(1)
"RTN","HLOPRSR2",36,0)
 .I CHAR=REP D  Q
"RTN","HLOPRSR2",37,0)
 ..I $$REP("+"),$$COMP(1),$$SUB(1)
"RTN","HLOPRSR2",38,0)
 .I CHAR=COMP D  Q
"RTN","HLOPRSR2",39,0)
 ..I $$COMP("+"),$$SUB(1)
"RTN","HLOPRSR2",40,0)
 .I CHAR=SUB D  Q
"RTN","HLOPRSR2",41,0)
 ..I $$SUB("+")
"RTN","HLOPRSR2",42,0)
 ;
"RTN","HLOPRSR2",43,0)
 F  S CHAR=$$GETCHAR("+") D  Q:QUIT
"RTN","HLOPRSR2",44,0)
 .I $L(CHAR),DELIM[CHAR S POS("NEXT DELIMITER")=$$LINE_"^"_$$X,QUIT=1 Q
"RTN","HLOPRSR2",45,0)
 .I '$L(VALUE) S VALUE("START")=$$LINE_"^"_$$X,VALUE("END")=VALUE("START")
"RTN","HLOPRSR2",46,0)
 .I CHAR="" D  Q
"RTN","HLOPRSR2",47,0)
 ..S QUIT=1
"RTN","HLOPRSR2",48,0)
 ..S POS("NEXT DELIMITER")=$$LINE_"^0" ;signals end of segment
"RTN","HLOPRSR2",49,0)
 .;
"RTN","HLOPRSR2",50,0)
 .S:$L(VALUE)<512 VALUE=VALUE_CHAR
"RTN","HLOPRSR2",51,0)
 S VALUE("END")=$$LINE_"^"_$$X
"RTN","HLOPRSR2",52,0)
 ;
"RTN","HLOPRSR2",53,0)
GORIGHT ;
"RTN","HLOPRSR2",54,0)
 ;keep the current field in the scrolling region
"RTN","HLOPRSR2",55,0)
 I $$Y>(IOBM-1) D SCROLL($$Y-(IOBM-1))
"RTN","HLOPRSR2",56,0)
 ;
"RTN","HLOPRSR2",57,0)
 D DESCRIBE^HLOPRSR3
"RTN","HLOPRSR2",58,0)
 D HILITE(+$G(VALUE("START")),$P($G(VALUE("START")),"^",2),+$G(VALUE("END")),$P($G(VALUE("END")),"^",2))
"RTN","HLOPRSR2",59,0)
 Q
"RTN","HLOPRSR2",60,0)
LEFT ;
"RTN","HLOPRSR2",61,0)
 N CHAR,LINE,QUIT
"RTN","HLOPRSR2",62,0)
 K VALUE
"RTN","HLOPRSR2",63,0)
 S (QUIT,VALUE)=""
"RTN","HLOPRSR2",64,0)
 ;
"RTN","HLOPRSR2",65,0)
 S POS("NEXT DELIMITER")=POS("CURRENT DELIMITER")
"RTN","HLOPRSR2",66,0)
 I $$LINE<2,$$X<2 D UP Q
"RTN","HLOPRSR2",67,0)
 ;
"RTN","HLOPRSR2",68,0)
 ;header segments are a special case
"RTN","HLOPRSR2",69,0)
 I ((SEGTYPE="MSH")!(SEGTYPE="BHS")),$$LINE=$$SEGSTART($$SEG),$$X<$F($G(@MSG@($$LINE)),FLD,5) D  G GOLEFT
"RTN","HLOPRSR2",70,0)
 .I $$X>4 D
"RTN","HLOPRSR2",71,0)
 ..S POS("CURRENT DELIMITER")=$$LINE_"^4"
"RTN","HLOPRSR2",72,0)
 ..S VALUE=FLD_$P($G(@MSG@($$LINE)),FLD,2)
"RTN","HLOPRSR2",73,0)
 ..S VALUE("START")=$$LINE_"^4"
"RTN","HLOPRSR2",74,0)
 ..S VALUE("END")=$$LINE_"^"_($L(VALUE)+3)
"RTN","HLOPRSR2",75,0)
 ..I $$X(4),$$FLD(2),$$REP(1),$$COMP(1),$$SUB(1)
"RTN","HLOPRSR2",76,0)
 ..S LASTPART(1)=1,LASTPART(1,1)=1,LASTPART(1,1,1)=1
"RTN","HLOPRSR2",77,0)
 ..S LASTPART(2)=1,LASTPART(2,1)=1,LASTPART(2,1,1)=1
"RTN","HLOPRSR2",78,0)
 .E  D
"RTN","HLOPRSR2",79,0)
 ..S VALUE=$P($G(@MSG@($$LINE)),FLD)
"RTN","HLOPRSR2",80,0)
 ..S POS("CURRENT DELIMITER")=$$LINE_"^0"
"RTN","HLOPRSR2",81,0)
 ..S VALUE("START")=$$LINE_"^1"
"RTN","HLOPRSR2",82,0)
 ..S VALUE("END")=$$LINE_"^3"
"RTN","HLOPRSR2",83,0)
 ..I $$X(0),$$FLD(0),$$REP(0),$$COMP(0),$$SUB(0)
"RTN","HLOPRSR2",84,0)
 .;
"RTN","HLOPRSR2",85,0)
 ;
"RTN","HLOPRSR2",86,0)
 I '$P(POS("CURRENT DELIMITER"),"^",2) D  G GOLEFT  ;at segment start so go to end of prior segment
"RTN","HLOPRSR2",87,0)
 .I $$LINE($$SEGSTART($$SEG(-1))),$$X(1),$$FLD(0),$$COMP(0),$$SUB(0) ;set line to start of prior seg
"RTN","HLOPRSR2",88,0)
 .K VALUE S VALUE=""
"RTN","HLOPRSR2",89,0)
 .S SEGTYPE=$E($G(@MSG@($$LINE)),1,3)
"RTN","HLOPRSR2",90,0)
 .Q:$$LINE<1
"RTN","HLOPRSR2",91,0)
 .I (SEGTYPE="MSH")!(SEGTYPE="BHS") D
"RTN","HLOPRSR2",92,0)
 ..S VALUE=FLD_$P($G(@MSG@($$LINE)),FLD,2)
"RTN","HLOPRSR2",93,0)
 ..S VALUE("START")=$$LINE_"^4"
"RTN","HLOPRSR2",94,0)
 ..S VALUE("END")=$$LINE_"^"_($L(VALUE)+3)
"RTN","HLOPRSR2",95,0)
 ..I $$X($F($G(@MSG@($$LINE)),FLD,5)-1),$$FLD(3),$$REP(1),$$COMP(1),$$SUB(1) S POS("CURRENT DELIMITER")=$$X
"RTN","HLOPRSR2",96,0)
 ..S LASTPART(1)=1,LASTPART(1,1)=1,LASTPART(1,1,1)=1
"RTN","HLOPRSR2",97,0)
 ..S LASTPART(2)=1,LASTPART(2,1)=1,LASTPART(2,1,1)=1
"RTN","HLOPRSR2",98,0)
 .E  D
"RTN","HLOPRSR2",99,0)
 ..S POS("CURRENT DELIMITER")=$$LINE_"^0"
"RTN","HLOPRSR2",100,0)
 ..S POS("NEXT DELIMITER")=$$LINE_"^0"
"RTN","HLOPRSR2",101,0)
 ..S VALUE=SEGTYPE,VALUE("START")=$$LINE_"^1",VALUE("END")=$$LINE_"^3"
"RTN","HLOPRSR2",102,0)
 .F  S CHAR=$$GETCHAR("+") Q:CHAR=""  D
"RTN","HLOPRSR2",103,0)
 ..I DELIM[CHAR D  Q
"RTN","HLOPRSR2",104,0)
 ...S POS("CURRENT DELIMITER")=$$LINE_"^"_$$X
"RTN","HLOPRSR2",105,0)
 ...K VALUE S VALUE=""
"RTN","HLOPRSR2",106,0)
 ...I CHAR=FLD,$$FLD("+"),$$REP(1),$$COMP(1),$$SUB(1)  Q
"RTN","HLOPRSR2",107,0)
 ...I CHAR=REP,$$REP("+"),$$COMP(1),$$SUB(1) Q
"RTN","HLOPRSR2",108,0)
 ...I CHAR=COMP,$$COMP("+"),$$SUB(1) Q
"RTN","HLOPRSR2",109,0)
 ...I CHAR=SUB,$$SUB("+") Q
"RTN","HLOPRSR2",110,0)
 ..E  D
"RTN","HLOPRSR2",111,0)
 ...S:$L(VALUE)<512 VALUE=VALUE_CHAR
"RTN","HLOPRSR2",112,0)
 ...I $L(VALUE)=1 S VALUE("START")=$$LINE_"^"_$$X
"RTN","HLOPRSR2",113,0)
 ...S VALUE("END")=$$LINE_"^"_$$X
"RTN","HLOPRSR2",114,0)
 ;
"RTN","HLOPRSR2",115,0)
 I $$LINE(+POS("CURRENT DELIMITER")),$$X($P(POS("CURRENT DELIMITER"),"^",2)) ;set current position to current delimiter
"RTN","HLOPRSR2",116,0)
 ;
"RTN","HLOPRSR2",117,0)
 ;
"RTN","HLOPRSR2",118,0)
 S CHAR=$$GETCHAR
"RTN","HLOPRSR2",119,0)
 D  ;what is the next position in the segment?
"RTN","HLOPRSR2",120,0)
 .I CHAR=FLD D  Q
"RTN","HLOPRSR2",121,0)
 ..I $$FLD("-"),$$REP(LASTPART($$FLD)),$$COMP(LASTPART($$FLD,$$REP)),$$SUB(LASTPART($$FLD,$$REP,$$COMP))
"RTN","HLOPRSR2",122,0)
 .I CHAR=REP D  Q
"RTN","HLOPRSR2",123,0)
 ..I $$REP("-"),$$COMP(LASTPART($$FLD,$$REP)),$$SUB(LASTPART($$FLD,$$REP,$$COMP))
"RTN","HLOPRSR2",124,0)
 .I CHAR=COMP D  Q
"RTN","HLOPRSR2",125,0)
 ..I $$COMP("-"),$$SUB(LASTPART($$FLD,$$REP,$$COMP))
"RTN","HLOPRSR2",126,0)
 .I CHAR=SUB D  Q
"RTN","HLOPRSR2",127,0)
 ..I $$SUB("-")
"RTN","HLOPRSR2",128,0)
 ;
"RTN","HLOPRSR2",129,0)
 F  S CHAR=$$GETCHAR("-") D  Q:QUIT
"RTN","HLOPRSR2",130,0)
 .I $L(CHAR),DELIM[CHAR S POS("CURRENT DELIMITER")=$$LINE_"^"_$$X,QUIT=1 D  Q
"RTN","HLOPRSR2",131,0)
 .I CHAR="" D
"RTN","HLOPRSR2",132,0)
 ..S QUIT=1
"RTN","HLOPRSR2",133,0)
 ..I VALUE="" D UP Q
"RTN","HLOPRSR2",134,0)
 ..S POS("CURRENT DELIMITER")=$$LINE_"^0" ;signals end of segment
"RTN","HLOPRSR2",135,0)
 .;
"RTN","HLOPRSR2",136,0)
 .S:$L(VALUE)<512 VALUE=CHAR_VALUE
"RTN","HLOPRSR2",137,0)
 .I $L(VALUE)=1 S VALUE("END")=$$LINE_"^"_$$X
"RTN","HLOPRSR2",138,0)
 .S VALUE("START")=$$LINE_"^"_$$X
"RTN","HLOPRSR2",139,0)
 ;
"RTN","HLOPRSR2",140,0)
GOLEFT ;
"RTN","HLOPRSR2",141,0)
 ;keep the current field in the scrolling region
"RTN","HLOPRSR2",142,0)
 I $$Y<(IOTM) D SCROLL($$Y-IOTM)
"RTN","HLOPRSR2",143,0)
 ;
"RTN","HLOPRSR2",144,0)
 D DESCRIBE^HLOPRSR3
"RTN","HLOPRSR2",145,0)
 D HILITE(+$G(VALUE("START")),$P($G(VALUE("START")),"^",2),+$G(VALUE("END")),$P($G(VALUE("END")),"^",2))
"RTN","HLOPRSR2",146,0)
 Q
"RTN","HLOPRSR2",147,0)
 ;
"RTN","HLOPRSR2",148,0)
MSGSIZE() ;
"RTN","HLOPRSR2",149,0)
 Q $$MSGSIZE^HLOPRSR1
"RTN","HLOPRSR2",150,0)
SCRNSIZE() ;
"RTN","HLOPRSR2",151,0)
 Q $$SCRNSIZE^HLOPRSR1
"RTN","HLOPRSR2",152,0)
TOP(INC) ;msg line at the top of the scrolling area
"RTN","HLOPRSR2",153,0)
 Q $$TOP^HLOPRSR1(.INC)
"RTN","HLOPRSR2",154,0)
LINE(TO,INC) ;msg line
"RTN","HLOPRSR2",155,0)
 Q $$LINE^HLOPRSR1(.TO,.INC)
"RTN","HLOPRSR2",156,0)
 ;
"RTN","HLOPRSR2",157,0)
X(TO,INC) ;current position within the line
"RTN","HLOPRSR2",158,0)
 ;
"RTN","HLOPRSR2",159,0)
 Q $$X^HLOPRSR1(.TO,.INC)
"RTN","HLOPRSR2",160,0)
Y(LINE) ;screen line of msg line = LINE
"RTN","HLOPRSR2",161,0)
 Q $$Y^HLOPRSR1(.LINE)
"RTN","HLOPRSR2",162,0)
SEG(INC) ;returns the current segement #
"RTN","HLOPRSR2",163,0)
 Q $$SEG^HLOPRSR1(.INC)
"RTN","HLOPRSR2",164,0)
FLD(SET) ;returns the currrent field #
"RTN","HLOPRSR2",165,0)
 Q $$FLD^HLOPRSR1(.SET)
"RTN","HLOPRSR2",166,0)
REP(SET) ;returns the current repitition #
"RTN","HLOPRSR2",167,0)
 Q $$REP^HLOPRSR1(.SET)
"RTN","HLOPRSR2",168,0)
COMP(SET) ;returns the current component #
"RTN","HLOPRSR2",169,0)
 Q $$COMP^HLOPRSR1(.SET)
"RTN","HLOPRSR2",170,0)
 ;
"RTN","HLOPRSR2",171,0)
SUB(SET) ;returns the current sub-component #
"RTN","HLOPRSR2",172,0)
 Q $$SUB^HLOPRSR1(.SET)
"RTN","HLOPRSR2",173,0)
 ;
"RTN","HLOPRSR2",174,0)
SEGSTART(SEGMENT) ;
"RTN","HLOPRSR2",175,0)
 Q $$SEGSTART^HLOPRSR1(.SEGMENT)
"RTN","HLOPRSR2",176,0)
 ;
"RTN","HLOPRSR2",177,0)
IOXY(Y,X) ; moves to screen position line=Y, col=X
"RTN","HLOPRSR2",178,0)
 D IOXY^HLOPRSR1(.Y,.X)
"RTN","HLOPRSR2",179,0)
 Q
"RTN","HLOPRSR2",180,0)
HILITE(LINE1,CHAR1,LINE2,CHAR2) ;does hightlighting
"RTN","HLOPRSR2",181,0)
 ;LINE1: starting line
"RTN","HLOPRSR2",182,0)
 ;CHAR1: starting character
"RTN","HLOPRSR2",183,0)
 ;LINE2: ending line
"RTN","HLOPRSR2",184,0)
 ;CHAR2: ending character
"RTN","HLOPRSR2",185,0)
 ;
"RTN","HLOPRSR2",186,0)
 N X
"RTN","HLOPRSR2",187,0)
 I $G(HILITE) D UNLITE
"RTN","HLOPRSR2",188,0)
 I LINE1>0,CHAR1>0,LINE2>0,CHAR2>0 D
"RTN","HLOPRSR2",189,0)
 .W IORVON
"RTN","HLOPRSR2",190,0)
 .S HILITE=LINE1_"^"_CHAR1_"^"_LINE2_"^"_CHAR2
"RTN","HLOPRSR2",191,0)
 .D LITE
"RTN","HLOPRSR2",192,0)
 W IORVOFF
"RTN","HLOPRSR2",193,0)
 S X=$P(POS("CURRENT DELIMITER"),"^",2)
"RTN","HLOPRSR2",194,0)
 ;
"RTN","HLOPRSR2",195,0)
 ;
"RTN","HLOPRSR2",196,0)
 ;move curson to the delimiter, and write in bold
"RTN","HLOPRSR2",197,0)
 D IOXY($$Y($$LINE(+POS("CURRENT DELIMITER"))),$$X(X))
"RTN","HLOPRSR2",198,0)
 ;
"RTN","HLOPRSR2",199,0)
 ;
"RTN","HLOPRSR2",200,0)
 I X D
"RTN","HLOPRSR2",201,0)
 .W IOINHI
"RTN","HLOPRSR2",202,0)
 .W $$GETCHAR
"RTN","HLOPRSR2",203,0)
 .W IOINORM
"RTN","HLOPRSR2",204,0)
 .D IOXY($$Y,$$X)
"RTN","HLOPRSR2",205,0)
 W IOCUON
"RTN","HLOPRSR2",206,0)
 Q
"RTN","HLOPRSR2",207,0)
 ;
"RTN","HLOPRSR2",208,0)
LITE N LINE
"RTN","HLOPRSR2",209,0)
 F LINE=LINE1:1:LINE2 D
"RTN","HLOPRSR2",210,0)
 .I '($$Y(LINE)>IOBM),'($$Y(LINE)<IOTM) D
"RTN","HLOPRSR2",211,0)
 ..D IOXY($$Y(LINE),$S(LINE=LINE1:CHAR1,1:1))
"RTN","HLOPRSR2",212,0)
 ..W $E($G(@MSG@(LINE)),$S(LINE=LINE1:CHAR1,1:1),$S(LINE=LINE2:CHAR2,1:80))
"RTN","HLOPRSR2",213,0)
 Q
"RTN","HLOPRSR2",214,0)
 ;
"RTN","HLOPRSR2",215,0)
UNLITE ;
"RTN","HLOPRSR2",216,0)
 N LINE1,CHAR1,LINE2,CHAR2
"RTN","HLOPRSR2",217,0)
 W IORVOFF
"RTN","HLOPRSR2",218,0)
 Q:$G(HILITE)=""
"RTN","HLOPRSR2",219,0)
 S LINE1=$P(HILITE,"^"),CHAR1=$P(HILITE,"^",2),LINE2=$P(HILITE,"^",3),CHAR2=$P(HILITE,"^",4)
"RTN","HLOPRSR2",220,0)
 K HILITE
"RTN","HLOPRSR2",221,0)
 I $G(SEGLINE(LINE2)),CHAR1=1 W IOINHI
"RTN","HLOPRSR2",222,0)
 D LITE
"RTN","HLOPRSR2",223,0)
 I $G(SEGLINE(LINE2)),CHAR1=1 W IOINORM
"RTN","HLOPRSR2",224,0)
 Q
"RTN","HLOPRSR2",225,0)
 ;
"RTN","HLOPRSR2",226,0)
DOWN ;
"RTN","HLOPRSR2",227,0)
 N I
"RTN","HLOPRSR2",228,0)
 K LASTPART
"RTN","HLOPRSR2",229,0)
 S SEGTYPE=""
"RTN","HLOPRSR2",230,0)
 I $$SEGSTART($$SEG("+1")) D
"RTN","HLOPRSR2",231,0)
 .I $$LINE($$SEGSTART($$SEG))
"RTN","HLOPRSR2",232,0)
 E  D
"RTN","HLOPRSR2",233,0)
 .I $$LINE(,1)>0,$$LINE<$$MSGSIZE,$$LINE($$MSGSIZE+1)
"RTN","HLOPRSR2",234,0)
 F I="FLD","REP","COMP","SUB" S POS(I)=0
"RTN","HLOPRSR2",235,0)
 I '($$Y>IOBM) D
"RTN","HLOPRSR2",236,0)
 .D IOXY($$Y,1)
"RTN","HLOPRSR2",237,0)
 E  D
"RTN","HLOPRSR2",238,0)
 .D SCROLL($$Y-IOBM)
"RTN","HLOPRSR2",239,0)
 S SEGTYPE=$E($G(@MSG@($$LINE)),1,3)
"RTN","HLOPRSR2",240,0)
 S POS("CURRENT DELIMITER")=$$LINE_"^0"
"RTN","HLOPRSR2",241,0)
 S POS("NEXT DELIMITER")=$$LINE_"^"_$S($$SEGSTART($$SEG):4,1:0)
"RTN","HLOPRSR2",242,0)
 D DESCRIBE^HLOPRSR3
"RTN","HLOPRSR2",243,0)
 D HILITE($$LINE,$$X,$$LINE,($$X+2))
"RTN","HLOPRSR2",244,0)
 Q
"RTN","HLOPRSR2",245,0)
 ;
"RTN","HLOPRSR2",246,0)
UP ;
"RTN","HLOPRSR2",247,0)
 N I
"RTN","HLOPRSR2",248,0)
 K LASTPART
"RTN","HLOPRSR2",249,0)
 S SEGTYPE=""
"RTN","HLOPRSR2",250,0)
 I $$SEGSTART($$SEG("-1")) D
"RTN","HLOPRSR2",251,0)
 .I $$LINE($$SEGSTART($$SEG))
"RTN","HLOPRSR2",252,0)
 E  D
"RTN","HLOPRSR2",253,0)
 .I $$LINE(,-1)>0,$$LINE<$$MSGSIZE,$$LINE(0) ;set line to 0
"RTN","HLOPRSR2",254,0)
 F I="FLD","REP","COMP","SUB" S POS(I)=0
"RTN","HLOPRSR2",255,0)
 I '($$Y<IOTM) D
"RTN","HLOPRSR2",256,0)
 .D IOXY($$Y,1)
"RTN","HLOPRSR2",257,0)
 E  D
"RTN","HLOPRSR2",258,0)
 .D SCROLL($$Y-IOTM)
"RTN","HLOPRSR2",259,0)
 S SEGTYPE=$E($G(@MSG@($$LINE)),1,3)
"RTN","HLOPRSR2",260,0)
 S POS("CURRENT DELIMITER")=$$LINE_"^0"
"RTN","HLOPRSR2",261,0)
 S POS("NEXT DELIMITER")=$$LINE_"^"_$S($$SEGSTART($$SEG):4,1:0)
"RTN","HLOPRSR2",262,0)
 D DESCRIBE^HLOPRSR3
"RTN","HLOPRSR2",263,0)
 D HILITE($$LINE,$$X,$$LINE,($$X+2))
"RTN","HLOPRSR2",264,0)
 Q
"RTN","HLOPRSR2",265,0)
 ;
"RTN","HLOPRSR2",266,0)
SCROLL(COUNT) ; Scrolls up (COUNT positive) or down (COUNT negative)
"RTN","HLOPRSR2",267,0)
 ;
"RTN","HLOPRSR2",268,0)
 N I
"RTN","HLOPRSR2",269,0)
 I COUNT>0 D
"RTN","HLOPRSR2",270,0)
 .D IOXY(IOBM,1)
"RTN","HLOPRSR2",271,0)
 .F I=1:1:COUNT D
"RTN","HLOPRSR2",272,0)
 ..W IOIND
"RTN","HLOPRSR2",273,0)
 ..I $$TOP(1)
"RTN","HLOPRSR2",274,0)
 ..W $G(@MSG@($$BOT^HLOPRSR1))
"RTN","HLOPRSR2",275,0)
 ..D IOXY(IOBM,1)
"RTN","HLOPRSR2",276,0)
 .I $$LINE($$BOT^HLOPRSR1)
"RTN","HLOPRSR2",277,0)
 .S POS("CHAR")=1
"RTN","HLOPRSR2",278,0)
 .;
"RTN","HLOPRSR2",279,0)
 I COUNT<0 D
"RTN","HLOPRSR2",280,0)
 .D IOXY(1,1)
"RTN","HLOPRSR2",281,0)
 .F I=-1:-1:COUNT D
"RTN","HLOPRSR2",282,0)
 ..W IORI
"RTN","HLOPRSR2",283,0)
 ..W $G(@MSG@($$TOP(-1)))
"RTN","HLOPRSR2",284,0)
 ..D IOXY(1,1)
"RTN","HLOPRSR2",285,0)
 .S POS("CHAR")=1
"RTN","HLOPRSR2",286,0)
 Q
"RTN","HLOPRSR2",287,0)
GETCHAR(INC) ;returns a message character, can go forward or backward but will not cross the segment boundary.
"RTN","HLOPRSR2",288,0)
 ;INC:
"RTN","HLOPRSR2",289,0)
 ;  not defined - assumes the current position
"RTN","HLOPRSR2",290,0)
 ;  "+" - the next character. May change $$X and $$LINE
"RTN","HLOPRSR2",291,0)
 ;  "-" - the prior character. May change $$X and $$LINE
"RTN","HLOPRSR2",292,0)
 ;
"RTN","HLOPRSR2",293,0)
 N END,TMP
"RTN","HLOPRSR2",294,0)
 S END=0
"RTN","HLOPRSR2",295,0)
 S TMP("LINE")=$$LINE
"RTN","HLOPRSR2",296,0)
 S TMP("X")=$$X
"RTN","HLOPRSR2",297,0)
 I $E($G(INC))="+" D
"RTN","HLOPRSR2",298,0)
 .I '($$X<80) D  ;get char from next line
"RTN","HLOPRSR2",299,0)
 ..;** P139 START CJM
"RTN","HLOPRSR2",300,0)
 ..I ('$$SEGSTART($$SEG+1))!(($$LINE+1)<$$SEGSTART($$SEG+1)),$$LINE(,1),$$X(1)
"RTN","HLOPRSR2",301,0)
 ..;** P139 END
"RTN","HLOPRSR2",302,0)
 .E  D
"RTN","HLOPRSR2",303,0)
 ..I $$X=$$X(,1) S END=1
"RTN","HLOPRSR2",304,0)
 E  I $E($G(INC))="-" D
"RTN","HLOPRSR2",305,0)
 .I '($$X()>1) D  ;get char from prior line
"RTN","HLOPRSR2",306,0)
 ..I $$SEGSTART($$SEG)<$$LINE D
"RTN","HLOPRSR2",307,0)
 ...I $$LINE(,-1),$$X($L($G(@MSG@($$LINE))))
"RTN","HLOPRSR2",308,0)
 ..E  D
"RTN","HLOPRSR2",309,0)
 ...S END=1
"RTN","HLOPRSR2",310,0)
 .E  D
"RTN","HLOPRSR2",311,0)
 ..I $$X=$$X(,-1) S END=1
"RTN","HLOPRSR2",312,0)
 ;** P146 START CJM
"RTN","HLOPRSR2",313,0)
 ;
"RTN","HLOPRSR2",314,0)
 ;This line was added in patch 139.  It is incorrect!
"RTN","HLOPRSR2",315,0)
 ;I TMP("LINE")=$$LINE,TMP("X")=$$X S END=1
"RTN","HLOPRSR2",316,0)
 ;
"RTN","HLOPRSR2",317,0)
 ;This is the corrected line.
"RTN","HLOPRSR2",318,0)
 I $L($G(INC)),TMP("LINE")=$$LINE,TMP("X")=$$X S END=1
"RTN","HLOPRSR2",319,0)
 ;**P146 END
"RTN","HLOPRSR2",320,0)
 ;
"RTN","HLOPRSR2",321,0)
 Q:END ""
"RTN","HLOPRSR2",322,0)
 Q $E($G(@MSG@($$LINE)),$$X)
"RTN","HLOPRSR2",323,0)
 ;
"RTN","HLOPRSR2",324,0)
LJ(STRING,LENGTH) ;
"RTN","HLOPRSR2",325,0)
 Q $$LJ^XLFSTR(STRING,LENGTH)
"RTN","HLOSRVR1")
0^32^B86429474^B86996455
"RTN","HLOSRVR1",1,0)
HLOSRVR1 ;IRMFO-ALB/CJM/OAK/PIJ - Reading messages, sending acks;03/24/2004  14:43 ;07/28/2009
"RTN","HLOSRVR1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,130,131,133,134,137,138,139,143,146**;Oct 13, 1995;Build 16
"RTN","HLOSRVR1",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOSRVR1",4,0)
 ;
"RTN","HLOSRVR1",5,0)
READMSG(HLCSTATE,HLMSTATE) ;
"RTN","HLOSRVR1",6,0)
 ;Reads a message.  The header is parsed. Does these checks:
"RTN","HLOSRVR1",7,0)
 ; 1) Duplicate?
"RTN","HLOSRVR1",8,0)
 ; 2) Wrong Receiving Facility?
"RTN","HLOSRVR1",9,0)
 ; 3) Can the Receiving App accept this message, based message type & event?
"RTN","HLOSRVR1",10,0)
 ; 4) Processing ID must match the receiving system
"RTN","HLOSRVR1",11,0)
 ; 5) Must have an ID
"RTN","HLOSRVR1",12,0)
 ; 6) Header must be BHS or MSH
"RTN","HLOSRVR1",13,0)
 ;
"RTN","HLOSRVR1",14,0)
 ;Output:
"RTN","HLOSRVR1",15,0)
 ;  Function returns 1 if the message was read fully, 0 otherwise
"RTN","HLOSRVR1",16,0)
 ;  HLMSTATE (pass by reference) the message.  It will include the fields for the return ack in HLMSTATE("MSA")
"RTN","HLOSRVR1",17,0)
 ;
"RTN","HLOSRVR1",18,0)
 N ACK,SEG,STORE,I
"RTN","HLOSRVR1",19,0)
 ;
"RTN","HLOSRVR1",20,0)
 S STORE=1
"RTN","HLOSRVR1",21,0)
 Q:'$$READHDR^HLOT(.HLCSTATE,.SEG) 0
"RTN","HLOSRVR1",22,0)
 D SPLITHDR(.SEG)
"RTN","HLOSRVR1",23,0)
 ;
"RTN","HLOSRVR1",24,0)
 ;parse the header, stop if unsuccessful because the server cannot know what to do next
"RTN","HLOSRVR1",25,0)
 I '$$PARSEHDR^HLOPRS(.SEG) D  Q 0
"RTN","HLOSRVR1",26,0)
ZB29 .S HLCSTATE("MESSAGE ENDED")=0
"RTN","HLOSRVR1",27,0)
 .D CLOSE^HLOT(.HLCSTATE)
"RTN","HLOSRVR1",28,0)
 ;
"RTN","HLOSRVR1",29,0)
 ;** P143 START CJM**
"RTN","HLOSRVR1",30,0)
 S I=$S(SEG("SEGMENT TYPE")="MSH":$G(SEG("MESSAGE CONTROL ID")),1:$G(SEG("BATCH CONTROL ID")))
"RTN","HLOSRVR1",31,0)
 I I'="" L +HLO("MSGID",I):5 I '$T D  Q 0
"RTN","HLOSRVR1",32,0)
 .S HLCSTATE("MESSAGE ENDED")=0
"RTN","HLOSRVR1",33,0)
 .D CLOSE^HLOT(.HLCSTATE)
"RTN","HLOSRVR1",34,0)
 ;** P143 END CJM
"RTN","HLOSRVR1",35,0)
 ;
"RTN","HLOSRVR1",36,0)
 D NEWMSG^HLOSRVR2(.HLCSTATE,.HLMSTATE,.SEG)
"RTN","HLOSRVR1",37,0)
 I HLMSTATE("ID")="" D
"RTN","HLOSRVR1",38,0)
 .S STORE=0
"RTN","HLOSRVR1",39,0)
 .I HLMSTATE("HDR","ACCEPT ACK TYPE")="AL" S HLMSTATE("MSA",1)="CE",HLMSTATE("MSA",3)="CONTROL ID MISSING"
"RTN","HLOSRVR1",40,0)
 I STORE,$$DUP(.HLMSTATE) D
"RTN","HLOSRVR1",41,0)
ZB30 .S STORE=0
"RTN","HLOSRVR1",42,0)
 ;
"RTN","HLOSRVR1",43,0)
 ;if the message is not to be stored, just read it and discard the segments
"RTN","HLOSRVR1",44,0)
 I 'STORE D
"RTN","HLOSRVR1",45,0)
 .F  Q:'$$READSEG^HLOT(.HLCSTATE,.SEG)
"RTN","HLOSRVR1",46,0)
 ;
"RTN","HLOSRVR1",47,0)
 E  D
"RTN","HLOSRVR1",48,0)
 .N FS,NEWMSGID
"RTN","HLOSRVR1",49,0)
 .S NEWMSGID=""
"RTN","HLOSRVR1",50,0)
 .S FS=HLMSTATE("HDR","FIELD SEPARATOR")
"RTN","HLOSRVR1",51,0)
 .F  Q:'$$READSEG^HLOT(.HLCSTATE,.SEG)  D
"RTN","HLOSRVR1",52,0)
 ..N MSA,SEGTYPE,OLDMSGID,CODE,IEN,TEXT
"RTN","HLOSRVR1",53,0)
 ..S SEGTYPE=$E($E(SEG(1),1,3)_$E($G(SEG(2)),1,2),1,3)
"RTN","HLOSRVR1",54,0)
 ..I SEGTYPE="MSA" D
"RTN","HLOSRVR1",55,0)
 ...S MSA=SEG(1)_$G(SEG(2))_$G(SEG(3))
"RTN","HLOSRVR1",56,0)
 ...;; ** Start HL*1.6*138 PIJ **
"RTN","HLOSRVR1",57,0)
 ...;;S OLDMSGID=$P(MSA,FS,3),CODE=$P(MSA,FS,2),TEXT=$E($P(MSA,FS,4),1,30)
"RTN","HLOSRVR1",58,0)
 ...S OLDMSGID=$P(MSA,FS,3),CODE=$P(MSA,FS,2)
"RTN","HLOSRVR1",59,0)
 ...S TEXT=$$ESCAPE^HLOPBLD(.HLMSTATE,$P(MSA,FS,4,$L(MSA,"|")))
"RTN","HLOSRVR1",60,0)
 ...;; ** End HL*1.6*138 **
"RTN","HLOSRVR1",61,0)
 ...I $E(CODE,1)'="A" S SEGTYPE="" Q
"RTN","HLOSRVR1",62,0)
 ...;** P143 START CJM
"RTN","HLOSRVR1",63,0)
 ...;S:$P(OLDMSGID,"-")]"" IEN=$O(^HLB("B",$P(OLDMSGID,"-"),0))
"RTN","HLOSRVR1",64,0)
 ...;S:$G(IEN) IEN=IEN_"^"_$P(OLDMSGID,"-",2)
"RTN","HLOSRVR1",65,0)
 ...S IEN=$$ACKTOIEN^HLOMSG1("",OLDMSGID)
"RTN","HLOSRVR1",66,0)
 ...;** P143 END CJM
"RTN","HLOSRVR1",67,0)
 ..I 'HLMSTATE("BATCH") D
"RTN","HLOSRVR1",68,0)
 ...D:SEGTYPE="MSA"
"RTN","HLOSRVR1",69,0)
 ....S HLMSTATE("ACK TO")=OLDMSGID
"RTN","HLOSRVR1",70,0)
 ....S HLMSTATE("ACK TO","ACK BY")=HLMSTATE("ID")
"RTN","HLOSRVR1",71,0)
 ....S HLMSTATE("ACK TO","STATUS")=$S(CODE="AA":"SU",1:"ER")
"RTN","HLOSRVR1",72,0)
 ....I $G(IEN) D
"RTN","HLOSRVR1",73,0)
 .....S HLMSTATE("ACK TO","IEN")=IEN
"RTN","HLOSRVR1",74,0)
 .....S HLMSTATE("ACK TO","SEQUENCE QUEUE")=$P($G(^HLB(+IEN,5)),"^")
"RTN","HLOSRVR1",75,0)
 ....S HLMSTATE("ACK TO","ERROR TEXT")=TEXT
"RTN","HLOSRVR1",76,0)
 ...D ADDSEG^HLOMSG(.HLMSTATE,.SEG)
"RTN","HLOSRVR1",77,0)
 ..E  D  ;batch
"RTN","HLOSRVR1",78,0)
 ...I SEGTYPE="MSH" D
"RTN","HLOSRVR1",79,0)
 ....D SPLITHDR(.SEG)
"RTN","HLOSRVR1",80,0)
 ....S NEWMSGID=$P(SEG(2),FS,5)
"RTN","HLOSRVR1",81,0)
 ....D ADDMSG2^HLOMSG(.HLMSTATE,.SEG)
"RTN","HLOSRVR1",82,0)
 ...E  D  ;not MSH
"RTN","HLOSRVR1",83,0)
 ....D:SEGTYPE="MSA"
"RTN","HLOSRVR1",84,0)
 .....N SUBIEN S SUBIEN=HLMSTATE("BATCH","CURRENT MESSAGE")
"RTN","HLOSRVR1",85,0)
 .....S HLMSTATE("BATCH","ACK TO",SUBIEN)=OLDMSGID
"RTN","HLOSRVR1",86,0)
 .....S HLMSTATE("BATCH","ACK TO",SUBIEN,"ACK BY")=NEWMSGID
"RTN","HLOSRVR1",87,0)
 .....S HLMSTATE("BATCH","ACK TO",SUBIEN,"STATUS")=$S(CODE="AA":"SU",1:"ER")
"RTN","HLOSRVR1",88,0)
 .....S:$D(IEN) HLMSTATE("BATCH","ACK TO",SUBIEN,"IEN")=IEN
"RTN","HLOSRVR1",89,0)
 ....D ADDSEG^HLOMSG(.HLMSTATE,.SEG)
"RTN","HLOSRVR1",90,0)
 .I HLMSTATE("UNSTORED LINES"),HLCSTATE("MESSAGE ENDED"),$$SAVEMSG^HLOF778(.HLMSTATE)
"RTN","HLOSRVR1",91,0)
 ;
"RTN","HLOSRVR1",92,0)
 I STORE,'HLCSTATE("MESSAGE ENDED") D
"RTN","HLOSRVR1",93,0)
 .;reading failed, don't store
"RTN","HLOSRVR1",94,0)
 .D:HLMSTATE("IEN") DEL778(HLMSTATE("IEN")) D:HLMSTATE("BODY") DEL777(HLMSTATE("BODY"))
"RTN","HLOSRVR1",95,0)
 .S HLMSTATE("IEN")="",HLMSTATE("BODY")=""
"RTN","HLOSRVR1",96,0)
 E  D:STORE
"RTN","HLOSRVR1",97,0)
 .D CHECKMSG(.HLMSTATE)
"RTN","HLOSRVR1",98,0)
 .D ADDAC(.HLMSTATE) ;so future duplicates are detected
"RTN","HLOSRVR1",99,0)
 .D COUNT^HLOSTAT(.HLCSTATE,HLMSTATE("HDR","RECEIVING APPLICATION"),HLMSTATE("HDR","SENDING APPLICATION"),$S(HLMSTATE("BATCH"):"BATCH",1:HLMSTATE("HDR","MESSAGE TYPE")_"~"_HLMSTATE("HDR","EVENT")))
"RTN","HLOSRVR1",100,0)
 ;
"RTN","HLOSRVR1",101,0)
 D:'HLCSTATE("MESSAGE ENDED") CLOSE^HLOT(.HLCSTATE)
"RTN","HLOSRVR1",102,0)
 Q HLCSTATE("MESSAGE ENDED")
"RTN","HLOSRVR1",103,0)
 ;
"RTN","HLOSRVR1",104,0)
ADDAC(HLMSTATE) ;adds the AC xref for duplicates detection
"RTN","HLOSRVR1",105,0)
 ;
"RTN","HLOSRVR1",106,0)
 N FROM
"RTN","HLOSRVR1",107,0)
 S FROM=$S(HLMSTATE("HDR","SENDING FACILITY",2)]"":HLMSTATE("HDR","SENDING FACILITY",2),1:HLMSTATE("HDR","SENDING FACILITY",1))
"RTN","HLOSRVR1",108,0)
 S ^HLB("AC",FROM_HLMSTATE("HDR","SENDING APPLICATION")_HLMSTATE("ID"),HLMSTATE("IEN"))=""
"RTN","HLOSRVR1",109,0)
 Q
"RTN","HLOSRVR1",110,0)
 ;
"RTN","HLOSRVR1",111,0)
DUP(HLMSTATE) ;
"RTN","HLOSRVR1",112,0)
 ;Returns 1 if the message is a duplicate and its ack (if requested) is found, 0 otherwise
"RTN","HLOSRVR1",113,0)
 ;Input:
"RTN","HLOSRVR1",114,0)
 ; HLMSTATE (pass by reference) the message being read
"RTN","HLOSRVR1",115,0)
 ;Output:
"RTN","HLOSRVR1",116,0)
 ;  Function returns 1 if the message is a duplicate, 0 otherwise
"RTN","HLOSRVR1",117,0)
 ;  HLMSTATE (pass by reference) IF the message is a duplicate:
"RTN","HLOSRVR1",118,0)
 ;     returns the prior MSA segment in HLMSTATE("MSA")
"RTN","HLOSRVR1",119,0)
 ;
"RTN","HLOSRVR1",120,0)
 N IEN,FROM,DUP
"RTN","HLOSRVR1",121,0)
 S (IEN,DUP)=0
"RTN","HLOSRVR1",122,0)
 ;
"RTN","HLOSRVR1",123,0)
 ;no way to determine!  Bad header will be rejected
"RTN","HLOSRVR1",124,0)
 Q:(HLMSTATE("ID")="") 0
"RTN","HLOSRVR1",125,0)
 ;
"RTN","HLOSRVR1",126,0)
 S FROM=$S(HLMSTATE("HDR","SENDING FACILITY",2)]"":HLMSTATE("HDR","SENDING FACILITY",2),1:HLMSTATE("HDR","SENDING FACILITY",1))
"RTN","HLOSRVR1",127,0)
 F  S IEN=$O(^HLB("AC",FROM_HLMSTATE("HDR","SENDING APPLICATION")_HLMSTATE("ID"),IEN)) Q:'IEN  D  Q:DUP
"RTN","HLOSRVR1",128,0)
 .I HLMSTATE("HDR","ACCEPT ACK TYPE")="NE" S DUP=1 Q
"RTN","HLOSRVR1",129,0)
 .;need the MSA to return
"RTN","HLOSRVR1",130,0)
 .D  Q
"RTN","HLOSRVR1",131,0)
 ..N NODE
"RTN","HLOSRVR1",132,0)
 ..S NODE=$P($G(^HLB(IEN,4)),"^",3,10)
"RTN","HLOSRVR1",133,0)
 ..S HLMSTATE("MSA",1)=$P(NODE,"|",2)
"RTN","HLOSRVR1",134,0)
 ..Q:$L(HLMSTATE("MSA",1))'=2
"RTN","HLOSRVR1",135,0)
 ..S HLMSTATE("MSA",2)=$P(NODE,"|",3)
"RTN","HLOSRVR1",136,0)
 ..S HLMSTATE("MSA",3)=$P(NODE,"|",4,10)
"RTN","HLOSRVR1",137,0)
 ..S DUP=1
"RTN","HLOSRVR1",138,0)
 ;
"RTN","HLOSRVR1",139,0)
 Q DUP
"RTN","HLOSRVR1",140,0)
 ;
"RTN","HLOSRVR1",141,0)
CHECKMSG(HLMSTATE) ;
"RTN","HLOSRVR1",142,0)
 ;Checks the header & MSA segment, sets HLMSTATE("STATUS","ACTION") if the message needs to be passed, determines if completion status should be set
"RTN","HLOSRVR1",143,0)
 ;Input:
"RTN","HLOSRVR1",144,0)
 ;  HLMSTATE("HDR") - the parsed header segment
"RTN","HLOSRVR1",145,0)
 ;Output:
"RTN","HLOSRVR1",146,0)
 ;  HLMSTATE("STATUS")="ER" if an error is detected
"RTN","HLOSRVR1",147,0)
 ;  HLMSTATE("STATUS","QUEUE") queue to put the message on
"RTN","HLOSRVR1",148,0)
 ;  HLMSTATE("STATUS","ACTION")  <tag^rtn> that is the processing routine for the receiving application
"RTN","HLOSRVR1",149,0)
 ;  HLMSTATE("MSA") - MSA(1)=accept code to be returned, MSA(3)= error txt
"RTN","HLOSRVR1",150,0)
 ;
"RTN","HLOSRVR1",151,0)
 N WANTACK,PASS,ACTION,QUEUE,ERROR
"RTN","HLOSRVR1",152,0)
 M HDR=HLMSTATE("HDR")
"RTN","HLOSRVR1",153,0)
 S ERROR=0
"RTN","HLOSRVR1",154,0)
 I HDR("ACCEPT ACK TYPE")="NE",'HLMSTATE("ORIGINAL MODE") D
"RTN","HLOSRVR1",155,0)
 .S WANTACK=0
"RTN","HLOSRVR1",156,0)
 E  D
"RTN","HLOSRVR1",157,0)
 .S WANTACK=1
"RTN","HLOSRVR1",158,0)
 I HLMSTATE("ORIGINAL MODE") S HLMSTATE("MSA",1)="AE",HLMSTATE("MSA",3)="THIS INTERFACE DOES NOT IMPLEMENT ORIGINAL MODE APPLICATION ACKOWLEDGMENTS",HLMSTATE("STATUS")="ER" Q
"RTN","HLOSRVR1",159,0)
 I $G(HLMSTATE("ACK TO"))="" D  Q:ERROR
"RTN","HLOSRVR1",160,0)
 .;
"RTN","HLOSRVR1",161,0)
 .;** do not immplement the Pass Immediate parameter **
"RTN","HLOSRVR1",162,0)
 .;N IMMEDIATE
"RTN","HLOSRVR1",163,0)
 .;I '$$ACTION^HLOAPP(.HDR,.ACTION,.QUEUE,.IMMEDIATE) S ERROR=1 S:WANTACK HLMSTATE("MSA",1)="CR" S HLMSTATE("MSA",3)="RECEIVING APPLICATION NOT DEFINED",HLMSTATE("STATUS")="ER" Q
"RTN","HLOSRVR1",164,0)
 .;S HLMSTATE("STATUS","ACTION")=$G(ACTION),HLMSTATE("STATUS","QUEUE")=$G(QUEUE),HLMSTATE("STATUS","PASS IMMEDIATE")=$G(IMMEDIATE)
"RTN","HLOSRVR1",165,0)
 .;
"RTN","HLOSRVR1",166,0)
 .I '$$ACTION^HLOAPP(.HDR,.ACTION,.QUEUE) S ERROR=1 S:WANTACK HLMSTATE("MSA",1)="CR" S HLMSTATE("MSA",3)="RECEIVING APPLICATION NOT DEFINED",HLMSTATE("STATUS")="ER" Q
"RTN","HLOSRVR1",167,0)
 .S HLMSTATE("STATUS","ACTION")=$G(ACTION),HLMSTATE("STATUS","QUEUE")=$G(QUEUE)
"RTN","HLOSRVR1",168,0)
 E  D  Q:ERROR  ;this is an app ack
"RTN","HLOSRVR1",169,0)
 .;does the original message exist?
"RTN","HLOSRVR1",170,0)
 .;
"RTN","HLOSRVR1",171,0)
 .;** do not immplement the Pass Immediate parameter **
"RTN","HLOSRVR1",172,0)
 .;N NODE,IMMEDIATE
"RTN","HLOSRVR1",173,0)
 .;
"RTN","HLOSRVR1",174,0)
 .N NODE
"RTN","HLOSRVR1",175,0)
 .S:+$G(HLMSTATE("ACK TO","IEN")) NODE=$G(^HLB(+HLMSTATE("ACK TO","IEN"),0))
"RTN","HLOSRVR1",176,0)
 .I $G(NODE)="" S ERROR=1,HLMSTATE("STATUS")="ER",HLMSTATE("ACK TO","IEN")="" S:WANTACK HLMSTATE("MSA",1)="CE" S HLMSTATE("MSA",3)="INITIAL MESSAGE TO APPLICATION ACKNOWLEDGMENT NOT FOUND" Q
"RTN","HLOSRVR1",177,0)
 .I $P(NODE,"^",7)'="",$P(NODE,"^",7)'=HLMSTATE("ID") S ERROR=1,HLMSTATE("STATUS")="ER",HLMSTATE("ACK TO","IEN")="" S:WANTACK HLMSTATE("MSA",1)="CE" S HLMSTATE("MSA",3)="INITIAL MESSAGE WAS ALREADY ACKED" Q
"RTN","HLOSRVR1",178,0)
 .I ($P(NODE,"^",11)]"") S HLMSTATE("STATUS","ACTION")=$P(NODE,"^",10,11),HLMSTATE("STATUS","QUEUE")=$S($P(NODE,"^",6)]"":$P(NODE,"^",6),1:"DEFAULT")  Q
"RTN","HLOSRVR1",179,0)
 .;processing routine for the app ack wasn't found with the original message, look in the HLO Application Registry
"RTN","HLOSRVR1",180,0)
 .I HLMSTATE("HDR","MESSAGE TYPE")="ACK",HLMSTATE("HDR","EVENT")="" S HDR("EVENT")=$$GETEVENT^HLOCLNT2(+HLMSTATE("ACK TO","IEN"))
"RTN","HLOSRVR1",181,0)
 .;
"RTN","HLOSRVR1",182,0)
 .;** do not immplement the Pass Immediate parameter **
"RTN","HLOSRVR1",183,0)
 .;I $$ACTION^HLOAPP(.HDR,.ACTION,.QUEUE,.IMMEDIATE) S HLMSTATE("STATUS","ACTION")=$G(ACTION),HLMSTATE("STATUS","QUEUE")=$G(QUEUE),HLMSTATE("STATUS","PASS IMMEDIATE")=$G(IMMEDIATE)
"RTN","HLOSRVR1",184,0)
 .;
"RTN","HLOSRVR1",185,0)
 .I $$ACTION^HLOAPP(.HDR,.ACTION,.QUEUE) S HLMSTATE("STATUS","ACTION")=$G(ACTION),HLMSTATE("STATUS","QUEUE")=$G(QUEUE)
"RTN","HLOSRVR1",186,0)
 ;
"RTN","HLOSRVR1",187,0)
 I HDR("PROCESSING ID")'=HLCSTATE("SYSTEM","PROCESSING ID") S:WANTACK HLMSTATE("MSA",1)="CR" S HLMSTATE("STATUS")="ER",HLMSTATE("MSA",3)="SYSTEM PROCESSING ID="_HLCSTATE("SYSTEM","PROCESSING ID") Q
"RTN","HLOSRVR1",188,0)
 ;
"RTN","HLOSRVR1",189,0)
 ;wrong receiving facility?  This is hard to check if the sender is not VistA, because the HL7 standard permits different coding systems to be used. This check is only for DNS or station number.
"RTN","HLOSRVR1",190,0)
 S PASS=0
"RTN","HLOSRVR1",191,0)
 D
"RTN","HLOSRVR1",192,0)
 .;if its an ack to an existing message, don't check the receiving facility
"RTN","HLOSRVR1",193,0)
 .I $G(HLMSTATE("ACK TO"))]"" S PASS=1 Q
"RTN","HLOSRVR1",194,0)
 .I HDR("RECEIVING FACILITY",1)=HLCSTATE("SYSTEM","STATION") S PASS=1 Q
"RTN","HLOSRVR1",195,0)
 .I HDR("RECEIVING FACILITY",3)'="DNS" S PASS=1 Q
"RTN","HLOSRVR1",196,0)
 .I HDR("RECEIVING FACILITY",2)="" S PASS=1 Q
"RTN","HLOSRVR1",197,0)
 .I $P(HDR("RECEIVING FACILITY",2),":")[HLCSTATE("SYSTEM","DOMAIN") S PASS=1 Q
"RTN","HLOSRVR1",198,0)
 .I HLCSTATE("SYSTEM","DOMAIN")[$P(HDR("RECEIVING FACILITY",2),":") S PASS=1 Q
"RTN","HLOSRVR1",199,0)
 I 'PASS S HLMSTATE("STATUS")="ER",HLMSTATE("MSA",3)="RECEIVING FACILITY IS "_HLCSTATE("SYSTEM","DOMAIN") S:WANTACK HLMSTATE("MSA",1)="CE"
"RTN","HLOSRVR1",200,0)
 I PASS,WANTACK S HLMSTATE("MSA",1)="CA"
"RTN","HLOSRVR1",201,0)
 Q
"RTN","HLOSRVR1",202,0)
 ;
"RTN","HLOSRVR1",203,0)
DEL777(IEN777) ;delete a record from file 777 where the read did not complete
"RTN","HLOSRVR1",204,0)
 ;
"RTN","HLOSRVR1",205,0)
 K ^HLA(IEN777,0)
"RTN","HLOSRVR1",206,0)
 Q
"RTN","HLOSRVR1",207,0)
DEL778(IEN778) ;delete a record from file 778 where the read did not complete
"RTN","HLOSRVR1",208,0)
 ;
"RTN","HLOSRVR1",209,0)
 K ^HLB(IEN778,0)
"RTN","HLOSRVR1",210,0)
 Q
"RTN","HLOSRVR1",211,0)
 ;
"RTN","HLOSRVR1",212,0)
SPLITHDR(HDR) ;
"RTN","HLOSRVR1",213,0)
 ;splits hdr segment into two lines, first being just components 1-6
"RTN","HLOSRVR1",214,0)
 ;
"RTN","HLOSRVR1",215,0)
 N TEMP,FS
"RTN","HLOSRVR1",216,0)
 D SQUISH(.HDR)
"RTN","HLOSRVR1",217,0)
 S FS=$E($G(HDR(1)),4)
"RTN","HLOSRVR1",218,0)
 S TEMP(1)=$P($G(HDR(1)),FS,1,6)
"RTN","HLOSRVR1",219,0)
 S TEMP(2)=""
"RTN","HLOSRVR1",220,0)
 I $L(TEMP(1))<$L($G(HDR(1))) S TEMP(2)=FS_$P($G(HDR(1)),FS,7,20)
"RTN","HLOSRVR1",221,0)
 S HDR(2)=TEMP(2)_$G(HDR(2))
"RTN","HLOSRVR1",222,0)
 S HDR(1)=TEMP(1)
"RTN","HLOSRVR1",223,0)
 Q
"RTN","HLOSRVR1",224,0)
 ;
"RTN","HLOSRVR1",225,0)
SQUISH(SEG) ;
"RTN","HLOSRVR1",226,0)
 ;reformat the segment array into full lines
"RTN","HLOSRVR1",227,0)
 ;
"RTN","HLOSRVR1",228,0)
 ;nothing to do if less than 2 lines
"RTN","HLOSRVR1",229,0)
 Q:'$O(SEG(1))
"RTN","HLOSRVR1",230,0)
 ;
"RTN","HLOSRVR1",231,0)
 N A,I,J,K,MAX,COUNT,LEN
"RTN","HLOSRVR1",232,0)
 S MAX=$S($G(HLCSTATE("SYSTEM","MAXSTRING"))>256:HLCSTATE("SYSTEM","MAXSTRING"),1:256)
"RTN","HLOSRVR1",233,0)
 S (COUNT,I)=0,J=1
"RTN","HLOSRVR1",234,0)
 F  S I=$O(SEG(I)) Q:'I  D
"RTN","HLOSRVR1",235,0)
 .S LEN=$L(SEG(I))
"RTN","HLOSRVR1",236,0)
 .F K=1:1:LEN D
"RTN","HLOSRVR1",237,0)
 ..S A(J)=$G(A(J))_$E(SEG(I),K)
"RTN","HLOSRVR1",238,0)
 ..S COUNT=COUNT+1
"RTN","HLOSRVR1",239,0)
 ..I (COUNT>(MAX-1)) S COUNT=0,J=J+1
"RTN","HLOSRVR1",240,0)
 K SEG
"RTN","HLOSRVR1",241,0)
 M SEG=A
"RTN","HLOSRVR1",242,0)
 Q
"RTN","HLOSRVR2")
0^24^B5350765^B5350765
"RTN","HLOSRVR2",1,0)
HLOSRVR2 ;ALB/CJM-HL7 - HLO Server ;07/17/2009
"RTN","HLOSRVR2",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**131,137,138,146**;Oct 13, 1995;Build 16
"RTN","HLOSRVR2",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOSRVR2",4,0)
 ;
"RTN","HLOSRVR2",5,0)
NEWMSG(HLCSTATE,HLMSTATE,HDR) ;
"RTN","HLOSRVR2",6,0)
 ;initialize the HLMSTATE array after reading the header
"RTN","HLOSRVR2",7,0)
 ;Inputs:
"RTN","HLOSRVR2",8,0)
 ;  HLCSTATE (pass by reference)
"RTN","HLOSRVR2",9,0)
 ;  HDR (pass by reference) parsed header
"RTN","HLOSRVR2",10,0)
 ;Output:
"RTN","HLOSRVR2",11,0)
 ;  HLMSTATE (pass by reference)
"RTN","HLOSRVR2",12,0)
 ;
"RTN","HLOSRVR2",13,0)
 K HLMSTATE
"RTN","HLOSRVR2",14,0)
 S HLMSTATE("IEN")=""
"RTN","HLOSRVR2",15,0)
 S HLMSTATE("BODY")=""
"RTN","HLOSRVR2",16,0)
 S HLMSTATE("DIRECTION")="IN"
"RTN","HLOSRVR2",17,0)
 S HLMSTATE("CURRENT SEGMENT")=0 ;no segments in cache
"RTN","HLOSRVR2",18,0)
 S HLMSTATE("UNSTORED LINES")=1 ;just the header in cache so far
"RTN","HLOSRVR2",19,0)
 S HLMSTATE("LINE COUNT")=0 ;no lines within message stored to disk
"RTN","HLOSRVR2",20,0)
 I HDR("SEGMENT TYPE")="BHS" D
"RTN","HLOSRVR2",21,0)
 .S HLMSTATE("BATCH")=1
"RTN","HLOSRVR2",22,0)
 .S HLMSTATE("ID")=HDR("BATCH CONTROL ID")
"RTN","HLOSRVR2",23,0)
 .S HLMSTATE("BATCH","CURRENT MESSAGE")=0 ;no messages in batch
"RTN","HLOSRVR2",24,0)
 .S HLMSTATE("UNSTORED MSH")=0
"RTN","HLOSRVR2",25,0)
 E  D
"RTN","HLOSRVR2",26,0)
 .S HLMSTATE("BATCH")=0
"RTN","HLOSRVR2",27,0)
 .S HLMSTATE("ID")=HDR("MESSAGE CONTROL ID")
"RTN","HLOSRVR2",28,0)
 M HLMSTATE("HDR")=HDR
"RTN","HLOSRVR2",29,0)
 M HLMSTATE("SYSTEM")=HLCSTATE("SYSTEM")
"RTN","HLOSRVR2",30,0)
 S HLMSTATE("STATUS")=""
"RTN","HLOSRVR2",31,0)
 S HLMSTATE("STATUS","QUEUE")=""
"RTN","HLOSRVR2",32,0)
 S HLMSTATE("STATUS","ACTION")=""
"RTN","HLOSRVR2",33,0)
 S HLMSTATE("STATUS","LINK NAME")=HLCSTATE("LINK","NAME")
"RTN","HLOSRVR2",34,0)
 S HLMSTATE("STATUS","PORT")=$P(HDR("SENDING FACILITY",2),":",2)
"RTN","HLOSRVR2",35,0)
 ;
"RTN","HLOSRVR2",36,0)
 ;if this is a batch, and it references another batch, assume it is a batch of app acks
"RTN","HLOSRVR2",37,0)
 ;** START 138 CJM
"RTN","HLOSRVR2",38,0)
 ;I HLMSTATE("BATCH"),HLMSTATE("ID")]"" D
"RTN","HLOSRVR2",39,0)
 I HLMSTATE("BATCH"),HLMSTATE("HDR","REFERENCE BATCH CONTROL ID")]"" D
"RTN","HLOSRVR2",40,0)
 .N IEN
"RTN","HLOSRVR2",41,0)
 .;S HLMSTATE("ACK TO")=HLMSTATE("ID")
"RTN","HLOSRVR2",42,0)
 .S HLMSTATE("ACK TO")=HLMSTATE("HDR","REFERENCE BATCH CONTROL ID")
"RTN","HLOSRVR2",43,0)
 .S HLMSTATE("ACK TO","STATUS")="SU"
"RTN","HLOSRVR2",44,0)
 .;S IEN=$O(^HLB("B",HLMSTATE("ID"),0))
"RTN","HLOSRVR2",45,0)
 .S IEN=$O(^HLB("B",HLMSTATE("HDR","REFERENCE BATCH CONTROL ID"),0))
"RTN","HLOSRVR2",46,0)
 .;** END 138 CJM
"RTN","HLOSRVR2",47,0)
 .I IEN S HLMSTATE("ACK TO","IEN")=IEN_"^"
"RTN","HLOSRVR2",48,0)
 E  S HLMSTATE("ACK TO")=""
"RTN","HLOSRVR2",49,0)
 I 'HLMSTATE("BATCH"),HDR("ACCEPT ACK TYPE")="",HDR("APP ACK TYPE")="" D
"RTN","HLOSRVR2",50,0)
 .S HLMSTATE("ORIGINAL MODE")=1
"RTN","HLOSRVR2",51,0)
 E  D
"RTN","HLOSRVR2",52,0)
 .S HLMSTATE("ORIGINAL MODE")=0
"RTN","HLOSRVR2",53,0)
 N I F I=1,3 S HLMSTATE("MSA",I)=""
"RTN","HLOSRVR2",54,0)
 S HLMSTATE("MSA",2)=HLMSTATE("ID")
"RTN","HLOSRVR2",55,0)
 Q
"RTN","HLOSTRAC")
0^25^B33783349^n/a
"RTN","HLOSTRAC",1,0)
HLOSTRAC ;;OIFO-OAK/RBN/CJM ;08/17/2009
"RTN","HLOSTRAC",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**146**;Oct 13, 1995;Build 16
"RTN","HLOSTRAC",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOSTRAC",4,0)
 ;;
"RTN","HLOSTRAC",5,0)
 ;; HLO SERVER TRACE Tool
"RTN","HLOSTRAC",6,0)
 ;; *** For troubleshooting HLO server issues ***
"RTN","HLOSTRAC",7,0)
 ;;     The HLO server runs in the foreground and writes trace
"RTN","HLOSTRAC",8,0)
 ;;     statements to the screen.
"RTN","HLOSTRAC",9,0)
 ;; 
"RTN","HLOSTRAC",10,0)
TRACE    ;
"RTN","HLOSTRAC",11,0)
 N CONF,HLOTRACE
"RTN","HLOSTRAC",12,0)
 S HLOTRACE("COUNT")=0
"RTN","HLOSTRAC",13,0)
 I '$G(DUZ) W !,"Your DUZ must be set!" Q
"RTN","HLOSTRAC",14,0)
 D OWNSKEY^XUSRB(.CONF,"XUPROG",DUZ)
"RTN","HLOSTRAC",15,0)
 I 'CONF(0) D  Q
"RTN","HLOSTRAC",16,0)
 . W !!,"   Sorry, you are not authorized to use this tool.",!!
"RTN","HLOSTRAC",17,0)
 ;I $P($$VERSION^%ZOSV(1),"/",1)'="Cache for OpenVMS" D  Q
"RTN","HLOSTRAC",18,0)
 I $P($$VERSION^%ZOSV(1),"/",1)'["Cache" D  Q
"RTN","HLOSTRAC",19,0)
 . W !!,"   Sorry, this tool can only be used under Cache",!!
"RTN","HLOSTRAC",20,0)
 N IEN,LINK,PORT
"RTN","HLOSTRAC",21,0)
 S IEN=+$O(^HLD(779.1,0))
"RTN","HLOSTRAC",22,0)
 D:IEN
"RTN","HLOSTRAC",23,0)
 .S LINK=$P($G(^HLD(779.1,IEN,0)),"^",10)
"RTN","HLOSTRAC",24,0)
 .S LINK=$P($G(^HLCS(870,LINK,0)),"^")
"RTN","HLOSTRAC",25,0)
 S:'$L($G(LINK)) LINK="HLO DEFAULT LISTENER"
"RTN","HLOSTRAC",26,0)
 W !,"What port do you want to listen on while in server trace mode?"
"RTN","HLOSTRAC",27,0)
 W !,"The port must be free. If a server already has it opened then the"
"RTN","HLOSTRAC",28,0)
 W !,"server needs to be stopped before starting in server trace mode."
"RTN","HLOSTRAC",29,0)
 S PORT=$$ASKPORT^HLOUSRA(LINK)
"RTN","HLOSTRAC",30,0)
 Q:'PORT
"RTN","HLOSTRAC",31,0)
 D SETBREAKS
"RTN","HLOSTRAC",32,0)
 ZB ZB999^HLOSRVR:"N":1:"S LINK(""PORT"")=PORT,LINK(""SERVER"")=""1^S"",LINK(""LLP"")=""TCP"""
"RTN","HLOSTRAC",33,0)
 ;
"RTN","HLOSTRAC",34,0)
 W !!,"Starting the server, hit the CTRL-C key to stop the server...",!!
"RTN","HLOSTRAC",35,0)
 D SERVER^HLOSRVR(LINK)
"RTN","HLOSTRAC",36,0)
 U $PRINCIPAL
"RTN","HLOSTRAC",37,0)
 ZB /CLEAR
"RTN","HLOSTRAC",38,0)
 W !,"DONE!"
"RTN","HLOSTRAC",39,0)
 Q
"RTN","HLOSTRAC",40,0)
 ;
"RTN","HLOSTRAC",41,0)
SETBREAKS ;
"RTN","HLOSTRAC",42,0)
 ZB /CLEAR
"RTN","HLOSTRAC",43,0)
 ZB /INTERRUPT:NORMAL
"RTN","HLOSTRAC",44,0)
 ;
"RTN","HLOSTRAC",45,0)
 ;report errors
"RTN","HLOSTRAC",46,0)
 ZB ERROR^HLOSRVR3:"N":1:"D ZB3^HLOTRACE"
"RTN","HLOSTRAC",47,0)
 ;
"RTN","HLOSTRAC",48,0)
 ;allow Server Trace tool to run even if HLO is shut down
"RTN","HLOSTRAC",49,0)
 ZB ZB25^HLOPROC:"N":1:"S RET=0"
"RTN","HLOSTRAC",50,0)
 ZB READMSG^HLOSRVR1:"N":1:"D READMSG^HLOSTRAC"
"RTN","HLOSTRAC",51,0)
 ZB PARSEHDR^HLOPRS:"N":1:"D PARSEHDR^HLOSTRAC"
"RTN","HLOSTRAC",52,0)
 ZB DUP^HLOSRVR1:"N":1:"D DUP^HLOSTRAC"
"RTN","HLOSTRAC",53,0)
 ZB CLOSE^HLOT:"N":1:"D CLOSE^HLOSTRAC"
"RTN","HLOSTRAC",54,0)
 ;set break ZB10 in the client(start of $$READHDR^HLOT)
"RTN","HLOSTRAC",55,0)
 ZB ZB10^HLOT:"N":1:"D ZB10^HLOSTRAC"
"RTN","HLOSTRAC",56,0)
 ;set break ZB11 in the client(end of $$READHDR^HLOT)
"RTN","HLOSTRAC",57,0)
 ZB ZB11^HLOT:"N":1:"D ZB11^HLOSTRAC"
"RTN","HLOSTRAC",58,0)
 ;set break ZB12 in the client(start of $$READSEG^HLOT)
"RTN","HLOSTRAC",59,0)
 ZB ZB12^HLOT:"N":1:"D ZB12^HLOSTRAC"
"RTN","HLOSTRAC",60,0)
 ;set break ZB13 in the client(end of $$READSEG^HLOT)
"RTN","HLOSTRAC",61,0)
 ZB ZB13^HLOT:"N":1:"D ZB13^HLOSTRAC"
"RTN","HLOSTRAC",62,0)
 ;set break ZB14 in the client(start of $$WRITESEG^HLOT)
"RTN","HLOSTRAC",63,0)
 ZB ZB14^HLOT:"N":1:"D ZB14^HLOSTRAC"
"RTN","HLOSTRAC",64,0)
 ;set break ZB15 in the client(end of $$WRITESEG^HLOT)
"RTN","HLOSTRAC",65,0)
 ZB ZB15^HLOT:"N":1:"D ZB15^HLOSTRAC"
"RTN","HLOSTRAC",66,0)
 ;set break ZB16 in the client(start of $$WRITEHDR^HLOT)
"RTN","HLOSTRAC",67,0)
 ZB ZB16^HLOT:"N":1:"D ZB16^HLOSTRAC"
"RTN","HLOSTRAC",68,0)
 ;set break ZB17 in the client(end of $$WRITEHDR^HLOT)
"RTN","HLOSTRAC",69,0)
 ZB ZB17^HLOT:"N":1:"D ZB17^HLOSTRAC"
"RTN","HLOSTRAC",70,0)
 ;set break ZB18 in the client(start of $$ENDMSG^HLOT)
"RTN","HLOSTRAC",71,0)
 ZB ZB18^HLOT:"N":1:"D ZB18^HLOSTRAC"
"RTN","HLOSTRAC",72,0)
 ;set break ZB19 in the server(end of $$ENDMSG^HLOT)
"RTN","HLOSTRAC",73,0)
 ZB ZB19^HLOT:"N":1:"D ZB19^HLOSTRAC"
"RTN","HLOSTRAC",74,0)
 ZB ZB25^HLOTCP:"N":1:"D ZB25^HLOSTRAC"
"RTN","HLOSTRAC",75,0)
 ZB ZB26^HLOTCP:"N":1:"D ZB26^HLOSTRAC"
"RTN","HLOSTRAC",76,0)
 ZB ZB27^HLOTCP:"N":1:"D ZB27^HLOSTRAC"
"RTN","HLOSTRAC",77,0)
 ZB ZB28^HLOTCP:"N":1:"D ZB28^HLOSTRAC"
"RTN","HLOSTRAC",78,0)
 ;set break ZB29 in the server(after parsing the message header)
"RTN","HLOSTRAC",79,0)
 ZB ZB29^HLOSRVR1:"N":1:"D ZB29^HLOSTRAC"
"RTN","HLOSTRAC",80,0)
 ;set break ZB30 in the server(afterchecking if duplicate)
"RTN","HLOSTRAC",81,0)
 ZB ZB30^HLOSRVR1:"N":1:"D ZB30^HLOSTRAC"
"RTN","HLOSTRAC",82,0)
 Q
"RTN","HLOSTRAC",83,0)
 ;
"RTN","HLOSTRAC",84,0)
WRITE(MSG) ;
"RTN","HLOSTRAC",85,0)
 N OLD
"RTN","HLOSTRAC",86,0)
 S OLD=$IO
"RTN","HLOSTRAC",87,0)
 U $PRINCIPAL
"RTN","HLOSTRAC",88,0)
 W !,?5,"Time: ",$$NOW^XLFDT,"   ",MSG
"RTN","HLOSTRAC",89,0)
 U OLD
"RTN","HLOSTRAC",90,0)
 Q
"RTN","HLOSTRAC",91,0)
WRITE2(MSG,VALUE) ;
"RTN","HLOSTRAC",92,0)
 N OLD,I
"RTN","HLOSTRAC",93,0)
 S OLD=$IO
"RTN","HLOSTRAC",94,0)
 U $PRINCIPAL
"RTN","HLOSTRAC",95,0)
 W !,?5,"Time: ",$$NOW^XLFDT,"   ",MSG
"RTN","HLOSTRAC",96,0)
 S I=0
"RTN","HLOSTRAC",97,0)
 W:$O(VALUE(0)) !
"RTN","HLOSTRAC",98,0)
 F  S I=$O(VALUE(I)) Q:'I  W VALUE(I)
"RTN","HLOSTRAC",99,0)
 U OLD
"RTN","HLOSTRAC",100,0)
 Q
"RTN","HLOSTRAC",101,0)
WRITE3(MSG) ;
"RTN","HLOSTRAC",102,0)
 N OLD
"RTN","HLOSTRAC",103,0)
 S OLD=$IO
"RTN","HLOSTRAC",104,0)
 U $PRINCIPAL
"RTN","HLOSTRAC",105,0)
 W !,MSG
"RTN","HLOSTRAC",106,0)
 U OLD
"RTN","HLOSTRAC",107,0)
 Q
"RTN","HLOSTRAC",108,0)
READMSG ;
"RTN","HLOSTRAC",109,0)
 ;
"RTN","HLOSTRAC",110,0)
 S HLOTRACE("COUNT")=HLOTRACE("COUNT")+1
"RTN","HLOSTRAC",111,0)
 I HLOTRACE("COUNT")>1 D
"RTN","HLOSTRAC",112,0)
 .N OLD,SEND
"RTN","HLOSTRAC",113,0)
 .S OLD=$IO
"RTN","HLOSTRAC",114,0)
 .U $PRINCIPAL
"RTN","HLOSTRAC",115,0)
 .W !
"RTN","HLOSTRAC",116,0)
 .S SEND=$$ASKYESNO^HLOUSR2("Do you want to trace another message transmission","NO")
"RTN","HLOSTRAC",117,0)
 .I 'SEND S $ECODE="ZZHLOSTOP"
"RTN","HLOSTRAC",118,0)
 .U OLD
"RTN","HLOSTRAC",119,0)
 W !
"RTN","HLOSTRAC",120,0)
 D WRITE3^HLOSTRAC("Beginning to read next message...")
"RTN","HLOSTRAC",121,0)
 Q
"RTN","HLOSTRAC",122,0)
PARSEHDR ;
"RTN","HLOSTRAC",123,0)
 D WRITE^HLOSTRAC("Parsing the message header...")
"RTN","HLOSTRAC",124,0)
 Q
"RTN","HLOSTRAC",125,0)
DUP ;
"RTN","HLOSTRAC",126,0)
 D WRITE^HLOSTRAC("Checking if duplicate message...")
"RTN","HLOSTRAC",127,0)
 Q
"RTN","HLOSTRAC",128,0)
CLOSE ;
"RTN","HLOSTRAC",129,0)
 D WRITE^HLOSTRAC("Closing the port...")
"RTN","HLOSTRAC",130,0)
 Q
"RTN","HLOSTRAC",131,0)
 ;
"RTN","HLOSTRAC",132,0)
ZB10 ;
"RTN","HLOSTRAC",133,0)
 D WRITE^HLOSTRAC("Reading message header...")
"RTN","HLOSTRAC",134,0)
 Q
"RTN","HLOSTRAC",135,0)
ZB11 I $D(HDR) D WRITE2^HLOSTRAC("",.HDR)
"RTN","HLOSTRAC",136,0)
 D WRITE^HLOSTRAC($S(SUCCESS:"Completed!",1:"**** FAILED TO COMPLETE *****"))
"RTN","HLOSTRAC",137,0)
 Q
"RTN","HLOSTRAC",138,0)
ZB12 ;
"RTN","HLOSTRAC",139,0)
 D WRITE^HLOSTRAC("Reading next segment...")
"RTN","HLOSTRAC",140,0)
 Q
"RTN","HLOSTRAC",141,0)
ZB13 I $D(SEG) D WRITE2^HLOSTRAC("",.SEG)
"RTN","HLOSTRAC",142,0)
 D WRITE^HLOSTRAC($S(RETURN:"Completed!",$G(HLCSTATE("MESSAGE ENDED")):"No more segments!",1:"**** FAILED TO COMPLETE *****"))
"RTN","HLOSTRAC",143,0)
 Q
"RTN","HLOSTRAC",144,0)
ZB14 ;
"RTN","HLOSTRAC",145,0)
 D WRITE2^HLOSTRAC("Writing next segment...",.SEG)
"RTN","HLOSTRAC",146,0)
 Q
"RTN","HLOSTRAC",147,0)
ZB15 D WRITE^HLOSTRAC($S(RETURN:"Completed!",1:"**** FAILED TO COMPLETE *****"))
"RTN","HLOSTRAC",148,0)
 Q
"RTN","HLOSTRAC",149,0)
ZB16 ;
"RTN","HLOSTRAC",150,0)
 D WRITE3^HLOSTRAC("Beginning to write the commit acknowledgment...")
"RTN","HLOSTRAC",151,0)
 D WRITE2^HLOSTRAC("Writing header segment...",.HDR)
"RTN","HLOSTRAC",152,0)
 Q
"RTN","HLOSTRAC",153,0)
ZB17 D WRITE^HLOSTRAC($S(SUCCESS:"Completed!",1:"**** FAILED TO COMPLETE *****"))
"RTN","HLOSTRAC",154,0)
 Q
"RTN","HLOSTRAC",155,0)
ZB18 ;
"RTN","HLOSTRAC",156,0)
 D WRITE^HLOSTRAC("Writing message terminators and flushing buffer...")
"RTN","HLOSTRAC",157,0)
 Q
"RTN","HLOSTRAC",158,0)
ZB19 D WRITE^HLOSTRAC($S(RETURN:"Completed!",1:"**** FAILED TO COMPLETE *****"))
"RTN","HLOSTRAC",159,0)
 Q
"RTN","HLOSTRAC",160,0)
ZB25 D WRITE^HLOSTRAC("Opening the port...")
"RTN","HLOSTRAC",161,0)
 Q
"RTN","HLOSTRAC",162,0)
ZB26 D WRITE^HLOSTRAC("Waiting for remote client to connect...")
"RTN","HLOSTRAC",163,0)
 Q
"RTN","HLOSTRAC",164,0)
ZB27 D WRITE^HLOSTRAC("Remote client connected...")
"RTN","HLOSTRAC",165,0)
 Q
"RTN","HLOSTRAC",166,0)
ZB28 D WRITE^HLOSTRAC("**** UNABLE TO OPEN PORT *****")
"RTN","HLOSTRAC",167,0)
 Q
"RTN","HLOSTRAC",168,0)
ZB29 D WRITE3^HLOSTRAC("*** THE MESSAGE HEADER COULD NOT BE PARSED   ***")
"RTN","HLOSTRAC",169,0)
 Q
"RTN","HLOSTRAC",170,0)
ZB30 D WRITE3^HLOSTRAC("*** THE MESSAGE IS A DUPLICATE AND WILL BE DISCARDED   ***")
"RTN","HLOSTRAC",171,0)
 D WRITE3^HLOSTRAC("*** THE ORIGINAL COMMIT ACKNOWLEDMENT WILL BE RETURNED ***")
"RTN","HLOSTRAC",172,0)
 Q
"RTN","HLOT")
0^23^B3437824^B3373728
"RTN","HLOT",1,0)
HLOT ;IRMFO-ALB/CJM - Services provided by the transport layer;03/24/2004  14:43 ;08/17/2009
"RTN","HLOT",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,131,139,146**;Oct 13, 1995;Build 16
"RTN","HLOT",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOT",4,0)
 ;
"RTN","HLOT",5,0)
 ;**NOTE:  tags of the format ZB* are used by the client-trace debugging tool and should not be removed
"RTN","HLOT",6,0)
 ;
"RTN","HLOT",7,0)
READHDR(HLCSTATE,HDR) ;
"RTN","HLOT",8,0)
ZB10 N SUCCESS,SEG
"RTN","HLOT",9,0)
 N MCODE
"RTN","HLOT",10,0)
 S HLCSTATE("MESSAGE ENDED")=0
"RTN","HLOT",11,0)
 ;**START P139 CJM
"RTN","HLOT",12,0)
 S HLCSTATE("MESSAGE STARTED")=0
"RTN","HLOT",13,0)
 ;**END P139
"RTN","HLOT",14,0)
 S MCODE="S SUCCESS=$$"_HLCSTATE("READ HEADER")_"(.HLCSTATE,.HDR)"
"RTN","HLOT",15,0)
 X MCODE
"RTN","HLOT",16,0)
 ;**START P139 CJM
"RTN","HLOT",17,0)
 I SUCCESS S HLCSTATE("MESSAGE STARTED")=1
"RTN","HLOT",18,0)
 ;**END P139
"RTN","HLOT",19,0)
ZB11 Q SUCCESS
"RTN","HLOT",20,0)
 ;
"RTN","HLOT",21,0)
READSEG(HLCSTATE,SEG) ;
"RTN","HLOT",22,0)
ZB12 N RETURN
"RTN","HLOT",23,0)
 N MCODE
"RTN","HLOT",24,0)
 S MCODE="S RETURN=$$"_HLCSTATE("READ SEGMENT")_"(.HLCSTATE,.SEG)"
"RTN","HLOT",25,0)
 X MCODE
"RTN","HLOT",26,0)
ZB13 Q RETURN
"RTN","HLOT",27,0)
 ;
"RTN","HLOT",28,0)
OPEN(HLCSTATE) ;
"RTN","HLOT",29,0)
 N MCODE
"RTN","HLOT",30,0)
 I '$L(HLCSTATE("OPEN")) S HLCSTATE("CONNECTED")=0 Q
"RTN","HLOT",31,0)
 S MCODE="D "_HLCSTATE("OPEN")_"(.HLCSTATE)"
"RTN","HLOT",32,0)
 X MCODE
"RTN","HLOT",33,0)
 Q
"RTN","HLOT",34,0)
 ;
"RTN","HLOT",35,0)
CLOSE(HLCSTATE) ;
"RTN","HLOT",36,0)
 N MCODE
"RTN","HLOT",37,0)
 S MCODE="D "_HLCSTATE("CLOSE")_"(.HLCSTATE)"
"RTN","HLOT",38,0)
 X MCODE
"RTN","HLOT",39,0)
 S HLCSTATE("CONNECTED")=0
"RTN","HLOT",40,0)
 Q
"RTN","HLOT",41,0)
 ;
"RTN","HLOT",42,0)
WRITESEG(HLCSTATE,SEG) ;
"RTN","HLOT",43,0)
ZB14 N RETURN
"RTN","HLOT",44,0)
 N MCODE
"RTN","HLOT",45,0)
 S MCODE="S RETURN=$$"_HLCSTATE("WRITE SEGMENT")_"(.HLCSTATE,.SEG)"
"RTN","HLOT",46,0)
 X MCODE
"RTN","HLOT",47,0)
ZB15 Q RETURN
"RTN","HLOT",48,0)
 ;
"RTN","HLOT",49,0)
WRITEHDR(HLCSTATE,HDR) ;
"RTN","HLOT",50,0)
ZB16 N SUCCESS
"RTN","HLOT",51,0)
 N MCODE
"RTN","HLOT",52,0)
 S MCODE="S SUCCESS=$$"_HLCSTATE("WRITE HEADER")_"(.HLCSTATE,.HDR)"
"RTN","HLOT",53,0)
 X MCODE
"RTN","HLOT",54,0)
ZB17 Q SUCCESS
"RTN","HLOT",55,0)
 ;
"RTN","HLOT",56,0)
ENDMSG(HLCSTATE) ;
"RTN","HLOT",57,0)
ZB18 N RETURN
"RTN","HLOT",58,0)
 N MCODE
"RTN","HLOT",59,0)
 S MCODE="S RETURN=$$"_HLCSTATE("END MESSAGE")_"(.HLCSTATE)"
"RTN","HLOT",60,0)
 X MCODE
"RTN","HLOT",61,0)
ZB19 Q RETURN
"RTN","HLOTCP")
0^11^B85513944^B61182306
"RTN","HLOTCP",1,0)
HLOTCP ;ALB/CJM- TCP/IP I/O - 10/4/94 1pm ;07/17/2009
"RTN","HLOTCP",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,131,134,137,138,139,146**;Oct 13, 1995;Build 16
"RTN","HLOTCP",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOTCP",4,0)
 ;
"RTN","HLOTCP",5,0)
OPEN(HLCSTATE,LOGICAL) ;
"RTN","HLOTCP",6,0)
 ;This may be called either in the context of a client or a server.
"RTN","HLOTCP",7,0)
 ;For the server, there are 3 situations:
"RTN","HLOTCP",8,0)
 ; 1) The server is not concurrent.  In this case the TCP device should be opened.
"RTN","HLOTCP",9,0)
 ; 2) The server is concurrent, but this process was spawned by the OS
"RTN","HLOTCP",10,0)
 ;    (via a VMS TCP Service)  In this case, the device should be opened
"RTN","HLOTCP",11,0)
 ;    via the LOGICAL that was passed in.
"RTN","HLOTCP",12,0)
 ;  3) The server is concurrent, but this process was spawned by the
"RTN","HLOTCP",13,0)
 ;     TaskMan multi-listener.  In this case TaskMan already opened the
"RTN","HLOTCP",14,0)
 ;     device.  This case can be determined by the absence of the LOGICAL
"RTN","HLOTCP",15,0)
 ;     input parameter.
"RTN","HLOTCP",16,0)
 ;
"RTN","HLOTCP",17,0)
 N IP,PORT,DNSFLAG
"RTN","HLOTCP",18,0)
 ;
"RTN","HLOTCP",19,0)
 S DNSFLAG=0 ;DNS has not been contacted for IP
"RTN","HLOTCP",20,0)
 ;
"RTN","HLOTCP",21,0)
 S:'$G(HLCSTATE("SERVER")) IP=HLCSTATE("LINK","IP")
"RTN","HLOTCP",22,0)
 S PORT=HLCSTATE("LINK","PORT")
"RTN","HLOTCP",23,0)
 S HLCSTATE("CONNECTED")=0
"RTN","HLOTCP",24,0)
 S HLCSTATE("READ HEADER")="READHDR^HLOTCP"
"RTN","HLOTCP",25,0)
 S HLCSTATE("WRITE HEADER")="WRITEHDR^HLOTCP"
"RTN","HLOTCP",26,0)
 S HLCSTATE("READ SEGMENT")="READSEG^HLOTCP"
"RTN","HLOTCP",27,0)
 S HLCSTATE("WRITE SEGMENT")="WRITESEG^HLOTCP"
"RTN","HLOTCP",28,0)
 S HLCSTATE("END MESSAGE")="ENDMSG^HLOTCP"
"RTN","HLOTCP",29,0)
 S HLCSTATE("CLOSE")="CLOSE^HLOTCP"
"RTN","HLOTCP",30,0)
 S HLCSTATE("TCP BUFFER")=""
"RTN","HLOTCP",31,0)
 S HLCSTATE("TCP BUFFER $X")=0
"RTN","HLOTCP",32,0)
 ;
"RTN","HLOTCP",33,0)
 ;spawned by TaskMan multi-listener? If so, the device has already been opened
"RTN","HLOTCP",34,0)
 I $G(HLCSTATE("SERVER")),$G(HLCSTATE("LINK","SERVER"))="1^M",$G(LOGICAL)="" D  Q
"RTN","HLOTCP",35,0)
 .S HLCSTATE("DEVICE")=IO(0),HLCSTATE("FLUSH")="!",HLCSTATE("TCP BUFFER SIZE")=512
"RTN","HLOTCP",36,0)
 .S HLCSTATE("CONNECTED")=1
"RTN","HLOTCP",37,0)
 ;
"RTN","HLOTCP",38,0)
 ;if no IP, not a server, give DNS a shot
"RTN","HLOTCP",39,0)
 I '$G(HLCSTATE("SERVER")),IP="" S DNSFLAG=1,IP=$$DNS(HLCSTATE("LINK","DOMAIN")),HLCSTATE("LINK","IP")=IP Q:IP=""
"RTN","HLOTCP",40,0)
 ;
"RTN","HLOTCP",41,0)
RETRY ;
"RTN","HLOTCP",42,0)
 ;
"RTN","HLOTCP",43,0)
 I HLCSTATE("SYSTEM","OS")="DSM" D
"RTN","HLOTCP",44,0)
 .S HLCSTATE("TCP BUFFER SIZE")=512
"RTN","HLOTCP",45,0)
 .I $G(LOGICAL)]"" S HLCSTATE("DEVICE")=LOGICAL
"RTN","HLOTCP",46,0)
 .E  S HLCSTATE("DEVICE")=PORT
"RTN","HLOTCP",47,0)
 .S HLCSTATE("FLUSH")="!"
"RTN","HLOTCP",48,0)
 .I $G(HLCSTATE("SERVER")) D
"RTN","HLOTCP",49,0)
 ..O:$G(LOGICAL)]"" HLCSTATE("DEVICE"):(TCPDEV,BLOCKSIZE=512):HLCSTATE("OPEN TIMEOUT")
"RTN","HLOTCP",50,0)
 ..O:$G(LOGICAL)="" HLCSTATE("DEVICE"):(TCPCHAN,BLOCKSIZE=512):HLCSTATE("OPEN TIMEOUT")
"RTN","HLOTCP",51,0)
 ..I $T D
"RTN","HLOTCP",52,0)
 ...S HLCSTATE("CONNECTED")=1
"RTN","HLOTCP",53,0)
 ...U HLCSTATE("DEVICE"):NOECHO
"RTN","HLOTCP",54,0)
 .E  D  ;client
"RTN","HLOTCP",55,0)
 ..O HLCSTATE("DEVICE"):(TCPCHAN,ADDRESS=IP,BLOCKSIZE=512):HLCSTATE("OPEN TIMEOUT")
"RTN","HLOTCP",56,0)
 ..I $T D
"RTN","HLOTCP",57,0)
 ...S HLCSTATE("CONNECTED")=1
"RTN","HLOTCP",58,0)
 ...U HLCSTATE("DEVICE"):NOECHO
"RTN","HLOTCP",59,0)
 E  I HLCSTATE("SYSTEM","OS")="CACHE" D
"RTN","HLOTCP",60,0)
 .S HLCSTATE("FLUSH")="!"
"RTN","HLOTCP",61,0)
 .I $G(LOGICAL)]"" S HLCSTATE("DEVICE")=LOGICAL
"RTN","HLOTCP",62,0)
 .E  S HLCSTATE("DEVICE")="|TCP|"_PORT
"RTN","HLOTCP",63,0)
 .S HLCSTATE("TCP BUFFER SIZE")=512
"RTN","HLOTCP",64,0)
 .I $G(HLCSTATE("SERVER")) D
"RTN","HLOTCP",65,0)
 ..I HLCSTATE("SERVER")="1^S" D  Q
"RTN","HLOTCP",66,0)
 ...;single server (no concurrent connections)
"RTN","HLOTCP",67,0)
ZB25 ...;
"RTN","HLOTCP",68,0)
 ...O HLCSTATE("DEVICE"):(:PORT:"+A-S":::):HLCSTATE("OPEN TIMEOUT")
"RTN","HLOTCP",69,0)
 ...I $T D
"RTN","HLOTCP",70,0)
 ....N A
"RTN","HLOTCP",71,0)
ZB26 ....S HLCSTATE("CONNECTED")=1
"RTN","HLOTCP",72,0)
 ....U HLCSTATE("DEVICE")
"RTN","HLOTCP",73,0)
 ....F  R *A:HLCSTATE("READ TIMEOUT") Q:$T  I $$CHKSTOP^HLOPROC S HLCSTATE("CONNECTED")=0 D CLOSE(.HLCSTATE) Q
"RTN","HLOTCP",74,0)
ZB27 ....;
"RTN","HLOTCP",75,0)
 ...E  D
"RTN","HLOTCP",76,0)
ZB28 ....;
"RTN","HLOTCP",77,0)
 ..;multi-server spawned by OS - VMS TCP Services
"RTN","HLOTCP",78,0)
 ..O HLCSTATE("DEVICE")::HLCSTATE("OPEN TIMEOUT") I '$T S HLCSTATE("CONNECTED")=0 Q
"RTN","HLOTCP",79,0)
 ..S HLCSTATE("CONNECTED")=1
"RTN","HLOTCP",80,0)
 ..U HLCSTATE("DEVICE"):(::"-S")
"RTN","HLOTCP",81,0)
 ..;
"RTN","HLOTCP",82,0)
 .E  D  ;client
"RTN","HLOTCP",83,0)
 ..S HLCSTATE("TCP BUFFER SIZE")=512
"RTN","HLOTCP",84,0)
 ..O HLCSTATE("DEVICE"):(IP:PORT:"-S":::):HLCSTATE("OPEN TIMEOUT")
"RTN","HLOTCP",85,0)
 ..I $T D
"RTN","HLOTCP",86,0)
 ...S HLCSTATE("CONNECTED")=1
"RTN","HLOTCP",87,0)
 E  D  ;any other system but Cache or DSM
"RTN","HLOTCP",88,0)
 .S HLCSTATE("TCP BUFFER SIZE")=256
"RTN","HLOTCP",89,0)
 .D CALL^%ZISTCP(IP,PORT,HLCSTATE("OPEN TIMEOUT"))
"RTN","HLOTCP",90,0)
 .S HLCSTATE("CONNECTED")='POP
"RTN","HLOTCP",91,0)
 .I HLCSTATE("CONNECTED") S HLCSTATE("DEVICE")=IO
"RTN","HLOTCP",92,0)
 ;
"RTN","HLOTCP",93,0)
 ;if not connected, not the server, give DNS a shot if not tried already
"RTN","HLOTCP",94,0)
 I '$G(HLCSTATE("SERVER")),'HLCSTATE("CONNECTED"),'DNSFLAG S DNSFLAG=1,IP=$$DNS(HLCSTATE("LINK","DOMAIN")) I IP]"",IP'=HLCSTATE("LINK","IP") S HLCSTATE("LINK","IP")=IP Q:IP=""  G RETRY
"RTN","HLOTCP",95,0)
 ;
"RTN","HLOTCP",96,0)
 I HLCSTATE("CONNECTED"),DNSFLAG S $P(^HLCS(870,HLCSTATE("LINK","IEN"),400),"^")=IP
"RTN","HLOTCP",97,0)
 Q
"RTN","HLOTCP",98,0)
 ;
"RTN","HLOTCP",99,0)
DNS(DOMAIN) ;
"RTN","HLOTCP",100,0)
 Q $P($$ADDRESS^XLFNSLK(DOMAIN),",")
"RTN","HLOTCP",101,0)
 ;
"RTN","HLOTCP",102,0)
WRITEHDR(HLCSTATE,HDR) ;
"RTN","HLOTCP",103,0)
 ;
"RTN","HLOTCP",104,0)
 ;insure that package buffer is empty
"RTN","HLOTCP",105,0)
 K HLCSTATE("BUFFER")
"RTN","HLOTCP",106,0)
 S HLCSTATE("BUFFER","BYTE COUNT")=0
"RTN","HLOTCP",107,0)
 S HLCSTATE("BUFFER","SEGMENT COUNT")=0
"RTN","HLOTCP",108,0)
 ;
"RTN","HLOTCP",109,0)
 ;Start the message with <SB>, then write the header
"RTN","HLOTCP",110,0)
 N SEG
"RTN","HLOTCP",111,0)
 S SEG(1)=$C(11)_HDR(1)
"RTN","HLOTCP",112,0)
 S SEG(2)=HDR(2)
"RTN","HLOTCP",113,0)
 Q $$WRITESEG(.HLCSTATE,.SEG)
"RTN","HLOTCP",114,0)
 ;
"RTN","HLOTCP",115,0)
WRITESEG(HLCSTATE,SEG) ;
"RTN","HLOTCP",116,0)
 N I,LAST
"RTN","HLOTCP",117,0)
 S HLCSTATE("BUFFER","SEGMENT COUNT")=HLCSTATE("BUFFER","SEGMENT COUNT")+1
"RTN","HLOTCP",118,0)
 S I=0,LAST=$O(SEG(99999),-1)
"RTN","HLOTCP",119,0)
 F  S I=$O(SEG(I)) Q:'I  D
"RTN","HLOTCP",120,0)
 .I HLCSTATE("BUFFER","BYTE COUNT")>HLCSTATE("SYSTEM","BUFFER") D FLUSH
"RTN","HLOTCP",121,0)
 .I I=LAST S SEG(I)=SEG(I)_$C(13)
"RTN","HLOTCP",122,0)
 .S HLCSTATE("BUFFER",HLCSTATE("BUFFER","SEGMENT COUNT"),I)=SEG(I),HLCSTATE("BUFFER","BYTE COUNT")=HLCSTATE("BUFFER","BYTE COUNT")+$L(SEG(I))+20
"RTN","HLOTCP",123,0)
 Q HLCSTATE("CONNECTED")
"RTN","HLOTCP",124,0)
 ;
"RTN","HLOTCP",125,0)
FLUSH ;flushes the HL7 package buffer, and the system TCP buffer when full
"RTN","HLOTCP",126,0)
 N SEGMENT,MAX
"RTN","HLOTCP",127,0)
 S SEGMENT=0
"RTN","HLOTCP",128,0)
 ;
"RTN","HLOTCP",129,0)
 S MAX=HLCSTATE("TCP BUFFER SIZE")-2
"RTN","HLOTCP",130,0)
 ;
"RTN","HLOTCP",131,0)
 U HLCSTATE("DEVICE") I (HLCSTATE("SYSTEM","OS")="CACHE") S HLCSTATE("CONNECTED")=($ZA\8192#2) I 'HLCSTATE("CONNECTED") D CLOSE(.HLCSTATE)
"RTN","HLOTCP",132,0)
 F  S SEGMENT=$O(HLCSTATE("BUFFER",SEGMENT)) Q:'SEGMENT  D
"RTN","HLOTCP",133,0)
 .N I S I=0
"RTN","HLOTCP",134,0)
 .F  S I=$O(HLCSTATE("BUFFER",SEGMENT,I)) Q:'I  D
"RTN","HLOTCP",135,0)
 ..N LINE
"RTN","HLOTCP",136,0)
 ..S LINE=HLCSTATE("BUFFER",SEGMENT,I)
"RTN","HLOTCP",137,0)
 ..;put the line in the TCP buffer, or as much as will fit - flush the buffer when it gets full
"RTN","HLOTCP",138,0)
 ..F  Q:LINE=""  D
"RTN","HLOTCP",139,0)
 ...N INC
"RTN","HLOTCP",140,0)
 ...;INC is how much space is left in the buffer
"RTN","HLOTCP",141,0)
 ...S INC=MAX-HLCSTATE("TCP BUFFER $X")
"RTN","HLOTCP",142,0)
 ...I '($L(LINE)>INC) D
"RTN","HLOTCP",143,0)
 ....S HLCSTATE("TCP BUFFER")=HLCSTATE("TCP BUFFER")_LINE
"RTN","HLOTCP",144,0)
 ....S HLCSTATE("TCP BUFFER $X")=HLCSTATE("TCP BUFFER $X")+$L(LINE)
"RTN","HLOTCP",145,0)
 ....S LINE=""
"RTN","HLOTCP",146,0)
 ...E  D
"RTN","HLOTCP",147,0)
 ....S HLCSTATE("TCP BUFFER")=HLCSTATE("TCP BUFFER")_$E(LINE,1,INC)
"RTN","HLOTCP",148,0)
 ....S HLCSTATE("TCP BUFFER $X")=MAX
"RTN","HLOTCP",149,0)
 ....S LINE=$E(LINE,INC+1,99999)
"RTN","HLOTCP",150,0)
 ...I HLCSTATE("TCP BUFFER $X")=MAX D
"RTN","HLOTCP",151,0)
 ....W HLCSTATE("TCP BUFFER"),@HLCSTATE("FLUSH")
"RTN","HLOTCP",152,0)
 ....S HLCSTATE("TCP BUFFER")="",HLCSTATE("TCP BUFFER $X")=0
"RTN","HLOTCP",153,0)
 K HLCSTATE("BUFFER")
"RTN","HLOTCP",154,0)
 S HLCSTATE("BUFFER","SEGMENT COUNT")=1
"RTN","HLOTCP",155,0)
 S HLCSTATE("BUFFER","BYTE COUNT")=0
"RTN","HLOTCP",156,0)
 Q
"RTN","HLOTCP",157,0)
 ;
"RTN","HLOTCP",158,0)
READSEG(HLCSTATE,SEG) ;
"RTN","HLOTCP",159,0)
 ;
"RTN","HLOTCP",160,0)
 ;Output:
"RTN","HLOTCP",161,0)
 ;  SEG - returns the segment (pass by reference)
"RTN","HLOTCP",162,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOTCP",163,0)
 ;
"RTN","HLOTCP",164,0)
 K SEG
"RTN","HLOTCP",165,0)
 ;**START P139 CJM - if the header segment has been read, and <EB> is encountered before the <CR>, then accept whatever came before <EB> as a segment
"RTN","HLOTCP",166,0)
 Q:HLCSTATE("MESSAGE ENDED") 0
"RTN","HLOTCP",167,0)
 ;**END P139
"RTN","HLOTCP",168,0)
 ;
"RTN","HLOTCP",169,0)
 N SUCCESS,COUNT,BUF
"RTN","HLOTCP",170,0)
 S (COUNT,SUCCESS)=0
"RTN","HLOTCP",171,0)
 ;
"RTN","HLOTCP",172,0)
 ;anything left from last read?
"RTN","HLOTCP",173,0)
 S BUF=HLCSTATE("READ")
"RTN","HLOTCP",174,0)
 S HLCSTATE("READ")=""
"RTN","HLOTCP",175,0)
 I BUF]"" D  ;something was left!
"RTN","HLOTCP",176,0)
 .S COUNT=1
"RTN","HLOTCP",177,0)
 .I BUF[$C(13) D  Q
"RTN","HLOTCP",178,0)
 ..S SEG(1)=$P(BUF,$C(13)),BUF=$P(BUF,$C(13),2,999999)
"RTN","HLOTCP",179,0)
 ..S SUCCESS=1
"RTN","HLOTCP",180,0)
 .;**START P139 CJM
"RTN","HLOTCP",181,0)
 .I HLCSTATE("MESSAGE STARTED"),BUF[$C(28) D  Q
"RTN","HLOTCP",182,0)
 ..S SEG(1)=$P(BUF,$C(28)),BUF=$P(BUF,$C(28),2,999999)
"RTN","HLOTCP",183,0)
 ..S SUCCESS=1
"RTN","HLOTCP",184,0)
 ..S HLCSTATE("MESSAGE ENDED")=1
"RTN","HLOTCP",185,0)
 .;**END P139 CJM
"RTN","HLOTCP",186,0)
 .S SEG(1)=BUF,BUF=""
"RTN","HLOTCP",187,0)
 ;
"RTN","HLOTCP",188,0)
 ; *** Begin HL*1.6*146 - RBN ***
"RTN","HLOTCP",189,0)
 ;I 'SUCCESS U HLCSTATE("DEVICE") F  R BUF:HLCSTATE("READ TIMEOUT") Q:'$T D Q:SUCCESS
"RTN","HLOTCP",190,0)
 I 'SUCCESS U HLCSTATE("DEVICE") F  Q:'$$READ(.BUF)  D  Q:SUCCESS
"RTN","HLOTCP",191,0)
 .;** End HL*1.6*146 - RBN ***
"RTN","HLOTCP",192,0)
 .;
"RTN","HLOTCP",193,0)
 .I BUF[$C(13) S SUCCESS=1,COUNT=COUNT+1,SEG(COUNT)=$P(BUF,$C(13)),BUF=$P(BUF,$C(13),2,999999) Q
"RTN","HLOTCP",194,0)
 .;
"RTN","HLOTCP",195,0)
 .;**START P139 CJM
"RTN","HLOTCP",196,0)
 .I HLCSTATE("MESSAGE STARTED"),BUF[$C(28) S SUCCESS=1,HLCSTATE("MESSAGE ENDED")=1,COUNT=COUNT+1,SEG(COUNT)=$P(BUF,$C(28)),BUF=$P(BUF,$C(28),2,999999) Q
"RTN","HLOTCP",197,0)
 .;**END P139 CJM
"RTN","HLOTCP",198,0)
 .;
"RTN","HLOTCP",199,0)
 .S COUNT=COUNT+1,SEG(COUNT)=BUF
"RTN","HLOTCP",200,0)
 ;
"RTN","HLOTCP",201,0)
 I SUCCESS D
"RTN","HLOTCP",202,0)
 .S HLCSTATE("READ")=BUF ;save the leftover
"RTN","HLOTCP",203,0)
 .I COUNT>1,SEG(COUNT)="" K SEG(COUNT) S COUNT=COUNT-1
"RTN","HLOTCP",204,0)
 ;Cache can return the connection status
"RTN","HLOTCP",205,0)
 E  I (HLCSTATE("SYSTEM","OS")="CACHE") S HLCSTATE("CONNECTED")=($ZA\8192#2) I 'HLCSTATE("CONNECTED") D CLOSE(.HLCSTATE)
"RTN","HLOTCP",206,0)
 ;
"RTN","HLOTCP",207,0)
 ;if the <EB> character was encountered, then there are no more segments in the message, set the end of message flag
"RTN","HLOTCP",208,0)
 I SUCCESS,SEG(COUNT)[$C(28) D
"RTN","HLOTCP",209,0)
 .K SEG
"RTN","HLOTCP",210,0)
 .S SUCCESS=0
"RTN","HLOTCP",211,0)
 .S HLCSTATE("MESSAGE ENDED")=1
"RTN","HLOTCP",212,0)
 Q SUCCESS
"RTN","HLOTCP",213,0)
 ;
"RTN","HLOTCP",214,0)
READHDR(HLCSTATE,HDR) ;
"RTN","HLOTCP",215,0)
 ;reads the next header segment in the message stream, discarding everything that comes before it
"RTN","HLOTCP",216,0)
 ;
"RTN","HLOTCP",217,0)
 N SEG,SUCCESS,J,I
"RTN","HLOTCP",218,0)
 S SUCCESS=0
"RTN","HLOTCP",219,0)
 K HDR
"RTN","HLOTCP",220,0)
 F  Q:'$$READSEG(.HLCSTATE,.SEG)  D  Q:SUCCESS
"RTN","HLOTCP",221,0)
 .S I=0
"RTN","HLOTCP",222,0)
 .;look for the <SB>
"RTN","HLOTCP",223,0)
 .;perhaps the <SB> isn't in the first line
"RTN","HLOTCP",224,0)
 .F  S I=$O(SEG(I)) Q:'I  D  Q:SUCCESS
"RTN","HLOTCP",225,0)
 ..I (SEG(I)'[$C(11)) K SEG(I) Q
"RTN","HLOTCP",226,0)
 ..S SEG(I)=$P(SEG(I),$C(11),2)
"RTN","HLOTCP",227,0)
 ..S SUCCESS=1
"RTN","HLOTCP",228,0)
 ..K:SEG(I)="" SEG(I)
"RTN","HLOTCP",229,0)
 I SUCCESS S (I,J)=0 F  S J=$O(SEG(J)) Q:'J  S I=I+1,HDR(I)=SEG(J)
"RTN","HLOTCP",230,0)
 Q SUCCESS
"RTN","HLOTCP",231,0)
 ;
"RTN","HLOTCP",232,0)
CLOSE(HLCSTATE) ;
"RTN","HLOTCP",233,0)
 CLOSE HLCSTATE("DEVICE")
"RTN","HLOTCP",234,0)
 ;**P146 START CJM
"RTN","HLOTCP",235,0)
 I $G(HLCSTATE("READ TIMEOUT","CHANGED")) D PUTTIME(.HLCSTATE)
"RTN","HLOTCP",236,0)
 ;**P146 END CJM
"RTN","HLOTCP",237,0)
 Q
"RTN","HLOTCP",238,0)
 ;
"RTN","HLOTCP",239,0)
ENDMSG(HLCSTATE)        ;
"RTN","HLOTCP",240,0)
 N SEG
"RTN","HLOTCP",241,0)
 S SEG(1)=$C(28)
"RTN","HLOTCP",242,0)
 I $$WRITESEG(.HLCSTATE,.SEG) D  Q 1
"RTN","HLOTCP",243,0)
 .D FLUSH
"RTN","HLOTCP",244,0)
 .I HLCSTATE("TCP BUFFER $X") D
"RTN","HLOTCP",245,0)
 ..U HLCSTATE("DEVICE")
"RTN","HLOTCP",246,0)
 ..W HLCSTATE("TCP BUFFER"),@HLCSTATE("FLUSH")
"RTN","HLOTCP",247,0)
 ..S HLCSTATE("TCP BUFFER")=""
"RTN","HLOTCP",248,0)
 ..S HLCSTATE("TCP BUFFER $X")=0
"RTN","HLOTCP",249,0)
 Q 0
"RTN","HLOTCP",250,0)
 ;
"RTN","HLOTCP",251,0)
 ;**P146 START CJM
"RTN","HLOTCP",252,0)
READ(BUF) ;
"RTN","HLOTCP",253,0)
 ;Performs a READ to BUF and returns the $T result as the function value.
"RTN","HLOTCP",254,0)
 ;For client reads the timeout value is dynamically adjusted based
"RTN","HLOTCP",255,0)
 ;on a random sample. For server reads the timeout is static.
"RTN","HLOTCP",256,0)
 ;
"RTN","HLOTCP",257,0)
 ;for the server the timeout is static
"RTN","HLOTCP",258,0)
 I $G(HLCSTATE("SERVER")) R BUF:HLCSTATE("READ TIMEOUT") Q $T
"RTN","HLOTCP",259,0)
 ;
"RTN","HLOTCP",260,0)
 N RETURN
"RTN","HLOTCP",261,0)
 I ($R(100)<10) D  Q RETURN
"RTN","HLOTCP",262,0)
 .;measure how long the READ really takes
"RTN","HLOTCP",263,0)
 . N T1,T2
"RTN","HLOTCP",264,0)
 . S T1=$$NOW^XLFDT
"RTN","HLOTCP",265,0)
 . R BUF:100
"RTN","HLOTCP",266,0)
 .I $T D
"RTN","HLOTCP",267,0)
 ..S RETURN=1
"RTN","HLOTCP",268,0)
 ..S T2=$$NOW^XLFDT
"RTN","HLOTCP",269,0)
 ..D SETTIME($$FMDIFF^XLFDT(T2,T1,2))
"RTN","HLOTCP",270,0)
 .E  D
"RTN","HLOTCP",271,0)
 ..S RETURN=0
"RTN","HLOTCP",272,0)
 E  R BUF:HLCSTATE("READ TIMEOUT") Q $T
"RTN","HLOTCP",273,0)
 ;
"RTN","HLOTCP",274,0)
 Q RETURN
"RTN","HLOTCP",275,0)
 ;
"RTN","HLOTCP",276,0)
SETTIME(TIME) ;
"RTN","HLOTCP",277,0)
 ;Re-sets the Read Timeout based on an algorithm that uses the
"RTN","HLOTCP",278,0)
 ;new read time + the prior 4 historical values.
"RTN","HLOTCP",279,0)
 ;
"RTN","HLOTCP",280,0)
 N MAX,I,TEMP
"RTN","HLOTCP",281,0)
 S HLCSTATE("READ TIMEOUT","HISTORICAL")=TIME_"^"_$P(HLCSTATE("READ TIMEOUT","HISTORICAL"),"^",1,4)
"RTN","HLOTCP",282,0)
 S MAX=0
"RTN","HLOTCP",283,0)
 F I=1:1:5 S TEMP=$P(HLCSTATE("READ TIMEOUT","HISTORICAL"),"^",I) I TEMP>MAX S MAX=TEMP
"RTN","HLOTCP",284,0)
 S TEMP=MAX+5
"RTN","HLOTCP",285,0)
 I TEMP<20 S TEMP=20
"RTN","HLOTCP",286,0)
 I TEMP>60 S TEMP=60
"RTN","HLOTCP",287,0)
 S HLCSTATE("READ TIMEOUT")=TEMP
"RTN","HLOTCP",288,0)
 S HLCSTATE("READ TIMEOUT","CHANGED")=1
"RTN","HLOTCP",289,0)
 Q
"RTN","HLOTCP",290,0)
 ;
"RTN","HLOTCP",291,0)
GETTIME(HLCSTATE) ;
"RTN","HLOTCP",292,0)
 ;Gets from ^HLTMP the current read timeout for the client link and the
"RTN","HLOTCP",293,0)
 ;historical data that the timeout value is based on.
"RTN","HLOTCP",294,0)
 N DATA
"RTN","HLOTCP",295,0)
 S DATA=$G(^HLTMP("READ TIMEOUT",HLCSTATE("LINK","NAME")))
"RTN","HLOTCP",296,0)
 I $P(DATA,"^")<20 D
"RTN","HLOTCP",297,0)
 .S HLCSTATE("READ TIMEOUT")=20
"RTN","HLOTCP",298,0)
 E  D
"RTN","HLOTCP",299,0)
 .S HLCSTATE("READ TIMEOUT")=$P(DATA,"^")
"RTN","HLOTCP",300,0)
 S HLCSTATE("READ TIMEOUT","HISTORICAL")=$P(DATA,"^",2,6)
"RTN","HLOTCP",301,0)
 S HLCSTATE("READ TIMEOUT","CHANGED")=0
"RTN","HLOTCP",302,0)
 Q
"RTN","HLOTCP",303,0)
 ;
"RTN","HLOTCP",304,0)
PUTTIME(HLCSTATE) ;
"RTN","HLOTCP",305,0)
 ;Stores to ^HLTMP the current read timeout for the client link and
"RTN","HLOTCP",306,0)
 ;the historical data that the timeout value is based on.
"RTN","HLOTCP",307,0)
 S ^HLTMP("READ TIMEOUT",HLCSTATE("LINK","NAME"))=HLCSTATE("READ TIMEOUT")_"^"_HLCSTATE("READ TIMEOUT","HISTORICAL")
"RTN","HLOTCP",308,0)
 Q
"RTN","HLOTCP",309,0)
 ;**P146 END CJM
"RTN","HLOTLNK")
0^20^B26226165^B25754770
"RTN","HLOTLNK",1,0)
HLOTLNK ;IRMFO-ALB/CJM - APIs for the HL Logical Link file;03/24/2004  14:43 ;08/17/2009
"RTN","HLOTLNK",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,130,131,139,146**;Oct 13, 1995;Build 16
"RTN","HLOTLNK",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOTLNK",4,0)
 ;
"RTN","HLOTLNK",5,0)
SETSHUT(LINKIEN) ;
"RTN","HLOTLNK",6,0)
 ;sets the shutdown flag (can not fail - if the link doesn't exist, by definition its shutdown)
"RTN","HLOTLNK",7,0)
 Q:'$G(LINKIEN) 1
"RTN","HLOTLNK",8,0)
 Q:'$D(^HLCS(870,LINKIEN,0)) 1
"RTN","HLOTLNK",9,0)
 S $P(^HLCS(870,LINKIEN,0),"^",16)=1
"RTN","HLOTLNK",10,0)
 Q 1
"RTN","HLOTLNK",11,0)
SETOPEN(LINKIEN) ;
"RTN","HLOTLNK",12,0)
 ;clears the shutdown flag, returns 1 on success, 0 on failure
"RTN","HLOTLNK",13,0)
 Q:'$G(LINKIEN) 0
"RTN","HLOTLNK",14,0)
 Q:'$D(^HLCS(870,LINKIEN,0)) 0
"RTN","HLOTLNK",15,0)
 S $P(^HLCS(870,LINKIEN,0),"^",16)=""
"RTN","HLOTLNK",16,0)
 Q 1
"RTN","HLOTLNK",17,0)
 ;
"RTN","HLOTLNK",18,0)
IFSHUT(LINKNAME) ;
"RTN","HLOTLNK",19,0)
 ;returns 1 if the link was shut down to HLO
"RTN","HLOTLNK",20,0)
 N IEN,LINK,RET
"RTN","HLOTLNK",21,0)
 S RET=0
"RTN","HLOTLNK",22,0)
 S LINK=$P($G(LINKNAME),":")
"RTN","HLOTLNK",23,0)
 ;** Start HL*1.6*139 RBN **
"RTN","HLOTLNK",24,0)
 ;Q:LINK=""
"RTN","HLOTLNK",25,0)
 Q:LINK="" 1
"RTN","HLOTLNK",26,0)
 ;** END HL*1.6*139 RBN **
"RTN","HLOTLNK",27,0)
 S IEN=$O(^HLCS(870,"B",LINK,0))
"RTN","HLOTLNK",28,0)
 Q:'IEN 1
"RTN","HLOTLNK",29,0)
 S:$P($G(^HLCS(870,IEN,0)),"^",16) RET=1
"RTN","HLOTLNK",30,0)
ZB0 Q RET
"RTN","HLOTLNK",31,0)
 ;
"RTN","HLOTLNK",32,0)
DOMAIN(LINKIEN) ;
"RTN","HLOTLNK",33,0)
 ;Returns the domain associated with this link
"RTN","HLOTLNK",34,0)
 ;
"RTN","HLOTLNK",35,0)
 Q:'$G(LINKIEN) ""
"RTN","HLOTLNK",36,0)
 N NODE,DOMAIN
"RTN","HLOTLNK",37,0)
 S DOMAIN=""
"RTN","HLOTLNK",38,0)
 S NODE=$G(^HLCS(870,LINKIEN,0))
"RTN","HLOTLNK",39,0)
 I $P(NODE,"^",7) D
"RTN","HLOTLNK",40,0)
 .S DOMAIN=$P($G(^DIC(4.2,$P(NODE,"^",7),0)),"^")
"RTN","HLOTLNK",41,0)
 .S DOMAIN=$S($L(DOMAIN):"HL7."_DOMAIN,1:"")
"RTN","HLOTLNK",42,0)
 I '$L(DOMAIN) S DOMAIN=$P(NODE,"^",8)
"RTN","HLOTLNK",43,0)
 Q DOMAIN
"RTN","HLOTLNK",44,0)
 ;
"RTN","HLOTLNK",45,0)
PORT(LINKIEN) ;
"RTN","HLOTLNK",46,0)
 ;Returns the HLO port associated with this link
"RTN","HLOTLNK",47,0)
 ;
"RTN","HLOTLNK",48,0)
 Q:'$G(LINKIEN) ""
"RTN","HLOTLNK",49,0)
 N NODE,PORT
"RTN","HLOTLNK",50,0)
 S NODE=$G(^HLCS(870,LINKIEN,400))
"RTN","HLOTLNK",51,0)
 S PORT=$P(NODE,"^",8)
"RTN","HLOTLNK",52,0)
 S:'PORT PORT=$S($P($G(^HLD(779.1,1,0)),"^",3)="P":5001,1:5026)
"RTN","HLOTLNK",53,0)
 Q PORT
"RTN","HLOTLNK",54,0)
 ;
"RTN","HLOTLNK",55,0)
PORT2(LINKNAME) ;given the name of the link, returns its HLO port
"RTN","HLOTLNK",56,0)
 N PORT
"RTN","HLOTLNK",57,0)
 Q:'$L(LINKNAME) ""
"RTN","HLOTLNK",58,0)
 S PORT=$$PORT($O(^HLCS(870,"B",LINKNAME,0)))
"RTN","HLOTLNK",59,0)
 Q:'$L(PORT) ""
"RTN","HLOTLNK",60,0)
 Q PORT
"RTN","HLOTLNK",61,0)
 ;
"RTN","HLOTLNK",62,0)
STATNUM(LINKIEN) ;
"RTN","HLOTLNK",63,0)
 ;Given the ien of the link, this function returns the station #.
"RTN","HLOTLNK",64,0)
 ;
"RTN","HLOTLNK",65,0)
 Q:'$G(LINKIEN) ""
"RTN","HLOTLNK",66,0)
 N INST
"RTN","HLOTLNK",67,0)
 S INST=$P($G(^HLCS(870,LINKIEN,0)),"^",2)
"RTN","HLOTLNK",68,0)
 Q:'INST ""
"RTN","HLOTLNK",69,0)
 Q $P($G(^DIC(4,INST,99)),"^")
"RTN","HLOTLNK",70,0)
 ;
"RTN","HLOTLNK",71,0)
FINDLINK(STATN) ;
"RTN","HLOTLNK",72,0)
 ;Returns the link ien based on the station # =STATN
"RTN","HLOTLNK",73,0)
 ;The link found must have a name starting with "VA", as these are
"RTN","HLOTLNK",74,0)
 ;reserved for officially released links associated with VHA institutions
"RTN","HLOTLNK",75,0)
 ;** EXCEPTION** MPIVA is an official link associated with 200M
"RTN","HLOTLNK",76,0)
 ;
"RTN","HLOTLNK",77,0)
 Q:'$L($G(STATN)) 0
"RTN","HLOTLNK",78,0)
 ;
"RTN","HLOTLNK",79,0)
 N NAME,IEN
"RTN","HLOTLNK",80,0)
 S (NAME,IEN)=""
"RTN","HLOTLNK",81,0)
 F  S NAME=$O(^HLCS(870,"AC",STATN,NAME)) Q:NAME=""  I (NAME'="VA-VIE"),($E(NAME,1,2)="VA")!(NAME="MPIVA") S IEN=$O(^HLCS(870,"AC",STATN,NAME,0)) Q
"RTN","HLOTLNK",82,0)
 Q IEN
"RTN","HLOTLNK",83,0)
 ;
"RTN","HLOTLNK",84,0)
GETLINK(LINKNAME,LINK) ;
"RTN","HLOTLNK",85,0)
 N IEN
"RTN","HLOTLNK",86,0)
 Q:'$L(LINKNAME) 0
"RTN","HLOTLNK",87,0)
 S IEN=$O(^HLCS(870,"B",LINKNAME,0))
"RTN","HLOTLNK",88,0)
 I IEN Q $$GET(IEN,.LINK)
"RTN","HLOTLNK",89,0)
 I LINKNAME="HLO DEFAULT LISTENER" D  Q 1
"RTN","HLOTLNK",90,0)
 .N NODE
"RTN","HLOTLNK",91,0)
 .S LINK("NAME")=LINKNAME
"RTN","HLOTLNK",92,0)
 .S LINK("IEN")=0
"RTN","HLOTLNK",93,0)
 .S LINK("SHUTDOWN")=""
"RTN","HLOTLNK",94,0)
 .S LINK("LLP")="TCP"
"RTN","HLOTLNK",95,0)
 .S LINK("SERVER")="1^"_"M"
"RTN","HLOTLNK",96,0)
 .S NODE=$G(^HLD(779.1,1,0))
"RTN","HLOTLNK",97,0)
 .S LINK("DOMAIN")=$P(NODE,"^",1)
"RTN","HLOTLNK",98,0)
 .S LINK("PORT")=$S($P(NODE,"^",3)="P":5001,$P(NODE,"^",3)="T":5026,1:"")
"RTN","HLOTLNK",99,0)
 .S LINK("IP")=""
"RTN","HLOTLNK",100,0)
 Q 0
"RTN","HLOTLNK",101,0)
GET(IEN,LINK) ;
"RTN","HLOTLNK",102,0)
 N NODE,PTR
"RTN","HLOTLNK",103,0)
 K LINK
"RTN","HLOTLNK",104,0)
 S NODE=$G(^HLCS(870,IEN,0))
"RTN","HLOTLNK",105,0)
 Q:NODE="" 0
"RTN","HLOTLNK",106,0)
 S LINK("NAME")=$P(NODE,"^")
"RTN","HLOTLNK",107,0)
 S LINK("IEN")=IEN
"RTN","HLOTLNK",108,0)
 S LINK("SHUTDOWN")=+$P(NODE,"^",16)
"RTN","HLOTLNK",109,0)
 I $P(NODE,"^",7) D
"RTN","HLOTLNK",110,0)
 .S LINK("DOMAIN")=$P(^DIC(4.2,$P(NODE,"^",7),0),"^")
"RTN","HLOTLNK",111,0)
 .S LINK("DOMAIN")=$S($L(LINK("DOMAIN")):"HL7."_LINK("DOMAIN"),1:"")
"RTN","HLOTLNK",112,0)
 I $G(LINK("DOMAIN"))="" S LINK("DOMAIN")=$P(NODE,"^",8)
"RTN","HLOTLNK",113,0)
 S PTR=$P(NODE,"^",3)
"RTN","HLOTLNK",114,0)
 S LINK("LLP")=$S('PTR:"",1:$P($G(^HLCS(869.1,PTR,0)),"^"))
"RTN","HLOTLNK",115,0)
 S LINK("SERVER")=""
"RTN","HLOTLNK",116,0)
 I LINK("LLP")="TCP" D
"RTN","HLOTLNK",117,0)
 .S LINK("SERVER")=1
"RTN","HLOTLNK",118,0)
 .S NODE=$G(^HLCS(870,IEN,400))
"RTN","HLOTLNK",119,0)
 .S LINK("IP")=$P(NODE,"^")
"RTN","HLOTLNK",120,0)
 .S LINK("PORT")=$P(NODE,"^",8)
"RTN","HLOTLNK",121,0)
 .S:'LINK("PORT") LINK("PORT")=$S($P($G(^HLD(779.1,1,0)),"^",3)="P":5001,1:5026)
"RTN","HLOTLNK",122,0)
 .S:$P(NODE,"^",3)="C" LINK("SERVER")=0
"RTN","HLOTLNK",123,0)
 .I LINK("SERVER") S LINK("SERVER")=LINK("SERVER")_"^"_$P(NODE,"^",3)
"RTN","HLOTLNK",124,0)
 Q 1
"RTN","HLOTLNK",125,0)
 ;
"RTN","HLOTLNK",126,0)
SET1(LINK,MDOMAIN) ;
"RTN","HLOTLNK",127,0)
 N DOMAIN
"RTN","HLOTLNK",128,0)
 Q:'$L(MDOMAIN)
"RTN","HLOTLNK",129,0)
 S DOMAIN=$P($G(^DIC(4.2,MDOMAIN,0)),"^")
"RTN","HLOTLNK",130,0)
 S DOMAIN=$S($L(DOMAIN):"HL7."_DOMAIN,1:"")
"RTN","HLOTLNK",131,0)
 I DOMAIN'="" S ^HLCS(870,"AD","TCP",DOMAIN,LINK)=""
"RTN","HLOTLNK",132,0)
 Q
"RTN","HLOTLNK",133,0)
KILL1(LINK,MDOMAIN) ;
"RTN","HLOTLNK",134,0)
 N DOMAIN
"RTN","HLOTLNK",135,0)
 Q:'$L(MDOMAIN)
"RTN","HLOTLNK",136,0)
 S DOMAIN=$P($G(^DIC(4.2,MDOMAIN,0)),"^")
"RTN","HLOTLNK",137,0)
 S DOMAIN=$S($L(DOMAIN):"HL7."_DOMAIN,1:"")
"RTN","HLOTLNK",138,0)
 I DOMAIN'="" K ^HLCS(870,"AD","TCP",DOMAIN,LINK)
"RTN","HLOTLNK",139,0)
 Q
"RTN","HLOTLNK",140,0)
SET2(LINK,DOMAIN) ;
"RTN","HLOTLNK",141,0)
 I DOMAIN'="" S ^HLCS(870,"AD","TCP",DOMAIN,LINK)=""
"RTN","HLOTLNK",142,0)
 Q
"RTN","HLOTLNK",143,0)
KILL2(LINK,DOMAIN) ;
"RTN","HLOTLNK",144,0)
 I DOMAIN'="" K ^HLCS(870,"AD","TCP",DOMAIN,LINK)
"RTN","HLOTLNK",145,0)
 Q
"RTN","HLOTLNK",146,0)
SET3(LINK,DEVICE) ;
"RTN","HLOTLNK",147,0)
 Q:'DEVICE
"RTN","HLOTLNK",148,0)
 S ^HLCS(870,"AD","HLLP",DEVICE,LINK)=""
"RTN","HLOTLNK",149,0)
 Q
"RTN","HLOTLNK",150,0)
KILL3(LINK,DEVICE) ;
"RTN","HLOTLNK",151,0)
 Q:'DEVICE
"RTN","HLOTLNK",152,0)
 S ^HLCS(870,"AD","HLLP",DEVICE,LINK)=""
"RTN","HLOTLNK",153,0)
 Q
"RTN","HLOTLNK",154,0)
LLP(LINKNAME) ;
"RTN","HLOTLNK",155,0)
 ;finds the type of LLP for a named link
"RTN","HLOTLNK",156,0)
 N IEN,LLP
"RTN","HLOTLNK",157,0)
 S IEN=$O(^HLCS(870,"B",LINKNAME,0))
"RTN","HLOTLNK",158,0)
 Q:'IEN ""
"RTN","HLOTLNK",159,0)
 S LLP=$P($G(^HLCS(870,IEN,0)),"^",3)
"RTN","HLOTLNK",160,0)
 Q:'LLP ""
"RTN","HLOTLNK",161,0)
 Q $P($G(^HLCS(869.1,LLP,0)),"^")
"RTN","HLOTLNK",162,0)
 ;
"RTN","HLOTLNK",163,0)
DEVICE(LINKNAME) ;
"RTN","HLOTLNK",164,0)
 N IEN
"RTN","HLOTLNK",165,0)
 S IEN=$O(^HLCS(870,"B",LINKNAME,0))
"RTN","HLOTLNK",166,0)
 Q:'IEN ""
"RTN","HLOTLNK",167,0)
 Q $P($G(^HLCS(870,IEN,200)),"^")
"RTN","HLOTLNK",168,0)
 ;
"RTN","HLOTLNK",169,0)
RTRNLNK(COMP1,COMP2,COMP3) ;
"RTN","HLOTLNK",170,0)
 ;based on the sending facility from the original header, this function finds the return link, or "" if not successful
"RTN","HLOTLNK",171,0)
 ;Inputs:
"RTN","HLOTLNK",172,0)
 ;  COMP1,COMP2,COMP3 - 3 components of the sending facility from the original message
"RTN","HLOTLNK",173,0)
 ;
"RTN","HLOTLNK",174,0)
 N LINK,IEN
"RTN","HLOTLNK",175,0)
 S LINK=""
"RTN","HLOTLNK",176,0)
 I $G(COMP3)="DNS",$P($G(COMP2),":")]"" S LINK=$O(^HLCS(870,"AD","TCP",$P(COMP2,":"),""))
"RTN","HLOTLNK",177,0)
 I LINK="",$L($G(COMP1)) S IEN=$$FINDLINK(COMP1) S:IEN LINK=$P($G(^HLCS(870,IEN,0)),"^")
"RTN","HLOTLNK",178,0)
 Q LINK
"RTN","HLOTLNK",179,0)
 ;
"RTN","HLOTLNK",180,0)
 ;HLLP is not implemented in HLO
"RTN","HLOTLNK",181,0)
 ;I LLP="HLLP" N DEVICE S DEVICE=$$DEVICE(FROMLINK) I DEVICE Q $O(^HLCS(870,"AD","TCP",DEVICE,""))
"RTN","HLOTLNK",182,0)
 ;Q ""
"RTN","HLOTLNK",183,0)
 ;
"RTN","HLOTLNK",184,0)
CHKLINK(LINK) ;
"RTN","HLOTLNK",185,0)
 Q:'$L(LINK) 0
"RTN","HLOTLNK",186,0)
 Q:'$O(^HLCS(870,"B",LINK,0)) 0
"RTN","HLOTLNK",187,0)
 Q 1
"RTN","HLOTRACE")
0^21^B65294426^n/a
"RTN","HLOTRACE",1,0)
HLOTRACE ;;OIFO-OAK/PIJ/CJM ;08/17/2009
"RTN","HLOTRACE",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**146** ;Oct 13, 1995;Build 16
"RTN","HLOTRACE",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOTRACE",4,0)
 ;;
"RTN","HLOTRACE",5,0)
 ;; HLO CLIENT TRACE Tool
"RTN","HLOTRACE",6,0)
 ;; *** For troubleshooting HLO client issues ***
"RTN","HLOTRACE",7,0)
 ;;     Client runs in the foreground and writes trace statements
"RTN","HLOTRACE",8,0)
 ;;     to the screen.
"RTN","HLOTRACE",9,0)
 ;; 
"RTN","HLOTRACE",10,0)
START ;
"RTN","HLOTRACE",11,0)
 N CONF
"RTN","HLOTRACE",12,0)
 I '$G(DUZ) W !,"Your DUZ must be set!" Q
"RTN","HLOTRACE",13,0)
 D OWNSKEY^XUSRB(.CONF,"XUPROG",DUZ)
"RTN","HLOTRACE",14,0)
 I 'CONF(0) D  Q
"RTN","HLOTRACE",15,0)
 . W !!,"   Sorry, you are not authorized to use this tool.",!!
"RTN","HLOTRACE",16,0)
 ;I $P($$VERSION^%ZOSV(1),"/",1)'="Cache for OpenVMS" D  Q
"RTN","HLOTRACE",17,0)
 I $P($$VERSION^%ZOSV(1),"/",1)'["Cache" D  Q
"RTN","HLOTRACE",18,0)
 . W !!,"   Sorry, this tool can only be used under Cache",!!
"RTN","HLOTRACE",19,0)
 N LINK,PORT,QUE,SUB,WORK,HLMSTATE,HLCSTATE,OLD,MAXTRACE,TRACECNT
"RTN","HLOTRACE",20,0)
 S LINK=$$ASKLINK^HLOUSR
"RTN","HLOTRACE",21,0)
 Q:LINK=""
"RTN","HLOTRACE",22,0)
 S PORT=$$ASKPORT(LINK)
"RTN","HLOTRACE",23,0)
 Q:'PORT
"RTN","HLOTRACE",24,0)
 S SUB=LINK_":"_PORT
"RTN","HLOTRACE",25,0)
 S QUE=$$ASKQUE(SUB)
"RTN","HLOTRACE",26,0)
 Q:QUE=""
"RTN","HLOTRACE",27,0)
 ZB /INTERRUPT:NORMAL ;disable CTRL-C breaks
"RTN","HLOTRACE",28,0)
 L +^HLB("QUEUE","OUT",SUB,QUE):20
"RTN","HLOTRACE",29,0)
 ;
"RTN","HLOTRACE",30,0)
 I '$T W !,"That queue is currently being processed. You need to either stop that link,",!,"stop that queue, or totally stop HLO so that this tool can be used." Q
"RTN","HLOTRACE",31,0)
 I '$O(^HLB("QUEUE","OUT",SUB,QUE,0)) W !,"There are no messages pending on that queue!" Q
"RTN","HLOTRACE",32,0)
 S TRACECNT=0
"RTN","HLOTRACE",33,0)
 S MAXTRACE=$$ASKCOUNT
"RTN","HLOTRACE",34,0)
 Q:(MAXTRACE<1)
"RTN","HLOTRACE",35,0)
 S WORK("QUEUE")=QUE,WORK("LINK")=SUB
"RTN","HLOTRACE",36,0)
 D SETBREAKS
"RTN","HLOTRACE",37,0)
 D DOWORK^HLOCLNT(.WORK)
"RTN","HLOTRACE",38,0)
 D:$G(HLCSTATE("CONNECTED")) CLOSE^HLOT(.HLCSTATE)
"RTN","HLOTRACE",39,0)
 ;
"RTN","HLOTRACE",40,0)
 U $PRINCIPAL
"RTN","HLOTRACE",41,0)
 L -^HLB("QUEUE","OUT",SUB,QUE)
"RTN","HLOTRACE",42,0)
 ZB /CLEAR
"RTN","HLOTRACE",43,0)
 W !,"DONE!"
"RTN","HLOTRACE",44,0)
 ;
"RTN","HLOTRACE",45,0)
 Q
"RTN","HLOTRACE",46,0)
SETBREAKS ;
"RTN","HLOTRACE",47,0)
 ZB /CLEAR
"RTN","HLOTRACE",48,0)
 ;
"RTN","HLOTRACE",49,0)
 ;set break in $$STOPPED^HLOQUE to circumvent shutdown of the queue
"RTN","HLOTRACE",50,0)
 ZB ZB0^HLOQUE:"N":1:"S RET=0"
"RTN","HLOTRACE",51,0)
 ;set break in $$IFSHUT^HLOTLNK to circumvent shutdown of the link
"RTN","HLOTRACE",52,0)
 ZB ZB0^HLOTLNK:"N":1:"S RET=0"
"RTN","HLOTRACE",53,0)
 ;set break at ZB0 in client (start of DOWORK)
"RTN","HLOTRACE",54,0)
 ZB ZB0^HLOCLNT:"N":1:"D WRITE^HLOTRACE(""Launching the client process..."")"
"RTN","HLOTRACE",55,0)
 ;set break at ZB1 in client ($$CONNECT)
"RTN","HLOTRACE",56,0)
 ZB ZB1^HLOCLNT1:"N":1:"D WRITE^HLOTRACE(""Trying to connect..."")"
"RTN","HLOTRACE",57,0)
 ;set break at ZB2 in client (end of $$CONNECT)
"RTN","HLOTRACE",58,0)
 ZB ZB2^HLOCLNT1:"N":1:"D ZB2^HLOTRACE"
"RTN","HLOTRACE",59,0)
 ;set break at ZB3 in client (ERROR TRAP)
"RTN","HLOTRACE",60,0)
 ZB ZB3^HLOCLNT:"N":1:"D ZB3^HLOTRACE"
"RTN","HLOTRACE",61,0)
 ;set break at ZB4 in client (FOR loop on the outgoing queue)
"RTN","HLOTRACE",62,0)
 ZB ZB4^HLOCLNT:"N":1:"D ZB4^HLOTRACE"
"RTN","HLOTRACE",63,0)
 ;set break at ZB5 in client (end of DOWORK, with just cleanup left)
"RTN","HLOTRACE",64,0)
 ZB ZB5^HLOCLNT:"N":1:"D WRITE3^HLOTRACE(""Cleaning up...."")"
"RTN","HLOTRACE",65,0)
 ;set break at ZB6 in client (start of $$TRANSMIT^HLOCLNT1)
"RTN","HLOTRACE",66,0)
 ZB ZB6^HLOCLNT1:"N":1:"D WRITE^HLOTRACE(""Beginning to transmit message...."")"
"RTN","HLOTRACE",67,0)
 ;set break at ZB7 in client (end of $$TRANSMIT^HLOCLNT1)
"RTN","HLOTRACE",68,0)
 ZB ZB7^HLOCLNT1:"N":1:"D WRITE^HLOTRACE(""Message transmitted!"")"
"RTN","HLOTRACE",69,0)
 ;set break at ZB8 in client (start of $$READACK^HLOCLNT1)
"RTN","HLOTRACE",70,0)
 ZB ZB8^HLOCLNT1:"N":1:"D WRITE^HLOTRACE(""Beginning to read commit acknowledgment...."")"
"RTN","HLOTRACE",71,0)
 ;set break at ZB9 in client (end of $$READACK^HLOCLNT1)
"RTN","HLOTRACE",72,0)
 ;ZB ZB9^HLOCLNT1:"N":1:"D WRITE^HLOTRACE(""Commit acknowledgment received!"")"
"RTN","HLOTRACE",73,0)
 ZB ZB9^HLOCLNT1:"N":1:"D ZB9^HLOTRACE"
"RTN","HLOTRACE",74,0)
 ;set break ZB10 in the client(start of $$READHDR^HLOT)
"RTN","HLOTRACE",75,0)
 ZB ZB10^HLOT:"N":1:"D ZB10^HLOTRACE"
"RTN","HLOTRACE",76,0)
 ;set break ZB11 in the client(end of $$READHDR^HLOT)
"RTN","HLOTRACE",77,0)
 ZB ZB11^HLOT:"N":1:"D ZB11^HLOTRACE"
"RTN","HLOTRACE",78,0)
 ;set break ZB12 in the client(start of $$READSEG^HLOT)
"RTN","HLOTRACE",79,0)
 ZB ZB12^HLOT:"N":1:"D ZB12^HLOTRACE"
"RTN","HLOTRACE",80,0)
 ;set break ZB13 in the client(end of $$READSEG^HLOT)
"RTN","HLOTRACE",81,0)
 ZB ZB13^HLOT:"N":1:"D ZB13^HLOTRACE"
"RTN","HLOTRACE",82,0)
 ;set break ZB14 in the client(start of $$WRITESEG^HLOT)
"RTN","HLOTRACE",83,0)
 ZB ZB14^HLOT:"N":1:"D ZB14^HLOTRACE"
"RTN","HLOTRACE",84,0)
 ;set break ZB15 in the client(end of $$WRITESEG^HLOT)
"RTN","HLOTRACE",85,0)
 ZB ZB15^HLOT:"N":1:"D ZB15^HLOTRACE"
"RTN","HLOTRACE",86,0)
 ;set break ZB16 in the client(start of $$WRITEHDR^HLOT)
"RTN","HLOTRACE",87,0)
 ZB ZB16^HLOT:"N":1:"D ZB16^HLOTRACE"
"RTN","HLOTRACE",88,0)
 ;set break ZB17 in the client(end of $$WRITEHDR^HLOT)
"RTN","HLOTRACE",89,0)
 ZB ZB17^HLOT:"N":1:"D ZB17^HLOTRACE"
"RTN","HLOTRACE",90,0)
 ;set break ZB18 in the client(start of $$ENDMSG^HLOT)
"RTN","HLOTRACE",91,0)
 ZB ZB18^HLOT:"N":1:"D ZB18^HLOTRACE"
"RTN","HLOTRACE",92,0)
 ;set break ZB19 in the client(end of $$ENDMSG^HLOT)
"RTN","HLOTRACE",93,0)
 ZB ZB19^HLOT:"N":1:"D ZB19^HLOTRACE"
"RTN","HLOTRACE",94,0)
 ZB ZB20^HLOT:"N":1:"D ZB20^HLOTRACE"
"RTN","HLOTRACE",95,0)
 ZB ZB21^HLOT:"N":1:"D ZB21^HLOTRACE"
"RTN","HLOTRACE",96,0)
 ZB ZB22^HLOT:"N":1:"D ZB22^HLOTRACE"
"RTN","HLOTRACE",97,0)
 ZB ZB23^HLOT:"N":1:"D ZB23^HLOTRACE"
"RTN","HLOTRACE",98,0)
 ZB ZB24^HLOCLNT1:"N":1:"D ZB24^HLOTRACE"
"RTN","HLOTRACE",99,0)
 ZB ZB25^HLOCLNT:"N":1:"D WRITE^HLOTRACE(""Calling DEQUE..."")"
"RTN","HLOTRACE",100,0)
 Q
"RTN","HLOTRACE",101,0)
WRITE(MSG) ;
"RTN","HLOTRACE",102,0)
 N OLD
"RTN","HLOTRACE",103,0)
 S OLD=$IO
"RTN","HLOTRACE",104,0)
 U $PRINCIPAL
"RTN","HLOTRACE",105,0)
 W !,?5,"Time: ",$$NOW^XLFDT,"   ",MSG
"RTN","HLOTRACE",106,0)
 U OLD
"RTN","HLOTRACE",107,0)
 Q
"RTN","HLOTRACE",108,0)
WRITE2(MSG,VALUE) ;
"RTN","HLOTRACE",109,0)
 N OLD,I
"RTN","HLOTRACE",110,0)
 S OLD=$IO
"RTN","HLOTRACE",111,0)
 U $PRINCIPAL
"RTN","HLOTRACE",112,0)
 W !,?5,"Time: ",$$NOW^XLFDT,"   ",MSG
"RTN","HLOTRACE",113,0)
 S I=0
"RTN","HLOTRACE",114,0)
 W:$O(VALUE(0)) !
"RTN","HLOTRACE",115,0)
 F  S I=$O(VALUE(I)) Q:'I  W VALUE(I)
"RTN","HLOTRACE",116,0)
 U OLD
"RTN","HLOTRACE",117,0)
 Q
"RTN","HLOTRACE",118,0)
WRITE3(MSG) ;
"RTN","HLOTRACE",119,0)
 N OLD
"RTN","HLOTRACE",120,0)
 S OLD=$IO
"RTN","HLOTRACE",121,0)
 U $PRINCIPAL
"RTN","HLOTRACE",122,0)
 W !,MSG
"RTN","HLOTRACE",123,0)
 U OLD
"RTN","HLOTRACE",124,0)
 Q
"RTN","HLOTRACE",125,0)
 ;
"RTN","HLOTRACE",126,0)
ZB3 ;
"RTN","HLOTRACE",127,0)
 N CON,MSG
"RTN","HLOTRACE",128,0)
 S CON=($ZA\8192#2)
"RTN","HLOTRACE",129,0)
 S MSG="Error encountered, $ECODE="_$ECODE
"RTN","HLOTRACE",130,0)
 D WRITE^HLOTRACE(MSG)
"RTN","HLOTRACE",131,0)
 S MSG=$S(CON:"           TCP connection still active",1:"          TCP connection was dropped")
"RTN","HLOTRACE",132,0)
 D WRITE3^HLOTRACE(MSG)
"RTN","HLOTRACE",133,0)
 D ^%ZTER
"RTN","HLOTRACE",134,0)
 Q
"RTN","HLOTRACE",135,0)
ZB4 ;
"RTN","HLOTRACE",136,0)
 N OLD
"RTN","HLOTRACE",137,0)
 S OLD=$IO
"RTN","HLOTRACE",138,0)
 U $PRINCIPAL
"RTN","HLOTRACE",139,0)
 W !!,"Looking for the next message to transmit..."
"RTN","HLOTRACE",140,0)
 I 'MSGIEN W !!,"No more messages pending on that queue!" S SUCCESS=0 Q
"RTN","HLOTRACE",141,0)
 S TRACECNT=$G(TRACECNT)+1
"RTN","HLOTRACE",142,0)
 I MAXTRACE>1 D
"RTN","HLOTRACE",143,0)
 .W !!,"Message IEN=",MSGIEN," next on queue"
"RTN","HLOTRACE",144,0)
 .I TRACECNT>MAXTRACE D
"RTN","HLOTRACE",145,0)
 ..I $$ASKYESNO^HLOUSR2("Do you want to trace another group of message transmissions","YES") S SUCCESS=1,TRACECNT=1
"RTN","HLOTRACE",146,0)
 ..E  S SUCCESS=0
"RTN","HLOTRACE",147,0)
 .E  S SUCCESS=1
"RTN","HLOTRACE",148,0)
 E  D
"RTN","HLOTRACE",149,0)
 .I '$$ASKYESNO^HLOUSR2("Message IEN="_MSGIEN_" next on queue, do you want to trace its transmission","YES") S SUCCESS=0
"RTN","HLOTRACE",150,0)
 U OLD
"RTN","HLOTRACE",151,0)
 Q
"RTN","HLOTRACE",152,0)
 ;
"RTN","HLOTRACE",153,0)
ZB2 ;
"RTN","HLOTRACE",154,0)
 W !,$S('HLCSTATE("CONNECTED"):"Connection Failed!",1:"Connected!")
"RTN","HLOTRACE",155,0)
 Q
"RTN","HLOTRACE",156,0)
ZB9 ;
"RTN","HLOTRACE",157,0)
 I $G(SUCCESS) D
"RTN","HLOTRACE",158,0)
 .D WRITE^HLOTRACE("Commit acknowledgment received!")
"RTN","HLOTRACE",159,0)
 E  D
"RTN","HLOTRACE",160,0)
 .D WRITE^HLOTRACE("Read of commit acknowledgment FAILED!")
"RTN","HLOTRACE",161,0)
 Q
"RTN","HLOTRACE",162,0)
ZB10 ;
"RTN","HLOTRACE",163,0)
 D WRITE^HLOTRACE("Reading header...")
"RTN","HLOTRACE",164,0)
 Q
"RTN","HLOTRACE",165,0)
ZB11 I $D(HDR) D WRITE2^HLOTRACE("",.HDR)
"RTN","HLOTRACE",166,0)
 D WRITE^HLOTRACE($S(SUCCESS:"Completed!",1:"**** FAILED TO COMPLETE *****"))
"RTN","HLOTRACE",167,0)
 Q
"RTN","HLOTRACE",168,0)
ZB12 ;
"RTN","HLOTRACE",169,0)
 D WRITE^HLOTRACE("Reading next segment...")
"RTN","HLOTRACE",170,0)
 Q
"RTN","HLOTRACE",171,0)
ZB13 I $D(SEG) D WRITE2^HLOTRACE("",.SEG)
"RTN","HLOTRACE",172,0)
 D WRITE^HLOTRACE($S(RETURN:"Completed!",$G(HLCSTATE("MESSAGE ENDED")):"No more segments!",1:"**** FAILED TO COMPLETE *****"))
"RTN","HLOTRACE",173,0)
 Q
"RTN","HLOTRACE",174,0)
ZB14 ;
"RTN","HLOTRACE",175,0)
 D WRITE2^HLOTRACE("Writing next segment...",.SEG)
"RTN","HLOTRACE",176,0)
 Q
"RTN","HLOTRACE",177,0)
ZB15 D WRITE^HLOTRACE($S(RETURN:"Completed!",1:"**** FAILED TO COMPLETE *****"))
"RTN","HLOTRACE",178,0)
 Q
"RTN","HLOTRACE",179,0)
ZB16 ;
"RTN","HLOTRACE",180,0)
 D WRITE2^HLOTRACE("Writing header segment...",.HDR)
"RTN","HLOTRACE",181,0)
 Q
"RTN","HLOTRACE",182,0)
ZB17 D WRITE^HLOTRACE($S(SUCCESS:"Completed!",1:"**** FAILED TO COMPLETE *****"))
"RTN","HLOTRACE",183,0)
 Q
"RTN","HLOTRACE",184,0)
ZB18 ;
"RTN","HLOTRACE",185,0)
 D WRITE^HLOTRACE("Writing message terminators and flushing buffer...")
"RTN","HLOTRACE",186,0)
 Q
"RTN","HLOTRACE",187,0)
ZB19 D WRITE^HLOTRACE($S(RETURN:"Completed!",1:"**** FAILED TO COMPLETE *****"))
"RTN","HLOTRACE",188,0)
 Q
"RTN","HLOTRACE",189,0)
ZB20 ;
"RTN","HLOTRACE",190,0)
 D WRITE^HLOTRACE("Message on queue was already transmitted, will be deleted from queue...")
"RTN","HLOTRACE",191,0)
 Q
"RTN","HLOTRACE",192,0)
ZB21 ;
"RTN","HLOTRACE",193,0)
 D WRITE^HLOTRACE("MSA segment shows this is not a commmit ack to the message transmitted...")
"RTN","HLOTRACE",194,0)
 Q
"RTN","HLOTRACE",195,0)
ZB22 ;
"RTN","HLOTRACE",196,0)
 D WRITE^HLOTRACE("Commit ack not CA, message status set to error...")
"RTN","HLOTRACE",197,0)
 Q
"RTN","HLOTRACE",198,0)
ZB23 ;
"RTN","HLOTRACE",199,0)
 D WRITE^HLOTRACE("Setting timestamp of sequence queue...")
"RTN","HLOTRACE",200,0)
 Q
"RTN","HLOTRACE",201,0)
ZB24 ;S HLOCSTATE("CONNECTED")=1
"RTN","HLOTRACE",202,0)
 S HLCSTATE("LINK","SHUTDOWN")=0
"RTN","HLOTRACE",203,0)
 Q
"RTN","HLOTRACE",204,0)
 ; 
"RTN","HLOTRACE",205,0)
ASKQUE(SUB) ;
"RTN","HLOTRACE",206,0)
 N DIR,Q1,Q2
"RTN","HLOTRACE",207,0)
 S Q1=$O(^HLB("QUEUE","OUT",SUB,""))
"RTN","HLOTRACE",208,0)
 I Q1="" W !,"There are no outgoing messages queued to that link!",! Q ""
"RTN","HLOTRACE",209,0)
 S Q2=$O(^HLB("QUEUE","OUT",SUB,Q1))
"RTN","HLOTRACE",210,0)
 I Q2="" D
"RTN","HLOTRACE",211,0)
 .S DIR("B")=Q1
"RTN","HLOTRACE",212,0)
 E  I $D(^HLB("QUEUE","OUT",SUB,"DEFAULT")) D
"RTN","HLOTRACE",213,0)
 .S DIR("B")="DEFAULT"
"RTN","HLOTRACE",214,0)
 E  D
"RTN","HLOTRACE",215,0)
 .S DIR("B")=Q1
"RTN","HLOTRACE",216,0)
 S DIR(0)="F^1:20"
"RTN","HLOTRACE",217,0)
 S DIR("A")="What is the name of the queue"
"RTN","HLOTRACE",218,0)
 S DIR("?",1)="To use this tool, there must be messages aleady pending transmission."
"RTN","HLOTRACE",219,0)
 S DIR("?")="Enter the name of the queue, or '^' to exit."
"RTN","HLOTRACE",220,0)
 D ^DIR
"RTN","HLOTRACE",221,0)
 I $D(DIRUT)!(Y="") Q ""
"RTN","HLOTRACE",222,0)
 Q Y
"RTN","HLOTRACE",223,0)
 ;
"RTN","HLOTRACE",224,0)
ASKCOUNT() ;
"RTN","HLOTRACE",225,0)
 N DIR
"RTN","HLOTRACE",226,0)
 S DIR(0)="N^1:100"
"RTN","HLOTRACE",227,0)
 S DIR("A")="Send how many at a time"
"RTN","HLOTRACE",228,0)
 S DIR("B")=1
"RTN","HLOTRACE",229,0)
 S DIR("?",1)="How many messages do you want to transmit at once"
"RTN","HLOTRACE",230,0)
 S DIR("?")="while tracing the client (100 maximum)?"
"RTN","HLOTRACE",231,0)
 D ^DIR
"RTN","HLOTRACE",232,0)
 Q:$D(DTOUT)!$D(DUOUT) -1
"RTN","HLOTRACE",233,0)
 Q X
"RTN","HLOTRACE",234,0)
ASKPORT(LINK) ;
"RTN","HLOTRACE",235,0)
 Q:LINK="" ""
"RTN","HLOTRACE",236,0)
 N PORT,QUEUE
"RTN","HLOTRACE",237,0)
 S QUEUE=$O(^HLB("QUEUE","OUT",LINK_":"))
"RTN","HLOTRACE",238,0)
 Q:$P(QUEUE,":")'=LINK ""
"RTN","HLOTRACE",239,0)
 S PORT=$P(QUEUE,":",2)
"RTN","HLOTRACE",240,0)
 Q:'PORT ""
"RTN","HLOTRACE",241,0)
 S QUEUE=$O(^HLB("QUEUE","OUT",QUEUE))
"RTN","HLOTRACE",242,0)
 Q:$P(QUEUE,":")'=LINK PORT
"RTN","HLOTRACE",243,0)
 S PORT=$$ASKPORT^HLOUSRA(LINK)
"RTN","HLOTRACE",244,0)
 Q PORT
"RTN","HLOUSR")
0^26^B92223063^B90546721
"RTN","HLOUSR",1,0)
HLOUSR ;ALB/CJM/OAK/PIJ/RBN -ListManager Screen for viewing system status;12 JUN 1997 10:00 am ;11/21/2008
"RTN","HLOUSR",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,130,134,137,138,139,146**;Oct 13, 1995;Build 16
"RTN","HLOUSR",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOUSR",4,0)
 ;
"RTN","HLOUSR",5,0)
EN ;
"RTN","HLOUSR",6,0)
 ;
"RTN","HLOUSR",7,0)
 N HLSCREEN,TESTOPEN,HLRFRSH,HLPARMS
"RTN","HLOUSR",8,0)
 D WAIT^DICD
"RTN","HLOUSR",9,0)
 D EN^VALM("HLO SYSTEM MONITOR")
"RTN","HLOUSR",10,0)
 Q
"RTN","HLOUSR",11,0)
 ;
"RTN","HLOUSR",12,0)
BRIEF ;
"RTN","HLOUSR",13,0)
 N COUNT,LINK,QUE,FROM,TIME,STATUS,TEMP,DIR,TODAY,LIST,LNKMSG
"RTN","HLOUSR",14,0)
 S HLRFRSH="BRIEF^HLOUSR"
"RTN","HLOUSR",15,0)
 S (HLSCREEN,VALMSG)="Brief System Status"
"RTN","HLOUSR",16,0)
 S VALMCNT=16
"RTN","HLOUSR",17,0)
 ;K @VALMAR
"RTN","HLOUSR",18,0)
 D CLEAN^VALM10
"RTN","HLOUSR",19,0)
 S VALMBG=1
"RTN","HLOUSR",20,0)
 S VALMBCK="R"
"RTN","HLOUSR",21,0)
 S VALMDDF("COL 1")="COL1^1^80^"
"RTN","HLOUSR",22,0)
 K VALMDDF("COL 2"),VALMDDF("COL 3"),VALMDDF("COL 4"),VALMDDF("COL 5")
"RTN","HLOUSR",23,0)
 D CHGCAP^VALM("COL 1"," Brief Operational Overview")
"RTN","HLOUSR",24,0)
 S @VALMAR@(1,0)="SYSTEM STATUS:             "_$S($$CHKSTOP^HLOPROC:"STOPPED",1:"RUNNING")
"RTN","HLOUSR",25,0)
 S @VALMAR@(2,0)="PROCESS MANAGER:           "_$S($$RUNNING:"RUNNING",1:"STOPPED")
"RTN","HLOUSR",26,0)
 ;
"RTN","HLOUSR",27,0)
 S TIME=$P($G(TESTOPEN("LISTENER")),"^",2)
"RTN","HLOUSR",28,0)
 I TIME,$$FMDIFF^XLFDT($$NOW^XLFDT,TIME,2)<300 D
"RTN","HLOUSR",29,0)
 .S STATUS=+TESTOPEN("LISTENER")
"RTN","HLOUSR",30,0)
 E  D
"RTN","HLOUSR",31,0)
 .S STATUS=0
"RTN","HLOUSR",32,0)
 .S LINK=$P($G(^HLD(779.1,1,0)),"^",10)
"RTN","HLOUSR",33,0)
 .I LINK S LINK=$P($G(^HLCS(870,LINK,0)),"^") Q:'$L(LINK)  S STATUS=$$IFOPEN^HLOUSR1(LINK)
"RTN","HLOUSR",34,0)
 .;
"RTN","HLOUSR",35,0)
 .;** P139 start CJM**
"RTN","HLOUSR",36,0)
 .I 'STATUS D
"RTN","HLOUSR",37,0)
 ..N SYS,POP,IO,IOF,IOST
"RTN","HLOUSR",38,0)
 ..D SYSPARMS^HLOSITE(.SYS)
"RTN","HLOUSR",39,0)
 ..D CALL^%ZISTCP("0.0.0.0",SYS("PORT"),5)
"RTN","HLOUSR",40,0)
 ..S STATUS='POP
"RTN","HLOUSR",41,0)
 ..C:STATUS IO
"RTN","HLOUSR",42,0)
 ..S:'STATUS LNKMSG=" Please restart the VMS TCPIP SERVICE FOR THE HLO LISTENER"
"RTN","HLOUSR",43,0)
 ..D:'STATUS CNTRL^VALM10(3,43,85,IOINHI,IOINORM)
"RTN","HLOUSR",44,0)
 .S TESTOPEN("LISTENER")=STATUS_"^"_$$NOW^XLFDT
"RTN","HLOUSR",45,0)
 S @VALMAR@(3,0)="STANDARD LISTENER:         "_$S(STATUS:"OPERATIONAL",1:"NOT OPERATIONAL ")_$G(LNKMSG)
"RTN","HLOUSR",46,0)
 ;** P139 end **
"RTN","HLOUSR",47,0)
 ;
"RTN","HLOUSR",48,0)
 S @VALMAR@(4,0)="TASKMAN:                   "_$S($$TM^%ZTLOAD:"RUNNING",1:"NOT RUNNING")
"RTN","HLOUSR",49,0)
 ;
"RTN","HLOUSR",50,0)
 S (LIST,LINK)=""
"RTN","HLOUSR",51,0)
 F  S LINK=$O(^HLTMP("FAILING LINKS",LINK)) Q:LINK=""  D  I $L(LIST)>60 S LIST=LIST_",..." Q
"RTN","HLOUSR",52,0)
 .N TIME,QUE,LINKARY
"RTN","HLOUSR",53,0)
 .I $$GETLINK^HLOTLNK($P(LINK,":"),.LINKARY)
"RTN","HLOUSR",54,0)
 .S TIME=$G(^HLTMP("FAILING LINKS",LINK)) Q:TIME=""
"RTN","HLOUSR",55,0)
 .I '$G(LINKARY("SHUTDOWN")),TIME="" Q
"RTN","HLOUSR",56,0)
 .I '$G(LINKARY("SHUTDOWN")),($$HDIFF^XLFDT($H,TIME,2)<300) Q
"RTN","HLOUSR",57,0)
 .;;***patch HL*1.6*138 start
"RTN","HLOUSR",58,0)
 .S LIST=LIST_$S($L(LIST):", ",1:"")_LINK
"RTN","HLOUSR",59,0)
 .;;.S LIST=LIST_$S($L(LIST):", ",1:"")_$P(LINK,":")
"RTN","HLOUSR",60,0)
 .;; ***patch HL*1.6*138 end
"RTN","HLOUSR",61,0)
 S @VALMAR@(5,0)="DOWN LINKS: "_LIST
"RTN","HLOUSR",62,0)
 S @VALMAR@(6,0)="CLIENT LINK PROCESSES:     "_+$G(^HLC("HL7 PROCESS COUNTS","RUNNING","OUTGOING CLIENT LINK"))
"RTN","HLOUSR",63,0)
 S @VALMAR@(7,0)="IN-FILER PROCESSES:        "_+$G(^HLC("HL7 PROCESS COUNTS","RUNNING","INCOMING QUEUES"))
"RTN","HLOUSR",64,0)
 ; ***patch HL*1.6*146 START - RBN ***
"RTN","HLOUSR",65,0)
 ;S COUNT=0,LINK=""
"RTN","HLOUSR",66,0)
 ;F  S LINK=$O(^HLC("QUEUECOUNT","OUT",LINK)) Q:LINK=""  D
"RTN","HLOUSR",67,0)
 ;.S QUE=""
"RTN","HLOUSR",68,0)
 ;.F  S QUE=$O(^HLC("QUEUECOUNT","OUT",LINK,QUE)) Q:QUE=""  D
"RTN","HLOUSR",69,0)
 ;..S TEMP=$G(^HLC("QUEUECOUNT","OUT",LINK,QUE))
"RTN","HLOUSR",70,0)
 ;..S:TEMP>0 COUNT=COUNT+TEMP
"RTN","HLOUSR",71,0)
 N CNTARRAY
"RTN","HLOUSR",72,0)
 S COUNT=$$OUT^HLOQUE(.CNTARRAY)
"RTN","HLOUSR",73,0)
 ; ***patch HL*1.6*146 END - RBN ***
"RTN","HLOUSR",74,0)
 S @VALMAR@(8,0)="MESSAGES PENDING ON OUT QUEUES:    "_$$RJ(+COUNT,7)_"     ON SEQUENCE QUEUES:  "_$$RJ(+$G(^HLC("QUEUECOUNT","SEQUENCE")),7)
"RTN","HLOUSR",75,0)
 S TEMP="STOPPED OUTGOING QUEUES: "
"RTN","HLOUSR",76,0)
 S COUNT=0,QUE=""
"RTN","HLOUSR",77,0)
 F  S QUE=$O(^HLTMP("STOPPED QUEUES","OUT",QUE)) Q:QUE=""  S COUNT=COUNT+1 Q:COUNT>4  S:COUNT=1 TEMP=TEMP_QUE S:"23"[COUNT TEMP=TEMP_"; "_QUE S:COUNT=4 TEMP=TEMP_" ..."
"RTN","HLOUSR",78,0)
 S @VALMAR@(9,0)=TEMP
"RTN","HLOUSR",79,0)
 ; ***patch HL*1.6*146 START - RBN ***
"RTN","HLOUSR",80,0)
 ;S COUNT=0,QUE=""
"RTN","HLOUSR",81,0)
 ;F  S QUE=$O(^HLC("QUEUECOUNT","IN",QUE)) Q:QUE=""  D
"RTN","HLOUSR",82,0)
 ;.S FROM=""
"RTN","HLOUSR",83,0)
 ;.F  S FROM=$O(^HLC("QUEUECOUNT","IN",QUE,FROM)) Q:FROM=""  D
"RTN","HLOUSR",84,0)
 ;..S TEMP=$G(^HLC("QUEUECOUNT","IN",QUE,FROM))
"RTN","HLOUSR",85,0)
 ;..S:TEMP>0 COUNT=COUNT+TEMP
"RTN","HLOUSR",86,0)
 S COUNT=0
"RTN","HLOUSR",87,0)
 K CNTARRAY
"RTN","HLOUSR",88,0)
 S COUNT=$$IN^HLOQUE(.CNTARRAY)
"RTN","HLOUSR",89,0)
 ; ***patch HL*1.6*146 END - RBN ***
"RTN","HLOUSR",90,0)
 S @VALMAR@(10,0)="MESSAGES PENDING ON APPLICATIONS: "_$$RJ(+COUNT,7)
"RTN","HLOUSR",91,0)
 S TEMP="STOPPED INCOMING QUEUES: "
"RTN","HLOUSR",92,0)
 S COUNT=0,QUE=""
"RTN","HLOUSR",93,0)
 F  S QUE=$O(^HLTMP("STOPPED QUEUES","IN",QUE)) Q:QUE=""  S COUNT=COUNT+1 Q:COUNT>4  S:COUNT=1 TEMP=TEMP_QUE S:"23"[COUNT TEMP=TEMP_"; "_QUE S:COUNT=4 TEMP=TEMP_" ..."
"RTN","HLOUSR",94,0)
 S @VALMAR@(11,0)=TEMP
"RTN","HLOUSR",95,0)
 S @VALMAR@(12,0)="FILE 777 RECORD COUNT:         "_$$RJ($P($G(^HLTMP("FILE 777 RECORD COUNT")),"^"),10)_"     --> as of "_$$FMTE^XLFDT($P($G(^HLTMP("FILE 777 RECORD COUNT")),"^",2))
"RTN","HLOUSR",96,0)
 S @VALMAR@(13,0)="FILE 778 RECORD COUNT:         "_$$RJ($P($G(^HLTMP("FILE 778 RECORD COUNT")),"^"),10)_"     --> as of "_$$FMTE^XLFDT($P($G(^HLTMP("FILE 778 RECORD COUNT")),"^",2))
"RTN","HLOUSR",97,0)
 S TODAY=$$DT^XLFDT
"RTN","HLOUSR",98,0)
 S @VALMAR@(14,0)="MESSAGES SENT TODAY:           "_$$RJ($$ADD("OUT"),10)
"RTN","HLOUSR",99,0)
 S @VALMAR@(15,0)="MESSAGES RECEIVED TODAY:       "_$$RJ($$ADD("IN"),10)
"RTN","HLOUSR",100,0)
 S @VALMAR@(16,0)="MESSAGE ERRORS TODAY:          "_$$RJ($$ADD("EOUT")+$$ADD("EIN"),10)
"RTN","HLOUSR",101,0)
 Q
"RTN","HLOUSR",102,0)
 ;
"RTN","HLOUSR",103,0)
ADD(DIR) ;
"RTN","HLOUSR",104,0)
 N RAP,SAP,TIME,TOTAL,TYPE
"RTN","HLOUSR",105,0)
 S TOTAL=0
"RTN","HLOUSR",106,0)
 S TIME=TODAY-.0001
"RTN","HLOUSR",107,0)
 F  S TIME=$O(^HLSTATS(DIR,"HOURLY",TIME)) Q:'TIME  Q:((TIME\1)>TODAY)  D
"RTN","HLOUSR",108,0)
 .S SAP=""
"RTN","HLOUSR",109,0)
 .F  S SAP=$O(^HLSTATS(DIR,"HOURLY",TIME,SAP)) Q:SAP=""  D
"RTN","HLOUSR",110,0)
 ..Q:SAP="ACCEPT ACK"
"RTN","HLOUSR",111,0)
 ..S RAP=""
"RTN","HLOUSR",112,0)
 ..F  S RAP=$O(^HLSTATS(DIR,"HOURLY",TIME,SAP,RAP)) Q:RAP=""  D
"RTN","HLOUSR",113,0)
 ...S TYPE=""
"RTN","HLOUSR",114,0)
 ...F  S TYPE=$O(^HLSTATS(DIR,"HOURLY",TIME,SAP,RAP,TYPE)) Q:TYPE=""  D
"RTN","HLOUSR",115,0)
 ....S TOTAL=TOTAL+$G(^HLSTATS(DIR,"HOURLY",TIME,SAP,RAP,TYPE))
"RTN","HLOUSR",116,0)
 Q TOTAL
"RTN","HLOUSR",117,0)
 ;
"RTN","HLOUSR",118,0)
HELP ;
"RTN","HLOUSR",119,0)
 S X="?" D DISP^XQORM1 W !!
"RTN","HLOUSR",120,0)
 Q
"RTN","HLOUSR",121,0)
 ;
"RTN","HLOUSR",122,0)
EXIT ;
"RTN","HLOUSR",123,0)
 D CLEAN^VALM10
"RTN","HLOUSR",124,0)
 D CLEAR^VALM1
"RTN","HLOUSR",125,0)
 Q
"RTN","HLOUSR",126,0)
 ;
"RTN","HLOUSR",127,0)
EXPND ;
"RTN","HLOUSR",128,0)
 Q
"RTN","HLOUSR",129,0)
 ;
"RTN","HLOUSR",130,0)
PROCS ;
"RTN","HLOUSR",131,0)
 S HLRFRSH="PROCS^HLOUSR"
"RTN","HLOUSR",132,0)
 ;K @VALMAR
"RTN","HLOUSR",133,0)
 D CLEAN^VALM10
"RTN","HLOUSR",134,0)
 S VALMCNT=0
"RTN","HLOUSR",135,0)
 S VALMBCK="R"
"RTN","HLOUSR",136,0)
 S VALMDDF("COL 1")="COL 1^1^34^"
"RTN","HLOUSR",137,0)
 S VALMDDF("COL 2")="COL 2^35^10^MIN^H"
"RTN","HLOUSR",138,0)
 S VALMDDF("COL 3")="COL 3^47^10^MAX^H"
"RTN","HLOUSR",139,0)
 S VALMDDF("COL 4")="COL 4^59^10^#RUNNING^H"
"RTN","HLOUSR",140,0)
 S VALMDDF("COL 5")="COL 5^71^10^#QUEUED^IOBON"
"RTN","HLOUSR",141,0)
 D CHGCAP^VALM("COL 1"," Process Type")
"RTN","HLOUSR",142,0)
 N IEN
"RTN","HLOUSR",143,0)
 S IEN=0
"RTN","HLOUSR",144,0)
 F  S IEN=$O(^HLD(779.3,"C",1,IEN)) Q:'IEN  D
"RTN","HLOUSR",145,0)
 .N PROC
"RTN","HLOUSR",146,0)
 .Q:'$$GETPROC^HLOPROC1(IEN,.PROC)
"RTN","HLOUSR",147,0)
 .Q:PROC("NAME")="VMS TCP LISTENER"
"RTN","HLOUSR",148,0)
 .S VALMCNT=VALMCNT+1
"RTN","HLOUSR",149,0)
 .S @VALMAR@(VALMCNT,0)=$$LJ(PROC("NAME"),30)_$$RJ(PROC("MINIMUM"),6)_$$RJ(PROC("MAXIMUM"),12)_$$RJ(+$G(^HLC("HL7 PROCESS COUNTS","RUNNING",PROC("NAME"))),14)_$$RJ(+$G(^HLC("HL7 PROCESS COUNTS","QUEUED",PROC("NAME"))),12)
"RTN","HLOUSR",150,0)
 S VALMCNT=VALMCNT+1,@VALMAR@(VALMCNT,0)=""
"RTN","HLOUSR",151,0)
 S IEN=""
"RTN","HLOUSR",152,0)
 F  S IEN=$O(^HLTMP("HL7 RUNNING PROCESSES",IEN)) Q:IEN=""  D
"RTN","HLOUSR",153,0)
 .N NODE
"RTN","HLOUSR",154,0)
 .S NODE=$G(^HLTMP("HL7 RUNNING PROCESSES",IEN))
"RTN","HLOUSR",155,0)
 .Q:NODE=""
"RTN","HLOUSR",156,0)
 .S VALMCNT=VALMCNT+1
"RTN","HLOUSR",157,0)
 .S @VALMAR@(VALMCNT,0)="$J: "_$$LJ(IEN,9)_" ->"_$$CJ($P(NODE,"^",3),28)_"<- started at "_$$HTE^XLFDT($P(NODE,"^"))
"RTN","HLOUSR",158,0)
 Q
"RTN","HLOUSR",159,0)
 ;
"RTN","HLOUSR",160,0)
INQUEUE ;
"RTN","HLOUSR",161,0)
 N FROM
"RTN","HLOUSR",162,0)
 D CLEAN^VALM10
"RTN","HLOUSR",163,0)
 ;K @VALMAR
"RTN","HLOUSR",164,0)
 S HLRFRSH="INQUEUE^HLOUSR"
"RTN","HLOUSR",165,0)
 S (HLSCREEN,VALMSG)="Incoming Queues ('!' = stopped queues)"
"RTN","HLOUSR",166,0)
 S VALMCNT=0
"RTN","HLOUSR",167,0)
 S VALMBCK="R"
"RTN","HLOUSR",168,0)
 S VALMDDF("COL 1")="COL 1^1^40^ From^H"
"RTN","HLOUSR",169,0)
 S VALMDDF("COL 2")="COL 2^45^20^Queue^H"
"RTN","HLOUSR",170,0)
 S VALMDDF("COL 3")="COL 3^70^10^Count^H"
"RTN","HLOUSR",171,0)
 K VALMDDF("COL 4"),VALMDDF("COL 5")
"RTN","HLOUSR",172,0)
 D CHGCAP^VALM("COL 1"," From")
"RTN","HLOUSR",173,0)
 S FROM=""
"RTN","HLOUSR",174,0)
 F  S FROM=$O(^HLC("QUEUECOUNT","IN",FROM)) Q:FROM=""  D
"RTN","HLOUSR",175,0)
 .N COUNT,QUE,SHOW
"RTN","HLOUSR",176,0)
 .S SHOW=$$LJ(FROM,40)_"  "
"RTN","HLOUSR",177,0)
 .S QUE=""
"RTN","HLOUSR",178,0)
 .F  S QUE=$O(^HLC("QUEUECOUNT","IN",FROM,QUE)) Q:QUE=""  D
"RTN","HLOUSR",179,0)
 ..S COUNT=$G(^HLC("QUEUECOUNT","IN",FROM,QUE))
"RTN","HLOUSR",180,0)
 ..Q:COUNT<0
"RTN","HLOUSR",181,0)
 ..S VALMCNT=VALMCNT+1
"RTN","HLOUSR",182,0)
 ..S @VALMAR@(VALMCNT,0)=SHOW_$$LJ($S($$STOPPED^HLOQUE("IN",QUE):"!",1:"")_QUE,21)_" "_$$RJ(COUNT,10)
"RTN","HLOUSR",183,0)
 ..S SHOW=$$LJ("",40)_"  "
"RTN","HLOUSR",184,0)
 Q
"RTN","HLOUSR",185,0)
VIEWLINK ;
"RTN","HLOUSR",186,0)
 N C,QUIT,LINK,LINKARY,TEMP
"RTN","HLOUSR",187,0)
 S (QUIT,C,LINK)=""
"RTN","HLOUSR",188,0)
 S VALMBCK="R"
"RTN","HLOUSR",189,0)
 ;
"RTN","HLOUSR",190,0)
 ;currently HL7 (Optimized) only does TCP
"RTN","HLOUSR",191,0)
 S LINK=$$ASKLINK
"RTN","HLOUSR",192,0)
 Q:LINK=""
"RTN","HLOUSR",193,0)
 Q:'$$GETLINK^HLOTLNK(LINK,.LINKARY)
"RTN","HLOUSR",194,0)
 S LINK=LINK_":"_LINKARY("PORT")
"RTN","HLOUSR",195,0)
 W !,"Hit any key to stop...",!
"RTN","HLOUSR",196,0)
 F  D  Q:QUIT
"RTN","HLOUSR",197,0)
 .N COUNT,QUE
"RTN","HLOUSR",198,0)
 .S (COUNT,QUE)=""
"RTN","HLOUSR",199,0)
 .F  S QUE=$O(^HLC("QUEUECOUNT","OUT",LINK,QUE)) Q:QUE=""  S TEMP=$G(^HLC("QUEUECOUNT","OUT",LINK,QUE)) S:TEMP>0 COUNT=COUNT+TEMP
"RTN","HLOUSR",200,0)
 .W $C(13),"                             ",$C(13),"MESSAGES PENDING TRANSMISSION: ",IOBON,$$RJ(+COUNT,10),IOBOFF
"RTN","HLOUSR",201,0)
 .R *C:1 I $T S QUIT=1
"RTN","HLOUSR",202,0)
 Q
"RTN","HLOUSR",203,0)
 ;
"RTN","HLOUSR",204,0)
CJ(STRING,LEN) ;
"RTN","HLOUSR",205,0)
 Q $$CJ^XLFSTR($E(STRING,1,LEN),LEN)
"RTN","HLOUSR",206,0)
LJ(STRING,LEN) ;
"RTN","HLOUSR",207,0)
 Q $$LJ^XLFSTR($E(STRING,1,LEN),LEN)
"RTN","HLOUSR",208,0)
RJ(STRING,LEN) ;
"RTN","HLOUSR",209,0)
 Q $$RJ^XLFSTR($E(STRING,1,LEN),LEN)
"RTN","HLOUSR",210,0)
 ;
"RTN","HLOUSR",211,0)
RUNNING() ;Process Manager running?
"RTN","HLOUSR",212,0)
 N RUNNING
"RTN","HLOUSR",213,0)
 L +^HLTMP("PROCESS MANAGER"):0
"RTN","HLOUSR",214,0)
 S RUNNING='$T
"RTN","HLOUSR",215,0)
 I 'RUNNING L -^HLTMP("PROCESS MANAGER")
"RTN","HLOUSR",216,0)
 Q RUNNING
"RTN","HLOUSR",217,0)
 ;
"RTN","HLOUSR",218,0)
TESTLINK ;
"RTN","HLOUSR",219,0)
 N LINKNAME,OK,PORT,LINK
"RTN","HLOUSR",220,0)
 S VALMBCK="R"
"RTN","HLOUSR",221,0)
 S LINKNAME=$$ASKLINK
"RTN","HLOUSR",222,0)
 Q:LINKNAME=""
"RTN","HLOUSR",223,0)
 ;**P138 START
"RTN","HLOUSR",224,0)
 S PORT=$$ASKPORT^HLOUSRA(LINKNAME)
"RTN","HLOUSR",225,0)
 Q:'PORT
"RTN","HLOUSR",226,0)
 S LINK=LINKNAME_":"_PORT
"RTN","HLOUSR",227,0)
 ;S OK=$$IFOPEN^HLOUSR1(LINKNAME)
"RTN","HLOUSR",228,0)
 S OK=$$IFOPEN^HLOUSR1(LINK)
"RTN","HLOUSR",229,0)
 ;** P138 END
"RTN","HLOUSR",230,0)
 I OK W !,LINK_" IS operational..."
"RTN","HLOUSR",231,0)
 E  W !,LINK_" is NOT operational..."
"RTN","HLOUSR",232,0)
 W !,"Hit any key to continue..."
"RTN","HLOUSR",233,0)
 R *C:DTIME
"RTN","HLOUSR",234,0)
 Q
"RTN","HLOUSR",235,0)
 ;
"RTN","HLOUSR",236,0)
ASKLINK() ;
"RTN","HLOUSR",237,0)
 N DIC,TCP,X,Y,DTOUT,DUOUT
"RTN","HLOUSR",238,0)
 S DIC=870
"RTN","HLOUSR",239,0)
 S DIC(0)="AENQ"
"RTN","HLOUSR",240,0)
 S TCP=$O(^HLCS(869.1,"B","TCP",0))
"RTN","HLOUSR",241,0)
 S DIC("A")="Select a TCP link:"
"RTN","HLOUSR",242,0)
 S DIC("S")="I $P(^(0),U,3)=TCP"
"RTN","HLOUSR",243,0)
 D FULL^VALM1
"RTN","HLOUSR",244,0)
 D ^DIC
"RTN","HLOUSR",245,0)
 I +Y'=-1,'$D(DTOUT),'$D(DUOUT) Q $P(Y,"^",2)
"RTN","HLOUSR",246,0)
 Q ""
"RTN","HLOUSR",247,0)
 ;
"RTN","HLOUSR",248,0)
STOP ;
"RTN","HLOUSR",249,0)
 I '$$ASKYESNO^HLOUSR2("Are you SURE that you want to stop sending and receiving messages","NO") S VALMBCK="" Q
"RTN","HLOUSR",250,0)
 ;
"RTN","HLOUSR",251,0)
 D STOPHL7^HLOPROC1
"RTN","HLOUSR",252,0)
 S VALMBCK="R",VALMSG="HL7 (Optimized) has been stopped...."
"RTN","HLOUSR",253,0)
 H 5
"RTN","HLOUSR",254,0)
 D @HLRFRSH
"RTN","HLOUSR",255,0)
 ;D:HLSCREEN="Brief System Status" BRIEF^HLOUSR
"RTN","HLOUSR",256,0)
 ;D:HLSCREEN="Running Processes" PROCS^HLOUSR
"RTN","HLOUSR",257,0)
 Q
"RTN","HLOUSR",258,0)
 ;
"RTN","HLOUSR",259,0)
UPDMODE ;realtime
"RTN","HLOUSR",260,0)
 Q:'$L(HLRFRSH)
"RTN","HLOUSR",261,0)
 N TOP,BOTTOM,DX,DY,IOTM,IOBM,LINE,OLD,OLDCNT
"RTN","HLOUSR",262,0)
 S OLDCNT=VALMCNT
"RTN","HLOUSR",263,0)
 W !!!!!,IOINHI,"Hit any key to escape realtime display mode...",IOINORM
"RTN","HLOUSR",264,0)
 S IOTM=20,IOBM=23 W @IOSTBM
"RTN","HLOUSR",265,0)
 S TOP=VALMBG
"RTN","HLOUSR",266,0)
 S BOTTOM=TOP+20
"RTN","HLOUSR",267,0)
 F LINE=TOP:1:BOTTOM D
"RTN","HLOUSR",268,0)
 .I LINE>VALMCNT S @VALMAR@(LINE,0)=$$LJ(" ",80) Q
"RTN","HLOUSR",269,0)
 .S @VALMAR@(LINE,0)=$$LJ($G(@VALMAR@(LINE,0)),80)
"RTN","HLOUSR",270,0)
 F LINE=TOP:1:BOTTOM D
"RTN","HLOUSR",271,0)
 .S OLD(LINE)=$G(@VALMAR@(LINE,0))
"RTN","HLOUSR",272,0)
 F LINE=17:1:BOTTOM D
"RTN","HLOUSR",273,0)
 .S DX=50,DY=22 X IOXY W !
"RTN","HLOUSR",274,0)
 .D WRITE^VALM10(LINE)
"RTN","HLOUSR",275,0)
 D  F  R *C:4 Q:$T  D
"RTN","HLOUSR",276,0)
 .D @HLRFRSH
"RTN","HLOUSR",277,0)
 .;**START PATCH 138**
"RTN","HLOUSR",278,0)
 .S OLDCNT=VALMCNT
"RTN","HLOUSR",279,0)
 .;**END PATCH 138**
"RTN","HLOUSR",280,0)
 .F LINE=TOP:1:BOTTOM D
"RTN","HLOUSR",281,0)
 ..I LINE>VALMCNT S @VALMAR@(LINE,0)=$$LJ(" ",80) Q
"RTN","HLOUSR",282,0)
 ..S @VALMAR@(LINE,0)=$$LJ($G(@VALMAR@(LINE,0)),80)
"RTN","HLOUSR",283,0)
 .S VALMCNT=BOTTOM
"RTN","HLOUSR",284,0)
 .F LINE=TOP:1:BOTTOM IF OLD(LINE)'=$G(@VALMAR@(LINE,0)) D
"RTN","HLOUSR",285,0)
 ..S OLD(LINE)=$G(@VALMAR@(LINE,0))
"RTN","HLOUSR",286,0)
 ..S DX=50,DY=22 X IOXY W !
"RTN","HLOUSR",287,0)
 ..D WRITE^VALM10(LINE)
"RTN","HLOUSR",288,0)
 ;**START PATCH 138**
"RTN","HLOUSR",289,0)
 S VALMCNT=OLDCNT
"RTN","HLOUSR",290,0)
 I VALMCNT<VALMBG S VALMBG=VALMCNT
"RTN","HLOUSR",291,0)
 ;**END PATCH 138**
"RTN","HLOUSR",292,0)
 S VALMBCK="R"
"RTN","HLOUSR",293,0)
 Q
"RTN","HLOUSR",294,0)
 ;
"RTN","HLOUSR",295,0)
EDITSITE ;
"RTN","HLOUSR",296,0)
 ;edit HLO System Parameters
"RTN","HLOUSR",297,0)
 N DR,DA,DIE
"RTN","HLOUSR",298,0)
 S DA=$O(^HLD(779.1,0))
"RTN","HLOUSR",299,0)
 Q:'DA
"RTN","HLOUSR",300,0)
 S DIE="^HLD(779.1,"
"RTN","HLOUSR",301,0)
 S DR="[HLO EDIT SYSTEM PARAMETERS]"
"RTN","HLOUSR",302,0)
 D ^DIE
"RTN","HLOUSR",303,0)
 Q
"RTN","HLOUSR6")
0^30^B24863677^B15582735
"RTN","HLOUSR6",1,0)
HLOUSR6 ;OAK/RBN -ListManager screen for reporting outbound queues;12 JUN 1997 10:00 am ;08/24/2009
"RTN","HLOUSR6",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**138,146**;Oct 13, 1995;Build 16
"RTN","HLOUSR6",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOUSR6",4,0)
 ;
"RTN","HLOUSR6",5,0)
 ;
"RTN","HLOUSR6",6,0)
EN ; Created list of outbound queues.
"RTN","HLOUSR6",7,0)
 N HLRFRSH,OLDRFRSH
"RTN","HLOUSR6",8,0)
 S OLDRFRSH=$G(HLRFRSH)
"RTN","HLOUSR6",9,0)
 D WAIT^DICD
"RTN","HLOUSR6",10,0)
 D EN^VALM("HLO DISPLAY OUT-GOING QUEUES")
"RTN","HLOUSR6",11,0)
 S HLRFRSH=OLDRFRSH
"RTN","HLOUSR6",12,0)
 I $L(HLRFRSH) D @HLRFRSH
"RTN","HLOUSR6",13,0)
 S VALMBCK="R"
"RTN","HLOUSR6",14,0)
 Q
"RTN","HLOUSR6",15,0)
 ;
"RTN","HLOUSR6",16,0)
INIT ; -- init variables and list array
"RTN","HLOUSR6",17,0)
 D OUTQUE
"RTN","HLOUSR6",18,0)
 D HDR
"RTN","HLOUSR6",19,0)
 D SHOW^VALM
"RTN","HLOUSR6",20,0)
 S VALMBCK="R"
"RTN","HLOUSR6",21,0)
 Q
"RTN","HLOUSR6",22,0)
 ;
"RTN","HLOUSR6",23,0)
HDR ; Header info. for the outbound queue display.
"RTN","HLOUSR6",24,0)
 N COUNT,LINK,QUE,FROM,TIME,STATUS,TEMP,DIR,TODAY,LIST,HLSCREEN
"RTN","HLOUSR6",25,0)
 S HLRFRSH="OUTQUE^HLOUSR6"
"RTN","HLOUSR6",26,0)
 S HLSCREEN="HLO Outbound Queues"
"RTN","HLOUSR6",27,0)
 S VALM("TITLE")="HLO Outbound Queues"
"RTN","HLOUSR6",28,0)
 S VALMSG="Outgoing Queues *down links !stopped queues"
"RTN","HLOUSR6",29,0)
 ;;; START HL*1.6*14  RBN - Commmented the next line out - prevents list from scrolling.
"RTN","HLOUSR6",30,0)
 S VALMCNT=16
"RTN","HLOUSR6",31,0)
 ;;; End HL*1.6*147
"RTN","HLOUSR6",32,0)
 S VALMBG=1
"RTN","HLOUSR6",33,0)
 S VALMDDF("COL 1")="COL1^1^80^"
"RTN","HLOUSR6",34,0)
 K VALMDDF("COL 2"),VALMDDF("COL 3"),VALMDDF("COL 4"),VALMDDF("COL 5")
"RTN","HLOUSR6",35,0)
 Q
"RTN","HLOUSR6",36,0)
 ;
"RTN","HLOUSR6",37,0)
OUTQUE ;
"RTN","HLOUSR6",38,0)
 N LINK,TOP,COUNT,LINE
"RTN","HLOUSR6",39,0)
 F LINE=1:1:16 D SET^VALM10(LINE,"")
"RTN","HLOUSR6",40,0)
 S VALMCNT=0
"RTN","HLOUSR6",41,0)
 S HLRFRSH="OUTQUE^HLOUSR6"
"RTN","HLOUSR6",42,0)
 S VALMAR="^TMP(""HLO OUTBOUND QUEUES"",$J)"
"RTN","HLOUSR6",43,0)
 S VALMBCK="R"
"RTN","HLOUSR6",44,0)
 S VALMDDF("COL 1")="COL 1^2^20^ Link^H"
"RTN","HLOUSR6",45,0)
 S VALMDDF("COL 2")="COL 2^28^20^Queue^H"
"RTN","HLOUSR6",46,0)
 S VALMDDF("COL 3")="COL 3^50^20^Count^H"
"RTN","HLOUSR6",47,0)
 S VALMDDF("COL 4")="COL 4^65^20^Top Message^H"
"RTN","HLOUSR6",48,0)
 K VALMDDF("COL 5")
"RTN","HLOUSR6",49,0)
 D CHGCAP^VALM("COL 1"," Link")
"RTN","HLOUSR6",50,0)
 S LINK=""
"RTN","HLOUSR6",51,0)
 F  S LINK=$O(^HLC("QUEUECOUNT","OUT",LINK)) Q:LINK=""  D
"RTN","HLOUSR6",52,0)
 .N COUNT,QUE,SHOW
"RTN","HLOUSR6",53,0)
 .S SHOW=LINK
"RTN","HLOUSR6",54,0)
 .I $D(^HLTMP("FAILING LINKS",SHOW)) S SHOW="*"_SHOW
"RTN","HLOUSR6",55,0)
 .S (TOP,QUE)=""
"RTN","HLOUSR6",56,0)
 .F  S QUE=$O(^HLC("QUEUECOUNT","OUT",LINK,QUE)) Q:QUE=""  D
"RTN","HLOUSR6",57,0)
 ..S COUNT=$G(^HLC("QUEUECOUNT","OUT",LINK,QUE))
"RTN","HLOUSR6",58,0)
 ..Q:COUNT<1
"RTN","HLOUSR6",59,0)
 ..S VALMCNT=VALMCNT+1
"RTN","HLOUSR6",60,0)
 ..S TOP=$$GETTOP()
"RTN","HLOUSR6",61,0)
 ..I $E(SHOW)="*" D
"RTN","HLOUSR6",62,0)
 ...S @VALMAR@(VALMCNT,0)=$$LJ(SHOW,20)_$$CJ($S($$STOPPED^HLOQUE("OUT",QUE):"!",1:"")_QUE,21)_"   "_$$RJ(COUNT,10)_$$RJ(TOP,20),SHOW="   "
"RTN","HLOUSR6",63,0)
 ...D CNTRL^VALM10(VALMCNT,1,1,IOBON,IOBOFF)
"RTN","HLOUSR6",64,0)
 ..E  S @VALMAR@(VALMCNT,0)=$$LJ(SHOW,20)_$$CJ($S($$STOPPED^HLOQUE("OUT",QUE):"!",1:"")_QUE,21)_"   "_$$RJ(COUNT,10)_$$RJ(TOP,20),SHOW="   "
"RTN","HLOUSR6",65,0)
 S VALMBCK="R"
"RTN","HLOUSR6",66,0)
 Q
"RTN","HLOUSR6",67,0)
 ;
"RTN","HLOUSR6",68,0)
CJ(STRING,LEN) ;
"RTN","HLOUSR6",69,0)
 Q $$CJ^XLFSTR($E(STRING,1,LEN),LEN)
"RTN","HLOUSR6",70,0)
LJ(STRING,LEN) ;
"RTN","HLOUSR6",71,0)
 Q $$LJ^XLFSTR($E(STRING,1,LEN),LEN)
"RTN","HLOUSR6",72,0)
RJ(STRING,LEN) ;
"RTN","HLOUSR6",73,0)
 Q $$RJ^XLFSTR($E(STRING,1,LEN),LEN)
"RTN","HLOUSR6",74,0)
 ;
"RTN","HLOUSR6",75,0)
CLEAN ; Clean up before leaving
"RTN","HLOUSR6",76,0)
 K ^TMP("HLO OUTBOUND QUEUES",$J)
"RTN","HLOUSR6",77,0)
 Q
"RTN","HLOUSR6",78,0)
 ;
"RTN","HLOUSR6",79,0)
GETTOP() ; Get top message in queue
"RTN","HLOUSR6",80,0)
 N TOP,QUIT
"RTN","HLOUSR6",81,0)
 S (TOP,QUIT)=0
"RTN","HLOUSR6",82,0)
 F  S TOP=$O(^HLB("QUEUE","OUT",LINK,QUE,TOP)) Q:'TOP  D  Q:QUIT
"RTN","HLOUSR6",83,0)
 .N NODE
"RTN","HLOUSR6",84,0)
 .S NODE=$G(^HLB(TOP,0))
"RTN","HLOUSR6",85,0)
 .I NODE="" K ^HLB("QUEUE","OUT",LINK,QUE,TOP) Q
"RTN","HLOUSR6",86,0)
 .S TOP=$P(NODE,"^",1),QUIT=1
"RTN","HLOUSR6",87,0)
 Q TOP
"RTN","HLOUSR6",88,0)
 ;
"RTN","HLOUSR6",89,0)
DELTOP ; Deletes the top message on a queue
"RTN","HLOUSR6",90,0)
 N CONF,HLOLNAM,HLOQNAM,LOCERR,TOP,LINKNAME,PORT,ERROR
"RTN","HLOUSR6",91,0)
 S VALMBCK="R"
"RTN","HLOUSR6",92,0)
 D OWNSKEY^XUSRB(.CONF,"HLOMGR",DUZ)
"RTN","HLOUSR6",93,0)
 I CONF(0)'=1 D  Q
"RTN","HLOUSR6",94,0)
 . W !,"**** You are not authorized to use this option ****" D PAUSE^VALM1
"RTN","HLOUSR6",95,0)
 ;**P146 START CJM
"RTN","HLOUSR6",96,0)
 ;S LOCERR=$$GETLNK^HLOAPI5()
"RTN","HLOUSR6",97,0)
 ;Q:($G(LOCERR)="Q")
"RTN","HLOUSR6",98,0)
 ;I $G(LOCERR)=-1 W !,"Sorry, that was an invalid link" D PAUSE^VALM1 Q
"RTN","HLOUSR6",99,0)
 S LINKNAME=$$ASKLINK^HLOUSR
"RTN","HLOUSR6",100,0)
 I LINKNAME="" W !,"Sorry, that is are no messages pending on that link." D PAUSE^VALM1 Q
"RTN","HLOUSR6",101,0)
 D
"RTN","HLOUSR6",102,0)
 .N PORT2
"RTN","HLOUSR6",103,0)
 .S ERROR=0
"RTN","HLOUSR6",104,0)
 .S PORT=$O(^HLB("QUEUE","OUT",LINKNAME_":"))
"RTN","HLOUSR6",105,0)
 .I ($P(PORT,":")'=LINKNAME) S PORT="" Q
"RTN","HLOUSR6",106,0)
 .S PORT2=$O(^HLB("QUEUE","OUT",LINKNAME_":"_$P(PORT,":",2)))
"RTN","HLOUSR6",107,0)
 .I ($P(PORT2,":")'=LINKNAME) S PORT=$P(PORT,":",2) Q
"RTN","HLOUSR6",108,0)
 .S PORT=$$ASKPORT^HLOUSRA(LINKNAME)
"RTN","HLOUSR6",109,0)
 .I 'PORT S ERROR=1
"RTN","HLOUSR6",110,0)
 Q:ERROR
"RTN","HLOUSR6",111,0)
 S HLOLNAM=LINKNAME_":"_PORT
"RTN","HLOUSR6",112,0)
 ;S LOCERR=$$GETQUE^HLOAPI5()
"RTN","HLOUSR6",113,0)
 ;I $G(LOCERR)="Q" Q
"RTN","HLOUSR6",114,0)
 ;I $G(LOCERR)=-1 W !,"Sorry, that was an invalid queue" D PAUSE^VALM1 Q
"RTN","HLOUSR6",115,0)
 S HLOQNAM=$$ASKQUE(HLOLNAM)
"RTN","HLOUSR6",116,0)
 Q:HLOQNAM=""
"RTN","HLOUSR6",117,0)
 L +^HLB("QUEUE","OUT",HLOLNAM,HLOQNAM):5 D
"RTN","HLOUSR6",118,0)
 .I '$T W !,"That queue is currently locked, please try again later." D PAUSE^VALM1 Q
"RTN","HLOUSR6",119,0)
 .D
"RTN","HLOUSR6",120,0)
 ..S TOP=$O(^HLB("QUEUE","OUT",HLOLNAM,HLOQNAM,""))
"RTN","HLOUSR6",121,0)
 ..;I TOP="" Q  ; There was nothing on the queue.
"RTN","HLOUSR6",122,0)
 ..I 'TOP W !,"There are no messages pending on that queue!" D PAUSE^VALM1 Q
"RTN","HLOUSR6",123,0)
 ..Q:$$VERIFY^HLOQUE1()=-1
"RTN","HLOUSR6",124,0)
 ..D DEQUE^HLOQUE(HLOLNAM,HLOQNAM,"OUT",TOP)
"RTN","HLOUSR6",125,0)
 ..D OUTQUE
"RTN","HLOUSR6",126,0)
 ..;
"RTN","HLOUSR6",127,0)
 .L -^HLB("QUEUE","OUT",HLOLNAM,HLOQNAM)
"RTN","HLOUSR6",128,0)
 ;K ^HLB("QUEUE","OUT",HLOLNAM,HLOQNAM,TOP)
"RTN","HLOUSR6",129,0)
 ;S ^HLC("QUEUECOUNT","OUT",HLOLNAM,HLOQNAM)=^HLC("QUEUECOUNT","OUT",HLOLNAM,HLOQNAM)-1
"RTN","HLOUSR6",130,0)
 ;S:^HLC("QUEUECOUNT","OUT",HLOLNAM,HLOQNAM)<0 ^HLC("QUEUECOUNT","OUT",HLOLNAM,HLOQNAM)=0
"RTN","HLOUSR6",131,0)
 ;D OUTQUE
"RTN","HLOUSR6",132,0)
 ;**P146 END CJM
"RTN","HLOUSR6",133,0)
 Q
"RTN","HLOUSR6",134,0)
 ;
"RTN","HLOUSR6",135,0)
 ;
"RTN","HLOUSR6",136,0)
 ;**P146 START CJM
"RTN","HLOUSR6",137,0)
ASKQUE(LINK) ;
"RTN","HLOUSR6",138,0)
 ;Input: LINK=<link>:<port>
"RTN","HLOUSR6",139,0)
 ;Ouput: function returns the queue name, or "" if not selected
"RTN","HLOUSR6",140,0)
 N X,QUE,Y,DUOUT,DEFAULT
"RTN","HLOUSR6",141,0)
 S DIR(0)="F"
"RTN","HLOUSR6",142,0)
 S DIR("A")="Enter queue name "
"RTN","HLOUSR6",143,0)
 S DEFAULT=$O(^HLB("QUEUE","OUT",LINK,""))
"RTN","HLOUSR6",144,0)
 I DEFAULT="" S DEFAULT="DEFAULT"
"RTN","HLOUSR6",145,0)
 S DIR("B")=DEFAULT
"RTN","HLOUSR6",146,0)
 S DIR("?",1)="Enter the queue name as displayed in the HLO System Monitor"
"RTN","HLOUSR6",147,0)
 S DIR("?",2)="                 Outgoing Queue display."
"RTN","HLOUSR6",148,0)
 D ^DIR
"RTN","HLOUSR6",149,0)
 K DIR
"RTN","HLOUSR6",150,0)
 I $G(DUOUT)!(Y="") Q ""
"RTN","HLOUSR6",151,0)
 Q Y
"RTN","HLOUSR6",152,0)
 ;**P146 END CJM
"VER")
8.0^22.0
"^DD",779.4,779.4,0)
FIELD^^3.06^10
"^DD",779.4,779.4,0,"DDA")
N
"^DD",779.4,779.4,0,"DT")
3090325
"^DD",779.4,779.4,0,"IX","B",779.4,.01)

"^DD",779.4,779.4,0,"NM","HLO SUBSCRIPTION REGISTRY")

"^DD",779.4,779.4,0,"VRPK")
HL
"^DD",779.4,779.4,.01,0)
NAME^RFX^^0;1^K:$L(X)>30!($L(X)<3) X
"^DD",779.4,779.4,.01,1,0)
^.1
"^DD",779.4,779.4,.01,1,1,0)
779.4^B
"^DD",779.4,779.4,.01,1,1,1)
S ^HLD(779.4,"B",$E(X,1,30),DA)=""
"^DD",779.4,779.4,.01,1,1,2)
K ^HLD(779.4,"B",$E(X,1,30),DA)
"^DD",779.4,779.4,.01,3)
Enter a unique name, 3-30 characters, namespaced by the application.
"^DD",779.4,779.4,.01,21,0)
^^11^11^3090323^^^^
"^DD",779.4,779.4,.01,21,1,0)
There are two means of assigning a name to a subscription list:
"^DD",779.4,779.4,.01,21,2,0)
 
"^DD",779.4,779.4,.01,21,3,0)
1) Subscription lists may be created at design time when developing a new
"^DD",779.4,779.4,.01,21,4,0)
   messaging application via the user option.  I that case the is textual and
"^DD",779.4,779.4,.01,21,5,0)
   should be a unique identifier namespaced by the application.
"^DD",779.4,779.4,.01,21,6,0)
 
"^DD",779.4,779.4,.01,21,7,0)
2) New subscription lists may be created dynamically via an API.  For example,
"^DD",779.4,779.4,.01,21,8,0)
   a subscription list may be added for a new patient for an existing
"^DD",779.4,779.4,.01,21,9,0)
   messaging applcation.  In that case the name is numeric, equal to the 
"^DD",779.4,779.4,.01,21,10,0)
   IEN of the entry.
"^DD",779.4,779.4,.01,21,11,0)

"^DD",779.4,779.4,.01,"DT")
3090323
"^DD",779.4,779.4,.02,0)
OWNER APPLICATION^RF^^0;2^K:$L(X)>40!($L(X)<1) X
"^DD",779.4,779.4,.02,1,0)
^.1^^0
"^DD",779.4,779.4,.02,3)
What application owns the subscription? 3-40 characters allowed.
"^DD",779.4,779.4,.02,21,0)
^^2^2^3040526^^
"^DD",779.4,779.4,.02,21,1,0)
This is the application or package responsible for creating this
"^DD",779.4,779.4,.02,21,2,0)
subscription.
"^DD",779.4,779.4,.02,"DT")
3090323
"^DD",779.4,779.4,.03,0)
DESCRIPTION^F^^1;1^K:$L(X)>75!($L(X)<1) X
"^DD",779.4,779.4,.03,3)
Answer must be 1-75 characters in length
"^DD",779.4,779.4,.03,"DT")
2991207
"^DD",779.4,779.4,3.01,0)
LOOKUP 1^F^^3;1^K:$L(X)>40!($L(X)<1) X
"^DD",779.4,779.4,3.01,3)
Answer must be 1-40 characters in length
"^DD",779.4,779.4,3.01,"DT")
3070124
"^DD",779.4,779.4,3.02,0)
LOOKUP 2^F^^3;2^K:$L(X)>40!($L(X)<1) X
"^DD",779.4,779.4,3.02,3)
Answer must be 1-40 characters in length
"^DD",779.4,779.4,3.02,"DT")
3070124
"^DD",779.4,779.4,3.03,0)
LOOKUP 3^F^^3;3^K:$L(X)>40!($L(X)<1) X
"^DD",779.4,779.4,3.03,3)
Answer must be 1-40 characters in length
"^DD",779.4,779.4,3.03,"DT")
3070124
"^DD",779.4,779.4,3.04,0)
LOOKUP 4^F^^3;4^K:$L(X)>40!($L(X)<1) X
"^DD",779.4,779.4,3.04,3)
Answer must be 1-40 characters in length
"^DD",779.4,779.4,3.04,"DT")
3070124
"^DD",779.4,779.4,3.05,0)
LOOKUP 5^F^^3;5^K:$L(X)>40!($L(X)<1) X
"^DD",779.4,779.4,3.05,3)
Answer must be 1-40 characters in length
"^DD",779.4,779.4,3.05,"DT")
3070124
"^DD",779.4,779.4,3.06,0)
LOOKUP 6^F^^3;6^K:$L(X)>40!($L(X)<1) X
"^DD",779.4,779.4,3.06,3)
Answer must be 1-40 characters in length
"^DD",779.4,779.4,3.06,"DT")
3070124
"^DD",779.4,779.4,20,0)
RECIPIENTS^779.41^^2;0
"^DD",779.4,779.41,0)
RECIPIENTS SUB-FIELD^^.021^8
"^DD",779.4,779.41,0,"DT")
3090325
"^DD",779.4,779.41,0,"IX","B",774.02,.01)

"^DD",779.4,779.41,0,"IX","B",779.41,.01)

"^DD",779.4,779.41,0,"NM","RECIPIENTS")

"^DD",779.4,779.41,0,"UP")
779.4
"^DD",779.4,779.41,.01,0)
RECEIVING APPLICATION^MRF^^0;1^K:$L(X)>60!($L(X)<3) X
"^DD",779.4,779.41,.01,1,0)
^.1
"^DD",779.4,779.41,.01,1,1,0)
779.41^B
"^DD",779.4,779.41,.01,1,1,1)
S ^HLS(779.4,DA(1),2,"B",$E(X,1,30),DA)=""
"^DD",779.4,779.41,.01,1,1,2)
K ^HLS(779.4,DA(1),2,"B",$E(X,1,30),DA)
"^DD",779.4,779.41,.01,3)
Enter the name of the application that will receive the messages. (3-60 characters)
"^DD",779.4,779.41,.01,"DT")
3090325
"^DD",779.4,779.41,.02,0)
MIDDLEWARE LOGICAL LINK^*P870'^HLCS(870,^0;2^S DIC("S")="I $P($G(^HLCS(870,Y,400)),""^"",3)=""C""" D ^DIC K DIC S DIC=$G(DIE),X=+Y K:Y<0 X
"^DD",779.4,779.41,.02,3)
If messages should be routed via middleware, such as an interface engine, what is the HL Logical Link?
"^DD",779.4,779.41,.02,12)
Allows only TCP clients.
"^DD",779.4,779.41,.02,12.1)
S DIC("S")="I $P($G(^HLCS(870,Y,400)),""^"",3)=""C"""
"^DD",779.4,779.41,.02,21,0)
^^11^11^3090528^^^^
"^DD",779.4,779.41,.02,21,1,0)
This field determines the HL Logical Link over which to transmit messages
"^DD",779.4,779.41,.02,21,2,0)
to this recipient. It determines the IP address and port, but not the
"^DD",779.4,779.41,.02,21,3,0)
receiving facility field that appears in the message header. 
"^DD",779.4,779.41,.02,21,4,0)

"^DD",779.4,779.41,.02,21,5,0)
This field is optional and should be entered only if messages should be routed
"^DD",779.4,779.41,.02,21,6,0)
through middleware, such as an interface engine. Otherwise it should not be
"^DD",779.4,779.41,.02,21,7,0)
entered, and the field FACILITY LOGICAL LINK will be used to determine
"^DD",779.4,779.41,.02,21,8,0)
the IP address and port over which to send messages.
"^DD",779.4,779.41,.02,21,9,0)

"^DD",779.4,779.41,.02,21,10,0)

"^DD",779.4,779.41,.02,21,11,0)

"^DD",779.4,779.41,.02,"DT")
3090528
"^DD",779.4,779.41,.021,0)
FACILITY LOGICAL LINK^R*P870'^HLCS(870,^0;6^S DIC("S")="I $P($G(^HLCS(870,Y,400)),""^"",3)=""C""" D ^DIC K DIC S DIC=$G(DIE),X=+Y K:Y<0 X
"^DD",779.4,779.41,.021,3)
What is the HL Logical Link for the receiving facility?
"^DD",779.4,779.41,.021,12)
Allows only TCP clients.
"^DD",779.4,779.41,.021,12.1)
S DIC("S")="I $P($G(^HLCS(870,Y,400)),""^"",3)=""C"""
"^DD",779.4,779.41,.021,21,0)
^^6^6^3090528^^
"^DD",779.4,779.41,.021,21,1,0)
This field determines the receiving facility field that appears in the message
"^DD",779.4,779.41,.021,21,2,0)
header for messages sent to this recipient.  If the MIDDLEWARE LOGICAL LINK
"^DD",779.4,779.41,.021,21,3,0)
field is blank, then this field also determines the IP address and port over
"^DD",779.4,779.41,.021,21,4,0)
which to send the message.
"^DD",779.4,779.41,.021,21,5,0)

"^DD",779.4,779.41,.021,21,6,0)

"^DD",779.4,779.41,.021,"DT")
3090528
"^DD",779.4,779.41,.03,0)
RECEIVING FACILITY COMPONENT 1^F^^0;3^K:$L(X)>50!($L(X)<1) X
"^DD",779.4,779.41,.03,3)
Answer must be 1-50 characters in length
"^DD",779.4,779.41,.03,21,0)
^^2^2^3040526^
"^DD",779.4,779.41,.03,21,1,0)
This is the value that should be placed in component 1 of the receiving
"^DD",779.4,779.41,.03,21,2,0)
facility field of the message header.
"^DD",779.4,779.41,.03,"DT")
3090325
"^DD",779.4,779.41,.04,0)
RECEIVING FACILITY COMPONENT 2^F^^0;4^K:$L(X)>50!($L(X)<1) X
"^DD",779.4,779.41,.04,3)
Answer must be 1-50 characters in length
"^DD",779.4,779.41,.04,21,0)
^^2^2^3040526^
"^DD",779.4,779.41,.04,21,1,0)
This is the value that should be placed in component 2 of the receiving
"^DD",779.4,779.41,.04,21,2,0)
facility field of the message header.
"^DD",779.4,779.41,.04,"DT")
3090325
"^DD",779.4,779.41,.05,0)
RECEIVING FACILITY COMPONENT 3^F^^0;5^K:$L(X)>10!($L(X)<1) X
"^DD",779.4,779.41,.05,3)
Answer must be 1-10 characters in length
"^DD",779.4,779.41,.05,21,0)
^^2^2^3041116^
"^DD",779.4,779.41,.05,21,1,0)
This is the value that should be placed in component 3 of the receiving
"^DD",779.4,779.41,.05,21,2,0)
facility field of the message header.
"^DD",779.4,779.41,.05,"DT")
3090325
"^DD",779.4,779.41,1.01,0)
DATE/TIME ADDED^RD^^1;1^S %DT="ESTXR" D ^%DT S X=Y K:X<1 X
"^DD",779.4,779.41,1.01,3)
Enter the date and time that this recipient was added to the subscription list.
"^DD",779.4,779.41,1.01,"DT")
3040526
"^DD",779.4,779.41,1.02,0)
DATE/TIME TERMINATED^D^^1;2^S %DT="ESTXR" D ^%DT S X=Y K:X<1 X
"^DD",779.4,779.41,1.02,3)
Enter the date and time that this recipient was dropped from the subscription list
"^DD",779.4,779.41,1.02,"DT")
3040526
"^DIC",779.4,779.4,0)
HLO SUBSCRIPTION REGISTRY^779.4
"^DIC",779.4,779.4,0,"GL")
^HLD(779.4,
"^DIC",779.4,779.4,"%",0)
^1.005^^0
"^DIC",779.4,779.4,"%D",0)
^1.001^6^6^3050215^^^
"^DIC",779.4,779.4,"%D",1,0)
This file is used to store static routing lists for messages.  
"^DIC",779.4,779.4,"%D",2,0)
 
"^DIC",779.4,779.4,"%D",3,0)
Static routing lists are lists of recipients that an application may create in
"^DIC",779.4,779.4,"%D",4,0)
advance for its messages.  The alternate routing method is dynamic routing, 
"^DIC",779.4,779.4,"%D",5,0)
whereby the recipient list is created by the application at the time the 
"^DIC",779.4,779.4,"%D",6,0)
message is created.
"^DIC",779.4,"B","HLO SUBSCRIPTION REGISTRY",779.4)

"BLD",1205,6)
^117
**END**
**END**
