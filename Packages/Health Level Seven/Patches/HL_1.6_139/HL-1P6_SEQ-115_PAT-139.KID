Released HL*1.6*139 SEQ #115
Extracted from mail message
**KIDS**:HL*1.6*139^

**INSTALL NAME**
HL*1.6*139
"BLD",1102,0)
HL*1.6*139^HEALTH LEVEL SEVEN^0^3081202^y
"BLD",1102,4,0)
^9.64PA^779.3^3
"BLD",1102,4,779.1,0)
779.1
"BLD",1102,4,779.1,222)
y^n^f^^^^n
"BLD",1102,4,779.2,0)
779.2
"BLD",1102,4,779.2,222)
y^n^f^^^^n
"BLD",1102,4,779.3,0)
779.3
"BLD",1102,4,779.3,2,0)
^9.641^779.3^1
"BLD",1102,4,779.3,2,779.3,0)
HLO PROCESS REGISTRY  (File-top level)
"BLD",1102,4,779.3,2,779.3,1,0)
^9.6411^.02^1
"BLD",1102,4,779.3,2,779.3,1,.02,0)
ACTIVE
"BLD",1102,4,779.3,222)
y^n^p^^^^n^^n
"BLD",1102,4,779.3,224)

"BLD",1102,4,"APDD",779.3,779.3)

"BLD",1102,4,"APDD",779.3,779.3,.02)

"BLD",1102,4,"B",779.1,779.1)

"BLD",1102,4,"B",779.2,779.2)

"BLD",1102,4,"B",779.3,779.3)

"BLD",1102,6.3)
11
"BLD",1102,"ABPKG")
n
"BLD",1102,"INI")
PRE^HLOP139
"BLD",1102,"INID")
^y^y
"BLD",1102,"INIT")
POST^HLOP139
"BLD",1102,"KRN",0)
^9.67PA^779.2^20
"BLD",1102,"KRN",.4,0)
.4
"BLD",1102,"KRN",.401,0)
.401
"BLD",1102,"KRN",.402,0)
.402
"BLD",1102,"KRN",.402,"NM",0)
^9.68A^1^1
"BLD",1102,"KRN",.402,"NM",1,0)
HLO EDIT SYSTEM PARAMETERS    FILE #779.1^779.1^0
"BLD",1102,"KRN",.402,"NM","B","HLO EDIT SYSTEM PARAMETERS    FILE #779.1",1)

"BLD",1102,"KRN",.403,0)
.403
"BLD",1102,"KRN",.5,0)
.5
"BLD",1102,"KRN",.84,0)
.84
"BLD",1102,"KRN",3.6,0)
3.6
"BLD",1102,"KRN",3.8,0)
3.8
"BLD",1102,"KRN",9.2,0)
9.2
"BLD",1102,"KRN",9.8,0)
9.8
"BLD",1102,"KRN",9.8,"NM",0)
^9.68A^18^18
"BLD",1102,"KRN",9.8,"NM",1,0)
HLOUSR^^0^B90546721
"BLD",1102,"KRN",9.8,"NM",2,0)
HLOPURGE^^0^B32879435
"BLD",1102,"KRN",9.8,"NM",3,0)
HLOAPI6^^0^B9832520
"BLD",1102,"KRN",9.8,"NM",4,0)
HLOCLNT^^0^B75551909
"BLD",1102,"KRN",9.8,"NM",5,0)
HLOCLNT1^^0^B32776376
"BLD",1102,"KRN",9.8,"NM",6,0)
HLOT^^0^B3373728
"BLD",1102,"KRN",9.8,"NM",7,0)
HLOTLNK^^0^B25754770
"BLD",1102,"KRN",9.8,"NM",8,0)
HLOCNRT1^^0^B47676959
"BLD",1102,"KRN",9.8,"NM",9,0)
HLOAPP^^0^B13112019
"BLD",1102,"KRN",9.8,"NM",10,0)
HLOSRVR^^0^B77915377
"BLD",1102,"KRN",9.8,"NM",11,0)
HLOSRVR1^^0^B79956205
"BLD",1102,"KRN",9.8,"NM",12,0)
HLOTCP^^0^B61182306
"BLD",1102,"KRN",9.8,"NM",13,0)
HLOAPI^^0^B95686689
"BLD",1102,"KRN",9.8,"NM",14,0)
HLOUSR3^^0^B66849245
"BLD",1102,"KRN",9.8,"NM",15,0)
HLOPROC1^^0^B91809391
"BLD",1102,"KRN",9.8,"NM",16,0)
HLOQUE1^^0^B78441748
"BLD",1102,"KRN",9.8,"NM",17,0)
HLOPRSR2^^0^B77395727
"BLD",1102,"KRN",9.8,"NM",18,0)
HLOPRSR1^^0^B21086795
"BLD",1102,"KRN",9.8,"NM","B","HLOAPI",13)

"BLD",1102,"KRN",9.8,"NM","B","HLOAPI6",3)

"BLD",1102,"KRN",9.8,"NM","B","HLOAPP",9)

"BLD",1102,"KRN",9.8,"NM","B","HLOCLNT",4)

"BLD",1102,"KRN",9.8,"NM","B","HLOCLNT1",5)

"BLD",1102,"KRN",9.8,"NM","B","HLOCNRT1",8)

"BLD",1102,"KRN",9.8,"NM","B","HLOPROC1",15)

"BLD",1102,"KRN",9.8,"NM","B","HLOPRSR1",18)

"BLD",1102,"KRN",9.8,"NM","B","HLOPRSR2",17)

"BLD",1102,"KRN",9.8,"NM","B","HLOPURGE",2)

"BLD",1102,"KRN",9.8,"NM","B","HLOQUE1",16)

"BLD",1102,"KRN",9.8,"NM","B","HLOSRVR",10)

"BLD",1102,"KRN",9.8,"NM","B","HLOSRVR1",11)

"BLD",1102,"KRN",9.8,"NM","B","HLOT",6)

"BLD",1102,"KRN",9.8,"NM","B","HLOTCP",12)

"BLD",1102,"KRN",9.8,"NM","B","HLOTLNK",7)

"BLD",1102,"KRN",9.8,"NM","B","HLOUSR",1)

"BLD",1102,"KRN",9.8,"NM","B","HLOUSR3",14)

"BLD",1102,"KRN",19,0)
19
"BLD",1102,"KRN",19,"NM",0)
^9.68A^8^3
"BLD",1102,"KRN",19,"NM",3,0)
HLO MAIN MENU^^2
"BLD",1102,"KRN",19,"NM",7,0)
HLO EDIT SYSTEM PARAMETERS^^0
"BLD",1102,"KRN",19,"NM",8,0)
HLO APPLICATION REGISTRY^^0
"BLD",1102,"KRN",19,"NM","B","HLO APPLICATION REGISTRY",8)

"BLD",1102,"KRN",19,"NM","B","HLO EDIT SYSTEM PARAMETERS",7)

"BLD",1102,"KRN",19,"NM","B","HLO MAIN MENU",3)

"BLD",1102,"KRN",19.1,0)
19.1
"BLD",1102,"KRN",101,0)
101
"BLD",1102,"KRN",101,"NM",0)
^9.68A^2^2
"BLD",1102,"KRN",101,"NM",1,0)
HLO SEQUENCE DELETE^^0
"BLD",1102,"KRN",101,"NM",2,0)
HLO OUTBOUND DELETE^^0
"BLD",1102,"KRN",101,"NM","B","HLO OUTBOUND DELETE",2)

"BLD",1102,"KRN",101,"NM","B","HLO SEQUENCE DELETE",1)

"BLD",1102,"KRN",409.61,0)
409.61
"BLD",1102,"KRN",409.61,"NM",0)
^9.68A^^
"BLD",1102,"KRN",771,0)
771
"BLD",1102,"KRN",779.2,0)
779.2
"BLD",1102,"KRN",870,0)
870
"BLD",1102,"KRN",8989.51,0)
8989.51
"BLD",1102,"KRN",8989.52,0)
8989.52
"BLD",1102,"KRN",8994,0)
8994
"BLD",1102,"KRN","B",.4,.4)

"BLD",1102,"KRN","B",.401,.401)

"BLD",1102,"KRN","B",.402,.402)

"BLD",1102,"KRN","B",.403,.403)

"BLD",1102,"KRN","B",.5,.5)

"BLD",1102,"KRN","B",.84,.84)

"BLD",1102,"KRN","B",3.6,3.6)

"BLD",1102,"KRN","B",3.8,3.8)

"BLD",1102,"KRN","B",9.2,9.2)

"BLD",1102,"KRN","B",9.8,9.8)

"BLD",1102,"KRN","B",19,19)

"BLD",1102,"KRN","B",19.1,19.1)

"BLD",1102,"KRN","B",101,101)

"BLD",1102,"KRN","B",409.61,409.61)

"BLD",1102,"KRN","B",771,771)

"BLD",1102,"KRN","B",779.2,779.2)

"BLD",1102,"KRN","B",870,870)

"BLD",1102,"KRN","B",8989.51,8989.51)

"BLD",1102,"KRN","B",8989.52,8989.52)

"BLD",1102,"KRN","B",8994,8994)

"BLD",1102,"QUES",0)
^9.62^^
"BLD",1102,"REQB",0)
^9.611^1^1
"BLD",1102,"REQB",1,0)
HL*1.6*138^2
"BLD",1102,"REQB","B","HL*1.6*138",1)

"FIA",779.1)
HLO SYSTEM PARAMETERS
"FIA",779.1,0)
^HLD(779.1,
"FIA",779.1,0,0)
779.1
"FIA",779.1,0,1)
y^n^f^^^^n
"FIA",779.1,0,10)

"FIA",779.1,0,11)

"FIA",779.1,0,"RLRO")

"FIA",779.1,0,"VR")
1.6^HL
"FIA",779.1,779.1)
0
"FIA",779.2)
HLO APPLICATION REGISTRY
"FIA",779.2,0)
^HLD(779.2,
"FIA",779.2,0,0)
779.2
"FIA",779.2,0,1)
y^n^f^^^^n
"FIA",779.2,0,10)

"FIA",779.2,0,11)

"FIA",779.2,0,"RLRO")

"FIA",779.2,0,"VR")
1.6^HL
"FIA",779.2,779.2)
0
"FIA",779.2,779.21)
0
"FIA",779.3)
HLO PROCESS REGISTRY
"FIA",779.3,0)
^HLD(779.3,
"FIA",779.3,0,0)
779.3
"FIA",779.3,0,1)
y^n^p^^^^n^^n
"FIA",779.3,0,10)

"FIA",779.3,0,11)

"FIA",779.3,0,"RLRO")

"FIA",779.3,0,"VR")
1.6^HL
"FIA",779.3,779.3)
1
"FIA",779.3,779.3,.02)

"INI")
PRE^HLOP139
"INIT")
POST^HLOP139
"IX",779.2,779.2,"C",0)
779.2^C^Uniqueness Index for Key 'A' of File #779.2^R^^F^IR^I^779.2^^^^^LS
"IX",779.2,779.2,"C",1)
S ^HLD(779.2,"C",X,DA)=""
"IX",779.2,779.2,"C",2)
K ^HLD(779.2,"C",X,DA)
"IX",779.2,779.2,"C",2.5)
K ^HLD(779.2,"C")
"IX",779.2,779.2,"C",11.1,0)
^.114IA^1^1
"IX",779.2,779.2,"C",11.1,1,0)
1^F^779.2^.01^^1
"IX",779.2,779.21,"C",0)
779.21^C^action by message type& event,with version not specified^MU^^R^IR^I^779.21^^^^^LS
"IX",779.2,779.21,"C",.1,0)
^^4^4^3060626^
"IX",779.2,779.21,"C",.1,1,0)
This index is used to find the application action by message type and event
"IX",779.2,779.21,"C",.1,2,0)
in cases where the application has chosen NOT to also specify the action
"IX",779.2,779.21,"C",.1,3,0)
according to the HL7 version.
"IX",779.2,779.21,"C",.1,4,0)

"IX",779.2,779.21,"C",1)
S ^HLD(779.2,DA(1),1,"C",X(1),X(2),DA)=""
"IX",779.2,779.21,"C",1.4)
S:$P(^HLD(779.2,DA(1),1,DA,0),"^",6)="" X=1
"IX",779.2,779.21,"C",2)
K ^HLD(779.2,DA(1),1,"C",X(1),X(2),DA)
"IX",779.2,779.21,"C",2.4)
S:$P(^HLD(779.2,DA(1),1,DA,0),"^",6)="" X=1
"IX",779.2,779.21,"C",2.5)
K ^HLD(779.2,DA(1),1,"C")
"IX",779.2,779.21,"C",11.1,0)
^.114IA^2^2
"IX",779.2,779.21,"C",11.1,1,0)
1^F^779.21^.01^^1
"IX",779.2,779.21,"C",11.1,2,0)
2^F^779.21^.02^^2^F
"IX",779.2,779.21,"D",0)
779.21^D^lookup message type including version^MU^^R^IR^I^779.21^^^^^LS
"IX",779.2,779.21,"D",1)
S ^HLD(779.2,DA(1),1,"D",$E(X(1),1,30),$E(X(2),1,30),$E(X(3),1,30),DA)="" K ^HLD(779.2,DA(1),1,"C",$E(X(1),1,30),$E(X(2),1,30),DA)
"IX",779.2,779.21,"D",2)
K ^HLD(779.2,DA(1),1,"D",$E(X(1),1,30),$E(X(2),1,30),$E(X(3),1,30),DA) S ^HLD(779.2,DA(1),1,"C",$E(X(1),1,30),$E(X(2),1,30),DA)=""
"IX",779.2,779.21,"D",2.5)
K ^HLD(779.2,DA(1),1,"D")
"IX",779.2,779.21,"D",11.1,0)
^.114IA^3^3
"IX",779.2,779.21,"D",11.1,1,0)
1^F^779.21^.01^30^1^F
"IX",779.2,779.21,"D",11.1,2,0)
2^F^779.21^.02^30^2^F
"IX",779.2,779.21,"D",11.1,3,0)
3^F^779.21^.06^30^3^F
"KEY",779.2,779.2,"A",0)
779.2^A^P^68
"KEY",779.2,779.2,"A",2,0)
^.312IA^1^1
"KEY",779.2,779.2,"A",2,1,0)
.01^779.2^1
"KEYPTR",779.2,779.2,"A")
779.2^C
"KRN",.402,104,-1)
0^1
"KRN",.402,104,0)
HLO EDIT SYSTEM PARAMETERS^3080922.0906^@^779.1^^@^3081106
"KRN",.402,104,"DR",1,779.1)
.01;.02;.03;.04;.05;.06;.07;.08;.12;.1;
"KRN",19,1047,-1)
2^3
"KRN",19,1047,0)
HLO MAIN MENU^HL7 (Optimized) MAIN MENU^^M^1000061^HLOMAIN^^^^^y^9
"KRN",19,1047,10,0)
^19.01IP^8^8
"KRN",19,1047,10,3,0)
1061^APPS^3
"KRN",19,1047,10,3,"^")
HLO APPLICATION REGISTRY
"KRN",19,1047,10,8,0)
1395^SP
"KRN",19,1047,10,8,"^")
HLO EDIT SYSTEM PARAMETERS
"KRN",19,1047,"U")
HL7 (OPTIMIZED) MAIN MENU
"KRN",19,1061,-1)
0^8
"KRN",19,1061,0)
HLO APPLICATION REGISTRY^HLO APPLICATION REGISTRY^^E^^^^^^^^HEALTH LEVEL SEVEN^y^
"KRN",19,1061,1,0)
^19.06^2^2^3071011^^^^
"KRN",19,1061,1,1,0)
This option allows the user to register an HL7 (Optimized) application in 
"KRN",19,1061,1,2,0)
the Application Registry File (779.2).
"KRN",19,1061,20)

"KRN",19,1061,30)
HLD(779.2,
"KRN",19,1061,31)
AEMQL
"KRN",19,1061,50)
HLD(779.2,
"KRN",19,1061,51)
[HLOAPREG]
"KRN",19,1061,"U")
HLO APPLICATION REGISTRY
"KRN",19,1395,-1)
0^7
"KRN",19,1395,0)
HLO EDIT SYSTEM PARAMETERS^EDIT HLO SYSTEM PARAMETERS^^A^^^^^^^y^HEALTH LEVEL SEVEN^^1
"KRN",19,1395,1,0)
^19.06^2^2^3080922^^
"KRN",19,1395,1,1,0)
Used to edit the HLO System Parmeters.
"KRN",19,1395,1,2,0)

"KRN",19,1395,20)
D EDITSITE^HLOUSR
"KRN",19,1395,"U")
EDIT HLO SYSTEM PARAMETERS
"KRN",101,513,-1)
0^1
"KRN",101,513,0)
HLO SEQUENCE DELETE^SEQUENCE QUEUE DELETE^^A^^^^^^^^HEALTH LEVEL SEVEN
"KRN",101,513,.1)
DELETE
"KRN",101,513,1,0)
^^2^2^3071109^
"KRN",101,513,1,1,0)
This action deletes a specified sequence queue.
"KRN",101,513,1,2,0)

"KRN",101,513,2,0)
^101.02A^1^1
"KRN",101,513,2,1,0)
QD
"KRN",101,513,2,"B","QD",1)

"KRN",101,513,15)
K QUETYP
"KRN",101,513,20)
S QUETYP="S" D LMQUES^HLOQUE1 S VALMBCK="R"
"KRN",101,513,99)
61206,27044
"KRN",101,514,-1)
0^2
"KRN",101,514,0)
HLO OUTBOUND DELETE^DEL QUE^^A^^^^^^^^HEALTH LEVEL SEVEN
"KRN",101,514,.1)
DELETE
"KRN",101,514,1,0)
^101.06^2^2^3071114^^^^
"KRN",101,514,1,1,0)
This action deletes messages from a specified queue.
"KRN",101,514,1,2,0)

"KRN",101,514,2,0)
^101.02A^2^2
"KRN",101,514,2,1,0)
QD
"KRN",101,514,2,2,0)
DQ
"KRN",101,514,2,"B","DQ",2)

"KRN",101,514,2,"B","QD",1)

"KRN",101,514,15)
K QUETYP
"KRN",101,514,20)
S QUETYP="O" D LMQUES^HLOQUE1 S VALMBCK="R"
"KRN",101,514,99)
61206,27044
"MBREQ")
0
"ORD",7,.402)
.402;7;;;EDEOUT^DIFROMSO(.402,DA,"",XPDA);FPRE^DIFROMSI(.402,"",XPDA);EPRE^DIFROMSI(.402,DA,$E("N",$G(XPDNEW)),XPDA,"",OLDA);;EPOST^DIFROMSI(.402,DA,"",XPDA);DEL^DIFROMSK(.402,"",%)
"ORD",7,.402,0)
INPUT TEMPLATE
"ORD",15,101)
101;15;;;PRO^XPDTA;PROF1^XPDIA;PROE1^XPDIA;PROF2^XPDIA;;PRODEL^XPDIA
"ORD",15,101,0)
PROTOCOL
"ORD",18,19)
19;18;;;OPT^XPDTA;OPTF1^XPDIA;OPTE1^XPDIA;OPTF2^XPDIA;;OPTDEL^XPDIA
"ORD",18,19,0)
OPTION
"PKG",9,-1)
1^1
"PKG",9,0)
HEALTH LEVEL SEVEN^HL^DHCP IMPLEMENTATION OF HEALTH LEVEL SEVEN^
"PKG",9,20,0)
^9.402P^^
"PKG",9,22,0)
^9.49I^1^1
"PKG",9,22,1,0)
1.6^2980130^2980130^6
"PKG",9,22,1,"PAH",1,0)
139^3081202
"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
NO
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
NO
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
NO
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
19
"RTN","HLOAPI")
0^13^B95686689^B91349575
"RTN","HLOAPI",1,0)
HLOAPI ;ALB/CJM-HL7 - Developer API's for sending & receiving messages ;11/12/2008
"RTN","HLOAPI",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,133,138,139**;Oct 13, 1995;Build 11
"RTN","HLOAPI",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOAPI",4,0)
 ;
"RTN","HLOAPI",5,0)
NEWMSG(PARMS,HLMSTATE,ERROR) ;; Starts a new message.
"RTN","HLOAPI",6,0)
 ;;
"RTN","HLOAPI",7,0)
 ;;** External API **
"RTN","HLOAPI",8,0)
 ;;  
"RTN","HLOAPI",9,0)
 ;;Input: 
"RTN","HLOAPI",10,0)
 ;;   PARMS( *pass by reference*
"RTN","HLOAPI",11,0)
 ;;     "COUNTRY")=3 character country code (optional)
"RTN","HLOAPI",12,0)
 ;;     "CONTINUATION POINTER" -indicates a fragmented message
"RTN","HLOAPI",13,0)
 ;;     "EVENT")=3 character event type (required)
"RTN","HLOAPI",14,0)
 ;;     "FIELD SEPARATOR")=field separator (optional, defaults to "|")
"RTN","HLOAPI",15,0)
 ;;     "ENCODING CHARACTERS")= 4 HL7 encoding characters (optional,defaults to "^~\&")
"RTN","HLOAPI",16,0)
 ;;     "MESSAGE STRUCTURE" - MSH 9, component 3 - a code from the standard HL7 table (optional)
"RTN","HLOAPI",17,0)
 ;;     "MESSAGE TYPE")=3 character message type (required)
"RTN","HLOAPI",18,0)
 ;;     "PROCESSING MODE" - MSH 11, component 2 - a 1 character code (optional)
"RTN","HLOAPI",19,0)
 ;;     "VERSION")=the HL7 Version ID, for example, "2.4" (optional, defaults to 2.4)
"RTN","HLOAPI",20,0)
 ;;Output:
"RTN","HLOAPI",21,0)
 ;;  Function- returns 1 on success, 0 on failure
"RTN","HLOAPI",22,0)
 ;;  HLMSTATE() - (pass by reference, required) This array is used by the HL7 package to track the progress of the message.  The application MUST NOT touch it!
"RTN","HLOAPI",23,0)
 ;;  PARMS - left defined when the function returns
"RTN","HLOAPI",24,0)
 ;;  ERROR (optional, pass by reference) - returns an error message on failure
"RTN","HLOAPI",25,0)
 ;;
"RTN","HLOAPI",26,0)
 ;
"RTN","HLOAPI",27,0)
 N DATA,I,SYSTEM,SUCCESS
"RTN","HLOAPI",28,0)
 S SUCCESS=0
"RTN","HLOAPI",29,0)
 K ERROR,HLMSTATE
"RTN","HLOAPI",30,0)
 D
"RTN","HLOAPI",31,0)
 .I $L($G(PARMS("PROCESSING MODE"))),$L(PARMS("PROCESSING MODE"))'=1 S ERROR="INVALID PROCESSING MODE" Q
"RTN","HLOAPI",32,0)
 .I $L($G(PARMS("COUNTRY"))),$L(PARMS("COUNTRY"))'=3 S ERROR="INVALID COUNTRY CODE" Q
"RTN","HLOAPI",33,0)
 .I $L($G(PARMS("EVENT")))'=3 S ERROR="INVALID EVENT CODE" Q
"RTN","HLOAPI",34,0)
 .I $L($G(PARMS("MESSAGE TYPE")))'=3 S ERROR="INVALID MESSAGE TYPE" Q
"RTN","HLOAPI",35,0)
 .I $L($G(PARMS("ENCODING CHARACTERS"))),$L(PARMS("ENCODING CHARACTERS"))'=4 S ERROR="INVALID ENCODING CHARACTERS" Q
"RTN","HLOAPI",36,0)
 .I $L($G(PARMS("FIELD SEPARATOR"))),$L(PARMS("FIELD SEPARATOR"))'=1 S ERROR="INVALID FIELD SEPARATOR" Q
"RTN","HLOAPI",37,0)
 .I '$L($G(PARMS("FIELD SEPARATOR"))) S PARMS("FIELD SEPARATOR")="|"
"RTN","HLOAPI",38,0)
 .I '$L($G(PARMS("ENCODING CHARACTERS"))) S PARMS("ENCODING CHARACTERS")="^~\&"
"RTN","HLOAPI",39,0)
 .I $G(PARMS("VERSION"))="" S PARMS("VERSION")="2.4"
"RTN","HLOAPI",40,0)
 .I ($L($G(PARMS("VERSION")))>20) S ERROR="VERSION > 20 CHARACTERS" Q
"RTN","HLOAPI",41,0)
 .F I="MESSAGE TYPE","EVENT","COUNTRY","FIELD SEPARATOR","ENCODING CHARACTERS","VERSION","CONTINUATION POINTER","MESSAGE STRUCTURE","PROCESSING MODE" S HLMSTATE("HDR",I)=$G(PARMS(I))
"RTN","HLOAPI",42,0)
 .S HLMSTATE("BATCH")=0 ;not a batch
"RTN","HLOAPI",43,0)
 .S HLMSTATE("DIRECTION")="OUT"
"RTN","HLOAPI",44,0)
 .S HLMSTATE("IEN")=""
"RTN","HLOAPI",45,0)
 .S HLMSTATE("BODY")="" ;record not yet created
"RTN","HLOAPI",46,0)
 .S HLMSTATE("CURRENT SEGMENT")=0 ;no segments cached
"RTN","HLOAPI",47,0)
 .S HLMSTATE("UNSTORED LINES")=0 ;nothing in cache
"RTN","HLOAPI",48,0)
 .S HLMSTATE("LINE COUNT")=0
"RTN","HLOAPI",49,0)
 .D GETSYS(.HLMSTATE)
"RTN","HLOAPI",50,0)
 .S SUCCESS=1
"RTN","HLOAPI",51,0)
 Q SUCCESS
"RTN","HLOAPI",52,0)
 ;
"RTN","HLOAPI",53,0)
NEWBATCH(PARMS,HLMSTATE,ERROR) ;;Starts a new batch message.  
"RTN","HLOAPI",54,0)
 ;;Input: 
"RTN","HLOAPI",55,0)
 ;;  PARMS( *pass by reference*
"RTN","HLOAPI",56,0)
 ;;   "COUNTRY")=3 character country code (optional)
"RTN","HLOAPI",57,0)
 ;;   "FIELD SEPARATOR")=field separator (optional, defaults to "|")
"RTN","HLOAPI",58,0)
 ;;   "ENCODING CHARACTERS")= 4 HL7 encoding characters (optional,defaults to "^~\&") 
"RTN","HLOAPI",59,0)
 ;;   "VERSION")=the HL7 Version ID, for example, "2.4" (optional, defaults to 2.4)
"RTN","HLOAPI",60,0)
 ;;Output:
"RTN","HLOAPI",61,0)
 ;;  Function - returns 1 on success, 0 on failure
"RTN","HLOAPI",62,0)
 ;;  PARMS - left defined when the function returns
"RTN","HLOAPI",63,0)
 ;;  HLMSTATE() - (pass by reference, required) This array is used by the HL7 package to track the progress of the message.  The application MUST NOT touch it!
"RTN","HLOAPI",64,0)
 ;;  ERROR (optional, pass by reference) - returns an error message on failure
"RTN","HLOAPI",65,0)
 ;;
"RTN","HLOAPI",66,0)
 ;
"RTN","HLOAPI",67,0)
 N DATA,I,SYSTEM,SUCCESS
"RTN","HLOAPI",68,0)
 S SUCCESS=0
"RTN","HLOAPI",69,0)
 K ERROR,HLMSTATE
"RTN","HLOAPI",70,0)
 D
"RTN","HLOAPI",71,0)
 .I $L($G(PARMS("COUNTRY"))),$L(PARMS("COUNTRY"))'=3 S ERROR="INVALID COUNTRY CODE" Q
"RTN","HLOAPI",72,0)
 .I $L($G(PARMS("ENCODING CHARACTERS"))),$L(PARMS("ENCODING CHARACTERS"))'=4 S ERROR="INVALID ENCODING CHARACTERS" Q
"RTN","HLOAPI",73,0)
 .I $L($G(PARMS("FIELD SEPARATOR"))),$L(PARMS("FIELD SEPARATOR"))'=1 S ERROR="INVALID FIELD SEPARATOR" Q
"RTN","HLOAPI",74,0)
 .I '$L($G(PARMS("FIELD SEPARATOR"))) S PARMS("FIELD SEPARATOR")="|"
"RTN","HLOAPI",75,0)
 .I '$L($G(PARMS("ENCODING CHARACTERS"))) S PARMS("ENCODING CHARACTERS")="^~\&"
"RTN","HLOAPI",76,0)
 .I $G(PARMS("VERSION"))="" S PARMS("VERSION")="2.4"
"RTN","HLOAPI",77,0)
 .I ($L(PARMS("VERSION"))>20) S ERROR="VERSION > 20 CHARACTERS" Q
"RTN","HLOAPI",78,0)
 .F I="COUNTRY","FIELD SEPARATOR","ENCODING CHARACTERS","VERSION" S HLMSTATE("HDR",I)=$G(PARMS(I))
"RTN","HLOAPI",79,0)
 .S HLMSTATE("IEN")=""
"RTN","HLOAPI",80,0)
 .S HLMSTATE("BODY")="" ;msg not yet stored
"RTN","HLOAPI",81,0)
 .S HLMSTATE("BATCH")=1
"RTN","HLOAPI",82,0)
 .S HLMSTATE("DIRECTION")="OUT"
"RTN","HLOAPI",83,0)
 .S HLMSTATE("BATCH","CURRENT MESSAGE")=0 ;no messages in batch
"RTN","HLOAPI",84,0)
 .S HLMSTATE("CURRENT SEGMENT")=0 ;no segments in cache
"RTN","HLOAPI",85,0)
 .S HLMSTATE("UNSTORED LINES")=0 ;nothing in cache
"RTN","HLOAPI",86,0)
 .S HLMSTATE("LINE COUNT")=0 ;no lines within message stored
"RTN","HLOAPI",87,0)
 .D GETSYS(.HLMSTATE)
"RTN","HLOAPI",88,0)
 .S SUCCESS=1
"RTN","HLOAPI",89,0)
 Q SUCCESS
"RTN","HLOAPI",90,0)
 ;
"RTN","HLOAPI",91,0)
SET(SEG,VALUE,FIELD,COMP,SUBCOMP,REP) ;;Sets a value to the array SEG(), used for building segments.
"RTN","HLOAPI",92,0)
 ;;Input:
"RTN","HLOAPI",93,0)
 ;; SEG - (required, pass by reference) - this is the array where the segment is being built.
"RTN","HLOAPI",94,0)
 ;; VALUE - the individual value to be set into the segment
"RTN","HLOAPI",95,0)
 ;; FIELD - the sequence # of the field (optional, defaults to 0)
"RTN","HLOAPI",96,0)
 ;;     *NOTE: FIELD=0 is used to denote the segment type.
"RTN","HLOAPI",97,0)
 ;; COMP - the # of the component (optional, defaults to 1)
"RTN","HLOAPI",98,0)
 ;; SUBCOMP - the # of the subcomponent (optional, defaults to 1)
"RTN","HLOAPI",99,0)
 ;; REP - the occurrence# (optional, defaults to 1)  For a non-repeating field, the occurrence # need not be provided, because it would be 1.
"RTN","HLOAPI",100,0)
 ;;Output: 
"RTN","HLOAPI",101,0)
 ;;  SEG array
"RTN","HLOAPI",102,0)
 ;;
"RTN","HLOAPI",103,0)
 ;;  Example:
"RTN","HLOAPI",104,0)
 ;;    D SET(.SEG,"MSA",0) creates an MSA segment 
"RTN","HLOAPI",105,0)
 ;;    D SET(.SEG,"AE",1) will place the value into the array position
"RTN","HLOAPI",106,0)
 ;;    reserved for the 1st field,1st occurence,1st comp,1st subcomp
"RTN","HLOAPI",107,0)
 ;;
"RTN","HLOAPI",108,0)
 ;;Implementation Note - This format is used for the segment array built by calls to SET: SEGMENT(<SEQ #>,<occurrence #>,<component #>,<subcomponent #>)=<subcomponent value> 
"RTN","HLOAPI",109,0)
 ;
"RTN","HLOAPI",110,0)
 S:'$G(FIELD) FIELD=0
"RTN","HLOAPI",111,0)
 S:'$G(COMP) COMP=1
"RTN","HLOAPI",112,0)
 S:'$G(SUBCOMP) SUBCOMP=1
"RTN","HLOAPI",113,0)
 S:'$G(REP) REP=1
"RTN","HLOAPI",114,0)
 S SEG(FIELD,REP,COMP,SUBCOMP)=$G(VALUE)
"RTN","HLOAPI",115,0)
 Q
"RTN","HLOAPI",116,0)
 ;
"RTN","HLOAPI",117,0)
ADDSEG(HLMSTATE,SEG,ERROR,TOARY) ;; Adds a segment to the message.
"RTN","HLOAPI",118,0)
 ;;Input:
"RTN","HLOAPI",119,0)
 ;;  HLMSTATE() - (pass by reference, required) This array is used by the HL7 package to track the progress of the message.  The application MUST NOT touch it!
"RTN","HLOAPI",120,0)
 ;;  SEG() - (pass by reference, required) Contains the data.  It must be built by calls to SET prior to calling $$ADDSEG.
"RTN","HLOAPI",121,0)
 ;;
"RTN","HLOAPI",122,0)
 ;;Note#1:  The message control segments, including the MSH and BHS segments, are added automatically.
"RTN","HLOAPI",123,0)
 ;;Note#2:  The 0th field must be a 3 character segment type
"RTN","HLOAPI",124,0)
 ;;Note#3: ***SEG is killed upon successfully adding the segment***
"RTN","HLOAPI",125,0)
 ;;
"RTN","HLOAPI",126,0)
 ;;Output:
"RTN","HLOAPI",127,0)
 ;;   HLMSTATE() - (pass by reference, required) This array is used by the HL7 package to track the progress of the message.
"RTN","HLOAPI",128,0)
 ;;  FUNCTION - returns 1 on success, 0 on failure
"RTN","HLOAPI",129,0)
 ;;  TOARY (optional, pass by reference) returns the built segment in
"RTN","HLOAPI",130,0)
 ;;        this format:
"RTN","HLOAPI",131,0)
 ;;         TOARY(1)
"RTN","HLOAPI",132,0)
 ;;         TOARY(2)
"RTN","HLOAPI",133,0)
 ;;         TOARY(3), etc.
"RTN","HLOAPI",134,0)
 ;;    If the segment fits on a single line, only TOARY(1) is returned.
"RTN","HLOAPI",135,0)
 ;;
"RTN","HLOAPI",136,0)
 ;;  ERROR (optional, pass by reference) - returns an error message on failure
"RTN","HLOAPI",137,0)
 ;;
"RTN","HLOAPI",138,0)
 ;
"RTN","HLOAPI",139,0)
 K ERROR
"RTN","HLOAPI",140,0)
 N TYPE
"RTN","HLOAPI",141,0)
 K TOARY
"RTN","HLOAPI",142,0)
 ;
"RTN","HLOAPI",143,0)
 S TYPE=$G(SEG(0,1,1,1)) ;segment type
"RTN","HLOAPI",144,0)
 ;
"RTN","HLOAPI",145,0)
 ;if a 'generic' app ack MSA was built, add it as the first segment before this one
"RTN","HLOAPI",146,0)
 I $D(HLMSTATE("MSA")) D
"RTN","HLOAPI",147,0)
 .I TYPE'="MSA" S TOARY(1)=HLMSTATE("MSA") D ADDSEG^HLOMSG(.HLMSTATE,.TOARY) K TOARY
"RTN","HLOAPI",148,0)
 .K HLMSTATE("MSA")
"RTN","HLOAPI",149,0)
 ;
"RTN","HLOAPI",150,0)
 I ($L(TYPE)'=3) S ERROR="INVALID SEGMENT TYPE" Q 0
"RTN","HLOAPI",151,0)
 I (TYPE="MSH")!(TYPE="BHS")!(TYPE="BTS")!(TYPE="FHS")!(TYPE="FTS") S ERROR="INVALID SEGMENT TYPE" Q 0
"RTN","HLOAPI",152,0)
 I HLMSTATE("BATCH"),'HLMSTATE("BATCH","CURRENT MESSAGE") S ERROR="NO MESSAGES IN BATCH, SO SEGMENTS NOT ALLOWED" Q 0
"RTN","HLOAPI",153,0)
 I $$BUILDSEG^HLOPBLD(.HLMSTATE,.SEG,.TOARY,.ERROR) D ADDSEG^HLOMSG(.HLMSTATE,.TOARY) K SEG Q 1
"RTN","HLOAPI",154,0)
 Q 0
"RTN","HLOAPI",155,0)
 ;
"RTN","HLOAPI",156,0)
ADDMSG(HLMSTATE,PARMS,ERROR) ;; Begins a new message in the batch.
"RTN","HLOAPI",157,0)
 ;;Input:
"RTN","HLOAPI",158,0)
 ;;  HLMSTATE() - (pass by reference, required) This array is used by the HL7 package to track the progress of the message.  The application MUST NOT touch it!
"RTN","HLOAPI",159,0)
 ;;  PARMS( *pass by reference*
"RTN","HLOAPI",160,0)
 ;;    "EVENT")=3 character event type (required)
"RTN","HLOAPI",161,0)
 ;;    "MESSAGE TYPE")=3 character message type (required)
"RTN","HLOAPI",162,0)
 ;;
"RTN","HLOAPI",163,0)
 ;;Output:
"RTN","HLOAPI",164,0)
 ;;   FUNCTION - returns 1 on success, 0 on failure
"RTN","HLOAPI",165,0)
 ;;   HLMSTATE() - (pass by reference, required) This array is used by the HL7 package to track the progress of the message.
"RTN","HLOAPI",166,0)
 ;;   PARMS - left defined when this function returns
"RTN","HLOAPI",167,0)
 ;;   ERROR (optional, pass by reference) - returns an error message on failure
"RTN","HLOAPI",168,0)
 ;;
"RTN","HLOAPI",169,0)
 N I
"RTN","HLOAPI",170,0)
 K ERROR
"RTN","HLOAPI",171,0)
 ;if a 'generic' app ack MSA was built, add it as the first segment before this one
"RTN","HLOAPI",172,0)
 I $D(HLMSTATE("MSA")) D
"RTN","HLOAPI",173,0)
 .N TOARY S TOARY(1)=HLMSTATE("MSA") D ADDSEG^HLOMSG(.HLMSTATE,.TOARY)
"RTN","HLOAPI",174,0)
 .K HLMSTATE("MSA")
"RTN","HLOAPI",175,0)
 I $L($G(PARMS("EVENT")))'=3 S ERROR="EVENT TYPE INVALID" Q 0
"RTN","HLOAPI",176,0)
 I $L($G(PARMS("MESSAGE TYPE")))'=3 S ERROR="MESSAGE TYPE INVALID" Q 0
"RTN","HLOAPI",177,0)
 D ADDMSG^HLOMSG(.HLMSTATE,.PARMS)
"RTN","HLOAPI",178,0)
 Q 1
"RTN","HLOAPI",179,0)
 ;
"RTN","HLOAPI",180,0)
GETSYS(HLMSTATE) ;
"RTN","HLOAPI",181,0)
 N SYS,SUB
"RTN","HLOAPI",182,0)
 D SYSPARMS^HLOSITE(.SYS)
"RTN","HLOAPI",183,0)
 F SUB="DOMAIN","STATION","PROCESSING ID","MAXSTRING","ERROR PURGE","NORMAL PURGE","PORT" S HLMSTATE("SYSTEM",SUB)=SYS(SUB)
"RTN","HLOAPI",184,0)
 S HLMSTATE("SYSTEM","BUFFER")=SYS("USER BUFFER")
"RTN","HLOAPI",185,0)
 Q
"RTN","HLOAPI",186,0)
 ;
"RTN","HLOAPI",187,0)
MOVEMSG(HLMSTATE,ARY) ;;
"RTN","HLOAPI",188,0)
 ;;If a message was built in the 'old' way, and resides in an array, this  routine will move it into file 777 (HL7 Message Body)
"RTN","HLOAPI",189,0)
 ;;Input:
"RTN","HLOAPI",190,0)
 ;;  HLMSTATE (pass by reference) the array created by calling $$NEWMSG or $$NEWBATCH
"RTN","HLOAPI",191,0)
 ;;  ARY - is the name of the array, local or global, where the message was built, used to reference the array by indirection.
"RTN","HLOAPI",192,0)
 ;;
"RTN","HLOAPI",193,0)
 N I S I=0
"RTN","HLOAPI",194,0)
 F  S I=$O(@ARY@(I)) Q:'I  D
"RTN","HLOAPI",195,0)
 .N SEG,J,J2
"RTN","HLOAPI",196,0)
 .S J=0,J2=1
"RTN","HLOAPI",197,0)
 .S SEG(J2)=@ARY@(I)
"RTN","HLOAPI",198,0)
 .F  S J=$O(@ARY@(I,J)) Q:'J  S J2=J2+1,SEG(J2)=@ARY@(I,J)
"RTN","HLOAPI",199,0)
 .I 'HLMSTATE("BATCH") D
"RTN","HLOAPI",200,0)
 ..D ADDSEG^HLOMSG(.HLMSTATE,.SEG)
"RTN","HLOAPI",201,0)
 .E  D
"RTN","HLOAPI",202,0)
 ..I $E(SEG(1),1,3)="MSH" D
"RTN","HLOAPI",203,0)
 ...D SPLITHDR^HLOSRVR1(.SEG)
"RTN","HLOAPI",204,0)
 ...D ADDMSG2^HLOMSG(.HLMSTATE,.SEG)
"RTN","HLOAPI",205,0)
 ..E  D ADDSEG^HLOMSG(.HLMSTATE,.SEG)
"RTN","HLOAPI",206,0)
 ;
"RTN","HLOAPI",207,0)
 ;signal SENDACK^HLOAPI2 that the application built its own msg
"RTN","HLOAPI",208,0)
 K HLMSTATE("MSA")
"RTN","HLOAPI",209,0)
 Q
"RTN","HLOAPI6")
0^3^B9832520^n/a
"RTN","HLOAPI6",1,0)
HLOAPI6 ;OIFO-OAK/RBN - VDEF HLO User interface API ;10/02/2008
"RTN","HLOAPI6",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**139**;Oct 13, 1995;Build 11
"RTN","HLOAPI6",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOAPI6",4,0)
 ;
"RTN","HLOAPI6",5,0)
 ;
"RTN","HLOAPI6",6,0)
 ; No direct calls - must use $$VDEFPCK^HLOAPI5
"RTN","HLOAPI6",7,0)
 ;
"RTN","HLOAPI6",8,0)
 Q
"RTN","HLOAPI6",9,0)
 ;
"RTN","HLOAPI6",10,0)
VDEFPCK(LINK,APP,TYPE,EVENT) ;; VDEF PARAMETER CHECK function
"RTN","HLOAPI6",11,0)
 ;;
"RTN","HLOAPI6",12,0)
 ;; REQUIREMENT #4 HL*1.6*139
"RTN","HLOAPI6",13,0)
 ;;
"RTN","HLOAPI6",14,0)
 ;;  
"RTN","HLOAPI6",15,0)
 ;;  Description:
"RTN","HLOAPI6",16,0)
 ;;               This API is provided to allow VDEF to verify that HLO is installed,
"RTN","HLOAPI6",17,0)
 ;;               running and has all the required parameters for a specific HL7
"RTN","HLOAPI6",18,0)
 ;;               message type and HL7 event type.  These parameters must be defined
"RTN","HLOAPI6",19,0)
 ;;               prior to use by VDEF users before VDEF can use HLO.
"RTN","HLOAPI6",20,0)
 ;;
"RTN","HLOAPI6",21,0)
 ;;  Inputs :
"RTN","HLOAPI6",22,0)
 ;;            The input parameters are all required if used. 
"RTN","HLOAPI6",23,0)
 ;;            1 LINK : Name of HL7 logical link.
"RTN","HLOAPI6",24,0)
 ;;            2 APP  : Name of HLO application.
"RTN","HLOAPI6",25,0)
 ;;            3 TYPE : HL7 Message Type.
"RTN","HLOAPI6",26,0)
 ;;            4 EVENT: HL7 Event type.
"RTN","HLOAPI6",27,0)
 ;;
"RTN","HLOAPI6",28,0)
 ;;  Outputs: Returns
"RTN","HLOAPI6",29,0)
 ;;             With input parameters:
"RTN","HLOAPI6",30,0)
 ;;              1         VDEF Event 'xxxxx' parameters exists HLO Engine.
"RTN","HLOAPI6",31,0)
 ;;              0         HLO running but parameters for VDEF Event 'xxxx'don't exist.
"RTN","HLOAPI6",32,0)
 ;;             -1         HLO installed but not running on target system.
"RTN","HLOAPI6",33,0)
 ;;             -2         HLO not installed on target system.
"RTN","HLOAPI6",34,0)
 ;;               
"RTN","HLOAPI6",35,0)
 ;;             If input parameters are null:
"RTN","HLOAPI6",36,0)
 ;;              1         HLO installed and running.
"RTN","HLOAPI6",37,0)
 ;;             -1         HLO installed but not running on target system.
"RTN","HLOAPI6",38,0)
 ;;             -2         HLO not installed on target system.
"RTN","HLOAPI6",39,0)
 ;;
"RTN","HLOAPI6",40,0)
 ;;  Variables used:
"RTN","HLOAPI6",41,0)
 ;;               .
"RTN","HLOAPI6",42,0)
 ;;               PARM1   - IEN of link in HL&7 Logical Link file (#870)
"RTN","HLOAPI6",43,0)
 ;;               PARM2   - IEN of application in HLO APPLICATION registry file (#779.2)
"RTN","HLOAPI6",44,0)
 ;;               PARM3   - IEN of message type in MESSAGE TYPE ACTION subfile (#779.21)
"RTN","HLOAPI6",45,0)
 ;;               RESULT  - Return value.
"RTN","HLOAPI6",46,0)
 ;; 
"RTN","HLOAPI6",47,0)
 ;
"RTN","HLOAPI6",48,0)
 N RESULT,PARM1,PARM2,PARM3
"RTN","HLOAPI6",49,0)
 S RESULT=-2
"RTN","HLOAPI6",50,0)
 ; Is HLO installed?
"RTN","HLOAPI6",51,0)
 Q:$D(^HLD(779.1))=0 RESULT
"RTN","HLOAPI6",52,0)
 ;
"RTN","HLOAPI6",53,0)
 ; Is HLO running?
"RTN","HLOAPI6",54,0)
 S RESULT=-1
"RTN","HLOAPI6",55,0)
 Q:$P($G(^HLD(779.1,1,0)),"^",9)=0 RESULT
"RTN","HLOAPI6",56,0)
 ;
"RTN","HLOAPI6",57,0)
 ; null parameters, so exit with a 1
"RTN","HLOAPI6",58,0)
 S RESULT=1
"RTN","HLOAPI6",59,0)
 Q:'$G(LINK)&'$G(APP)&'$G(TYPE)&'$G(EVENT) RESULT
"RTN","HLOAPI6",60,0)
 ;
"RTN","HLOAPI6",61,0)
 ; Are the link, app and event setup?
"RTN","HLOAPI6",62,0)
 S RESULT=0
"RTN","HLOAPI6",63,0)
 S (PARM1,PARM2,PARM3)=""
"RTN","HLOAPI6",64,0)
 S PARM1=$O(^HLCS(870,"B",LINK,PARM1))
"RTN","HLOAPI6",65,0)
 S PARM2=$O(^HLD(779.2,"B",APP,PARM2))
"RTN","HLOAPI6",66,0)
 I (PARM1&PARM2) D
"RTN","HLOAPI6",67,0)
 . S PARM3=$O(^HLD(779.2,PARM2,1,"B",TYPE,PARM3))
"RTN","HLOAPI6",68,0)
 . ; Yes, so return a 1
"RTN","HLOAPI6",69,0)
 . I PARM3 D
"RTN","HLOAPI6",70,0)
 . .  S:$P(^HLD(779.2,PARM2,1,PARM3,0),"^",2)=EVENT RESULT=1
"RTN","HLOAPI6",71,0)
 Q RESULT
"RTN","HLOAPP")
0^9^B13112019^B11107696
"RTN","HLOAPP",1,0)
HLOAPP ;ALB/CJM-HL7 -Application Registry ;11/10/2008
"RTN","HLOAPP",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,132,137,139**;Oct 13, 1995;Build 11
"RTN","HLOAPP",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOAPP",4,0)
 ;
"RTN","HLOAPP",5,0)
GETIEN(NAME) ;given the application name, it finds the ien.  Returns 0 on failure
"RTN","HLOAPP",6,0)
 Q:'$L($G(NAME)) 0
"RTN","HLOAPP",7,0)
 Q +$O(^HLD(779.2,"C",$E(NAME,1,60),0))
"RTN","HLOAPP",8,0)
 ;
"RTN","HLOAPP",9,0)
ACTION(HEADER,ACTION,QUEUE) ;Given the parsed header of a message it returns both the action that should be performed in response to the message and the incoming queue that it should be placed on.
"RTN","HLOAPP",10,0)
 ;
"RTN","HLOAPP",11,0)
 ;** do not immplement the Pass Immediate parameter **
"RTN","HLOAPP",12,0)
 ;ACTION(HEADER,ACTION,QUEUE,IMMEDIATE);Given the parsed header of a message it returns both the action that should be performed in response to the message and the incoming queue that it should be placed on.
"RTN","HLOAPP",13,0)
 ;
"RTN","HLOAPP",14,0)
 ;Input:
"RTN","HLOAPP",15,0)
 ;  HEADER() subscripts are used: "RECEIVING APPLICATION","SEGMENT TYPE", "MESSAGE TYPE", "EVENT", "VERSION"
"RTN","HLOAPP",16,0)
 ;Output:
"RTN","HLOAPP",17,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOAPP",18,0)
 ;  ACTION (pass by reference) <tag>^<rtn>
"RTN","HLOAPP",19,0)
 ;  QUEUE (pass by reference) returns the named queue if there is one, else "DEFAULT"
"RTN","HLOAPP",20,0)
 ;
"RTN","HLOAPP",21,0)
 ;** do not immplement the Pass Immediate parameter **
"RTN","HLOAPP",22,0)
 ;  IMMEDIATE (pass by reference, optional) returns 1 if the application wants its messages passed to the incoming queue immediately, 0 otherwise
"RTN","HLOAPP",23,0)
 ;
"RTN","HLOAPP",24,0)
 N IEN
"RTN","HLOAPP",25,0)
 S (ACTION,QUEUE)=""
"RTN","HLOAPP",26,0)
 S IEN=$$GETIEN(HEADER("RECEIVING APPLICATION"))
"RTN","HLOAPP",27,0)
 Q:'$G(IEN) 0
"RTN","HLOAPP",28,0)
 I $G(HEADER("SEGMENT TYPE"))="BHS" D
"RTN","HLOAPP",29,0)
 .S NODE=$G(^HLD(779.2,IEN,0))
"RTN","HLOAPP",30,0)
 .I $P(NODE,"^",5)]"" D
"RTN","HLOAPP",31,0)
 ..S ACTION=$P(NODE,"^",4,5)
"RTN","HLOAPP",32,0)
 .E  I $P(NODE,"^",7)]"" S ACTION=$P(NODE,"^",6,7)
"RTN","HLOAPP",33,0)
 .I $P(NODE,"^",8)]"" D
"RTN","HLOAPP",34,0)
 ..S QUEUE=$P(NODE,"^",8)
"RTN","HLOAPP",35,0)
 .E  I $P(NODE,"^",3)]"" S QUEUE=$P(NODE,"^",3)
"RTN","HLOAPP",36,0)
 E  I HEADER("SEGMENT TYPE")="MSH" D
"RTN","HLOAPP",37,0)
 .I HEADER("MESSAGE TYPE")'="",HEADER("EVENT")'="" D
"RTN","HLOAPP",38,0)
 ..N SUBIEN,NODE
"RTN","HLOAPP",39,0)
 ..;did the application specify an action for the particular version of this message?
"RTN","HLOAPP",40,0)
 ..I HEADER("VERSION")'="" S SUBIEN=$O(^HLD(779.2,IEN,1,"D",HEADER("MESSAGE TYPE"),HEADER("EVENT"),HEADER("VERSION"),0))
"RTN","HLOAPP",41,0)
 ..;if not, look on the "C" index
"RTN","HLOAPP",42,0)
 ..S:'$G(SUBIEN) SUBIEN=$O(^HLD(779.2,IEN,1,"C",HEADER("MESSAGE TYPE"),HEADER("EVENT"),0))
"RTN","HLOAPP",43,0)
 ..;
"RTN","HLOAPP",44,0)
 ..I SUBIEN D
"RTN","HLOAPP",45,0)
 ...S NODE=$G(^HLD(779.2,IEN,1,SUBIEN,0))
"RTN","HLOAPP",46,0)
 ...I $P(NODE,"^",5)]"" S ACTION=$P(NODE,"^",4,5)
"RTN","HLOAPP",47,0)
 ...I $P(NODE,"^",3)]"" S QUEUE=$P(NODE,"^",3)
"RTN","HLOAPP",48,0)
 ...;
"RTN","HLOAPP",49,0)
 ...;** do not immplement the Pass Immediate parameter **
"RTN","HLOAPP",50,0)
 ...S IMMEDIATE=$P(NODE,"^",8)
"RTN","HLOAPP",51,0)
 ...;
"RTN","HLOAPP",52,0)
 ..I ACTION="" S NODE=$G(^HLD(779.2,IEN,0)) I $P(NODE,"^",7)]"" S ACTION=$P(NODE,"^",6,7)
"RTN","HLOAPP",53,0)
 ..I QUEUE="" S NODE=$G(^HLD(779.2,IEN,0)) I $P(NODE,"^",3)]"" S QUEUE=$P(NODE,"^",3)
"RTN","HLOAPP",54,0)
 I QUEUE="" S QUEUE="DEFAULT"
"RTN","HLOAPP",55,0)
 ;
"RTN","HLOAPP",56,0)
 ;** do not immplement the Pass Immediate parameter **
"RTN","HLOAPP",57,0)
 I $G(IMMEDIATE)'=1 S IMMEDIATE=0
"RTN","HLOAPP",58,0)
 ;
"RTN","HLOAPP",59,0)
 I ACTION="" Q 0
"RTN","HLOAPP",60,0)
 Q 1
"RTN","HLOAPP",61,0)
 ;
"RTN","HLOAPP",62,0)
RTRNLNK(APPNAME) ;
"RTN","HLOAPP",63,0)
 ;given the name of a receiving application, this returns the return
"RTN","HLOAPP",64,0)
 ;link for application acks if one is provided.  Otherwise, return
"RTN","HLOAPP",65,0)
 ;acks are routed based on the information provide in the message hdr
"RTN","HLOAPP",66,0)
 ;
"RTN","HLOAPP",67,0)
 Q:(APPNAME="") ""
"RTN","HLOAPP",68,0)
 N IEN
"RTN","HLOAPP",69,0)
 S IEN=$$GETIEN(APPNAME)
"RTN","HLOAPP",70,0)
 Q:IEN $P($G(^HLD(779.2,IEN,0)),"^",2)
"RTN","HLOAPP",71,0)
 Q ""
"RTN","HLOAPP",72,0)
 ;
"RTN","HLOAPP",73,0)
RTRNPORT(APPNAME) ;
"RTN","HLOAPP",74,0)
 ;Given the name of the sending application, IF the application has its
"RTN","HLOAPP",75,0)
 ;own listener, its port # is returned.  Application acks should be
"RTN","HLOAPP",76,0)
 ;returned using that port
"RTN","HLOAPP",77,0)
 Q:(APPNAME="") ""
"RTN","HLOAPP",78,0)
 N IEN,LINK
"RTN","HLOAPP",79,0)
 S IEN=$$GETIEN(APPNAME)
"RTN","HLOAPP",80,0)
 Q:'IEN ""
"RTN","HLOAPP",81,0)
 S LINK=$P($G(^HLD(779.2,IEN,0)),"^",9)
"RTN","HLOAPP",82,0)
 Q:'LINK ""
"RTN","HLOAPP",83,0)
 Q $$PORT^HLOTLNK(LINK)
"RTN","HLOAPP",84,0)
 ;
"RTN","HLOAPP",85,0)
ACTIVE(APP,MSGTYPE,EVENT,VERSION) ;
"RTN","HLOAPP",86,0)
 ;Returns 1 if the message's INACTIVE flag has NOT been set.
"RTN","HLOAPP",87,0)
 ;
"RTN","HLOAPP",88,0)
 ;Input:
"RTN","HLOAPP",89,0)
 ;  APP (required) the name of the sending application
"RTN","HLOAPP",90,0)
 ;  MSGTYPE (required) 3 character HL7 message type
"RTN","HLOAPP",91,0)
 ;  EVENT (required) 3 character HL7 event
"RTN","HLOAPP",92,0)
 ;  VERSION (optional) HL7 version ID as it appears in the message header
"RTN","HLOAPP",93,0)
 ;Output:
"RTN","HLOAPP",94,0)
 ;  Function returns 1 if the message type specified by the input parameters has not been set to INACTIVE.  It returns 0 otherwise.
"RTN","HLOAPP",95,0)
 ;
"RTN","HLOAPP",96,0)
 N IEN,ACTIVE,SUBIEN
"RTN","HLOAPP",97,0)
 S ACTIVE=1
"RTN","HLOAPP",98,0)
 S IEN=$$GETIEN($G(APP))
"RTN","HLOAPP",99,0)
 Q:'$G(IEN) ACTIVE
"RTN","HLOAPP",100,0)
 Q:$G(MSGTYPE)="" ACTIVE
"RTN","HLOAPP",101,0)
 Q:$G(EVENT)="" ACTIVE
"RTN","HLOAPP",102,0)
 ;did the application specify an action for the particular version of this message?
"RTN","HLOAPP",103,0)
 I $G(VERSION)'="" S SUBIEN=$O(^HLD(779.2,IEN,1,"D",MSGTYPE,EVENT,VERSION,0))
"RTN","HLOAPP",104,0)
 ;if not, look on the "C" index
"RTN","HLOAPP",105,0)
 S:'$G(SUBIEN) SUBIEN=$O(^HLD(779.2,IEN,1,"C",MSGTYPE,EVENT,0))
"RTN","HLOAPP",106,0)
 ;
"RTN","HLOAPP",107,0)
 S:SUBIEN ACTIVE='(+$P($G(^HLD(779.2,IEN,1,SUBIEN,0)),"^",7))
"RTN","HLOAPP",108,0)
 Q ACTIVE
"RTN","HLOAPP",109,0)
 ;
"RTN","HLOAPP",110,0)
EXCEPT(APPNAME) ;
"RTN","HLOAPP",111,0)
 ;returns the exception handler (tag^routine) that should be invoked
"RTN","HLOAPP",112,0)
 ;when an applicaiton's messages are being sequenced and an app ack
"RTN","HLOAPP",113,0)
 ;is not timely received
"RTN","HLOAPP",114,0)
 ;
"RTN","HLOAPP",115,0)
 N IEN,RTN
"RTN","HLOAPP",116,0)
 S IEN=$$GETIEN($G(APPNAME))
"RTN","HLOAPP",117,0)
 I IEN S RTN=$P($G(^HLD(779.2,IEN,0)),"^",10,11)
"RTN","HLOAPP",118,0)
 I $L($G(RTN))>1 Q RTN
"RTN","HLOAPP",119,0)
 Q "DEFAULT^HLOAPP"
"RTN","HLOAPP",120,0)
 ;
"RTN","HLOAPP",121,0)
DEFAULT ;default exception handler if the app doesn't specify one
"RTN","HLOAPP",122,0)
 S ^TMP("HLO SEQUENCING EXCEPTION",$J,$$NOW^XLFDT,+$G(HLMSGIEN))=""
"RTN","HLOAPP",123,0)
 Q
"RTN","HLOAPP",124,0)
 ;
"RTN","HLOAPP",125,0)
TIMEOUT(APPNAME) ;
"RTN","HLOAPP",126,0)
 N IEN,TIME
"RTN","HLOAPP",127,0)
 S IEN=$$GETIEN($G(APPNAME))
"RTN","HLOAPP",128,0)
 I IEN S TIME=$P($G(^HLD(779.2,IEN,0)),"^",12)
"RTN","HLOAPP",129,0)
 Q:'$G(TIME) 10
"RTN","HLOAPP",130,0)
 Q TIME
"RTN","HLOCLNT")
0^4^B75551909^B73473677
"RTN","HLOCLNT",1,0)
HLOCLNT ;ALB/CJM- Client for sending messages - 10/4/94 1pm ;10/10/2008
"RTN","HLOCLNT",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,130,131,134,137,139**;Oct 13, 1995;Build 11
"RTN","HLOCLNT",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOCLNT",4,0)
 ;
"RTN","HLOCLNT",5,0)
 ;GET WORK function for the process running under the Process Manager
"RTN","HLOCLNT",6,0)
GETWORK(QUE) ;
"RTN","HLOCLNT",7,0)
 ;Input:
"RTN","HLOCLNT",8,0)
 ;  QUE - (pass by reference) These subscripts are used:
"RTN","HLOCLNT",9,0)
 ;    ("LINK")  - <link name>_":"_<port> last obtained
"RTN","HLOCLNT",10,0)
 ;    ("QUEUE") - name of the queue last obtained
"RTN","HLOCLNT",11,0)
 ;Output:
"RTN","HLOCLNT",12,0)
 ;  Function returns 1 if success, 0 if no more work
"RTN","HLOCLNT",13,0)
 ;  QUE -  updated to identify next queue of messages to process.
"RTN","HLOCLNT",14,0)
 ;    ("LINK") - <link name>_":"_<port>
"RTN","HLOCLNT",15,0)
 ;    ("QUEUE") - the named queue on the link
"RTN","HLOCLNT",16,0)
 ;    ("DOWN") - =1 means that the last OPEN attempt failed
"RTN","HLOCLNT",17,0)
 ;
"RTN","HLOCLNT",18,0)
 N LINK,QUEUE
"RTN","HLOCLNT",19,0)
 S LINK=$G(QUE("LINK")),QUEUE=$G(QUE("QUEUE"))
"RTN","HLOCLNT",20,0)
 I (LINK]""),(QUEUE]"") D
"RTN","HLOCLNT",21,0)
 .L -^HLB("QUEUE","OUT",LINK,QUEUE)
"RTN","HLOCLNT",22,0)
 .I '$$CNNCTD(LINK),$$FAILING(.LINK) S QUEUE="" Q
"RTN","HLOCLNT",23,0)
 .F  S QUEUE=$O(^HLB("QUEUE","OUT",LINK,QUEUE)) Q:(QUEUE="")  I '$$STOPPED^HLOQUE("OUT",QUEUE) L +^HLB("QUEUE","OUT",LINK,QUEUE):0  Q:$T
"RTN","HLOCLNT",24,0)
 I (LINK]""),(QUEUE="") D
"RTN","HLOCLNT",25,0)
 .F  S LINK=$O(^HLB("QUEUE","OUT",LINK)) Q:LINK=""  D  Q:$L(QUEUE)
"RTN","HLOCLNT",26,0)
 ..I '$$CNNCTD(LINK),$$FAILING(.LINK) Q
"RTN","HLOCLNT",27,0)
 ..S QUEUE="" F  S QUEUE=$O(^HLB("QUEUE","OUT",LINK,QUEUE)) Q:(QUEUE="")  I '$$STOPPED^HLOQUE("OUT",QUEUE) L +^HLB("QUEUE","OUT",LINK,QUEUE):0 Q:$T
"RTN","HLOCLNT",28,0)
 I LINK="" D
"RTN","HLOCLNT",29,0)
 .F  S LINK=$O(^HLB("QUEUE","OUT",LINK)) Q:LINK=""  D  Q:$L(QUEUE)
"RTN","HLOCLNT",30,0)
 ..I '$$CNNCTD(LINK),$$FAILING(.LINK) Q
"RTN","HLOCLNT",31,0)
 ..S QUEUE="" F  S QUEUE=$O(^HLB("QUEUE","OUT",LINK,QUEUE)) Q:(QUEUE="")  I '$$STOPPED^HLOQUE("OUT",QUEUE) L +^HLB("QUEUE","OUT",LINK,QUEUE):0 Q:$T
"RTN","HLOCLNT",32,0)
 S QUE("LINK")=LINK,QUE("QUEUE")=QUEUE,QUE("DOWN")=$G(LINK("DOWN"))
"RTN","HLOCLNT",33,0)
 Q:$L(QUEUE) 1
"RTN","HLOCLNT",34,0)
 D:$G(HLCSTATE("CONNECTED")) CLOSE^HLOT(.HLCSTATE)
"RTN","HLOCLNT",35,0)
 Q 0
"RTN","HLOCLNT",36,0)
 ;
"RTN","HLOCLNT",37,0)
FAILING(LINK) ;
"RTN","HLOCLNT",38,0)
 ;Returns 1 if the link has failed in the last 30 seconds, 0 otherwise
"RTN","HLOCLNT",39,0)
 ;Also returns LINK("DOWN")=1 if the link was failing > 30 seconds ago, not yet known if its up
"RTN","HLOCLNT",40,0)
 ;
"RTN","HLOCLNT",41,0)
 N LASTTIME,SET
"RTN","HLOCLNT",42,0)
 S LINK("DOWN")=0
"RTN","HLOCLNT",43,0)
 S LASTTIME=$G(^HLB("QUEUE","OUT",LINK))
"RTN","HLOCLNT",44,0)
 S SET=$S(LASTTIME]"":1,1:0)
"RTN","HLOCLNT",45,0)
 I SET D
"RTN","HLOCLNT",46,0)
 .I $$HDIFF^XLFDT($H,LASTTIME,2)>30 S ^HLB("QUEUE","OUT",LINK)="",SET=0,LINK("DOWN")=1
"RTN","HLOCLNT",47,0)
 I $D(^HLTMP("FAILING LINKS",LINK)) S LINK("DOWN")=1
"RTN","HLOCLNT",48,0)
 Q SET
"RTN","HLOCLNT",49,0)
 ;
"RTN","HLOCLNT",50,0)
LINKDOWN(HLCSTATE) ;
"RTN","HLOCLNT",51,0)
 D:$G(HLCSTATE("CONNECTED")) CLOSE^HLOT(.HLCSTATE)
"RTN","HLOCLNT",52,0)
 I $D(HLCSTATE("LINK","NAME")),$D(HLCSTATE("LINK","PORT")) D
"RTN","HLOCLNT",53,0)
 .S TO=HLCSTATE("LINK","NAME")_":"_HLCSTATE("LINK","PORT")
"RTN","HLOCLNT",54,0)
 .S ^HLB("QUEUE","OUT",TO)=$H
"RTN","HLOCLNT",55,0)
 .S:'$D(^HLTMP("FAILING LINKS",TO)) ^HLTMP("FAILING LINKS",TO)=$H
"RTN","HLOCLNT",56,0)
 Q
"RTN","HLOCLNT",57,0)
 ;
"RTN","HLOCLNT",58,0)
ERROR ;error trap
"RTN","HLOCLNT",59,0)
ZB3 ;
"RTN","HLOCLNT",60,0)
 ;
"RTN","HLOCLNT",61,0)
 S $ETRAP="Q:$QUIT """" Q"
"RTN","HLOCLNT",62,0)
 ;
"RTN","HLOCLNT",63,0)
 N HOUR
"RTN","HLOCLNT",64,0)
 S HOUR=$E($$NOW^XLFDT,1,10)
"RTN","HLOCLNT",65,0)
 S ^TMP("HL7 ERRORS",$J,HOUR,$P($ECODE,",",2))=$G(^TMP("HL7 ERRORS",$J,HOUR,$P($ECODE,",",2)))+1
"RTN","HLOCLNT",66,0)
 D END
"RTN","HLOCLNT",67,0)
 D LINKDOWN(.HLCSTATE)
"RTN","HLOCLNT",68,0)
 ;
"RTN","HLOCLNT",69,0)
 I ($ECODE["TOOMANYFILES")!($ECODE["EDITED") Q:$QUIT "" Q
"RTN","HLOCLNT",70,0)
 ;while debugging quit on all errors - this will return the process to the Process Manager error trap
"RTN","HLOCLNT",71,0)
 I $G(^HLTMP("LOG ALL ERRORS")) Q:$QUIT "" Q
"RTN","HLOCLNT",72,0)
 ;
"RTN","HLOCLNT",73,0)
 ;don't log some common errors
"RTN","HLOCLNT",74,0)
 I ($ECODE["READ")!($ECODE["NOTOPEN")!($ECODE["DEVNOTOPN")!($ECODE["WRITE")!($ECODE["OPENERR") D
"RTN","HLOCLNT",75,0)
 .;
"RTN","HLOCLNT",76,0)
 E  D
"RTN","HLOCLNT",77,0)
 .;but do log all the others
"RTN","HLOCLNT",78,0)
 .D ^%ZTER
"RTN","HLOCLNT",79,0)
 ;
"RTN","HLOCLNT",80,0)
 ;a lot of errors of the same type may indicate an endless loop
"RTN","HLOCLNT",81,0)
 ;return to the Process Manager error trap
"RTN","HLOCLNT",82,0)
 I ($G(^TMP("HL7 ERRORS",$J,HOUR,$P($ECODE,",",2)))>30) Q:$QUIT "" Q
"RTN","HLOCLNT",83,0)
 ;
"RTN","HLOCLNT",84,0)
 ;resume execution of the process manager executing the client
"RTN","HLOCLNT",85,0)
 D UNWIND^%ZTER
"RTN","HLOCLNT",86,0)
 Q
"RTN","HLOCLNT",87,0)
 ;
"RTN","HLOCLNT",88,0)
DOWORK(QUEUE) ;sends the messages on the queue
"RTN","HLOCLNT",89,0)
ZB0 N $ETRAP,$ESTACK S $ETRAP="G ERROR^HLOCLNT"
"RTN","HLOCLNT",90,0)
 N MSGIEN,DEQUE,SUCCESS,MSGCOUNT
"RTN","HLOCLNT",91,0)
 S DEQUE=0
"RTN","HLOCLNT",92,0)
 S SUCCESS=1
"RTN","HLOCLNT",93,0)
 ;
"RTN","HLOCLNT",94,0)
 I '$$CNNCTD(QUEUE("LINK")),'$$CONNECT^HLOCLNT1($P(QUEUE("LINK"),":"),$P(QUEUE("LINK"),":",2),30,.HLCSTATE) Q
"RTN","HLOCLNT",95,0)
 S (MSGCOUNT,MSGIEN)=0
"RTN","HLOCLNT",96,0)
 F  S MSGIEN=$O(^HLB("QUEUE","OUT",QUEUE("LINK"),QUEUE("QUEUE"),MSGIEN)) D  Q:'SUCCESS  Q:MSGCOUNT>1000
"RTN","HLOCLNT",97,0)
 .S:'MSGIEN SUCCESS=0
"RTN","HLOCLNT",98,0)
ZB4 .;
"RTN","HLOCLNT",99,0)
 .Q:'SUCCESS
"RTN","HLOCLNT",100,0)
 .N UPDATE
"RTN","HLOCLNT",101,0)
 .S ^HLB(MSGIEN,"TRIES")=$G(^HLB(MSGIEN,"TRIES"))+1
"RTN","HLOCLNT",102,0)
 .S SUCCESS=0
"RTN","HLOCLNT",103,0)
 .S:$$TRANSMIT(.HLCSTATE,MSGIEN,.UPDATE) SUCCESS=1
"RTN","HLOCLNT",104,0)
 .Q:('SUCCESS)!('$D(UPDATE))
"RTN","HLOCLNT",105,0)
 .D DEQUE(.UPDATE)
"RTN","HLOCLNT",106,0)
 .S MSGCOUNT=MSGCOUNT+1
"RTN","HLOCLNT",107,0)
 .D:HLCSTATE("COUNTS")>4 SAVECNTS^HLOSTAT(.HLCSTATE)
"RTN","HLOCLNT",108,0)
 .;
"RTN","HLOCLNT",109,0)
 .;if the queue was on the down list, and not since shutdown, mark it as up, since a message has been successfully transmitted across it
"RTN","HLOCLNT",110,0)
 .I $G(QUEUE("DOWN"))!$$FAILING(QUEUE("LINK")),'$$IFSHUT^HLOTLNK(QUEUE("LINK")) S QUEUE("DOWN")=0,^HLB("QUEUE","OUT",QUEUE("LINK"))="" K ^HLTMP("FAILING LINKS",QUEUE("LINK"))
"RTN","HLOCLNT",111,0)
 ;
"RTN","HLOCLNT",112,0)
ZB5 ;
"RTN","HLOCLNT",113,0)
END D DEQUE()
"RTN","HLOCLNT",114,0)
 D SAVECNTS^HLOSTAT(.HLCSTATE)
"RTN","HLOCLNT",115,0)
 Q
"RTN","HLOCLNT",116,0)
CNNCTD(LINK) ;
"RTN","HLOCLNT",117,0)
 ;Connected to LINK?  HLCSTATE must be defined, LINK=<link name>:<port>
"RTN","HLOCLNT",118,0)
 ;
"RTN","HLOCLNT",119,0)
 I ($G(HLCSTATE("LINK","NAME"))=$P(LINK,":")),($G(HLCSTATE("LINK","PORT"))=$P(LINK,":",2)),$G(HLCSTATE("CONNECTED")) Q 1
"RTN","HLOCLNT",120,0)
 Q 0
"RTN","HLOCLNT",121,0)
 ;
"RTN","HLOCLNT",122,0)
DEQUE(UPDATE) ;
"RTN","HLOCLNT",123,0)
 I $D(UPDATE) S DEQUE=DEQUE+1,DEQUE(+UPDATE)=$P(UPDATE,"^",2,99) S:$G(UPDATE("MSA"))]"" DEQUE(+UPDATE,"MSA")=UPDATE("MSA") S:$G(UPDATE("ACTION"))]"" DEQUE(+UPDATE,"ACTION")=UPDATE("ACTION")
"RTN","HLOCLNT",124,0)
 I '$D(UPDATE)!(DEQUE>15) D
"RTN","HLOCLNT",125,0)
 .N MSGIEN S MSGIEN=0
"RTN","HLOCLNT",126,0)
 .F  S MSGIEN=$O(DEQUE(MSGIEN)) Q:'MSGIEN  D
"RTN","HLOCLNT",127,0)
 ..N NODE,TIME
"RTN","HLOCLNT",128,0)
 ..D DEQUE^HLOQUE(QUEUE("LINK"),QUEUE("QUEUE"),"OUT",MSGIEN)
"RTN","HLOCLNT",129,0)
 ..S TIME=$P(DEQUE(MSGIEN),"^")
"RTN","HLOCLNT",130,0)
 ..Q:'TIME
"RTN","HLOCLNT",131,0)
 ..S NODE=QUEUE("LINK")_"^"_QUEUE("QUEUE")_"^"_$P(DEQUE(MSGIEN),"^",2,99)
"RTN","HLOCLNT",132,0)
 ..S ^HLTMP("CLIENT UPDATES",$J,TIME,MSGIEN)=NODE
"RTN","HLOCLNT",133,0)
 ..S:$G(DEQUE(MSGIEN,"MSA"))]"" ^HLTMP("CLIENT UPDATES",$J,TIME,MSGIEN,"MSA")=DEQUE(MSGIEN,"MSA")
"RTN","HLOCLNT",134,0)
 ..S:$G(DEQUE(MSGIEN,"ACTION"))]"" ^HLTMP("CLIENT UPDATES",$J,TIME,MSGIEN,"ACTION")=DEQUE(MSGIEN,"ACTION")
"RTN","HLOCLNT",135,0)
 .K DEQUE S DEQUE=0
"RTN","HLOCLNT",136,0)
 Q
"RTN","HLOCLNT",137,0)
 ;
"RTN","HLOCLNT",138,0)
TRANSMIT(HLCSTATE,MSGIEN,UPDATE) ;
"RTN","HLOCLNT",139,0)
 ;Transmits a single message and if a commit ack was requested reads it.  Updates file 778 with the result.  Queues for the infiler the application accept action if one was requested.
"RTN","HLOCLNT",140,0)
 ;Input:
"RTN","HLOCLNT",141,0)
 ;   HLCSTATE (pass by reference)
"RTN","HLOCLNT",142,0)
 ;   MSGIEN - ien, file 778, of message to be transmitted
"RTN","HLOCLNT",143,0)
 ;Output:
"RTN","HLOCLNT",144,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOCLNT",145,0)
 ;  UPDATE - (pass by reference) to contain updates needed for message
"RTN","HLOCLNT",146,0)
 ;
"RTN","HLOCLNT",147,0)
 N HLMSTATE,MSA,HDR,SUCCESS
"RTN","HLOCLNT",148,0)
 ;
"RTN","HLOCLNT",149,0)
 S SUCCESS=0
"RTN","HLOCLNT",150,0)
 S HLCSTATE("ATTEMPT")=0
"RTN","HLOCLNT",151,0)
 ;
"RTN","HLOCLNT",152,0)
 ;start saving updates needed after the message is transmitted
"RTN","HLOCLNT",153,0)
 S UPDATE=MSGIEN
"RTN","HLOCLNT",154,0)
 Q:'$$GETMSG^HLOCLNT2(MSGIEN,.HLMSTATE) 1  ;returns 1 so the message will be removed from the queue
"RTN","HLOCLNT",155,0)
 I HLMSTATE("DT/TM"),HLMSTATE("STATUS","ACCEPTED")!(HLMSTATE("HDR","ACCEPT ACK TYPE")="NE") Q 1  ;the message was already transmitted
"RTN","HLOCLNT",156,0)
 ;
"RTN","HLOCLNT",157,0)
 S UPDATE=UPDATE_"^"_$$NOW^XLFDT
"RTN","HLOCLNT",158,0)
RETRY D
"RTN","HLOCLNT",159,0)
 .S HLCSTATE("ATTEMPT")=HLCSTATE("ATTEMPT")+1
"RTN","HLOCLNT",160,0)
 .I 'HLCSTATE("CONNECTED") D OPEN^HLOT(.HLCSTATE) Q:'HLCSTATE("CONNECTED")
"RTN","HLOCLNT",161,0)
 .;
"RTN","HLOCLNT",162,0)
 .;try to send the message
"RTN","HLOCLNT",163,0)
 .;
"RTN","HLOCLNT",164,0)
 .;
"RTN","HLOCLNT",165,0)
 .Q:'$$WRITEMSG^HLOCLNT1(.HLCSTATE,.HLMSTATE)
"RTN","HLOCLNT",166,0)
 .;does the message need an accept ack?
"RTN","HLOCLNT",167,0)
 .I HLMSTATE("HDR","ACCEPT ACK TYPE")="AL" D
"RTN","HLOCLNT",168,0)
 ..N FS
"RTN","HLOCLNT",169,0)
 ..Q:'$$READACK^HLOCLNT1(.HLCSTATE,.HDR,.MSA)
"RTN","HLOCLNT",170,0)
 ..;does the MSA refer to the correct control id?
"RTN","HLOCLNT",171,0)
 ..S FS=$E(HDR(1),4)
"RTN","HLOCLNT",172,0)
 ..Q:$P(MSA,FS,3)'=HLMSTATE("ID")
"RTN","HLOCLNT",173,0)
 ..N ACKID,ACKCODE
"RTN","HLOCLNT",174,0)
 ..S ACKCODE=$P(MSA,FS,2)
"RTN","HLOCLNT",175,0)
 ..S ACKID=$S($E(HDR(1),1,3)="MSH":$P(HDR(2),FS,5),1:$P(HDR(2),FS,6))
"RTN","HLOCLNT",176,0)
 ..S $P(UPDATE,"^",5)=1
"RTN","HLOCLNT",177,0)
 ..S UPDATE("MSA")=ACKID_"^"_MSA
"RTN","HLOCLNT",178,0)
 ..I '(ACKCODE="CA") S $P(UPDATE,"^",3)="ER",$P(UPDATE,"^",4)=2
"RTN","HLOCLNT",179,0)
 ..I ACKCODE="CA",HLMSTATE("HDR","APP ACK TYPE")="NE" S $P(UPDATE,"^",3)="SU",$P(UPDATE,"^",4)=$S(HLMSTATE("BATCH"):"2",1:1)
"RTN","HLOCLNT",180,0)
 ..I ($P(UPDATE,"^",3)="ER") S $P(UPDATE,"^",6)=$P(HLMSTATE("HDR",1),FS,5) ;errors need the application for xref
"RTN","HLOCLNT",181,0)
 ..;
"RTN","HLOCLNT",182,0)
 ..;if it's from a sequence queue, timestamp the queue
"RTN","HLOCLNT",183,0)
 ..I $L($G(HLMSTATE("STATUS","SEQUENCE QUEUE"))) D
"RTN","HLOCLNT",184,0)
 ...L +^HLB("QUEUE","SEQUENCE",HLMSTATE("STATUS","SEQUENCE QUEUE")):200
"RTN","HLOCLNT",185,0)
 ...I $P($G(^HLB("QUEUE","SEQUENCE",HLMSTATE("STATUS","SEQUENCE QUEUE"))),"^")'=MSGIEN L -^HLB("QUEUE","SEQUENCE",HLMSTATE("STATUS","SEQUENCE QUEUE")) Q
"RTN","HLOCLNT",186,0)
 ...I ACKCODE="CA" S $P(^HLB("QUEUE","SEQUENCE",HLMSTATE("STATUS","SEQUENCE QUEUE")),"^",2)=$$FMADD^XLFDT($P(UPDATE,"^",2),,,$$TIMEOUT^HLOAPP($$GETSAP^HLOCLNT2(MSGIEN))) L -^HLB("QUEUE","SEQUENCE",HLMSTATE("STATUS","SEQUENCE QUEUE")) Q
"RTN","HLOCLNT",187,0)
 ...;if the message wasn't accepted, need to notify without waiting
"RTN","HLOCLNT",188,0)
 ...S $P(^HLB("QUEUE","SEQUENCE",HLMSTATE("STATUS","SEQUENCE QUEUE")),"^",2)=$P(UPDATE,"^",2)
"RTN","HLOCLNT",189,0)
 ...L -^HLB("QUEUE","SEQUENCE",HLMSTATE("STATUS","SEQUENCE QUEUE"))
"RTN","HLOCLNT",190,0)
 ..;
"RTN","HLOCLNT",191,0)
 ..;does the app need notification of accept ack?
"RTN","HLOCLNT",192,0)
 ..S UPDATE("ACTION")=HLMSTATE("ACCEPT ACK RESPONSE")
"RTN","HLOCLNT",193,0)
 ..;
"RTN","HLOCLNT",194,0)
 ..S SUCCESS=1
"RTN","HLOCLNT",195,0)
 .E  D  ;accept ack wasn't requested
"RTN","HLOCLNT",196,0)
 ..S SUCCESS=1
"RTN","HLOCLNT",197,0)
 ..I HLMSTATE("HDR","APP ACK TYPE")="NE" S $P(UPDATE,"^",3)="SU",$P(UPDATE,"^",4)=$S(HLMSTATE("BATCH"):2,1:1)
"RTN","HLOCLNT",198,0)
 ;
"RTN","HLOCLNT",199,0)
 I 'SUCCESS,'HLCSTATE("CONNECTED"),(HLCSTATE("ATTEMPT")<2) G RETRY
"RTN","HLOCLNT",200,0)
 I SUCCESS D
"RTN","HLOCLNT",201,0)
 .D COUNT^HLOSTAT(.HLCSTATE,HLMSTATE("HDR","RECEIVING APPLICATION"),HLMSTATE("HDR","SENDING APPLICATION"),$S(HLMSTATE("BATCH"):"BATCH",1:HLMSTATE("HDR","MESSAGE TYPE")_"~"_HLMSTATE("HDR","EVENT")))
"RTN","HLOCLNT",202,0)
 .;if this is an ack to a message need to purge the original message, so store its ien with the purge date
"RTN","HLOCLNT",203,0)
 .S:$G(HLMSTATE("ACK TO IEN")) $P(UPDATE,"^",4)=$P(UPDATE,"^",4)_"-"_HLMSTATE("ACK TO IEN")
"RTN","HLOCLNT",204,0)
 I ('HLCSTATE("CONNECTED"))!('SUCCESS) D LINKDOWN(.HLCSTATE)
"RTN","HLOCLNT",205,0)
 Q SUCCESS
"RTN","HLOCLNT1")
0^5^B32776376^B31047007
"RTN","HLOCLNT1",1,0)
HLOCLNT1 ;IRMFO-ALB/CJM - Writing messages, reading acks;03/24/2004  14:43 ;10/27/2008
"RTN","HLOCLNT1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,130,131,134,137,139**;Oct 13, 1995;Build 11
"RTN","HLOCLNT1",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOCLNT1",4,0)
 ;
"RTN","HLOCLNT1",5,0)
 ;
"RTN","HLOCLNT1",6,0)
WRITEMSG(HLCSTATE,HLMSTATE) ;
"RTN","HLOCLNT1",7,0)
 ;Description:  This function uses the services offered by the transport layer to send a message over an open communication channel.
"RTN","HLOCLNT1",8,0)
 ;
"RTN","HLOCLNT1",9,0)
 ;Input:
"RTN","HLOCLNT1",10,0)
 ;  HLCSTATE (pass by reference, required) Defines the LLP & its state
"RTN","HLOCLNT1",11,0)
 ;  HLMSTATE (pass by reference, required) The message
"RTN","HLOCLNT1",12,0)
 ;Output:
"RTN","HLOCLNT1",13,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOCLNT1",14,0)
ZB6 ;
"RTN","HLOCLNT1",15,0)
 N SEG,QUIT,HDR
"RTN","HLOCLNT1",16,0)
 S QUIT=0
"RTN","HLOCLNT1",17,0)
 I '$G(HLMSTATE("IEN")) S QUIT=1 G ZB7
"RTN","HLOCLNT1",18,0)
 S HDR(1)=HLMSTATE("HDR",1),HDR(2)=HLMSTATE("HDR",2)
"RTN","HLOCLNT1",19,0)
 I '$$WRITEHDR^HLOT(.HLCSTATE,.HDR) S QUIT=1 G ZB7
"RTN","HLOCLNT1",20,0)
 I HLMSTATE("BATCH") D
"RTN","HLOCLNT1",21,0)
 .N LAST S LAST=0
"RTN","HLOCLNT1",22,0)
 .S HLMSTATE("BATCH","CURRENT MESSAGE")=0
"RTN","HLOCLNT1",23,0)
 .F  Q:'$$NEXTMSG^HLOMSG(.HLMSTATE,.SEG)  D  Q:QUIT
"RTN","HLOCLNT1",24,0)
 ..S LAST=HLMSTATE("BATCH","CURRENT MESSAGE")
"RTN","HLOCLNT1",25,0)
 ..I '$$WRITESEG^HLOT(.HLCSTATE,.SEG) S QUIT=1 Q
"RTN","HLOCLNT1",26,0)
 ..F  Q:'$$HLNEXT^HLOMSG(.HLMSTATE,.SEG)  D  Q:QUIT
"RTN","HLOCLNT1",27,0)
 ...I '$$WRITESEG^HLOT(.HLCSTATE,.SEG) S QUIT=1 Q
"RTN","HLOCLNT1",28,0)
 .K SEG S SEG(1)="BTS"_HLMSTATE("HDR","FIELD SEPARATOR")_LAST
"RTN","HLOCLNT1",29,0)
 .S:'$$WRITESEG^HLOT(.HLCSTATE,.SEG) QUIT=1
"RTN","HLOCLNT1",30,0)
 E  D
"RTN","HLOCLNT1",31,0)
 .F  Q:'$$HLNEXT^HLOMSG(.HLMSTATE,.SEG)  D  Q:QUIT
"RTN","HLOCLNT1",32,0)
 ..S:'$$WRITESEG^HLOT(.HLCSTATE,.SEG) QUIT=1
"RTN","HLOCLNT1",33,0)
 S:'$$ENDMSG^HLOT(.HLCSTATE) QUIT=1
"RTN","HLOCLNT1",34,0)
ZB7 ;
"RTN","HLOCLNT1",35,0)
 Q 'QUIT
"RTN","HLOCLNT1",36,0)
 ;
"RTN","HLOCLNT1",37,0)
READACK(HLCSTATE,HDR,MSA) ;
"RTN","HLOCLNT1",38,0)
 ;Description:  This function uses the services offered by the transport layer to read an accept ack.
"RTN","HLOCLNT1",39,0)
 ;
"RTN","HLOCLNT1",40,0)
 ;Input:
"RTN","HLOCLNT1",41,0)
 ;  HLCSTATE (pass by reference, required) Defines the communication channel and its state.
"RTN","HLOCLNT1",42,0)
 ;Output:
"RTN","HLOCLNT1",43,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOCLNT1",44,0)
 ;  HDR (pass by reference) the message header:
"RTN","HLOCLNT1",45,0)
 ;   HDR(1) is components 1-6
"RTN","HLOCLNT1",46,0)
 ;   HDR(2) is components 7-end
"RTN","HLOCLNT1",47,0)
 ;  MSA (pass by reference) the MSA segment as an unsubscripted variable
"RTN","HLOCLNT1",48,0)
 ;
"RTN","HLOCLNT1",49,0)
ZB8 ;
"RTN","HLOCLNT1",50,0)
 N SEG,SUCCESS
"RTN","HLOCLNT1",51,0)
 S SUCCESS=0
"RTN","HLOCLNT1",52,0)
 K HDR,MSA,MAX,I
"RTN","HLOCLNT1",53,0)
 S MAX=HLCSTATE("SYSTEM","MAXSTRING")-40 ;MAX is the maximum that can be safely stored on a node, leaving room for the other fields stored with MSA seg
"RTN","HLOCLNT1",54,0)
 G:'$$READHDR^HLOT(.HLCSTATE,.HDR) ZB9
"RTN","HLOCLNT1",55,0)
 F  Q:'$$READSEG^HLOT(.HLCSTATE,.SEG)  D
"RTN","HLOCLNT1",56,0)
 .I $E($E(SEG(1),1,3)_$E($G(SEG(2)),1,3),1,3)="MSA" D
"RTN","HLOCLNT1",57,0)
 ..S MSA=""
"RTN","HLOCLNT1",58,0)
 ..F I=1:1 Q:'$D(SEG(I))  S MSA=MSA_$S((MAX-$L(MSA))<1:"",1:$E(SEG(I),1,MAX))
"RTN","HLOCLNT1",59,0)
 I $D(MSA),HLCSTATE("MESSAGE ENDED") D  S SUCCESS=1
"RTN","HLOCLNT1",60,0)
 .D SPLITHDR^HLOSRVR1(.HDR)
"RTN","HLOCLNT1",61,0)
 .S HLCSTATE("COUNTS","ACKS")=$G(HLCSTATE("COUNTS","ACKS"))+1
"RTN","HLOCLNT1",62,0)
ZB9 Q SUCCESS
"RTN","HLOCLNT1",63,0)
 ;
"RTN","HLOCLNT1",64,0)
CONNECT(LINK,PORT,TIMEOUT,HLCSTATE) ;
"RTN","HLOCLNT1",65,0)
ZB1 ;sets up HLCSTATE() and opens a client connection
"RTN","HLOCLNT1",66,0)
 ;Input:
"RTN","HLOCLNT1",67,0)
 ;  LINK - name of the link to connect to
"RTN","HLOCLNT1",68,0)
 ;  PORT (optional) port # to connect to, defaults to that specified by the link
"RTN","HLOCLNT1",69,0)
 ;  TIMEOUT (optional) specifies the open timeout in seconds, defaults to 30
"RTN","HLOCLNT1",70,0)
 ;Output:
"RTN","HLOCLNT1",71,0)
 ;   HLCSTATE - array to hold the connection state
"RTN","HLOCLNT1",72,0)
 ;
"RTN","HLOCLNT1",73,0)
 I '$G(HLCSTATE("CONNECTED")) S HLCSTATE("CONNECTED")=0
"RTN","HLOCLNT1",74,0)
 I HLCSTATE("CONNECTED") D  G:HLCSTATE("CONNECTED") ZB2
"RTN","HLOCLNT1",75,0)
 .I $G(HLCSTATE("LINK","NAME"))]"",($G(HLCSTATE("LINK","NAME"))'=LINK) D CLOSE^HLOT(.HLCSTATE) Q
"RTN","HLOCLNT1",76,0)
 .I $G(HLCSTATE("LINK","NAME"))]"",$G(PORT),($G(HLCSTATE("LINK","PORT"))'=PORT) D CLOSE^HLOT(.HLCSTATE) Q
"RTN","HLOCLNT1",77,0)
 .I (HLCSTATE("SYSTEM","OS")="CACHE") D  Q
"RTN","HLOCLNT1",78,0)
 ..U HLCSTATE("DEVICE") S HLCSTATE("CONNECTED")=($ZA\8192#2)
"RTN","HLOCLNT1",79,0)
 ..I 'HLCSTATE("CONNECTED") D CLOSE^HLOT(.HLCSTATE)
"RTN","HLOCLNT1",80,0)
 .;D CLOSE^HLOT(.HLCSTATE)
"RTN","HLOCLNT1",81,0)
 K HLCSTATE
"RTN","HLOCLNT1",82,0)
 N ARY,NODE
"RTN","HLOCLNT1",83,0)
 I '$$GETLINK^HLOTLNK(LINK,.ARY) S HLCSTATE("LINK","NAME")=LINK,HLCSTATE("LINK","PORT")=$G(PORT) D LINKDOWN^HLOCLNT(.HLCSTATE) G ZB2
"RTN","HLOCLNT1",84,0)
 M HLCSTATE("LINK")=ARY
"RTN","HLOCLNT1",85,0)
 I HLCSTATE("LINK","SHUTDOWN") S HLCSTATE("CONNECTED")=0 D LINKDOWN^HLOCLNT(.HLCSTATE) G ZB2
"RTN","HLOCLNT1",86,0)
 ;overlay the port if supplied from the queue
"RTN","HLOCLNT1",87,0)
 S:$G(PORT) HLCSTATE("LINK","PORT")=PORT
"RTN","HLOCLNT1",88,0)
 S HLCSTATE("READ TIMEOUT")=20
"RTN","HLOCLNT1",89,0)
 S HLCSTATE("OPEN TIMEOUT")=$S($G(TIMEOUT):TIMEOUT,1:30)
"RTN","HLOCLNT1",90,0)
 S HLCSTATE("COUNTS")=0
"RTN","HLOCLNT1",91,0)
 S HLCSTATE("READ")="" ;where the reads are stored
"RTN","HLOCLNT1",92,0)
 ;
"RTN","HLOCLNT1",93,0)
 ;HLCSTATE("BUFFER",<seg>,<line>) serves as a write buffer so that a lot can be written all at once
"RTN","HLOCLNT1",94,0)
 S HLCSTATE("BUFFER","BYTE COUNT")=0 ;count of BYTES in buffer
"RTN","HLOCLNT1",95,0)
 S HLCSTATE("BUFFER","SEGMENT COUNT")=0 ;count of segments in buffer
"RTN","HLOCLNT1",96,0)
 ;
"RTN","HLOCLNT1",97,0)
 S HLCSTATE("MESSAGE ENDED")=0 ;end of message flag
"RTN","HLOCLNT1",98,0)
 S NODE=^%ZOSF("OS")
"RTN","HLOCLNT1",99,0)
 S HLCSTATE("SERVER")=0
"RTN","HLOCLNT1",100,0)
 S HLCSTATE("SYSTEM","OS")=$S(NODE["DSM":"DSM",NODE["OpenM":"CACHE",NODE["G.TM":"G.TM",1:"")
"RTN","HLOCLNT1",101,0)
 I HLCSTATE("SYSTEM","OS")="" D LINKDOWN^HLOCLNT(.HLCSTATE) G ZB2
"RTN","HLOCLNT1",102,0)
 D
"RTN","HLOCLNT1",103,0)
 .N SYS
"RTN","HLOCLNT1",104,0)
 .D SYSPARMS^HLOSITE(.SYS)
"RTN","HLOCLNT1",105,0)
 .S HLCSTATE("SYSTEM","BUFFER")=SYS("HL7 BUFFER")
"RTN","HLOCLNT1",106,0)
 .S HLCSTATE("SYSTEM","MAXSTRING")=SYS("MAXSTRING")
"RTN","HLOCLNT1",107,0)
 .S HLCSTATE("SYSTEM","NORMAL PURGE")=SYS("NORMAL PURGE")
"RTN","HLOCLNT1",108,0)
 .S HLCSTATE("SYSTEM","ERROR PURGE")=SYS("ERROR PURGE")
"RTN","HLOCLNT1",109,0)
 I HLCSTATE("LINK","LLP")="TCP" D
"RTN","HLOCLNT1",110,0)
 .S HLCSTATE("OPEN")="OPEN^HLOTCP"
"RTN","HLOCLNT1",111,0)
 E  ;no other LLP implemented
"RTN","HLOCLNT1",112,0)
 D OPEN^HLOT(.HLCSTATE)
"RTN","HLOCLNT1",113,0)
 ;
"RTN","HLOCLNT1",114,0)
 ;mark the failure time for the link so other processes know not to try for a while
"RTN","HLOCLNT1",115,0)
 I 'HLCSTATE("CONNECTED") D LINKDOWN^HLOCLNT(.HLCSTATE)
"RTN","HLOCLNT1",116,0)
ZB2 ;
"RTN","HLOCLNT1",117,0)
 Q HLCSTATE("CONNECTED")
"RTN","HLOCLNT1",118,0)
 ;
"RTN","HLOCLNT1",119,0)
BADMSGS(WORK) ;
"RTN","HLOCLNT1",120,0)
 ;finds messages that won't transmit after 8 hours of trying and takes them off the outgoing queue
"RTN","HLOCLNT1",121,0)
 N LINK
"RTN","HLOCLNT1",122,0)
 S LINK=""
"RTN","HLOCLNT1",123,0)
 F  S LINK=$O(^HLTMP("FAILING LINKS",LINK)) Q:LINK=""  D
"RTN","HLOCLNT1",124,0)
 .N TIME,QUE,COUNT
"RTN","HLOCLNT1",125,0)
 .S TIME=$G(^HLTMP("FAILING LINKS",LINK)) Q:TIME=""
"RTN","HLOCLNT1",126,0)
 .Q:$$HDIFF^XLFDT($H,TIME,2)<28800  ;8 hours
"RTN","HLOCLNT1",127,0)
 .Q:'$$IFOPEN^HLOUSR1(LINK)
"RTN","HLOCLNT1",128,0)
 .L +^HLB("QUEUE","OUT",LINK):0
"RTN","HLOCLNT1",129,0)
 .S QUE=""
"RTN","HLOCLNT1",130,0)
 .F  S QUE=$O(^HLB("QUEUE","OUT",LINK,QUE)) Q:QUE=""  D
"RTN","HLOCLNT1",131,0)
 ..N MSG S MSG=0
"RTN","HLOCLNT1",132,0)
 ..S MSG=$O(^HLB("QUEUE","OUT",LINK,QUE,MSG))
"RTN","HLOCLNT1",133,0)
 ..Q:'MSG
"RTN","HLOCLNT1",134,0)
 ..S COUNT=$G(^HLB(MSG,"TRIES"))
"RTN","HLOCLNT1",135,0)
 ..I COUNT>20 D
"RTN","HLOCLNT1",136,0)
 ...N NODE0,NODE1,NODE2,TIME,RAPP,SAPP,FS,CS,ACTION,MTYPE,EVENT
"RTN","HLOCLNT1",137,0)
 ...S NODE0=$G(^HLB(MSG,0))
"RTN","HLOCLNT1",138,0)
 ...Q:'$P(NODE0,"^",2)
"RTN","HLOCLNT1",139,0)
 ...S TIME=$$NOW^XLFDT
"RTN","HLOCLNT1",140,0)
 ...S NODE1=$G(^HLB(MSG,1))
"RTN","HLOCLNT1",141,0)
 ...S NODE2=$G(^HLB(MSG,2))
"RTN","HLOCLNT1",142,0)
 ...S FS=$E(NODE1,4)
"RTN","HLOCLNT1",143,0)
 ...Q:FS=""
"RTN","HLOCLNT1",144,0)
 ...S CS=$E(NODE1,5)
"RTN","HLOCLNT1",145,0)
 ...Q:CS=""
"RTN","HLOCLNT1",146,0)
 ...S SAPP=$P(NODE1,FS,3)
"RTN","HLOCLNT1",147,0)
 ...S:SAPP="" SAPP="UNKNOWN"
"RTN","HLOCLNT1",148,0)
 ...S RAPP=$P(NODE1,FS,5)
"RTN","HLOCLNT1",149,0)
 ...S MTYPE=$P($P(NODE2,FS,4),CS)
"RTN","HLOCLNT1",150,0)
 ...S EVENT=$P($P(NODE2,FS,4),CS,2)
"RTN","HLOCLNT1",151,0)
 ...S $P(^HLB(MSG,0),"^",21)=COUNT_" FAILED TRANSMISSIONS"
"RTN","HLOCLNT1",152,0)
 ...S $P(^HLB(MSG,0),"^",20)="TF"
"RTN","HLOCLNT1",153,0)
 ...S ^HLB("ERRORS",RAPP,TIME,MSG)=""
"RTN","HLOCLNT1",154,0)
 ...D COUNT^HLOESTAT("OUT",RAPP,SAPP,MTYPE,EVENT)
"RTN","HLOCLNT1",155,0)
 ...S ACTION=$P(NODE0,"^",14,15)
"RTN","HLOCLNT1",156,0)
 ...I ACTION'="^",ACTION]"" D INQUE^HLOQUE(LINK,QUE,MSG,ACTION,1)
"RTN","HLOCLNT1",157,0)
 ...D DEQUE^HLOQUE(LINK,QUE,"OUT",MSG)
"RTN","HLOCLNT1",158,0)
 .L -^HLB("QUEUE","OUT",LINK)
"RTN","HLOCLNT1",159,0)
 Q
"RTN","HLOCNRT1")
0^8^B47676959^n/a
"RTN","HLOCNRT1",1,0)
HLOCNRT1 ;ALB/CJM-Generate HL7 Optimized Message ;12/02/2008
"RTN","HLOCNRT1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**139**;Oct 13, 1995;Build 11
"RTN","HLOCNRT1",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOCNRT1",4,0)
 ;
"RTN","HLOCNRT1",5,0)
 ;
"RTN","HLOCNRT1",6,0)
HLO(PARAMETERS,TRANSFORM) ;
"RTN","HLOCNRT1",7,0)
 ;INPUT -
"RTN","HLOCNRT1",8,0)
 ;    PARMAMETERS (optional,pass by reference) The following parameters, 
"RTN","HLOCNRT1",9,0)
 ;         if specififed, will override what is specied by the Event and
"RTN","HLOCNRT1",10,0)
 ;         Subscriber Protocols.
"RTN","HLOCNRT1",11,0)
 ;
"RTN","HLOCNRT1",12,0)
 ;  "ACCEPT ACK RESPONSE")=<tag^routine> to call when the commit ack is received (optional)
"RTN","HLOCNRT1",13,0)
 ;  "ACCEPT ACK TYPE") = <AL,NE>
"RTN","HLOCNRT1",14,0)
 ;  "APP ACK TYPE") = <AL,NE>
"RTN","HLOCNRT1",15,0)
 ;  "COUNTRY")=3 character country code
"RTN","HLOCNRT1",16,0)
 ;  "CONTINUATION POINTER" -indicates a fragmented message
"RTN","HLOCNRT1",17,0)
 ;  "EVENT")=3 character event type
"RTN","HLOCNRT1",18,0)
 ;  "FAILURE RESPONSE" - <tag>^<routine> The sending application routine to execute when the transmission of the message fails, i.e., the message can not be sent or no commit ack is received.
"RTN","HLOCNRT1",19,0)
 ;  "MESSAGE STRUCTURE" - MSH 9, component 3 - a code from the standard HL7 table
"RTN","HLOCNRT1",20,0)
 ;  "MESSAGE TYPE")=3 character message type
"RTN","HLOCNRT1",21,0)
 ;  "PROCESSING MODE" - MSH 11, component 2 - a 1 character code
"RTN","HLOCNRT1",22,0)
 ;  "QUEUE" - An application can name its own private queue -just a string up to 20 characters, it should be namespaced.
"RTN","HLOCNRT1",23,0)
 ;  "SECURITY")=security information to include in the header segment, SEQ 8
"RTN","HLOCNRT1",24,0)
 ;  "SEQUENCE QUEUE") The sequence queue to use, up to 30 characters. It should be namespaced.  Requires that application acks be used.
"RTN","HLOCNRT1",25,0)
 ;  "SENDING APPLICATION")=name of sending app (60 maximum length)
"RTN","HLOCNRT1",26,0)
 ;  "VERSION")=the HL7 Version ID, for example, "2.4"
"RTN","HLOCNRT1",27,0)
 ;
"RTN","HLOCNRT1",28,0)
 ;     
"RTN","HLOCNRT1",29,0)
 ;    TRANSFORM (optional) A routine that will transform the message
"RTN","HLOCNRT1",30,0)
 ;          before the message is sent. The routine must 
"RTN","HLOCNRT1",31,0)
 ;          have a formal parameter to received the name of the 
"RTN","HLOCNRT1",32,0)
 ;          array that contains the message. The array may be either
"RTN","HLOCNRT1",33,0)
 ;          local or global.The application references the array
"RTN","HLOCNRT1",34,0)
 ;          by indirection to add, edit, or delete segments. The
"RTN","HLOCNRT1",35,0)
 ;          application may decide not to send the message, in which
"RTN","HLOCNRT1",36,0)
 ;          case it should delete the message array.
"RTN","HLOCNRT1",37,0)
 ;       
"RTN","HLOCNRT1",38,0)
 ;          An application's TRANSFORM routine can loop through the 
"RTN","HLOCNRT1",39,0)
 ;          segments in the message in this way:
"RTN","HLOCNRT1",40,0)
 ;          1) The application's TRANSFORM routine should be defined
"RTN","HLOCNRT1",41,0)
 ;             to accept an input parameter.  HLO will set the parameter
"RTN","HLOCNRT1",42,0)
 ;             to the name of an array that contains the message, one 
"RTN","HLOCNRT1",43,0)
 ;             segment per subscript:
"RTN","HLOCNRT1",44,0)
 ;               
"RTN","HLOCNRT1",45,0)
 ;             MSG(1)=<first segment>
"RTN","HLOCNRT1",46,0)
 ;             MSG(2)=<second segment>
"RTN","HLOCNRT1",47,0)
 ;              etc.
"RTN","HLOCNRT1",48,0)
 ;      
"RTN","HLOCNRT1",49,0)
 ;           2) The application's TRANSFORM routine should loop through
"RTN","HLOCNRT1",50,0)
 ;              the message array using indirection:
"RTN","HLOCNRT1",51,0)
 ;  
"RTN","HLOCNRT1",52,0)
 ;              S I=0 F  S I=$O(@MSG@(I)) Q:'I  D <process the segment>
"RTN","HLOCNRT1",53,0)
 ;
"RTN","HLOCNRT1",54,0)
 ;              *Note:  MSG is show here, but the name of of the variable
"RTN","HLOCNRT1",55,0)
 ;               is actually whatever the application routine defined as
"RTN","HLOCNRT1",56,0)
 ;               its formal input parameter.
"RTN","HLOCNRT1",57,0)
 ;
"RTN","HLOCNRT1",58,0)
 ;            3) The segment value is obtained by:
"RTN","HLOCNRT1",59,0)
 ;               S SEGMENT=$G(@MSG@(I)) D <process the segment>
"RTN","HLOCNRT1",60,0)
 ;
"RTN","HLOCNRT1",61,0)
 ;            4) These variables are defined for the application to use
"RTN","HLOCNRT1",62,0)
 ;               in parsing segments:
"RTN","HLOCNRT1",63,0)
 ;
"RTN","HLOCNRT1",64,0)
 ;               FS  - field separator
"RTN","HLOCNRT1",65,0)
 ;               CS  - component separator
"RTN","HLOCNRT1",66,0)
 ;               SUB - subcomponent separator
"RTN","HLOCNRT1",67,0)
 ;               REP - repitition separator
"RTN","HLOCNRT1",68,0)
 ;               ESC - escape character 
"RTN","HLOCNRT1",69,0)
 ;
"RTN","HLOCNRT1",70,0)
 ;
"RTN","HLOCNRT1",71,0)
 ;    !!!  CAUTION: This API currently has these limitations: !!!
"RTN","HLOCNRT1",72,0)
 ;         1) Each individual segment must fit in a single node.
"RTN","HLOCNRT1",73,0)
 ;         2) It can not be used for batch messages.
"RTN","HLOCNRT1",74,0)
 ;
"RTN","HLOCNRT1",75,0)
 ;OUTPUT:
"RTN","HLOCNRT1",76,0)
 ;   Function returns:
"RTN","HLOCNRT1",77,0)
 ;           - 0:if the message is not forwarded
"RTN","HLOCNRT1",78,0)
 ;           - message ien, file 778: if the message is forwarded
"RTN","HLOCNRT1",79,0)
 ;
"RTN","HLOCNRT1",80,0)
 ;      Example 1: The application wants to subscribe to an existing
"RTN","HLOCNRT1",81,0)
 ;         message produced by the old HL7 1.6 set of messaging APIs,
"RTN","HLOCNRT1",82,0)
 ;         but it wants to route the messages via HLO.
"RTN","HLOCNRT1",83,0)
 ;         To accomplish that the application needs to create a
"RTN","HLOCNRT1",84,0)
 ;         new subscriber protocol with this M code to the ROUTING LOGIC:
"RTN","HLOCNRT1",85,0)
 ;          
"RTN","HLOCNRT1",86,0)
 ;             D HLO^HLOCNRT1()
"RTN","HLOCNRT1",87,0)
 ;        
"RTN","HLOCNRT1",88,0)
 ;      Example 2:  Same as example 1, except that the application would
"RTN","HLOCNRT1",89,0)
 ;      like to:
"RTN","HLOCNRT1",90,0)
 ;   - Change the version of the message to 2.4
"RTN","HLOCNRT1",91,0)
 ;   - Strip out the Z segments from the message before sending it. To
"RTN","HLOCNRT1",92,0)
 ;     do so, it may devise the following routine:
"RTN","HLOCNRT1",93,0)
 ;
"RTN","HLOCNRT1",94,0)
 ;      ZSTRIP^ZZRTN(MSG) ;
"RTN","HLOCNRT1",95,0)
 ;      N I S I=0
"RTN","HLOCNRT1",96,0)
 ;      F  S I=$O(@MSG@(I)) Q:'I  D
"RTN","HLOCNRT1",97,0)
 ;      .I $E(@MSG@(I),1)="Z" K @MSG@(I)
"RTN","HLOCNRT1",98,0)
 ;      Q
"RTN","HLOCNRT1",99,0)
 ;
"RTN","HLOCNRT1",100,0)
 ;  Here is the ROUTING LOGIC for the new subscriber protocol:
"RTN","HLOCNRT1",101,0)
 ;         
"RTN","HLOCNRT1",102,0)
 ;     N PARMS S PARMS("VERSION")=2.4 I $$HLO^CNRT1(.PARMS,"STRIPZ^ZZRTN")
"RTN","HLOCNRT1",103,0)
 ;
"RTN","HLOCNRT1",104,0)
 ;  Output: none
"RTN","HLOCNRT1",105,0)
 ;
"RTN","HLOCNRT1",106,0)
 N HLMSTATE,PARMS,WHO,EVENT,SUBSCRIBER,MARY,SUB
"RTN","HLOCNRT1",107,0)
 ;
"RTN","HLOCNRT1",108,0)
 ;
"RTN","HLOCNRT1",109,0)
 S EVENT=$G(HLEID)
"RTN","HLOCNRT1",110,0)
 Q:'EVENT 0
"RTN","HLOCNRT1",111,0)
 S SUBSCRIBER=$G(HLEIDS)
"RTN","HLOCNRT1",112,0)
 Q:'SUBSCRIBER 0
"RTN","HLOCNRT1",113,0)
 ;
"RTN","HLOCNRT1",114,0)
 Q:'$$GETPARMS(EVENT,SUBSCRIBER,.PARMS,.WHO) 0
"RTN","HLOCNRT1",115,0)
 ;
"RTN","HLOCNRT1",116,0)
 ;accept parameters passed in via PARMETERS
"RTN","HLOCNRT1",117,0)
 F SUB="COUNTRY","CONTINUATION POINTER","EVENT","MESSAGE TYPE","PROCESSING MODE","MESSAGE STRUCTURE","VERSION" I $D(PARAMETERS(SUB)) S PARMS(SUB)=$G(PARAMETERS(SUB))
"RTN","HLOCNRT1",118,0)
 ;
"RTN","HLOCNRT1",119,0)
 Q:'$$NEWMSG^HLOAPI(.PARMS,.HLMSTATE,.ERROR) 0
"RTN","HLOCNRT1",120,0)
 ;
"RTN","HLOCNRT1",121,0)
 ;
"RTN","HLOCNRT1",122,0)
 ;if there is transform logic, copy the message to a workspace and execute the transform
"RTN","HLOCNRT1",123,0)
 I $L($G(TRANSFORM)) D
"RTN","HLOCNRT1",124,0)
 .N FROM,I,J
"RTN","HLOCNRT1",125,0)
 .I $E($G(HLARYTYP),1)="G" S FROM="^TMP(""HLS"",$J)",MARY="^TMP(""HLO"",$J)"
"RTN","HLOCNRT1",126,0)
 .I $E($G(HLARYTYP),1)="L" S FROM="HLA(""HLS"")",MARY="HLA(""HLO"")"
"RTN","HLOCNRT1",127,0)
 .Q:'$L($G(MARY))
"RTN","HLOCNRT1",128,0)
 .S I=0
"RTN","HLOCNRT1",129,0)
 .F  S I=$O(@FROM@(I)) Q:'I  D
"RTN","HLOCNRT1",130,0)
 ..S @MARY@(I)=$G(@FROM@(I))
"RTN","HLOCNRT1",131,0)
 ..S J=0
"RTN","HLOCNRT1",132,0)
 ..F  S J=$O(@MARY@(I,J)) Q:'J  S @MARY@(I)=@MARY@(I)_$G(@FROM@(I,J))
"RTN","HLOCNRT1",133,0)
 .;
"RTN","HLOCNRT1",134,0)
 .;execute the applications transform logic
"RTN","HLOCNRT1",135,0)
 .D
"RTN","HLOCNRT1",136,0)
 ..N FS,CS,SUB,REP,ESC,NODE
"RTN","HLOCNRT1",137,0)
 ..S NODE=HLMSTATE("HDR","ENCODING CHARACTERS")
"RTN","HLOCNRT1",138,0)
 ..S FS=HLMSTATE("HDR","FIELD SEPARATOR")
"RTN","HLOCNRT1",139,0)
 ..S CS=$E(NODE,1)
"RTN","HLOCNRT1",140,0)
 ..S REP=$E(NODE,2)
"RTN","HLOCNRT1",141,0)
 ..S ESC=$E(NODE,3)
"RTN","HLOCNRT1",142,0)
 ..S SUB=$E(NODE,4)
"RTN","HLOCNRT1",143,0)
 ..X "D "_TRANSFORM_"(MARY)"
"RTN","HLOCNRT1",144,0)
 .;
"RTN","HLOCNRT1",145,0)
 .;if the application chose not to subscribe, delete the message array
"RTN","HLOCNRT1",146,0)
 .I '$D(@MARY) K MARY Q
"RTN","HLOCNRT1",147,0)
 .;Move the existing message from array into HL0
"RTN","HLOCNRT1",148,0)
 .D MOVEMSG^HLOAPI(.HLMSTATE,MARY)
"RTN","HLOCNRT1",149,0)
 .K @MARY
"RTN","HLOCNRT1",150,0)
 E  D
"RTN","HLOCNRT1",151,0)
 .I $E($G(HLARYTYP),1)="G" S MARY="^TMP(""HLS"",$J)"
"RTN","HLOCNRT1",152,0)
 .I $E($G(HLARYTYP),1)="L" S MARY="HLA(""HLS"")"
"RTN","HLOCNRT1",153,0)
 .Q:'$L($G(MARY))
"RTN","HLOCNRT1",154,0)
 .;Move the existing message from array into HL0
"RTN","HLOCNRT1",155,0)
 .D MOVEMSG^HLOAPI(.HLMSTATE,MARY)
"RTN","HLOCNRT1",156,0)
 Q:'$L($G(MARY)) 0
"RTN","HLOCNRT1",157,0)
 ;
"RTN","HLOCNRT1",158,0)
 ;
"RTN","HLOCNRT1",159,0)
 ;accept parameters passed in via PARAMETERS
"RTN","HLOCNRT1",160,0)
 F SUB="APP ACK RESPONSE","ACCEPT ACK RESPONSE","ACCEPT ACK TYPE","APP ACK TYPE","FAILURE RESPONSE","QUEUE","SECURITY","SEQUENCE QUEUE","SENDING APPLICATION" I $D(PARAMETERS(SUB)) S PARMS(SUB)=$G(PARAMETERS(SUB))
"RTN","HLOCNRT1",161,0)
 ;
"RTN","HLOCNRT1",162,0)
 Q $$SENDONE^HLOAPI1(.HLMSTATE,.PARMS,.WHO)
"RTN","HLOCNRT1",163,0)
 ;
"RTN","HLOCNRT1",164,0)
GETPARMS(EVENT,SUBSCRIBER,PARMS,WHO) ;  Set up PARMS & WHO arrays from Protocols
"RTN","HLOCNRT1",165,0)
 K PARMS,WHO
"RTN","HLOCNRT1",166,0)
 N NODE,APP,LINK
"RTN","HLOCNRT1",167,0)
 S NODE=$G(^ORD(101,EVENT,770))
"RTN","HLOCNRT1",168,0)
 S PARMS("EVENT")=$P(NODE,"^",4),PARMS("EVENT")=$S(PARMS("EVENT"):$P($G(^HL(779.001,PARMS("EVENT"),0)),"^"),1:"")
"RTN","HLOCNRT1",169,0)
 S PARMS("MESSAGE TYPE")=$P(NODE,"^",3),PARMS("MESSAGE TYPE")=$S(PARMS("MESSAGE TYPE"):$P($G(^HL(771.2,PARMS("MESSAGE TYPE"),0)),"^"),1:"")
"RTN","HLOCNRT1",170,0)
 S PARMS("APP ACK TYPE")=$P(NODE,"^",9),PARMS("APP ACK TYPE")=$S(PARMS("APP ACK TYPE"):$P($G(^HL(779.003,PARMS("APP ACK TYPE"),0)),"^"),1:"")
"RTN","HLOCNRT1",171,0)
 S PARMS("ACCEPT ACK TYPE")=$P(NODE,"^",8),PARMS("ACCEPT ACK TYPE")=$S(PARMS("ACCEPT ACK TYPE"):$P($G(^HL(779.003,PARMS("ACCEPT ACK TYPE"),0)),"^"),1:"")
"RTN","HLOCNRT1",172,0)
 S PARMS("VERSION")=$P(NODE,"^",10),PARMS("VERSION")=$S(PARMS("VERSION"):$P($G(^HL(771.5,PARMS("VERSION"),0)),"^"),1:"")
"RTN","HLOCNRT1",173,0)
 S PARMS("SENDING APPLICATION")=$P(NODE,"^")
"RTN","HLOCNRT1",174,0)
 I PARMS("SENDING APPLICATION") D
"RTN","HLOCNRT1",175,0)
 .N COUNTRY
"RTN","HLOCNRT1",176,0)
 .S COUNTRY=$P($G(^HL(771,PARMS("SENDING APPLICATION"),0)),"^",7)
"RTN","HLOCNRT1",177,0)
 .I $L(COUNTRY) S COUNTRY=$P($G(^HL(779.004,COUNTRY,0)),"^")
"RTN","HLOCNRT1",178,0)
 .S PARMS("COUNTRY")=$G(COUNTRY)
"RTN","HLOCNRT1",179,0)
 .S PARMS("FIELD SEPARATOR")=$E($G(^HL(771,PARMS("SENDING APPLICATION"),"FS")),1)
"RTN","HLOCNRT1",180,0)
 .S:PARMS("FIELD SEPARATOR")="" PARMS("FIELD SEPARATOR")="^"
"RTN","HLOCNRT1",181,0)
 .S PARMS("ENCODING CHARACTERS")=$E($G(^HL(771,PARMS("SENDING APPLICATION"),"EC")),1,4)
"RTN","HLOCNRT1",182,0)
 .S:PARMS("ENCODING CHARACTERS")="" PARMS("ENCODING CHARACTERS")="~|\&"
"RTN","HLOCNRT1",183,0)
 .S PARMS("SENDING APPLICATION")=$P($G(^HL(771,PARMS("SENDING APPLICATION"),0)),"^")
"RTN","HLOCNRT1",184,0)
 .I PARMS("SENDING APPLICATION")'="",'$O(^HLD(779.2,"C",PARMS("SENDING APPLICATION"),0)) D
"RTN","HLOCNRT1",185,0)
 ..;add the sending applcation to the registry
"RTN","HLOCNRT1",186,0)
 ..N DATA,ERROR
"RTN","HLOCNRT1",187,0)
 ..S DATA(.01)=PARMS("SENDING APPLICATION")
"RTN","HLOCNRT1",188,0)
 ..S DATA(2)=$P($G(^ORD(101,HLEID,0)),"^",12)
"RTN","HLOCNRT1",189,0)
 ..I $$ADD^HLOASUB1(779.2,,.DATA,.ERROR)
"RTN","HLOCNRT1",190,0)
 E  D
"RTN","HLOCNRT1",191,0)
 .S PARMS("SENDING APPLICATION")=""
"RTN","HLOCNRT1",192,0)
 .S PARMS("FIELD SEPARATOR")="^"
"RTN","HLOCNRT1",193,0)
 .S PARMS("ENCODING CHARACTERS")="~|\&"
"RTN","HLOCNRT1",194,0)
 ;
"RTN","HLOCNRT1",195,0)
 S NODE=$G(^ORD(101,SUBSCRIBER,770))
"RTN","HLOCNRT1",196,0)
 S APP=$P(NODE,"^",2)
"RTN","HLOCNRT1",197,0)
 Q:'APP 0
"RTN","HLOCNRT1",198,0)
 S LINK=$P(NODE,"^",7)
"RTN","HLOCNRT1",199,0)
 Q:'LINK 0
"RTN","HLOCNRT1",200,0)
 S WHO("RECEIVING APPLICATION")=$P($G(^HL(771,APP,0)),"^")
"RTN","HLOCNRT1",201,0)
 S WHO("FACILITY LINK NAME")=$P($G(^HLCS(870,LINK,0)),"^")
"RTN","HLOCNRT1",202,0)
 Q 1
"RTN","HLOCNRT1",203,0)
STRIPZ(MSG) ;strips the Z segments from the message
"RTN","HLOCNRT1",204,0)
 N I S I=0
"RTN","HLOCNRT1",205,0)
 F  S I=$O(@MSG@(I)) Q:'I  D
"RTN","HLOCNRT1",206,0)
 .I $E(@MSG@(I),1)="Z" K @MSG@(I)
"RTN","HLOCNRT1",207,0)
 Q
"RTN","HLOP139")
0^^B1692838^n/a
"RTN","HLOP139",1,0)
HLOP139 ;ALB/CJM-Pre & Post install ;10/27/2008
"RTN","HLOP139",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**139**;Oct 13, 1995;Build 11
"RTN","HLOP139",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOP139",4,0)
 ;
"RTN","HLOP139",5,0)
PRE ;
"RTN","HLOP139",6,0)
 ;
"RTN","HLOP139",7,0)
 N WORK
"RTN","HLOP139",8,0)
 L +^HLTMP("PROCESS MANAGER"):0
"RTN","HLOP139",9,0)
 I '$T D ABORT Q
"RTN","HLOP139",10,0)
 D CHKDEAD^HLOPROC1(.WORK)
"RTN","HLOP139",11,0)
 I $O(^HLTMP("HL7 RUNNING PROCESSES",""))'="" D ABORT
"RTN","HLOP139",12,0)
 L -^HLTMP("PROCESS MANAGER")
"RTN","HLOP139",13,0)
 Q
"RTN","HLOP139",14,0)
ABORT ;
"RTN","HLOP139",15,0)
 S XPDABORT=1
"RTN","HLOP139",16,0)
 D BMES^XPDUTL("HLO processes are still running and prevent this installation from completing")
"RTN","HLOP139",17,0)
 Q
"RTN","HLOP139",18,0)
 ;
"RTN","HLOP139",19,0)
POST ;
"RTN","HLOP139",20,0)
 N PROC,IEN
"RTN","HLOP139",21,0)
 F PROC="CLIENT MESSAGE UPDATES","SET SEARCH X-REF" D
"RTN","HLOP139",22,0)
 .S IEN=$O(^HLD(779.3,"B",PROC,0)) Q:'IEN  I $P(^HLD(779.3,IEN,0),"^",3)<1 S $P(^HLD(779.3,IEN,0),"^",3)=1 W !,"CHANGED:",PROC
"RTN","HLOP139",23,0)
 Q
"RTN","HLOPROC1")
0^15^B91809391^B90713886
"RTN","HLOPROC1",1,0)
HLOPROC1 ;ALB/CJM/OAK/PIJ- Process Manager - 10/4/94 1pm ;11/06/2008
"RTN","HLOPROC1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,138,139**;Oct 13, 1995;Build 11
"RTN","HLOPROC1",3,0)
 ;
"RTN","HLOPROC1",4,0)
 ;
"RTN","HLOPROC1",5,0)
GETWORK(PROCESS) ;
"RTN","HLOPROC1",6,0)
 ;finds a process that needs to be started
"RTN","HLOPROC1",7,0)
 ;
"RTN","HLOPROC1",8,0)
 N NAME,IEN,GOTWORK
"RTN","HLOPROC1",9,0)
 ;this is how  HL7 can be stopped via Taskman
"RTN","HLOPROC1",10,0)
 I $$S^%ZTLOAD D STOPHL7 Q 0
"RTN","HLOPROC1",11,0)
 S GOTWORK=0
"RTN","HLOPROC1",12,0)
 S IEN=+$G(PROCESS("IEN"))
"RTN","HLOPROC1",13,0)
 F  S IEN=$O(^HLD(779.3,"C",1,IEN)) Q:IEN=$G(PROCESS("IEN"))  I IEN D  Q:GOTWORK
"RTN","HLOPROC1",14,0)
 .N PROC,COUNT,QUEUED,RUNNING
"RTN","HLOPROC1",15,0)
 .Q:'$$GETPROC(IEN,.PROC)
"RTN","HLOPROC1",16,0)
 .Q:PROC("VMS SERVICE")
"RTN","HLOPROC1",17,0)
 .Q:PROC("NAME")="PROCESS MANAGER"
"RTN","HLOPROC1",18,0)
 .Q:'PROC("ACTIVE")
"RTN","HLOPROC1",19,0)
 .S PROCESS("COUNT")=1
"RTN","HLOPROC1",20,0)
 .S QUEUED=+$G(^HLC("HL7 PROCESS COUNTS","QUEUED",PROC("NAME")))
"RTN","HLOPROC1",21,0)
 .S:QUEUED<0 QUEUED=0
"RTN","HLOPROC1",22,0)
 .S RUNNING=+$G(^HLC("HL7 PROCESS COUNTS","RUNNING",PROC("NAME")))
"RTN","HLOPROC1",23,0)
 .S:RUNNING<0 RUNNING=0
"RTN","HLOPROC1",24,0)
 .S COUNT=QUEUED+RUNNING
"RTN","HLOPROC1",25,0)
 .I COUNT<PROC("MINIMUM") S GOTWORK=1,PROCESS("IEN")=IEN,PROCESS("NAME")=PROC("NAME"),PROCESS("COUNT")=(PROC("MINIMUM")-COUNT) Q
"RTN","HLOPROC1",26,0)
 .I COUNT<PROC("MAXIMUM"),$$FMDIFF^XLFDT($$NOW^XLFDT,PROC("LAST DT/TM"),2)>PROC("WAIT SECONDS"),'QUEUED S GOTWORK=1,PROCESS("IEN")=IEN,PROCESS("NAME")=PROC("NAME"),PROCESS("COUNT")=1 Q
"RTN","HLOPROC1",27,0)
 I 'GOTWORK K PROCESS
"RTN","HLOPROC1",28,0)
 Q GOTWORK
"RTN","HLOPROC1",29,0)
 ;
"RTN","HLOPROC1",30,0)
DOWORK(PROCESS) ;
"RTN","HLOPROC1",31,0)
 ;starts a process
"RTN","HLOPROC1",32,0)
 ;
"RTN","HLOPROC1",33,0)
 ;don't start a new task if stopped
"RTN","HLOPROC1",34,0)
 Q:$$CHKSTOP^HLOPROC
"RTN","HLOPROC1",35,0)
 ;
"RTN","HLOPROC1",36,0)
 N ZTRTN,ZTDESC,ZTSAVE,ZTIO,ZTSK,I,ZTDTH
"RTN","HLOPROC1",37,0)
 S:'$G(PROCESS("COUNT")) PROCESS("COUNT")=1
"RTN","HLOPROC1",38,0)
 F I=1:1:PROCESS("COUNT") D
"RTN","HLOPROC1",39,0)
 .S ZTRTN="PROCESS^HLOPROC"
"RTN","HLOPROC1",40,0)
 .S ZTDESC="HL7 - "_PROCESS("NAME")
"RTN","HLOPROC1",41,0)
 .S ZTIO=""
"RTN","HLOPROC1",42,0)
 .S ZTSAVE("PROCNAME")=PROCESS("NAME")
"RTN","HLOPROC1",43,0)
 .S ZTDTH=$H
"RTN","HLOPROC1",44,0)
 .D ^%ZTLOAD
"RTN","HLOPROC1",45,0)
 .I $D(ZTSK) D
"RTN","HLOPROC1",46,0)
 ..;lock before changing counts
"RTN","HLOPROC1",47,0)
 ..L +HL7("COUNTING PROCESSES"):20
"RTN","HLOPROC1",48,0)
 ..I $$INC^HLOSITE($NA(^HLC("HL7 PROCESS COUNTS","QUEUED",PROCESS("NAME"))))
"RTN","HLOPROC1",49,0)
 ..S $P(^HLD(779.3,PROCESS("IEN"),0),"^",6)=$$NOW^XLFDT,^HLTMP("HL7 QUEUED PROCESSES",ZTSK)=$H_"^"_PROCESS("NAME")
"RTN","HLOPROC1",50,0)
 ..L -HL7("COUNTING PROCESSES")
"RTN","HLOPROC1",51,0)
 Q
"RTN","HLOPROC1",52,0)
 ;
"RTN","HLOPROC1",53,0)
GETPROC(IEN,PROCESS) ;
"RTN","HLOPROC1",54,0)
 ;given the ien of the HL7 Process Registry entry, returns the entry as a subscripted array in .PROCESS
"RTN","HLOPROC1",55,0)
 ;
"RTN","HLOPROC1",56,0)
 ;Output: Function returns 0 on failure, 1 on success
"RTN","HLOPROC1",57,0)
 ;
"RTN","HLOPROC1",58,0)
 N NODE
"RTN","HLOPROC1",59,0)
 S NODE=$G(^HLD(779.3,IEN,0))
"RTN","HLOPROC1",60,0)
 Q:NODE="" 0
"RTN","HLOPROC1",61,0)
 S PROCESS("NAME")=$P(NODE,"^")
"RTN","HLOPROC1",62,0)
 S PROCESS("IEN")=IEN
"RTN","HLOPROC1",63,0)
 S PROCESS("ACTIVE")=$P(NODE,"^",2)
"RTN","HLOPROC1",64,0)
 S PROCESS("MINIMUM")=+$P(NODE,"^",3)
"RTN","HLOPROC1",65,0)
 S PROCESS("MAXIMUM")=+$P(NODE,"^",4)
"RTN","HLOPROC1",66,0)
 S PROCESS("WAIT SECONDS")=+($P(NODE,"^",5))*60
"RTN","HLOPROC1",67,0)
 I 'PROCESS("WAIT SECONDS") S PROCESS("WAIT SECONDS")=1000
"RTN","HLOPROC1",68,0)
 S PROCESS("LAST DT/TM")=$P(NODE,"^",6)
"RTN","HLOPROC1",69,0)
 S PROCESS("VMS SERVICE")=$P(NODE,"^",15)
"RTN","HLOPROC1",70,0)
 Q 1
"RTN","HLOPROC1",71,0)
 ;
"RTN","HLOPROC1",72,0)
STOPHL7 ;shut down HLO HL7
"RTN","HLOPROC1",73,0)
 N ZTSK,DOLLARJ
"RTN","HLOPROC1",74,0)
 ;let other processes know that starting/stopping is underway
"RTN","HLOPROC1",75,0)
 S $P(^HLD(779.1,1,0),"^",9)=0
"RTN","HLOPROC1",76,0)
 S ZTSK=""
"RTN","HLOPROC1",77,0)
 F  S ZTSK=$O(^HLTMP("HL7 QUEUED PROCESSES",ZTSK)) Q:ZTSK=""  D DQ^%ZTLOAD
"RTN","HLOPROC1",78,0)
 S DOLLARJ=""
"RTN","HLOPROC1",79,0)
 F  S DOLLARJ=$O(^HLTMP("HL7 RUNNING PROCESSES",DOLLARJ)) Q:DOLLARJ=""  S ZTSK=$P($G(^HLTMP("HL7 RUNNING PROCESSES",DOLLARJ)),"^",2) I ZTSK]"" D PCLEAR^%ZTLOAD(ZTSK) I $$ASKSTOP^%ZTLOAD(ZTSK)
"RTN","HLOPROC1",80,0)
 D CHKQUED
"RTN","HLOPROC1",81,0)
 Q
"RTN","HLOPROC1",82,0)
 ;
"RTN","HLOPROC1",83,0)
STARTHL7 ; Jim's changes
"RTN","HLOPROC1",84,0)
 ;start HL7 system, but first do some cleanup
"RTN","HLOPROC1",85,0)
 ;
"RTN","HLOPROC1",86,0)
 ;*****Start HL*1.6*138
"RTN","HLOPROC1",87,0)
 N STOPPED
"RTN","HLOPROC1",88,0)
 D STOPHL7^HLOPROC1
"RTN","HLOPROC1",89,0)
 L +^HLTMP("PROCESS MANAGER"):60
"RTN","HLOPROC1",90,0)
 S STOPPED=$T
"RTN","HLOPROC1",91,0)
 D RECOUNT() ;checks list of processes, both running and queued
"RTN","HLOPROC1",92,0)
 I STOPPED D
"RTN","HLOPROC1",93,0)
 .N ALLDEAD
"RTN","HLOPROC1",94,0)
 .;wait a little while to see if all the processes stop 
"RTN","HLOPROC1",95,0)
 .F I=1:1:4 S ALLDEAD=$S(($O(^HLTMP("HL7 RUNNING PROCESSES",""))=""):1,1:0) Q:ALLDEAD  H 5
"RTN","HLOPROC1",96,0)
 .Q:'ALLDEAD  ;giveup on recounting queues - processes
"RTN","HLOPROC1",97,0)
 .;
"RTN","HLOPROC1",98,0)
 .;start HL*1.6*138
"RTN","HLOPROC1",99,0)
 .D RESET ;;recounts the queues and sets counts
"RTN","HLOPROC1",100,0)
 .;*****End HL*1.6*138
"RTN","HLOPROC1",101,0)
 ;set the system status flag to active
"RTN","HLOPROC1",102,0)
 S $P(^HLD(779.1,1,0),"^",9)=1
"RTN","HLOPROC1",103,0)
 ;
"RTN","HLOPROC1",104,0)
 ;start the HL7 Process Manager, which will start everything else
"RTN","HLOPROC1",105,0)
 N PROCESS
"RTN","HLOPROC1",106,0)
 S PROCESS("NAME")="PROCESS MANAGER"
"RTN","HLOPROC1",107,0)
 S PROCESS("IEN")=$O(^HLD(779.3,"B","PROCESS MANAGER",0))
"RTN","HLOPROC1",108,0)
 L -^HLTMP("PROCESS MANAGER") ;signals that HLO process manager can be started again
"RTN","HLOPROC1",109,0)
 D DOWORK(.PROCESS)
"RTN","HLOPROC1",110,0)
 Q
"RTN","HLOPROC1",111,0)
 ;
"RTN","HLOPROC1",112,0)
QUIT1(COUNT) ;just returns 1 as function value first time around,then 0, insuring that the DO WORK function is called just once
"RTN","HLOPROC1",113,0)
 I '$G(COUNT) S COUNT=1 Q 1
"RTN","HLOPROC1",114,0)
 Q 0
"RTN","HLOPROC1",115,0)
 ;
"RTN","HLOPROC1",116,0)
CHKDEAD(WORK) ;
"RTN","HLOPROC1",117,0)
 ;did any process terminate without erasing itself?
"RTN","HLOPROC1",118,0)
 ;WORK (pass by reference, not required) by the Process Manager that is not used and not required
"RTN","HLOPROC1",119,0)
 N DOLLARJ S DOLLARJ=""
"RTN","HLOPROC1",120,0)
 L +HL7("COUNTING PROCESSES"):20
"RTN","HLOPROC1",121,0)
 Q:'$T
"RTN","HLOPROC1",122,0)
 F  S DOLLARJ=$O(^HLTMP("HL7 RUNNING PROCESSES",DOLLARJ)) Q:DOLLARJ=""  I DOLLARJ'=$J L +^HLTMP("HL7 RUNNING PROCESSES",DOLLARJ):1 D:$T
"RTN","HLOPROC1",123,0)
 .L -^HLTMP("HL7 RUNNING PROCESSES",DOLLARJ)
"RTN","HLOPROC1",124,0)
 .N PROC
"RTN","HLOPROC1",125,0)
 .S PROC=$P($G(^HLTMP("HL7 RUNNING PROCESSES",DOLLARJ)),"^",3)
"RTN","HLOPROC1",126,0)
 .K ^HLTMP("HL7 RUNNING PROCESSES",DOLLARJ)
"RTN","HLOPROC1",127,0)
 .Q:PROC=""
"RTN","HLOPROC1",128,0)
 .I $$INC^HLOSITE($NA(^HLC("HL7 PROCESS COUNTS","RUNNING",PROC)),-1)<0,$$INC^HLOSITE($NA(^HLC("HL7 PROCESS COUNTS","RUNNING",PROC)),1)
"RTN","HLOPROC1",129,0)
 L -HL7("COUNTING PROCESSES")
"RTN","HLOPROC1",130,0)
 Q
"RTN","HLOPROC1",131,0)
CHKQUED ;did any queued task get dequeued without being erased?
"RTN","HLOPROC1",132,0)
 N PROC,JOB
"RTN","HLOPROC1",133,0)
 L +HL7("COUNTING PROCESSES"):20
"RTN","HLOPROC1",134,0)
 Q:'$T
"RTN","HLOPROC1",135,0)
 S JOB=""
"RTN","HLOPROC1",136,0)
 F  S JOB=$O(^HLTMP("HL7 QUEUED PROCESSES",JOB)) Q:JOB=""  I '$$QUEUED(JOB) D
"RTN","HLOPROC1",137,0)
 .N PROC
"RTN","HLOPROC1",138,0)
 .S PROC=$P($G(^HLTMP("HL7 QUEUED PROCESSES",JOB)),"^",2)
"RTN","HLOPROC1",139,0)
 .I PROC]"",$$INC^HLOSITE($NA(^HLC("HL7 PROCESS COUNTS","QUEUED",PROC)),-1)<0,$$INC^HLOSITE($NA(^HLC("HL7 PROCESS COUNTS","QUEUED",PROC)),1)
"RTN","HLOPROC1",140,0)
 .K ^HLTMP("HL7 QUEUED PROCESSES",JOB)
"RTN","HLOPROC1",141,0)
 L -HL7("COUNTING PROCESSES")
"RTN","HLOPROC1",142,0)
 Q
"RTN","HLOPROC1",143,0)
 ;
"RTN","HLOPROC1",144,0)
QUEUED(TASK) ;
"RTN","HLOPROC1",145,0)
 ;function returns 0 if ZTSK is not queued to run, 1 if it is
"RTN","HLOPROC1",146,0)
 N ZTSK
"RTN","HLOPROC1",147,0)
 S ZTSK=TASK
"RTN","HLOPROC1",148,0)
 D ISQED^%ZTLOAD
"RTN","HLOPROC1",149,0)
 Q:ZTSK(0) 1
"RTN","HLOPROC1",150,0)
 Q 0
"RTN","HLOPROC1",151,0)
 ;
"RTN","HLOPROC1",152,0)
CNTLIVE ;count the running processes
"RTN","HLOPROC1",153,0)
 N JOB,COUNTS,PROC
"RTN","HLOPROC1",154,0)
 L +HL7("COUNTING PROCESSES"):20
"RTN","HLOPROC1",155,0)
 Q:'$T
"RTN","HLOPROC1",156,0)
 S JOB=""
"RTN","HLOPROC1",157,0)
 F  S JOB=$O(^HLTMP("HL7 RUNNING PROCESSES",JOB)) Q:JOB=""  S PROC=$P($G(^HLTMP("HL7 RUNNING PROCESSES",JOB)),"^",3) I PROC]"" S COUNTS(PROC)=$G(COUNTS(PROC))+1
"RTN","HLOPROC1",158,0)
 S PROC="" F  S PROC=$O(COUNTS(PROC)) Q:PROC=""  S ^HLC("HL7 PROCESS COUNTS","RUNNING",PROC)=COUNTS(PROC)
"RTN","HLOPROC1",159,0)
 S PROC="" F  S PROC=$O(^HLC("HL7 PROCESS COUNTS","RUNNING",PROC)) Q:PROC=""  S ^HLC("HL7 PROCESS COUNTS","RUNNING",PROC)=+$G(COUNTS(PROC))
"RTN","HLOPROC1",160,0)
 L -HL7("COUNTING PROCESSES")
"RTN","HLOPROC1",161,0)
 Q
"RTN","HLOPROC1",162,0)
 ;
"RTN","HLOPROC1",163,0)
CNTQUED ;count the queued tasks
"RTN","HLOPROC1",164,0)
 N JOB,COUNTS,PROC
"RTN","HLOPROC1",165,0)
 L +HL7("COUNTING PROCESSES"):20
"RTN","HLOPROC1",166,0)
 Q:'$T
"RTN","HLOPROC1",167,0)
 S JOB=""
"RTN","HLOPROC1",168,0)
 F  S JOB=$O(^HLTMP("HL7 QUEUED PROCESSES",JOB)) Q:JOB=""  S PROC=$P($G(^HLTMP("HL7 QUEUED PROCESSES",JOB)),"^",2) I PROC]"" S COUNTS(PROC)=$G(COUNTS(PROC))+1
"RTN","HLOPROC1",169,0)
 S PROC="" F  S PROC=$O(COUNTS(PROC)) Q:PROC=""  S ^HLC("HL7 PROCESS COUNTS","QUEUED",PROC)=COUNTS(PROC)
"RTN","HLOPROC1",170,0)
 S PROC="" F  S PROC=$O(^HLC("HL7 PROCESS COUNTS","QUEUED",PROC)) Q:PROC=""  S ^HLC("HL7 PROCESS COUNTS","QUEUED",PROC)=+$G(COUNTS(PROC))
"RTN","HLOPROC1",171,0)
 L -HL7("COUNTING PROCESSES")
"RTN","HLOPROC1",172,0)
 Q
"RTN","HLOPROC1",173,0)
 ;
"RTN","HLOPROC1",174,0)
RECOUNT(RECOUNT) ;check that the processes that are supposed to be running actually are, same for the queued processes
"RTN","HLOPROC1",175,0)
 ;Input:
"RTN","HLOPROC1",176,0)
 ;  RECOUNT (pass by reference, optional) not used, but passed in by the process manager
"RTN","HLOPROC1",177,0)
 ;
"RTN","HLOPROC1",178,0)
 ;
"RTN","HLOPROC1",179,0)
 ;check for processes that are supposed to be running or queued but aren't
"RTN","HLOPROC1",180,0)
 D CHKDEAD(),CHKQUED
"RTN","HLOPROC1",181,0)
 ;
"RTN","HLOPROC1",182,0)
 ;recount the processes
"RTN","HLOPROC1",183,0)
 D CNTLIVE,CNTQUED
"RTN","HLOPROC1",184,0)
 Q
"RTN","HLOPROC1",185,0)
 ;
"RTN","HLOPROC1",186,0)
 ;*****Start HL*1.6*138 PIJ 10/26/2007
"RTN","HLOPROC1",187,0)
RESET ;
"RTN","HLOPROC1",188,0)
 N CTR,DT,LINK,QUEUE,MSGIEN
"RTN","HLOPROC1",189,0)
 K ^HLTMP("FAILING LINKS")
"RTN","HLOPROC1",190,0)
 S LINK=""
"RTN","HLOPROC1",191,0)
 F  S LINK=$O(^HLB("QUEUE","OUT",LINK)) Q:LINK=""  D
"RTN","HLOPROC1",192,0)
 . S DT=$G(^HLB("QUEUE","OUT",LINK))
"RTN","HLOPROC1",193,0)
 . I DT'="" S ^HLTMP("FAILING LINKS",LINK)=DT ;; down link (has a DT/TM)
"RTN","HLOPROC1",194,0)
 ;
"RTN","HLOPROC1",195,0)
QCNT ; reset QUEUECOUNT
"RTN","HLOPROC1",196,0)
 N LOCK,FROM
"RTN","HLOPROC1",197,0)
 N $ETRAP,$ESTACK S $ETRAP="G ERROR^HLOPROC1"
"RTN","HLOPROC1",198,0)
 D RCNT^HLOSITE("S") ;; SET RECOUNT FLAG on
"RTN","HLOPROC1",199,0)
 ;
"RTN","HLOPROC1",200,0)
 ; recount each OUT queue
"RTN","HLOPROC1",201,0)
 ;first delete counters for non-existent queues
"RTN","HLOPROC1",202,0)
 S LINK=""
"RTN","HLOPROC1",203,0)
 F  S LINK=$O(^HLC("QUEUECOUNT","OUT",LINK)) Q:LINK=""  D
"RTN","HLOPROC1",204,0)
 . S QUEUE=""
"RTN","HLOPROC1",205,0)
 . F  S QUEUE=$O(^HLC("QUEUECOUNT","OUT",LINK,QUEUE)) Q:QUEUE=""  I '$O(^HLB("QUEUE","OUT",LINK,QUEUE,0)) D
"RTN","HLOPROC1",206,0)
 . . S LOCK=$NA(RECOUNT("OUT",LINK,QUEUE))
"RTN","HLOPROC1",207,0)
 . . L +@LOCK:1 Q:'$T  ;should not fail, but if it does skip recount for this queue
"RTN","HLOPROC1",208,0)
 . .I '$O(^HLB("QUEUE","OUT",LINK,QUEUE,0)) S ^HLC("QUEUECOUNT","OUT",LINK,QUEUE)=0
"RTN","HLOPROC1",209,0)
 . . L -@LOCK
"RTN","HLOPROC1",210,0)
 ;
"RTN","HLOPROC1",211,0)
 ;now count the queues
"RTN","HLOPROC1",212,0)
 S LINK=""
"RTN","HLOPROC1",213,0)
 F  S LINK=$O(^HLB("QUEUE","OUT",LINK)) Q:LINK=""  D
"RTN","HLOPROC1",214,0)
 . S QUEUE=""
"RTN","HLOPROC1",215,0)
 . F  S QUEUE=$O(^HLB("QUEUE","OUT",LINK,QUEUE)) Q:QUEUE=""  D
"RTN","HLOPROC1",216,0)
 . . S LOCK=$NA(RECOUNT("OUT",LINK,QUEUE))
"RTN","HLOPROC1",217,0)
 . . L +@LOCK:1 Q:'$T  ;should not fail, but if it does skip recount for this queue
"RTN","HLOPROC1",218,0)
 . . S (MSGIEN,CTR)=0
"RTN","HLOPROC1",219,0)
 . . F  S MSGIEN=$O(^HLB("QUEUE","OUT",LINK,QUEUE,MSGIEN)) Q:MSGIEN=""  S CTR=CTR+1
"RTN","HLOPROC1",220,0)
 . . S ^HLC("QUEUECOUNT","OUT",LINK,QUEUE)=CTR
"RTN","HLOPROC1",221,0)
 . . L -@LOCK
"RTN","HLOPROC1",222,0)
 ;
"RTN","HLOPROC1",223,0)
 ; recount each sequence queue
"RTN","HLOPROC1",224,0)
 ;first delete counts for non-existent queues
"RTN","HLOPROC1",225,0)
 S QUEUE=""
"RTN","HLOPROC1",226,0)
 F  S QUEUE=$O(^HLC("QUEUECOUNT","SEQUENCE",QUEUE)) Q:QUEUE=""  D
"RTN","HLOPROC1",227,0)
 . Q:$G(^HLB("QUEUE","SEQUENCE",QUEUE))!$O(^HLB("QUEUE","SEQUENCE",QUEUE,0))
"RTN","HLOPROC1",228,0)
 . S LOCK=$NA(RECOUNT("SEQUENCE",QUEUE))
"RTN","HLOPROC1",229,0)
 . L +@LOCK:1 Q:'$T
"RTN","HLOPROC1",230,0)
 . I '$G(^HLB("QUEUE","SEQUENCE",QUEUE)),'$O(^HLB("QUEUE","SEQUENCE",QUEUE,0)) S ^HLC("QUEUECOUNT","SEQUENCE",QUEUE)=0
"RTN","HLOPROC1",231,0)
 . L -@LOCK
"RTN","HLOPROC1",232,0)
 ;
"RTN","HLOPROC1",233,0)
 ;now count the queues
"RTN","HLOPROC1",234,0)
 S QUEUE=""
"RTN","HLOPROC1",235,0)
 F  S QUEUE=$O(^HLB("QUEUE","SEQUENCE",QUEUE)) Q:QUEUE=""  D
"RTN","HLOPROC1",236,0)
 .S LOCK=$NA(RECOUNT("SEQUENCE",QUEUE))
"RTN","HLOPROC1",237,0)
 . L +@LOCK:1 Q:'$T  ;should not fail, but if it does, skip the recount  of this queue
"RTN","HLOPROC1",238,0)
 .;
"RTN","HLOPROC1",239,0)
 .S (MSGIEN,CTR)=0
"RTN","HLOPROC1",240,0)
 .;count msg even if not on the queue if the queue is waiting on it
"RTN","HLOPROC1",241,0)
 . I +$G(^HLB("QUEUE","SEQUENCE",QUEUE)) S CTR=1
"RTN","HLOPROC1",242,0)
 .;
"RTN","HLOPROC1",243,0)
 . F  S MSGIEN=$O(^HLB("QUEUE","SEQUENCE",QUEUE,MSGIEN)) Q:MSGIEN=""  S CTR=CTR+1
"RTN","HLOPROC1",244,0)
 . S ^HLC("QUEUECOUNT","SEQUENCE",QUEUE)=CTR
"RTN","HLOPROC1",245,0)
 . L -@LOCK
"RTN","HLOPROC1",246,0)
 ;
"RTN","HLOPROC1",247,0)
 ;recount flag not needed anymore
"RTN","HLOPROC1",248,0)
 D RCNT^HLOSITE("U")
"RTN","HLOPROC1",249,0)
 ;
"RTN","HLOPROC1",250,0)
 ; now caculate the all-inclusive counter
"RTN","HLOPROC1",251,0)
 S QUEUE=""
"RTN","HLOPROC1",252,0)
 S CTR=0
"RTN","HLOPROC1",253,0)
 F  S QUEUE=$O(^HLC("QUEUECOUNT","SEQUENCE",QUEUE)) Q:QUEUE=""  S CTR=CTR+$G(^HLC("QUEUECOUNT","SEQUENCE",QUEUE))
"RTN","HLOPROC1",254,0)
 S ^HLC("QUEUECOUNT","SEQUENCE")=CTR
"RTN","HLOPROC1",255,0)
 ;
"RTN","HLOPROC1",256,0)
 ;
"RTN","HLOPROC1",257,0)
 ; recount IN queues
"RTN","HLOPROC1",258,0)
 ;the infilers and server should currently be stopped, so there is no contention for these data structures
"RTN","HLOPROC1",259,0)
 ;
"RTN","HLOPROC1",260,0)
 ;first delete counts for non-existent queues
"RTN","HLOPROC1",261,0)
 S FROM=""
"RTN","HLOPROC1",262,0)
 F  S FROM=$O(^HLC("QUEUECOUNT","IN",FROM)) Q:FROM=""  D
"RTN","HLOPROC1",263,0)
 . S QUEUE=""
"RTN","HLOPROC1",264,0)
 . F  S QUEUE=$O(^HLC("QUEUECOUNT","IN",FROM,QUEUE)) Q:QUEUE=""  I '$O(^HLB("QUEUE","IN",FROM,QUEUE,0)) S ^HLC("QUEUECOUNT","IN",FROM,QUEUE)=0
"RTN","HLOPROC1",265,0)
 ;
"RTN","HLOPROC1",266,0)
 ;now count the queues
"RTN","HLOPROC1",267,0)
 S FROM=""
"RTN","HLOPROC1",268,0)
 F  S FROM=$O(^HLB("QUEUE","IN",FROM)) Q:FROM=""  D
"RTN","HLOPROC1",269,0)
 . S QUEUE=""
"RTN","HLOPROC1",270,0)
 . F  S QUEUE=$O(^HLB("QUEUE","IN",FROM,QUEUE)) Q:QUEUE=""  D
"RTN","HLOPROC1",271,0)
 . . S (MSGIEN,CTR)=0
"RTN","HLOPROC1",272,0)
 . . F  S MSGIEN=$O(^HLB("QUEUE","IN",FROM,QUEUE,MSGIEN)) Q:MSGIEN=""  D
"RTN","HLOPROC1",273,0)
 . . . S CTR=CTR+1
"RTN","HLOPROC1",274,0)
 . . S ^HLC("QUEUECOUNT","IN",FROM,QUEUE)=CTR
"RTN","HLOPROC1",275,0)
 ;
"RTN","HLOPROC1",276,0)
 Q
"RTN","HLOPROC1",277,0)
ERROR ;
"RTN","HLOPROC1",278,0)
 ;cleanup if the error occurred during queue recount
"RTN","HLOPROC1",279,0)
 D RCNT^HLOSITE("U")
"RTN","HLOPROC1",280,0)
 I $L($G(LOCK)) L -@LOCK
"RTN","HLOPROC1",281,0)
 D ^%ZTER
"RTN","HLOPROC1",282,0)
 D UNWIND^%ZTER
"RTN","HLOPROC1",283,0)
 Q
"RTN","HLOPROC1",284,0)
 ;*****End HL*1.6*138
"RTN","HLOPRSR1")
0^18^B21086795^B20800062
"RTN","HLOPRSR1",1,0)
HLOPRSR1 ;ALB/CJM - Visual Parser 12 JUN 1997 10:00 am ;11/12/2008
"RTN","HLOPRSR1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**138,139**;Oct 13, 1995;Build 11
"RTN","HLOPRSR1",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOPRSR1",4,0)
 ;
"RTN","HLOPRSR1",5,0)
 ;
"RTN","HLOPRSR1",6,0)
 ;Definitions:
"RTN","HLOPRSR1",7,0)
 ;$$SCRNSIZE number of lines in the scrolling region
"RTN","HLOPRSR1",8,0)
 ;@MSG@() array containing the message
"RTN","HLOPRSR1",9,0)
 ;$$MSGSIZE number of lines in the message
"RTN","HLOPRSR1",10,0)
 ;$$TOP msg line number appearing at the top of the scrolling region.
"RTN","HLOPRSR1",11,0)
 ;     It could be negative if the user scrolled up past the top of
"RTN","HLOPRSR1",12,0)
 ;     the msg.
"RTN","HLOPRSR1",13,0)
 ;$$BOT msg line number of the line that appears at the bottom of the
"RTN","HLOPRSR1",14,0)
 ;          scrolling area. It could be bigger than $$MSGSIZE if the user
"RTN","HLOPRSR1",15,0)
 ;          scrolled down past the msg
"RTN","HLOPRSR1",16,0)
 ;$$LINE    the msg line being parsed
"RTN","HLOPRSR1",17,0)
 ;$$X       the character parsing position within the msg line
"RTN","HLOPRSR1",18,0)
 ;$$Y       the screen line of the current message line
"RTN","HLOPRSR1",19,0)
 ;$$SEG     current segment #
"RTN","HLOPRSR1",20,0)
 ;$$FLD     current field number
"RTN","HLOPRSR1",21,0)
 ;$$REP     current repitition number
"RTN","HLOPRSR1",22,0)
 ;$$COMP    current component #
"RTN","HLOPRSR1",23,0)
 ;$$SUB     current subcomponent #
"RTN","HLOPRSR1",24,0)
 ;$$SEGSTART (<segment number>) msg line # that the segment starts on
"RTN","HLOPRSR1",25,0)
 ;SEGTYPE - 3 character segment type of the current segment
"RTN","HLOPRSR1",26,0)
 ;DELIM -field,component,subcomponent,repitition dlimiters 
"RTN","HLOPRSR1",27,0)
 ;FLD - field delimiter
"RTN","HLOPRSR1",28,0)
 ;REP -repitition delimiter
"RTN","HLOPRSR1",29,0)
 ;COMP - component delimiter
"RTN","HLOPRSR1",30,0)
 ;SUB - subcomponent delimiter
"RTN","HLOPRSR1",31,0)
 ;SEG - SEG(<seg#>)=line it starts on
"RTN","HLOPRSR1",32,0)
 ;SEGLINE() - SEGLINE(<line number>)=segment it is in (1st line only)
"RTN","HLOPRSR1",33,0)
 ;@DESCRIBE@() - list of text lines containing the description of current field
"RTN","HLOPRSR1",34,0)
 ;
"RTN","HLOPRSR1",35,0)
PARSE(PARMS) ;
"RTN","HLOPRSR1",36,0)
 N MSG,POS,SEG,INPUT,QUIT,IOBM,IOTM,HILITE,FLD,REP,ESC,COMP,SUB,DELIM,SEGTYPE,SEGLINE,OLDBM,OLDTM,DESCRIBE,VALUE,LASTPART,VERSION,VALMBCK,XGRT,OLD,REPEAT
"RTN","HLOPRSR1",37,0)
 S OLDBM=$G(IOBM),OLDTM=$G(IOTM)
"RTN","HLOPRSR1",38,0)
 S VALMBCK="R"
"RTN","HLOPRSR1",39,0)
 Q:'$$SETUP^HLOPRSR3(.PARMS,.MSG,.POS,.SEG)
"RTN","HLOPRSR1",40,0)
 S QUIT=0
"RTN","HLOPRSR1",41,0)
 F  S INPUT=$$READ^XGF(1,30) D  Q:QUIT  W IOCUON
"RTN","HLOPRSR1",42,0)
 .D
"RTN","HLOPRSR1",43,0)
 ..;remove what the user typed
"RTN","HLOPRSR1",44,0)
 ..N CHAR,X,Y
"RTN","HLOPRSR1",45,0)
 ..W IOCUOFF
"RTN","HLOPRSR1",46,0)
 ..S CHAR=$$GETCHAR^HLOPRSR2
"RTN","HLOPRSR1",47,0)
 ..I CHAR="" S CHAR=" "
"RTN","HLOPRSR1",48,0)
 ..D IOXY($$Y,$$X)
"RTN","HLOPRSR1",49,0)
 ..W $S($P(POS("CURRENT DELIMITER"),"^",2):IORVON,1:IOINHI)
"RTN","HLOPRSR1",50,0)
 ..W IORVOFF,IOINORM
"RTN","HLOPRSR1",51,0)
 ..W CHAR
"RTN","HLOPRSR1",52,0)
 .;
"RTN","HLOPRSR1",53,0)
 .I XGRT="UP" D UP^HLOPRSR2 Q
"RTN","HLOPRSR1",54,0)
 .I (INPUT="U")!(INPUT="u") D UP^HLOPRSR2 Q
"RTN","HLOPRSR1",55,0)
 .I XGRT="DOWN" D DOWN^HLOPRSR2 Q
"RTN","HLOPRSR1",56,0)
 .I (INPUT="D")!(INPUT="d") D DOWN^HLOPRSR2 Q
"RTN","HLOPRSR1",57,0)
 .I XGRT="LEFT" D LEFT^HLOPRSR2 Q
"RTN","HLOPRSR1",58,0)
 .I (INPUT="L")!(INPUT="l") D LEFT^HLOPRSR2 Q
"RTN","HLOPRSR1",59,0)
 .I XGRT="RIGHT" D RIGHT^HLOPRSR2 Q
"RTN","HLOPRSR1",60,0)
 .I XGRT="TAB" D RIGHT^HLOPRSR2 Q
"RTN","HLOPRSR1",61,0)
 .I (INPUT="R")!(INPUT="r") D RIGHT^HLOPRSR2 Q
"RTN","HLOPRSR1",62,0)
 .I (INPUT="Q")!(INPUT="q") S QUIT=1
"RTN","HLOPRSR1",63,0)
 .I (INPUT="?")!(INPUT="h")!(INPUT="h") D HELP^HLOPRSR3 Q
"RTN","HLOPRSR1",64,0)
 .D IOXY($$Y,$$X) W IOCUON
"RTN","HLOPRSR1",65,0)
 K @MSG
"RTN","HLOPRSR1",66,0)
 I $L(DESCRIBE) K @DESCRIBE
"RTN","HLOPRSR1",67,0)
 D CLEAN^XGF
"RTN","HLOPRSR1",68,0)
 D ENS^%ZISS
"RTN","HLOPRSR1",69,0)
 W IOEDALL
"RTN","HLOPRSR1",70,0)
 S IOTM=OLDTM,IOBM=OLDBM W @IOSTBM
"RTN","HLOPRSR1",71,0)
 Q
"RTN","HLOPRSR1",72,0)
 ;
"RTN","HLOPRSR1",73,0)
WRITELN(LINE,Y) ;writes one line to the screen
"RTN","HLOPRSR1",74,0)
 ;LINE- # of line in @MSG
"RTN","HLOPRSR1",75,0)
 ;Y - screen line #
"RTN","HLOPRSR1",76,0)
 D IOXY(Y,1)
"RTN","HLOPRSR1",77,0)
 I $G(SEGLINE(LINE)) D
"RTN","HLOPRSR1",78,0)
 .W IOINHI
"RTN","HLOPRSR1",79,0)
 .W $E($G(@MSG@(LINE)),1,3)
"RTN","HLOPRSR1",80,0)
 .W IOINORM
"RTN","HLOPRSR1",81,0)
 .W $E($G(@MSG@(LINE)),4,80)
"RTN","HLOPRSR1",82,0)
 E  D
"RTN","HLOPRSR1",83,0)
 .W $G(@MSG@(LINE))
"RTN","HLOPRSR1",84,0)
 Q
"RTN","HLOPRSR1",85,0)
 ;
"RTN","HLOPRSR1",86,0)
MSGSIZE() ;
"RTN","HLOPRSR1",87,0)
 Q $O(@MSG@(9999999999),-1)
"RTN","HLOPRSR1",88,0)
SCRNSIZE() ;
"RTN","HLOPRSR1",89,0)
 Q (IOBM-IOTM)+1
"RTN","HLOPRSR1",90,0)
TOP(INC) ;msg line at the top of the scrolling area
"RTN","HLOPRSR1",91,0)
 I $G(INC) S POS("TOP")=POS("TOP")+INC
"RTN","HLOPRSR1",92,0)
 Q POS("TOP")
"RTN","HLOPRSR1",93,0)
BOT() ;msg line at the bottom of the scrolling area
"RTN","HLOPRSR1",94,0)
 Q ($$TOP+$$SCRNSIZE)-1
"RTN","HLOPRSR1",95,0)
LINE(TO,INC) ;msg line
"RTN","HLOPRSR1",96,0)
 ;
"RTN","HLOPRSR1",97,0)
 ;If TO and INC are null, $$LINE returns the current msg line
"RTN","HLOPRSR1",98,0)
 ;If TO is valued, the current line is set to TO and that value returned
"RTN","HLOPRSR1",99,0)
 ;Otherwise, if INC is valued the current line is incremented by that value and is returned
"RTN","HLOPRSR1",100,0)
 D
"RTN","HLOPRSR1",101,0)
 .I $L($G(TO)),$$X(1) S POS("LINE")=TO
"RTN","HLOPRSR1",102,0)
 .I $G(INC),$$X(1) S POS("LINE")=POS("LINE")+INC
"RTN","HLOPRSR1",103,0)
 Q +$G(POS("LINE"))
"RTN","HLOPRSR1",104,0)
 ;
"RTN","HLOPRSR1",105,0)
X(TO,INC) ;current position within the line
"RTN","HLOPRSR1",106,0)
 ;
"RTN","HLOPRSR1",107,0)
 ;If TO and INC are null, $$X returns the current character position
"RTN","HLOPRSR1",108,0)
 ;If TO is valued, the current position is set to TO and that value returned
"RTN","HLOPRSR1",109,0)
 ;Otherwise, if INC is valued the current position is incremented by that value and is returned
"RTN","HLOPRSR1",110,0)
 ;
"RTN","HLOPRSR1",111,0)
 D
"RTN","HLOPRSR1",112,0)
 .I $L($G(TO)) S POS("CHAR")=TO
"RTN","HLOPRSR1",113,0)
 .I $G(INC) S POS("CHAR")=POS("CHAR")+INC
"RTN","HLOPRSR1",114,0)
 ;
"RTN","HLOPRSR1",115,0)
 I $G(POS("CHAR"))>$L($G(@MSG@($$LINE))) S POS("CHAR")=$L($G(@MSG@($$LINE)))
"RTN","HLOPRSR1",116,0)
 I $G(POS("CHAR"))<1 S POS("CHAR")=1
"RTN","HLOPRSR1",117,0)
 Q +$G(POS("CHAR"))
"RTN","HLOPRSR1",118,0)
Y(LINE) ;screen line of msg line = LINE
"RTN","HLOPRSR1",119,0)
 ;LINE defaults to $$LINE
"RTN","HLOPRSR1",120,0)
 I $D(LINE) Q (LINE-$$TOP)+1
"RTN","HLOPRSR1",121,0)
 Q ($$LINE-$$TOP)+1
"RTN","HLOPRSR1",122,0)
SEG(INC) ;returns the current segement #
"RTN","HLOPRSR1",123,0)
 ;if INC is passed in, the segment # is first incremented/decremented by INC, then the new value is returned
"RTN","HLOPRSR1",124,0)
 ;returns the new current segment
"RTN","HLOPRSR1",125,0)
 S POS("SEG")=$G(POS("SEG"))+$G(INC)
"RTN","HLOPRSR1",126,0)
 Q POS("SEG")
"RTN","HLOPRSR1",127,0)
FLD(SET) ;returns the currrent field #
"RTN","HLOPRSR1",128,0)
 ;Input:
"RTN","HLOPRSR1",129,0)
 ;  SET:
"RTN","HLOPRSR1",130,0)
 ;      if "+" increments the field #
"RTN","HLOPRSR1",131,0)
 ;      if "-" decrements the field #
"RTN","HLOPRSR1",132,0)
 ;      if SET>0 sets the field # to SET
"RTN","HLOPRSR1",133,0)
 D:$D(SET)
"RTN","HLOPRSR1",134,0)
 .I $E(SET)="+" S POS("FLD")=$G(POS("FLD"))+1 Q
"RTN","HLOPRSR1",135,0)
 .I $E(SET)="-" S POS("FLD")=$G(POS("FLD"))-1 Q
"RTN","HLOPRSR1",136,0)
 .S POS("FLD")=SET
"RTN","HLOPRSR1",137,0)
 Q $G(POS("FLD"))
"RTN","HLOPRSR1",138,0)
REP(SET) ;returns the current repitition #
"RTN","HLOPRSR1",139,0)
 ;Input:
"RTN","HLOPRSR1",140,0)
 ;  SET:
"RTN","HLOPRSR1",141,0)
 ;      if "+" increments the repitition #
"RTN","HLOPRSR1",142,0)
 ;      if "-" decrements the repitition #
"RTN","HLOPRSR1",143,0)
 ;      if >0 sets the repitition # to SET
"RTN","HLOPRSR1",144,0)
 D:$D(SET) 
"RTN","HLOPRSR1",145,0)
 .I $E(SET)="+" S POS("REP")=$G(POS("REP"))+1 Q
"RTN","HLOPRSR1",146,0)
 .I $E(SET)="-" S POS("REP")=POS("REP")-1 Q
"RTN","HLOPRSR1",147,0)
 .S POS("REP")=SET
"RTN","HLOPRSR1",148,0)
 I $D(SET) S:'($G(LASTPART($$FLD))>POS("REP")) LASTPART($$FLD)=POS("REP")
"RTN","HLOPRSR1",149,0)
 Q +$G(POS("REP"))
"RTN","HLOPRSR1",150,0)
COMP(SET) ;returns the current component #
"RTN","HLOPRSR1",151,0)
 ;Input:
"RTN","HLOPRSR1",152,0)
 ;  SET:
"RTN","HLOPRSR1",153,0)
 ;      if "+" increments the component #
"RTN","HLOPRSR1",154,0)
 ;      if "-" decrements the component #
"RTN","HLOPRSR1",155,0)
 ;      if >0 sets the component # to SET
"RTN","HLOPRSR1",156,0)
 D:$D(SET) 
"RTN","HLOPRSR1",157,0)
 .I $E(SET)="+" S POS("COMP")=$G(POS("COMP"))+1  Q
"RTN","HLOPRSR1",158,0)
 .I $E(SET)="-" S POS("COMP")=POS("COMP")-1 Q
"RTN","HLOPRSR1",159,0)
 .S POS("COMP")=SET
"RTN","HLOPRSR1",160,0)
 I $D(SET) S:'($G(LASTPART($$FLD,$$REP))>POS("COMP")) LASTPART($$FLD,$$REP)=POS("COMP")
"RTN","HLOPRSR1",161,0)
 Q +$G(POS("COMP"))
"RTN","HLOPRSR1",162,0)
 ;
"RTN","HLOPRSR1",163,0)
SUB(SET) ;returns the current sub-component #
"RTN","HLOPRSR1",164,0)
 ;Input:
"RTN","HLOPRSR1",165,0)
 ;  SET:
"RTN","HLOPRSR1",166,0)
 ;      if "+" increments the subcomponent #
"RTN","HLOPRSR1",167,0)
 ;      if "-" decrements the subcomponent #
"RTN","HLOPRSR1",168,0)
 ;      if >0 sets the sub-component # to SET
"RTN","HLOPRSR1",169,0)
 D:$D(SET) 
"RTN","HLOPRSR1",170,0)
 .I $E(SET)="+" S POS("SUB")=$G(POS("SUB"))+1  Q
"RTN","HLOPRSR1",171,0)
 .I $E(SET)="-" S POS("SUB")=POS("SUB")-1 Q
"RTN","HLOPRSR1",172,0)
 .S POS("SUB")=SET
"RTN","HLOPRSR1",173,0)
 I $D(SET) S:'($G(LASTPART($$FLD,$$REP,$$COMP))>POS("SUB")) LASTPART($$FLD,$$REP,$$COMP)=POS("SUB")
"RTN","HLOPRSR1",174,0)
 Q +$G(POS("SUB"))
"RTN","HLOPRSR1",175,0)
 ;
"RTN","HLOPRSR1",176,0)
SEGSTART(SEGMENT) ;
"RTN","HLOPRSR1",177,0)
 Q $G(SEG(SEGMENT))
"RTN","HLOPRSR1",178,0)
 ;
"RTN","HLOPRSR1",179,0)
IOXY(Y,X) ; moves to screen position line=Y, col=X
"RTN","HLOPRSR1",180,0)
 ;convert to (0,0) origin
"RTN","HLOPRSR1",181,0)
 I $G(X),X=+X S X=X-1
"RTN","HLOPRSR1",182,0)
 I $G(Y),Y=+Y S Y=Y-1
"RTN","HLOPRSR1",183,0)
 ;
"RTN","HLOPRSR1",184,0)
 D IOXY^XGF($G(Y),$G(X))
"RTN","HLOPRSR1",185,0)
 Q
"RTN","HLOPRSR2")
0^17^B77395727^B73937410
"RTN","HLOPRSR2",1,0)
HLOPRSR2 ;ALB/CJM - Visual Parser 12 JUN 1997 10:00 am ;11/13/2008
"RTN","HLOPRSR2",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**138,139**;Oct 13, 1995;Build 11
"RTN","HLOPRSR2",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOPRSR2",4,0)
 ;
"RTN","HLOPRSR2",5,0)
 ;
"RTN","HLOPRSR2",6,0)
WRITELN(LINE,Y) ;writes one line to the screen
"RTN","HLOPRSR2",7,0)
 D WRITELN^HLOPRSR1(.LINE,.Y)
"RTN","HLOPRSR2",8,0)
 Q
"RTN","HLOPRSR2",9,0)
 ;
"RTN","HLOPRSR2",10,0)
RIGHT ;
"RTN","HLOPRSR2",11,0)
 N CHAR,LINE,QUIT
"RTN","HLOPRSR2",12,0)
 K VALUE
"RTN","HLOPRSR2",13,0)
 S (QUIT,VALUE)=""
"RTN","HLOPRSR2",14,0)
 ;
"RTN","HLOPRSR2",15,0)
 ;header segments are a special case
"RTN","HLOPRSR2",16,0)
 I ((SEGTYPE="MSH")!(SEGTYPE="BHS")),(+POS("CURRENT DELIMITER")=$$SEGSTART($$SEG)),$P(POS("CURRENT DELIMITER"),"^",2)=0 D  G GORIGHT
"RTN","HLOPRSR2",17,0)
 .S POS("CURRENT DELIMITER")=$$LINE_"^4"
"RTN","HLOPRSR2",18,0)
 .S POS("NEXT DELIMITER")=$$LINE_"^"_($F($G(@MSG@($$LINE)),FLD,5)-1)
"RTN","HLOPRSR2",19,0)
 .S VALUE=FLD_$P($G(@MSG@($$LINE)),FLD,2)
"RTN","HLOPRSR2",20,0)
 .S VALUE("START")=$$LINE_"^4"
"RTN","HLOPRSR2",21,0)
 .S VALUE("END")=$$LINE_"^"_($L(VALUE)+3)
"RTN","HLOPRSR2",22,0)
 .I $$X(4),$$FLD(2),$$REP(1),$$COMP(1),$$SUB(1)
"RTN","HLOPRSR2",23,0)
 .S LASTPART(1)=1,LASTPART(1,1)=1,LASTPART(1,1,1)=1
"RTN","HLOPRSR2",24,0)
 .S LASTPART(2)=1,LASTPART(2,1)=1,LASTPART(2,1,1)=1
"RTN","HLOPRSR2",25,0)
 .;
"RTN","HLOPRSR2",26,0)
 ;
"RTN","HLOPRSR2",27,0)
 S POS("CURRENT DELIMITER")=POS("NEXT DELIMITER")
"RTN","HLOPRSR2",28,0)
 I '(+POS("CURRENT DELIMITER"))!'$P(POS("CURRENT DELIMITER"),"^",2) D DOWN Q  ;at segment end so go to next segment
"RTN","HLOPRSR2",29,0)
 ;
"RTN","HLOPRSR2",30,0)
 I $$LINE(+POS("CURRENT DELIMITER")),$$X($P(POS("CURRENT DELIMITER"),"^",2)) ;set current position to current delimiter
"RTN","HLOPRSR2",31,0)
 ;
"RTN","HLOPRSR2",32,0)
 S CHAR=$$GETCHAR
"RTN","HLOPRSR2",33,0)
 D  ;what is the next position in the segment?
"RTN","HLOPRSR2",34,0)
 .I CHAR=FLD D  Q
"RTN","HLOPRSR2",35,0)
 ..I $$FLD("+"),$$REP(1),$$COMP(1),$$SUB(1)
"RTN","HLOPRSR2",36,0)
 .I CHAR=REP D  Q
"RTN","HLOPRSR2",37,0)
 ..I $$REP("+"),$$COMP(1),$$SUB(1)
"RTN","HLOPRSR2",38,0)
 .I CHAR=COMP D  Q
"RTN","HLOPRSR2",39,0)
 ..I $$COMP("+"),$$SUB(1)
"RTN","HLOPRSR2",40,0)
 .I CHAR=SUB D  Q
"RTN","HLOPRSR2",41,0)
 ..I $$SUB("+")
"RTN","HLOPRSR2",42,0)
 ;
"RTN","HLOPRSR2",43,0)
 F  S CHAR=$$GETCHAR("+") D  Q:QUIT
"RTN","HLOPRSR2",44,0)
 .I $L(CHAR),DELIM[CHAR S POS("NEXT DELIMITER")=$$LINE_"^"_$$X,QUIT=1 Q
"RTN","HLOPRSR2",45,0)
 .I '$L(VALUE) S VALUE("START")=$$LINE_"^"_$$X,VALUE("END")=VALUE("START")
"RTN","HLOPRSR2",46,0)
 .I CHAR="" D  Q
"RTN","HLOPRSR2",47,0)
 ..S QUIT=1
"RTN","HLOPRSR2",48,0)
 ..S POS("NEXT DELIMITER")=$$LINE_"^0" ;signals end of segment
"RTN","HLOPRSR2",49,0)
 .;
"RTN","HLOPRSR2",50,0)
 .S:$L(VALUE)<512 VALUE=VALUE_CHAR
"RTN","HLOPRSR2",51,0)
 S VALUE("END")=$$LINE_"^"_$$X
"RTN","HLOPRSR2",52,0)
 ;
"RTN","HLOPRSR2",53,0)
GORIGHT ;
"RTN","HLOPRSR2",54,0)
 ;keep the current field in the scrolling region
"RTN","HLOPRSR2",55,0)
 I $$Y>(IOBM-1) D SCROLL($$Y-(IOBM-1))
"RTN","HLOPRSR2",56,0)
 ;
"RTN","HLOPRSR2",57,0)
 D DESCRIBE^HLOPRSR3
"RTN","HLOPRSR2",58,0)
 D HILITE(+$G(VALUE("START")),$P($G(VALUE("START")),"^",2),+$G(VALUE("END")),$P($G(VALUE("END")),"^",2))
"RTN","HLOPRSR2",59,0)
 Q
"RTN","HLOPRSR2",60,0)
LEFT ;
"RTN","HLOPRSR2",61,0)
 N CHAR,LINE,QUIT
"RTN","HLOPRSR2",62,0)
 K VALUE
"RTN","HLOPRSR2",63,0)
 S (QUIT,VALUE)=""
"RTN","HLOPRSR2",64,0)
 ;
"RTN","HLOPRSR2",65,0)
 S POS("NEXT DELIMITER")=POS("CURRENT DELIMITER")
"RTN","HLOPRSR2",66,0)
 I $$LINE<2,$$X<2 D UP Q
"RTN","HLOPRSR2",67,0)
 ;
"RTN","HLOPRSR2",68,0)
 ;header segments are a special case
"RTN","HLOPRSR2",69,0)
 I ((SEGTYPE="MSH")!(SEGTYPE="BHS")),$$LINE=$$SEGSTART($$SEG),$$X<$F($G(@MSG@($$LINE)),FLD,5) D  G GOLEFT
"RTN","HLOPRSR2",70,0)
 .I $$X>4 D
"RTN","HLOPRSR2",71,0)
 ..S POS("CURRENT DELIMITER")=$$LINE_"^4"
"RTN","HLOPRSR2",72,0)
 ..S VALUE=FLD_$P($G(@MSG@($$LINE)),FLD,2)
"RTN","HLOPRSR2",73,0)
 ..S VALUE("START")=$$LINE_"^4"
"RTN","HLOPRSR2",74,0)
 ..S VALUE("END")=$$LINE_"^"_($L(VALUE)+3)
"RTN","HLOPRSR2",75,0)
 ..I $$X(4),$$FLD(2),$$REP(1),$$COMP(1),$$SUB(1)
"RTN","HLOPRSR2",76,0)
 ..S LASTPART(1)=1,LASTPART(1,1)=1,LASTPART(1,1,1)=1
"RTN","HLOPRSR2",77,0)
 ..S LASTPART(2)=1,LASTPART(2,1)=1,LASTPART(2,1,1)=1
"RTN","HLOPRSR2",78,0)
 .E  D
"RTN","HLOPRSR2",79,0)
 ..S VALUE=$P($G(@MSG@($$LINE)),FLD)
"RTN","HLOPRSR2",80,0)
 ..S POS("CURRENT DELIMITER")=$$LINE_"^0"
"RTN","HLOPRSR2",81,0)
 ..S VALUE("START")=$$LINE_"^1"
"RTN","HLOPRSR2",82,0)
 ..S VALUE("END")=$$LINE_"^3"
"RTN","HLOPRSR2",83,0)
 ..I $$X(0),$$FLD(0),$$REP(0),$$COMP(0),$$SUB(0)
"RTN","HLOPRSR2",84,0)
 .;
"RTN","HLOPRSR2",85,0)
 ;
"RTN","HLOPRSR2",86,0)
 I '$P(POS("CURRENT DELIMITER"),"^",2) D  G GOLEFT  ;at segment start so go to end of prior segment
"RTN","HLOPRSR2",87,0)
 .I $$LINE($$SEGSTART($$SEG(-1))),$$X(1),$$FLD(0),$$COMP(0),$$SUB(0) ;set line to start of prior seg
"RTN","HLOPRSR2",88,0)
 .K VALUE S VALUE=""
"RTN","HLOPRSR2",89,0)
 .S SEGTYPE=$E($G(@MSG@($$LINE)),1,3)
"RTN","HLOPRSR2",90,0)
 .Q:$$LINE<1
"RTN","HLOPRSR2",91,0)
 .I (SEGTYPE="MSH")!(SEGTYPE="BHS") D
"RTN","HLOPRSR2",92,0)
 ..S VALUE=FLD_$P($G(@MSG@($$LINE)),FLD,2)
"RTN","HLOPRSR2",93,0)
 ..S VALUE("START")=$$LINE_"^4"
"RTN","HLOPRSR2",94,0)
 ..S VALUE("END")=$$LINE_"^"_($L(VALUE)+3)
"RTN","HLOPRSR2",95,0)
 ..I $$X($F($G(@MSG@($$LINE)),FLD,5)-1),$$FLD(3),$$REP(1),$$COMP(1),$$SUB(1) S POS("CURRENT DELIMITER")=$$X
"RTN","HLOPRSR2",96,0)
 ..S LASTPART(1)=1,LASTPART(1,1)=1,LASTPART(1,1,1)=1
"RTN","HLOPRSR2",97,0)
 ..S LASTPART(2)=1,LASTPART(2,1)=1,LASTPART(2,1,1)=1
"RTN","HLOPRSR2",98,0)
 .E  D
"RTN","HLOPRSR2",99,0)
 ..S POS("CURRENT DELIMITER")=$$LINE_"^0"
"RTN","HLOPRSR2",100,0)
 ..S POS("NEXT DELIMITER")=$$LINE_"^0"
"RTN","HLOPRSR2",101,0)
 ..S VALUE=SEGTYPE,VALUE("START")=$$LINE_"^1",VALUE("END")=$$LINE_"^3"
"RTN","HLOPRSR2",102,0)
 .F  S CHAR=$$GETCHAR("+") Q:CHAR=""  D
"RTN","HLOPRSR2",103,0)
 ..I DELIM[CHAR D  Q
"RTN","HLOPRSR2",104,0)
 ...S POS("CURRENT DELIMITER")=$$LINE_"^"_$$X
"RTN","HLOPRSR2",105,0)
 ...K VALUE S VALUE=""
"RTN","HLOPRSR2",106,0)
 ...I CHAR=FLD,$$FLD("+"),$$REP(1),$$COMP(1),$$SUB(1)  Q
"RTN","HLOPRSR2",107,0)
 ...I CHAR=REP,$$REP("+"),$$COMP(1),$$SUB(1) Q
"RTN","HLOPRSR2",108,0)
 ...I CHAR=COMP,$$COMP("+"),$$SUB(1) Q
"RTN","HLOPRSR2",109,0)
 ...I CHAR=SUB,$$SUB("+") Q
"RTN","HLOPRSR2",110,0)
 ..E  D
"RTN","HLOPRSR2",111,0)
 ...S:$L(VALUE)<512 VALUE=VALUE_CHAR
"RTN","HLOPRSR2",112,0)
 ...I $L(VALUE)=1 S VALUE("START")=$$LINE_"^"_$$X
"RTN","HLOPRSR2",113,0)
 ...S VALUE("END")=$$LINE_"^"_$$X
"RTN","HLOPRSR2",114,0)
 ;
"RTN","HLOPRSR2",115,0)
 I $$LINE(+POS("CURRENT DELIMITER")),$$X($P(POS("CURRENT DELIMITER"),"^",2)) ;set current position to current delimiter
"RTN","HLOPRSR2",116,0)
 ;
"RTN","HLOPRSR2",117,0)
 ;
"RTN","HLOPRSR2",118,0)
 S CHAR=$$GETCHAR
"RTN","HLOPRSR2",119,0)
 D  ;what is the next position in the segment?
"RTN","HLOPRSR2",120,0)
 .I CHAR=FLD D  Q
"RTN","HLOPRSR2",121,0)
 ..I $$FLD("-"),$$REP(LASTPART($$FLD)),$$COMP(LASTPART($$FLD,$$REP)),$$SUB(LASTPART($$FLD,$$REP,$$COMP))
"RTN","HLOPRSR2",122,0)
 .I CHAR=REP D  Q
"RTN","HLOPRSR2",123,0)
 ..I $$REP("-"),$$COMP(LASTPART($$FLD,$$REP)),$$SUB(LASTPART($$FLD,$$REP,$$COMP))
"RTN","HLOPRSR2",124,0)
 .I CHAR=COMP D  Q
"RTN","HLOPRSR2",125,0)
 ..I $$COMP("-"),$$SUB(LASTPART($$FLD,$$REP,$$COMP))
"RTN","HLOPRSR2",126,0)
 .I CHAR=SUB D  Q
"RTN","HLOPRSR2",127,0)
 ..I $$SUB("-")
"RTN","HLOPRSR2",128,0)
 ;
"RTN","HLOPRSR2",129,0)
 F  S CHAR=$$GETCHAR("-") D  Q:QUIT
"RTN","HLOPRSR2",130,0)
 .I $L(CHAR),DELIM[CHAR S POS("CURRENT DELIMITER")=$$LINE_"^"_$$X,QUIT=1 D  Q
"RTN","HLOPRSR2",131,0)
 .I CHAR="" D
"RTN","HLOPRSR2",132,0)
 ..S QUIT=1
"RTN","HLOPRSR2",133,0)
 ..I VALUE="" D UP Q
"RTN","HLOPRSR2",134,0)
 ..S POS("CURRENT DELIMITER")=$$LINE_"^0" ;signals end of segment
"RTN","HLOPRSR2",135,0)
 .;
"RTN","HLOPRSR2",136,0)
 .S:$L(VALUE)<512 VALUE=CHAR_VALUE
"RTN","HLOPRSR2",137,0)
 .I $L(VALUE)=1 S VALUE("END")=$$LINE_"^"_$$X
"RTN","HLOPRSR2",138,0)
 .S VALUE("START")=$$LINE_"^"_$$X
"RTN","HLOPRSR2",139,0)
 ;
"RTN","HLOPRSR2",140,0)
GOLEFT ;
"RTN","HLOPRSR2",141,0)
 ;keep the current field in the scrolling region
"RTN","HLOPRSR2",142,0)
 I $$Y<(IOTM) D SCROLL($$Y-IOTM)
"RTN","HLOPRSR2",143,0)
 ;
"RTN","HLOPRSR2",144,0)
 D DESCRIBE^HLOPRSR3
"RTN","HLOPRSR2",145,0)
 D HILITE(+$G(VALUE("START")),$P($G(VALUE("START")),"^",2),+$G(VALUE("END")),$P($G(VALUE("END")),"^",2))
"RTN","HLOPRSR2",146,0)
 Q
"RTN","HLOPRSR2",147,0)
 ;
"RTN","HLOPRSR2",148,0)
MSGSIZE() ;
"RTN","HLOPRSR2",149,0)
 Q $$MSGSIZE^HLOPRSR1
"RTN","HLOPRSR2",150,0)
SCRNSIZE() ;
"RTN","HLOPRSR2",151,0)
 Q $$SCRNSIZE^HLOPRSR1
"RTN","HLOPRSR2",152,0)
TOP(INC) ;msg line at the top of the scrolling area
"RTN","HLOPRSR2",153,0)
 Q $$TOP^HLOPRSR1(.INC)
"RTN","HLOPRSR2",154,0)
LINE(TO,INC) ;msg line
"RTN","HLOPRSR2",155,0)
 Q $$LINE^HLOPRSR1(.TO,.INC)
"RTN","HLOPRSR2",156,0)
 ;
"RTN","HLOPRSR2",157,0)
X(TO,INC) ;current position within the line
"RTN","HLOPRSR2",158,0)
 ;
"RTN","HLOPRSR2",159,0)
 Q $$X^HLOPRSR1(.TO,.INC)
"RTN","HLOPRSR2",160,0)
Y(LINE) ;screen line of msg line = LINE
"RTN","HLOPRSR2",161,0)
 Q $$Y^HLOPRSR1(.LINE)
"RTN","HLOPRSR2",162,0)
SEG(INC) ;returns the current segement #
"RTN","HLOPRSR2",163,0)
 Q $$SEG^HLOPRSR1(.INC)
"RTN","HLOPRSR2",164,0)
FLD(SET) ;returns the currrent field #
"RTN","HLOPRSR2",165,0)
 Q $$FLD^HLOPRSR1(.SET)
"RTN","HLOPRSR2",166,0)
REP(SET) ;returns the current repitition #
"RTN","HLOPRSR2",167,0)
 Q $$REP^HLOPRSR1(.SET)
"RTN","HLOPRSR2",168,0)
COMP(SET) ;returns the current component #
"RTN","HLOPRSR2",169,0)
 Q $$COMP^HLOPRSR1(.SET)
"RTN","HLOPRSR2",170,0)
 ;
"RTN","HLOPRSR2",171,0)
SUB(SET) ;returns the current sub-component #
"RTN","HLOPRSR2",172,0)
 Q $$SUB^HLOPRSR1(.SET)
"RTN","HLOPRSR2",173,0)
 ;
"RTN","HLOPRSR2",174,0)
SEGSTART(SEGMENT) ;
"RTN","HLOPRSR2",175,0)
 Q $$SEGSTART^HLOPRSR1(.SEGMENT)
"RTN","HLOPRSR2",176,0)
 ;
"RTN","HLOPRSR2",177,0)
IOXY(Y,X) ; moves to screen position line=Y, col=X
"RTN","HLOPRSR2",178,0)
 D IOXY^HLOPRSR1(.Y,.X)
"RTN","HLOPRSR2",179,0)
 Q
"RTN","HLOPRSR2",180,0)
HILITE(LINE1,CHAR1,LINE2,CHAR2) ;does hightlighting
"RTN","HLOPRSR2",181,0)
 ;LINE1: starting line
"RTN","HLOPRSR2",182,0)
 ;CHAR1: starting character
"RTN","HLOPRSR2",183,0)
 ;LINE2: ending line
"RTN","HLOPRSR2",184,0)
 ;CHAR2: ending character
"RTN","HLOPRSR2",185,0)
 ;
"RTN","HLOPRSR2",186,0)
 N X
"RTN","HLOPRSR2",187,0)
 I $G(HILITE) D UNLITE
"RTN","HLOPRSR2",188,0)
 I LINE1>0,CHAR1>0,LINE2>0,CHAR2>0 D
"RTN","HLOPRSR2",189,0)
 .W IORVON
"RTN","HLOPRSR2",190,0)
 .S HILITE=LINE1_"^"_CHAR1_"^"_LINE2_"^"_CHAR2
"RTN","HLOPRSR2",191,0)
 .D LITE
"RTN","HLOPRSR2",192,0)
 W IORVOFF
"RTN","HLOPRSR2",193,0)
 S X=$P(POS("CURRENT DELIMITER"),"^",2)
"RTN","HLOPRSR2",194,0)
 ;
"RTN","HLOPRSR2",195,0)
 ;
"RTN","HLOPRSR2",196,0)
 ;move curson to the delimiter, and write in bold
"RTN","HLOPRSR2",197,0)
 D IOXY($$Y($$LINE(+POS("CURRENT DELIMITER"))),$$X(X))
"RTN","HLOPRSR2",198,0)
 ;
"RTN","HLOPRSR2",199,0)
 ;
"RTN","HLOPRSR2",200,0)
 I X D
"RTN","HLOPRSR2",201,0)
 .W IOINHI
"RTN","HLOPRSR2",202,0)
 .W $$GETCHAR
"RTN","HLOPRSR2",203,0)
 .W IOINORM
"RTN","HLOPRSR2",204,0)
 .D IOXY($$Y,$$X)
"RTN","HLOPRSR2",205,0)
 W IOCUON
"RTN","HLOPRSR2",206,0)
 Q
"RTN","HLOPRSR2",207,0)
 ;
"RTN","HLOPRSR2",208,0)
LITE N LINE
"RTN","HLOPRSR2",209,0)
 F LINE=LINE1:1:LINE2 D
"RTN","HLOPRSR2",210,0)
 .I '($$Y(LINE)>IOBM),'($$Y(LINE)<IOTM) D
"RTN","HLOPRSR2",211,0)
 ..D IOXY($$Y(LINE),$S(LINE=LINE1:CHAR1,1:1))
"RTN","HLOPRSR2",212,0)
 ..W $E($G(@MSG@(LINE)),$S(LINE=LINE1:CHAR1,1:1),$S(LINE=LINE2:CHAR2,1:80))
"RTN","HLOPRSR2",213,0)
 Q
"RTN","HLOPRSR2",214,0)
 ;
"RTN","HLOPRSR2",215,0)
UNLITE ;
"RTN","HLOPRSR2",216,0)
 N LINE1,CHAR1,LINE2,CHAR2
"RTN","HLOPRSR2",217,0)
 W IORVOFF
"RTN","HLOPRSR2",218,0)
 Q:$G(HILITE)=""
"RTN","HLOPRSR2",219,0)
 S LINE1=$P(HILITE,"^"),CHAR1=$P(HILITE,"^",2),LINE2=$P(HILITE,"^",3),CHAR2=$P(HILITE,"^",4)
"RTN","HLOPRSR2",220,0)
 K HILITE
"RTN","HLOPRSR2",221,0)
 I $G(SEGLINE(LINE2)),CHAR1=1 W IOINHI
"RTN","HLOPRSR2",222,0)
 D LITE
"RTN","HLOPRSR2",223,0)
 I $G(SEGLINE(LINE2)),CHAR1=1 W IOINORM
"RTN","HLOPRSR2",224,0)
 Q
"RTN","HLOPRSR2",225,0)
 ;
"RTN","HLOPRSR2",226,0)
DOWN ;
"RTN","HLOPRSR2",227,0)
 N I
"RTN","HLOPRSR2",228,0)
 K LASTPART
"RTN","HLOPRSR2",229,0)
 S SEGTYPE=""
"RTN","HLOPRSR2",230,0)
 I $$SEGSTART($$SEG("+1")) D
"RTN","HLOPRSR2",231,0)
 .I $$LINE($$SEGSTART($$SEG))
"RTN","HLOPRSR2",232,0)
 E  D
"RTN","HLOPRSR2",233,0)
 .I $$LINE(,1)>0,$$LINE<$$MSGSIZE,$$LINE($$MSGSIZE+1)
"RTN","HLOPRSR2",234,0)
 F I="FLD","REP","COMP","SUB" S POS(I)=0
"RTN","HLOPRSR2",235,0)
 I '($$Y>IOBM) D
"RTN","HLOPRSR2",236,0)
 .D IOXY($$Y,1)
"RTN","HLOPRSR2",237,0)
 E  D
"RTN","HLOPRSR2",238,0)
 .D SCROLL($$Y-IOBM)
"RTN","HLOPRSR2",239,0)
 S SEGTYPE=$E($G(@MSG@($$LINE)),1,3)
"RTN","HLOPRSR2",240,0)
 S POS("CURRENT DELIMITER")=$$LINE_"^0"
"RTN","HLOPRSR2",241,0)
 S POS("NEXT DELIMITER")=$$LINE_"^"_$S($$SEGSTART($$SEG):4,1:0)
"RTN","HLOPRSR2",242,0)
 D DESCRIBE^HLOPRSR3
"RTN","HLOPRSR2",243,0)
 D HILITE($$LINE,$$X,$$LINE,($$X+2))
"RTN","HLOPRSR2",244,0)
 Q
"RTN","HLOPRSR2",245,0)
 ;
"RTN","HLOPRSR2",246,0)
UP ;
"RTN","HLOPRSR2",247,0)
 N I
"RTN","HLOPRSR2",248,0)
 K LASTPART
"RTN","HLOPRSR2",249,0)
 S SEGTYPE=""
"RTN","HLOPRSR2",250,0)
 I $$SEGSTART($$SEG("-1")) D
"RTN","HLOPRSR2",251,0)
 .I $$LINE($$SEGSTART($$SEG))
"RTN","HLOPRSR2",252,0)
 E  D
"RTN","HLOPRSR2",253,0)
 .I $$LINE(,-1)>0,$$LINE<$$MSGSIZE,$$LINE(0) ;set line to 0
"RTN","HLOPRSR2",254,0)
 F I="FLD","REP","COMP","SUB" S POS(I)=0
"RTN","HLOPRSR2",255,0)
 I '($$Y<IOTM) D
"RTN","HLOPRSR2",256,0)
 .D IOXY($$Y,1)
"RTN","HLOPRSR2",257,0)
 E  D
"RTN","HLOPRSR2",258,0)
 .D SCROLL($$Y-IOTM)
"RTN","HLOPRSR2",259,0)
 S SEGTYPE=$E($G(@MSG@($$LINE)),1,3)
"RTN","HLOPRSR2",260,0)
 S POS("CURRENT DELIMITER")=$$LINE_"^0"
"RTN","HLOPRSR2",261,0)
 S POS("NEXT DELIMITER")=$$LINE_"^"_$S($$SEGSTART($$SEG):4,1:0)
"RTN","HLOPRSR2",262,0)
 D DESCRIBE^HLOPRSR3
"RTN","HLOPRSR2",263,0)
 D HILITE($$LINE,$$X,$$LINE,($$X+2))
"RTN","HLOPRSR2",264,0)
 Q
"RTN","HLOPRSR2",265,0)
 ;
"RTN","HLOPRSR2",266,0)
SCROLL(COUNT) ; Scrolls up (COUNT positive) or down (COUNT negative)
"RTN","HLOPRSR2",267,0)
 ;
"RTN","HLOPRSR2",268,0)
 N I
"RTN","HLOPRSR2",269,0)
 I COUNT>0 D
"RTN","HLOPRSR2",270,0)
 .D IOXY(IOBM,1)
"RTN","HLOPRSR2",271,0)
 .F I=1:1:COUNT D
"RTN","HLOPRSR2",272,0)
 ..W IOIND
"RTN","HLOPRSR2",273,0)
 ..I $$TOP(1)
"RTN","HLOPRSR2",274,0)
 ..W $G(@MSG@($$BOT^HLOPRSR1))
"RTN","HLOPRSR2",275,0)
 ..D IOXY(IOBM,1)
"RTN","HLOPRSR2",276,0)
 .I $$LINE($$BOT^HLOPRSR1)
"RTN","HLOPRSR2",277,0)
 .S POS("CHAR")=1
"RTN","HLOPRSR2",278,0)
 .;
"RTN","HLOPRSR2",279,0)
 I COUNT<0 D
"RTN","HLOPRSR2",280,0)
 .D IOXY(1,1)
"RTN","HLOPRSR2",281,0)
 .F I=-1:-1:COUNT D
"RTN","HLOPRSR2",282,0)
 ..W IORI
"RTN","HLOPRSR2",283,0)
 ..W $G(@MSG@($$TOP(-1)))
"RTN","HLOPRSR2",284,0)
 ..D IOXY(1,1)
"RTN","HLOPRSR2",285,0)
 .S POS("CHAR")=1
"RTN","HLOPRSR2",286,0)
 Q
"RTN","HLOPRSR2",287,0)
GETCHAR(INC) ;returns a message character, can go forward or backward but will not cross the segment boundary.
"RTN","HLOPRSR2",288,0)
 ;INC:
"RTN","HLOPRSR2",289,0)
 ;  not defined - assumes the current position
"RTN","HLOPRSR2",290,0)
 ;  "+" - the next character. May change $$X and $$LINE
"RTN","HLOPRSR2",291,0)
 ;  "-" - the prior character. May change $$X and $$LINE
"RTN","HLOPRSR2",292,0)
 ;
"RTN","HLOPRSR2",293,0)
 N END,TMP
"RTN","HLOPRSR2",294,0)
 S END=0
"RTN","HLOPRSR2",295,0)
 S TMP("LINE")=$$LINE
"RTN","HLOPRSR2",296,0)
 S TMP("X")=$$X
"RTN","HLOPRSR2",297,0)
 I $E($G(INC))="+" D
"RTN","HLOPRSR2",298,0)
 .I '($$X<80) D  ;get char from next line
"RTN","HLOPRSR2",299,0)
 ..;** P139 START CJM
"RTN","HLOPRSR2",300,0)
 ..I ('$$SEGSTART($$SEG+1))!(($$LINE+1)<$$SEGSTART($$SEG+1)),$$LINE(,1),$$X(1)
"RTN","HLOPRSR2",301,0)
 ..;** P139 END
"RTN","HLOPRSR2",302,0)
 .E  D
"RTN","HLOPRSR2",303,0)
 ..I $$X=$$X(,1) S END=1
"RTN","HLOPRSR2",304,0)
 E  I $E($G(INC))="-" D
"RTN","HLOPRSR2",305,0)
 .I '($$X()>1) D  ;get char from prior line
"RTN","HLOPRSR2",306,0)
 ..I $$SEGSTART($$SEG)<$$LINE D
"RTN","HLOPRSR2",307,0)
 ...I $$LINE(,-1),$$X($L($G(@MSG@($$LINE))))
"RTN","HLOPRSR2",308,0)
 ..E  D
"RTN","HLOPRSR2",309,0)
 ...S END=1
"RTN","HLOPRSR2",310,0)
 .E  D
"RTN","HLOPRSR2",311,0)
 ..I $$X=$$X(,-1) S END=1
"RTN","HLOPRSR2",312,0)
 ;** P139 START CJM
"RTN","HLOPRSR2",313,0)
 I TMP("LINE")=$$LINE,TMP("X")=$$X S END=1
"RTN","HLOPRSR2",314,0)
 ;**P139 END
"RTN","HLOPRSR2",315,0)
 Q:END ""
"RTN","HLOPRSR2",316,0)
 Q $E($G(@MSG@($$LINE)),$$X)
"RTN","HLOPRSR2",317,0)
 ;
"RTN","HLOPRSR2",318,0)
LJ(STRING,LENGTH) ;
"RTN","HLOPRSR2",319,0)
 Q $$LJ^XLFSTR(STRING,LENGTH)
"RTN","HLOPURGE")
0^2^B32879435^B32660278
"RTN","HLOPURGE",1,0)
HLOPURGE ;IRMFO-ALB/CJM - Purging Old Messages;03/24/2004  14:43 ;07/16/2008
"RTN","HLOPURGE",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,134,136,137,139**;Oct 13, 1995;Build 11
"RTN","HLOPURGE",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOPURGE",4,0)
 ;
"RTN","HLOPURGE",5,0)
GETWORK(WORK) ;
"RTN","HLOPURGE",6,0)
 ;
"RTN","HLOPURGE",7,0)
 N OK
"RTN","HLOPURGE",8,0)
 S OK=0
"RTN","HLOPURGE",9,0)
 I $G(WORK)]"" L -HLPURGE(WORK)
"RTN","HLOPURGE",10,0)
 F WORK="IN","OUT","OLD778","OLD777" I '$G(WORK("DONE",WORK)) S WORK("DONE",WORK)=1 L +HLPURGE(WORK):0 S OK=$T Q:OK
"RTN","HLOPURGE",11,0)
 I 'OK K WORK("DONE") S WORK=""
"RTN","HLOPURGE",12,0)
 Q OK
"RTN","HLOPURGE",13,0)
 ;
"RTN","HLOPURGE",14,0)
DOWORK(WORK) ;
"RTN","HLOPURGE",15,0)
 I WORK="OLD778" D OLD778
"RTN","HLOPURGE",16,0)
 I WORK="OLD777" D OLD777
"RTN","HLOPURGE",17,0)
 I (WORK="IN")!(WORK="OUT") D
"RTN","HLOPURGE",18,0)
 .N TIME,NOW
"RTN","HLOPURGE",19,0)
 .S NOW=$$NOW^XLFDT
"RTN","HLOPURGE",20,0)
 .S TIME=0
"RTN","HLOPURGE",21,0)
 .F  S TIME=$O(^HLB("AD",WORK,TIME)) Q:TIME=""  Q:TIME>NOW  D
"RTN","HLOPURGE",22,0)
 ..N MSGIEN
"RTN","HLOPURGE",23,0)
 ..S MSGIEN=0
"RTN","HLOPURGE",24,0)
 ..F  S MSGIEN=$O(^HLB("AD",WORK,TIME,MSGIEN)) Q:'MSGIEN  D
"RTN","HLOPURGE",25,0)
 ...K ^HLB("AD",WORK,TIME,MSGIEN)
"RTN","HLOPURGE",26,0)
 ...D DELETE(MSGIEN)
"RTN","HLOPURGE",27,0)
 L -HLPURGE(WORK)
"RTN","HLOPURGE",28,0)
 Q
"RTN","HLOPURGE",29,0)
OLD778 ;
"RTN","HLOPURGE",30,0)
 N OLD,START,END,APP,TYPE,TODAY,PARMS
"RTN","HLOPURGE",31,0)
 S TODAY=$$DT^XLFDT
"RTN","HLOPURGE",32,0)
 S OLD=$$FMADD^XLFDT(TODAY,-$$OLDPURGE^HLOSITE)
"RTN","HLOPURGE",33,0)
 F START=0,100000000000,200000000000,300000000000 D
"RTN","HLOPURGE",34,0)
 .S END=(START+100000000000)-1
"RTN","HLOPURGE",35,0)
 .N MSGIEN,QUIT
"RTN","HLOPURGE",36,0)
 .S QUIT=0
"RTN","HLOPURGE",37,0)
 .S MSGIEN=START
"RTN","HLOPURGE",38,0)
 .F  S MSGIEN=$O(^HLB(MSGIEN)) Q:'MSGIEN  Q:(MSGIEN>END)  D  Q:QUIT
"RTN","HLOPURGE",39,0)
 ..N WHEN,BODY,NODE
"RTN","HLOPURGE",40,0)
 ..S NODE=$G(^HLB(MSGIEN,0))
"RTN","HLOPURGE",41,0)
 ..S WHEN=$P(NODE,"^",16)
"RTN","HLOPURGE",42,0)
 ..I WHEN,WHEN<OLD,$P(NODE,"^",9)<TODAY D DELETE(MSGIEN) Q
"RTN","HLOPURGE",43,0)
 ..I 'WHEN D
"RTN","HLOPURGE",44,0)
 ...S BODY=$P(NODE,"^",2)
"RTN","HLOPURGE",45,0)
 ...Q:'BODY
"RTN","HLOPURGE",46,0)
 ...S WHEN=+$G(^HLA(BODY,0))
"RTN","HLOPURGE",47,0)
 ...I WHEN,WHEN<OLD D  Q
"RTN","HLOPURGE",48,0)
 ....;I've seen messages sitting on outgoing queues forever, but it should never happen for incoming
"RTN","HLOPURGE",49,0)
 ....I $E($P(NODE,"^",4))="O",$P(NODE,"^",5)]"",$P(NODE,"^",6)]"" D
"RTN","HLOPURGE",50,0)
 .....N FROM
"RTN","HLOPURGE",51,0)
 .....S FROM=$P(NODE,"^",5)
"RTN","HLOPURGE",52,0)
 .....I $P(NODE,"^",8) S FROM=FROM_":"_$P(NODE,"^",8)
"RTN","HLOPURGE",53,0)
 .....Q:'$D(^HLB("QUEUE","OUT",FROM,$P(NODE,"^",6),MSGIEN))
"RTN","HLOPURGE",54,0)
 .....D DEQUE^HLOQUE(FROM,$P(NODE,"^",6),"OUT",MSGIEN)
"RTN","HLOPURGE",55,0)
 ....D DELETE(MSGIEN) Q
"RTN","HLOPURGE",56,0)
 ...;stop looking for old records?
"RTN","HLOPURGE",57,0)
 ...I WHEN,WHEN>OLD S QUIT=1
"RTN","HLOPURGE",58,0)
 ;
"RTN","HLOPURGE",59,0)
 ;also kill old errors left lying around
"RTN","HLOPURGE",60,0)
 D SYSPARMS^HLOSITE(.PARMS)
"RTN","HLOPURGE",61,0)
 S OLD=$$FMADD^XLFDT($$DT^XLFDT,-PARMS("ERROR PURGE"))
"RTN","HLOPURGE",62,0)
 S APP=""
"RTN","HLOPURGE",63,0)
 F  S APP=$O(^HLB("ERRORS",APP)) Q:APP=""  D
"RTN","HLOPURGE",64,0)
 .N TIME
"RTN","HLOPURGE",65,0)
 .S TIME=0
"RTN","HLOPURGE",66,0)
 .F  S TIME=$O(^HLB("ERRORS",APP,TIME)) Q:'TIME  Q:TIME>OLD  K ^HLB("ERRORS",APP,TIME)
"RTN","HLOPURGE",67,0)
 Q
"RTN","HLOPURGE",68,0)
OLD777 ;
"RTN","HLOPURGE",69,0)
 N OLD,TIME,TODAY
"RTN","HLOPURGE",70,0)
 S TODAY=$$DT^XLFDT
"RTN","HLOPURGE",71,0)
 S OLD=$$FMADD^XLFDT(TODAY,-$$OLDPURGE^HLOSITE)
"RTN","HLOPURGE",72,0)
 S TIME=0
"RTN","HLOPURGE",73,0)
 F  S TIME=$O(^HLA("B",TIME)) Q:'TIME  Q:TIME>OLD  D
"RTN","HLOPURGE",74,0)
 .N MSGIEN
"RTN","HLOPURGE",75,0)
 .S MSGIEN=0
"RTN","HLOPURGE",76,0)
 .F  S MSGIEN=$O(^HLA("B",TIME,MSGIEN)) Q:'MSGIEN  D
"RTN","HLOPURGE",77,0)
 ..N IEN778,STOP
"RTN","HLOPURGE",78,0)
 ..S (STOP,IEN778)=0
"RTN","HLOPURGE",79,0)
 ..F  S IEN778=$O(^HLB("C",MSGIEN,IEN778)) Q:'IEN778  D
"RTN","HLOPURGE",80,0)
 ...I $P($G(^HLB(IEN778,0)),"^",9)>TODAY S STOP=1 Q
"RTN","HLOPURGE",81,0)
 ...D DELETE(IEN778,1)
"RTN","HLOPURGE",82,0)
 ..K:'STOP ^HLB("C",MSGIEN),^HLA("B",TIME,MSGIEN),^HLA(MSGIEN)
"RTN","HLOPURGE",83,0)
 Q
"RTN","HLOPURGE",84,0)
 ;
"RTN","HLOPURGE",85,0)
DELETE(MSGIEN,FLAG) ;
"RTN","HLOPURGE",86,0)
 ;Input:
"RTN","HLOPURGE",87,0)
 ;  MSGIEN - IEN, file 778
"RTN","HLOPURGE",88,0)
 ;  FLAG - if $G(FLAG), will not delete the pointed to record in file 777
"RTN","HLOPURGE",89,0)
 N AC,SUBIEN,RAPP,SAPP,FS,CS,MSG
"RTN","HLOPURGE",90,0)
 I '$$GETMSG^HLOMSG(MSGIEN,.MSG) ;MSG is corrupted, but there sill may be nodes to delete
"RTN","HLOPURGE",91,0)
 S (RAPP,SAPP)=""
"RTN","HLOPURGE",92,0)
 D
"RTN","HLOPURGE",93,0)
 .S FS=$E(MSG("HDR",1),4)
"RTN","HLOPURGE",94,0)
 .Q:FS=""
"RTN","HLOPURGE",95,0)
 .S CS=$E(MSG("HDR",1),5)
"RTN","HLOPURGE",96,0)
 .S SAPP=$P($P(MSG("HDR",1),FS,3),CS)
"RTN","HLOPURGE",97,0)
 .I SAPP="" S SAPP="UNKNOWN"
"RTN","HLOPURGE",98,0)
 .S RAPP=$P($P(MSG("HDR",1),FS,5),CS)
"RTN","HLOPURGE",99,0)
 .I RAPP="" S RAPP="UNKNOWN"
"RTN","HLOPURGE",100,0)
 ;
"RTN","HLOPURGE",101,0)
 I 'MSG("BATCH") D KSEARCH(.MSG,MSG("MESSAGE TYPE"),MSG("EVENT"),SAPP,RAPP,MSGIEN)
"RTN","HLOPURGE",102,0)
 ;if an error status,take care of the "ERRORS" x-ref
"RTN","HLOPURGE",103,0)
 I MSG("STATUS")'="",MSG("STATUS")'="SU",MSG("BODY") D
"RTN","HLOPURGE",104,0)
 .K ^HLB("ERRORS",RAPP,MSG("DT/TM CREATED"),MSGIEN)
"RTN","HLOPURGE",105,0)
 .I MSG("STATUS")="ER" D
"RTN","HLOPURGE",106,0)
 ..N SUB
"RTN","HLOPURGE",107,0)
 ..S SUB=MSGIEN_"^"
"RTN","HLOPURGE",108,0)
 ..K ^HLB("ERRORS",RAPP,MSG("DT/TM CREATED"),SUB)
"RTN","HLOPURGE",109,0)
 ..F  S SUB=$O(^HLB("ERRORS",RAPP,MSG("DT/TM CREATED"),SUB)) Q:SUB=""  Q:+SUB'=MSGIEN  K ^HLB("ERRORS",RAPP,MSG("DT/TM CREATED"),SUB)
"RTN","HLOPURGE",110,0)
 ;
"RTN","HLOPURGE",111,0)
 ;kill the whole-file xrefs for the message ien within a batch
"RTN","HLOPURGE",112,0)
 S SUBIEN=0
"RTN","HLOPURGE",113,0)
 F  S SUBIEN=$O(^HLB(MSGIEN,3,SUBIEN)) Q:'SUBIEN  D
"RTN","HLOPURGE",114,0)
 .N MSGID
"RTN","HLOPURGE",115,0)
 .I FS]"" D
"RTN","HLOPURGE",116,0)
 ..N VALUE,HDR2,MSGTYPE,EVENT
"RTN","HLOPURGE",117,0)
 ..S HDR2=$G(^HLB(MSGIEN,3,SUBIEN,2))
"RTN","HLOPURGE",118,0)
 ..S VALUE=$P(HDR2,FS,4)
"RTN","HLOPURGE",119,0)
 ..S MSGTYPE=$P(VALUE,CS)
"RTN","HLOPURGE",120,0)
 ..S EVENT=$P(VALUE,CS,2)
"RTN","HLOPURGE",121,0)
 ..D KSEARCH(.MSG,MSGTYPE,EVENT,SAPP,RAPP,MSGIEN_"^"_SUBIEN)
"RTN","HLOPURGE",122,0)
 .S MSGID=$P($G(^HLB(MSGIEN,3,SUBIEN,0)),"^",2)
"RTN","HLOPURGE",123,0)
 .I MSGID]"" K ^HLB("AE",MSGID,MSGIEN_"^"_SUBIEN)
"RTN","HLOPURGE",124,0)
 ;
"RTN","HLOPURGE",125,0)
 I MSG("DIRECTION")="IN" D
"RTN","HLOPURGE",126,0)
 .Q:FS=""
"RTN","HLOPURGE",127,0)
 .N VALUE,HDR
"RTN","HLOPURGE",128,0)
 .S HDR("SENDING APPLICATION")=$P(MSG("HDR",1),FS,3)
"RTN","HLOPURGE",129,0)
 .S VALUE=$P(MSG("HDR",1),FS,4)
"RTN","HLOPURGE",130,0)
 .S HDR("SENDING FACILITY",1)=$P(VALUE,CS)
"RTN","HLOPURGE",131,0)
 .S HDR("SENDING FACILITY",2)=$P(VALUE,CS,2)
"RTN","HLOPURGE",132,0)
 .S HDR("SENDING FACILITY",3)=$P(VALUE,CS,3)
"RTN","HLOPURGE",133,0)
 .S AC=$S(HDR("SENDING FACILITY",2)]"":HDR("SENDING FACILITY",2),1:HDR("SENDING FACILITY",1))_HDR("SENDING APPLICATION")_MSG("ID")
"RTN","HLOPURGE",134,0)
 K ^HLB(MSGIEN)
"RTN","HLOPURGE",135,0)
 I MSG("STATUS","PURGE"),MSG("DIRECTION")'="" K ^HLB("AD",MSG("DIRECTION"),MSG("STATUS","PURGE"),MSGIEN)
"RTN","HLOPURGE",136,0)
 K:(MSG("ID")]"") ^HLB("B",MSG("ID"),MSGIEN)
"RTN","HLOPURGE",137,0)
 I MSG("DIRECTION")="IN" D
"RTN","HLOPURGE",138,0)
 .K:($G(AC)]"") ^HLB("AC",AC,MSGIEN)
"RTN","HLOPURGE",139,0)
 .I MSG("BODY"),'$G(FLAG) D KILL777(MSG("BODY"))
"RTN","HLOPURGE",140,0)
 I MSG("DIRECTION")="OUT" D
"RTN","HLOPURGE",141,0)
 .K ^HLB("C",+MSG("BODY"),MSGIEN)
"RTN","HLOPURGE",142,0)
 .I '$G(FLAG),'$O(^HLB("C",+MSG("BODY"),0)) D KILL777(MSG("BODY"))
"RTN","HLOPURGE",143,0)
 Q
"RTN","HLOPURGE",144,0)
 ;
"RTN","HLOPURGE",145,0)
KILL777(BODY) ;
"RTN","HLOPURGE",146,0)
 Q:'$G(BODY)
"RTN","HLOPURGE",147,0)
 N TIME
"RTN","HLOPURGE",148,0)
 S TIME=$P($G(^HLA(BODY,0)),"^")
"RTN","HLOPURGE",149,0)
 K ^HLA(BODY)
"RTN","HLOPURGE",150,0)
 K:(TIME]"") ^HLA("B",TIME,BODY)
"RTN","HLOPURGE",151,0)
 Q
"RTN","HLOPURGE",152,0)
 ;
"RTN","HLOPURGE",153,0)
KSEARCH(MSG,MSGTYPE,EVENT,SAPP,RAPP,IEN) ;
"RTN","HLOPURGE",154,0)
 ;Kills the ^HLB("SEARCH") x-ref
"RTN","HLOPURGE",155,0)
 ;
"RTN","HLOPURGE",156,0)
 N APP
"RTN","HLOPURGE",157,0)
 S:MSGTYPE="" MSGTYPE="<none>"
"RTN","HLOPURGE",158,0)
 S:EVENT="" EVENT="<none>"
"RTN","HLOPURGE",159,0)
 Q:'MSG("DT/TM CREATED")
"RTN","HLOPURGE",160,0)
 I MSG("DIRECTION")'="IN",MSG("DIRECTION")'="OUT" Q
"RTN","HLOPURGE",161,0)
 S APP=$S(MSG("DIRECTION")="IN":RAPP,1:SAPP)
"RTN","HLOPURGE",162,0)
 Q:APP=""
"RTN","HLOPURGE",163,0)
 K ^HLB("SEARCH",MSG("DIRECTION"),MSG("DT/TM CREATED"),APP,MSGTYPE,EVENT,IEN)
"RTN","HLOPURGE",164,0)
 Q
"RTN","HLOQUE1")
0^16^B78441748^B70409958
"RTN","HLOQUE1",1,0)
HLOQUE1 ;OIFO-OAK/RBN - HLO Developer API's for removing messages from queues ;11/21/2008
"RTN","HLOQUE1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**138,139**;Oct 13, 1995;Build 11
"RTN","HLOQUE1",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOQUE1",4,0)
 ;
"RTN","HLOQUE1",5,0)
 ;
"RTN","HLOQUE1",6,0)
 ; No direct calls - must use $$MSGDEL^HLOQUE1*(HLOLNAM,HLOQNAM,HLOPURDT)
"RTN","HLOQUE1",7,0)
 ;
"RTN","HLOQUE1",8,0)
 Q
"RTN","HLOQUE1",9,0)
 ;
"RTN","HLOQUE1",10,0)
MSGDEL(HLOLNAM,HLOQNAM,HLOPURDT,HLOERR) ;;  Delete messages from a queue
"RTN","HLOQUE1",11,0)
 ;;
"RTN","HLOQUE1",12,0)
 ;; Functional enhancement #6  Delete all messages on a queue.
"RTN","HLOQUE1",13,0)
 ;;  
"RTN","HLOQUE1",14,0)
 ;;  Description:
"RTN","HLOQUE1",15,0)
 ;;               This API deletes all the messages from a given OUT queue.  This is
"RTN","HLOQUE1",16,0)
 ;;               the core non-interactive API.  It can be used in code, or via the
"RTN","HLOQUE1",17,0)
 ;;               separate interactive user interface QUEPUR^HLOAPI
"RTN","HLOQUE1",18,0)
 ;;
"RTN","HLOQUE1",19,0)
 ;;  Inputs :
"RTN","HLOQUE1",20,0)
 ;;            1 Name of link (if null assume sequence queues)
"RTN","HLOQUE1",21,0)
 ;;            2 Name of queue (required)
"RTN","HLOQUE1",22,0)
 ;;            3 Purge date/time (defaults to file 779.1 error purge)
"RTN","HLOQUE1",23,0)
 ;;            4 HLOERR, passed by reference (required if error report required)
"RTN","HLOQUE1",24,0)
 ;;
"RTN","HLOQUE1",25,0)
 ;;  Outputs:
"RTN","HLOQUE1",26,0)
 ;;            1. Success:
"RTN","HLOQUE1",27,0)
 ;;               HLORPT -> name of queue^link^number of messages deleted
"RTN","HLOQUE1",28,0)
 ;;               Returns number of messages deleted.
"RTN","HLOQUE1",29,0)
 ;;
"RTN","HLOQUE1",30,0)
 ;;            2. Failure:
"RTN","HLOQUE1",31,0)
 ;;               HLOERR("LINK")   -> "Invalid link name"
"RTN","HLOQUE1",32,0)
 ;;                                   "Required link parameter missing
"RTN","HLOQUE1",33,0)
 ;;               HLOERR("QUEUE")  -> "Queue name does not exist"
"RTN","HLOQUE1",34,0)
 ;;                                   "Required queue parameter missing"
"RTN","HLOQUE1",35,0)
 ;;               HLOERR("PURDAT") -> "Invalid purge date"
"RTN","HLOQUE1",36,0)
 ;;                                   "Required purge date parameter missing"
"RTN","HLOQUE1",37,0)
 ;;               HLOERR("PURGE")  -> "Message"_MessageIEN_"not purged"
"RTN","HLOQUE1",38,0)
 ;;               Returns 0
"RTN","HLOQUE1",39,0)
 ;;
"RTN","HLOQUE1",40,0)
 ;;  Variables used:
"RTN","HLOQUE1",41,0)
 ;;               HLOLNAM  - logical link name.
"RTN","HLOQUE1",42,0)
 ;;               HLOQNAM  - queue name.
"RTN","HLOQUE1",43,0)
 ;;               HLOPURDT- purge date/time.
"RTN","HLOQUE1",44,0)
 ;;               HLOQIEN  - ien of message in file #778.
"RTN","HLOQUE1",45,0)
 ;;               HLOSRPT  - summary report array.
"RTN","HLOQUE1",46,0)
 ;;               HLOERR   - error report array, passed by reference.
"RTN","HLOQUE1",47,0)
 ;;               HLOCNT   - number of messages deleted from queue.
"RTN","HLOQUE1",48,0)
 ;;               SUCCESS  - Return value.
"RTN","HLOQUE1",49,0)
 ;;
"RTN","HLOQUE1",50,0)
 ;
"RTN","HLOQUE1",51,0)
 ; Init variables
"RTN","HLOQUE1",52,0)
 N HLOQIEN,QIEN,MIEN,FLG,HLOCNT,FROMORTO
"RTN","HLOQUE1",53,0)
 S HLOCNT=0
"RTN","HLOQUE1",54,0)
 S FLG=1
"RTN","HLOQUE1",55,0)
 ;
"RTN","HLOQUE1",56,0)
 ; Check for presence of input parameters
"RTN","HLOQUE1",57,0)
 D PARAM
"RTN","HLOQUE1",58,0)
 ;
"RTN","HLOQUE1",59,0)
 ; Validate them
"RTN","HLOQUE1",60,0)
 D VAL
"RTN","HLOQUE1",61,0)
 ;
"RTN","HLOQUE1",62,0)
 ; If any of the input parameters are bad quit and return 0 (zero)
"RTN","HLOQUE1",63,0)
 Q:$D(HLOERR)=11 HLOCNT
"RTN","HLOQUE1",64,0)
 ;
"RTN","HLOQUE1",65,0)
 ; Start the actual purging of the queue
"RTN","HLOQUE1",66,0)
 I $G(HLOLNAM)'="" D HLOPUR
"RTN","HLOQUE1",67,0)
 I $G(HLOLNAM)="" D SEQPUR
"RTN","HLOQUE1",68,0)
 ;
"RTN","HLOQUE1",69,0)
 ; Return to calling routine
"RTN","HLOQUE1",70,0)
 Q HLOCNT
"RTN","HLOQUE1",71,0)
 ;
"RTN","HLOQUE1",72,0)
 ;****
"RTN","HLOQUE1",73,0)
 ;Subroutines
"RTN","HLOQUE1",74,0)
 ;****
"RTN","HLOQUE1",75,0)
 ;
"RTN","HLOQUE1",76,0)
VAL ; Validate the link name, queue name and purge d/t
"RTN","HLOQUE1",77,0)
 N TMPLNAM,%DT,X,Y,SYSPARM
"RTN","HLOQUE1",78,0)
 S QIEN=""
"RTN","HLOQUE1",79,0)
 S TMPLNAM=$P(HLOLNAM,":",1)
"RTN","HLOQUE1",80,0)
 ;
"RTN","HLOQUE1",81,0)
 Q:$D(HLOERR)=11
"RTN","HLOQUE1",82,0)
 ;
"RTN","HLOQUE1",83,0)
 ; Are input parameters valid?
"RTN","HLOQUE1",84,0)
 S FLG=1                              ; LINK
"RTN","HLOQUE1",85,0)
 I $G(HLOLNAM)'="",$D(^HLCS(870,"B",TMPLNAM))=0 D
"RTN","HLOQUE1",86,0)
 . S HLOERR("LINK")="Invalid link name"_HLOLNAM
"RTN","HLOQUE1",87,0)
 . S FLG=0
"RTN","HLOQUE1",88,0)
 ;
"RTN","HLOQUE1",89,0)
 S FLG=0                              ; QUEUE
"RTN","HLOQUE1",90,0)
 I $G(HLOLNAM)'="" D
"RTN","HLOQUE1",91,0)
 .  F  S QIEN=$O(^HLB("QUEUE","OUT",HLOLNAM,QIEN)) Q:QIEN=""!FLG=1  D
"RTN","HLOQUE1",92,0)
 .  .  S:QIEN=HLOQNAM FLG=1
"RTN","HLOQUE1",93,0)
 .  S:FLG=0 HLOERR("QUEUE")="Queue "_HLOQNAM_" does not exist"
"RTN","HLOQUE1",94,0)
 I $G(HLOLNAM)="" D
"RTN","HLOQUE1",95,0)
 .  F  S QIEN=$O(^HLB("QUEUE","SEQUENCE",QIEN)) Q:QIEN=""!FLG=1  D
"RTN","HLOQUE1",96,0)
 .  .  S:QIEN=HLOQNAM FLG=1
"RTN","HLOQUE1",97,0)
 .  S:FLG=0 HLOERR("QUEUE")="Queue "_HLOQNAM_" does not exist"
"RTN","HLOQUE1",98,0)
 ;
"RTN","HLOQUE1",99,0)
 I $G(HLOPURDT)'=""  D
"RTN","HLOQUE1",100,0)
 .  S %DT="ST"
"RTN","HLOQUE1",101,0)
 .  S X=HLOPURDT
"RTN","HLOQUE1",102,0)
 .  D ^%DT
"RTN","HLOQUE1",103,0)
 .  S:Y<0 HLOERR("PURDAT")="Invalid purge date"
"RTN","HLOQUE1",104,0)
 ;
"RTN","HLOQUE1",105,0)
 ; could kill off the user entered purge date and force the standard
"RTN","HLOQUE1",106,0)
 ; purge date from the HLO SYSTEM PARAMETERS FILE
"RTN","HLOQUE1",107,0)
 ; S:Y<0 HLOPURDT=""
"RTN","HLOQUE1",108,0)
 ; 
"RTN","HLOQUE1",109,0)
 I HLOPURDT="" D                      ; PURGE DATE/TIME
"RTN","HLOQUE1",110,0)
 .  D SYSPARMS^HLOSITE(.SYSPARM)
"RTN","HLOQUE1",111,0)
 .  S HLOPURDT=$$FMADD^XLFDT($$NOW^XLFDT,0,SYSPARM("ERROR PURGE"),0,0)
"RTN","HLOQUE1",112,0)
 Q
"RTN","HLOQUE1",113,0)
 ;
"RTN","HLOQUE1",114,0)
PARAM ; Check for missing input parameters
"RTN","HLOQUE1",115,0)
 I $G(HLOQNAM)="" S HLOERR("QUEUE")="Required queue parameter missing" S FLG=0
"RTN","HLOQUE1",116,0)
 Q
"RTN","HLOQUE1",117,0)
 ;
"RTN","HLOQUE1",118,0)
HLOPUR ; Process HLO queue
"RTN","HLOQUE1",119,0)
 N CONF
"RTN","HLOQUE1",120,0)
 D OWNSKEY^XUSRB(.CONF,"HLOMGR",DUZ)
"RTN","HLOQUE1",121,0)
 I CONF(0)'=1 D  Q
"RTN","HLOQUE1",122,0)
 . W !,"**** You are not authorized to use this option ****" D PAUSE^VALM1 Q
"RTN","HLOQUE1",123,0)
 N MSGNUM
"RTN","HLOQUE1",124,0)
 S MIEN=""
"RTN","HLOQUE1",125,0)
 I '$G(HLOPURDT) Q
"RTN","HLOQUE1",126,0)
 L +^HLB("QUEUE","OUT",HLOLNAM,HLOQNAM):15 I '$T D  Q
"RTN","HLOQUE1",127,0)
 .  W !!,?5,"Sorry, someone else is using that queue - try again later.",!!
"RTN","HLOQUE1",128,0)
 .  S DIR("0")="E"
"RTN","HLOQUE1",129,0)
 .  D ^DIR
"RTN","HLOQUE1",130,0)
 F  S MIEN=$O(^HLB("QUEUE","OUT",HLOLNAM,HLOQNAM,MIEN)) Q:'MIEN  D
"RTN","HLOQUE1",131,0)
 .  ; don't need to mess about with crossreferences since the call below handles
"RTN","HLOQUE1",132,0)
 .  ; related to purging
"RTN","HLOQUE1",133,0)
 .  S FLG=$$SETPURGE^HLOAPI3(MIEN,HLOPURDT)
"RTN","HLOQUE1",134,0)
 .  ; if the message does not purge log the fact
"RTN","HLOQUE1",135,0)
 .  ; and do not delete it.
"RTN","HLOQUE1",136,0)
 .  I 'FLG D  Q
"RTN","HLOQUE1",137,0)
 .  .  S MSGNUM=$P(^HLB(MIEN,0),"^",1)
"RTN","HLOQUE1",138,0)
 .  .  S HLOERR("PURGE",MSGNUM)="Message "_MSGNUM_"not purged"
"RTN","HLOQUE1",139,0)
 .  S $P(^HLB(MIEN,0),"^",21)="MESSAGE GENERATED IN ERROR AND NOT PROCESSED"
"RTN","HLOQUE1",140,0)
 .  D DEQUE^HLOQUE(HLOLNAM,HLOQNAM,"OUT",MIEN)
"RTN","HLOQUE1",141,0)
 .  ; If we actually want to delete the messages that were dequeued
"RTN","HLOQUE1",142,0)
 .  ; uncomment the next two lines.
"RTN","HLOQUE1",143,0)
 .  ; D GETWORK^HLOPURGE("OUT")
"RTN","HLOQUE1",144,0)
 .  ; D DOWORK^HLOPURGE("OUT")
"RTN","HLOQUE1",145,0)
 .  S HLOCNT=HLOCNT+1
"RTN","HLOQUE1",146,0)
 L -^HLB("QUEUE","OUT",HLOLNAM,HLOQNAM)
"RTN","HLOQUE1",147,0)
 Q
"RTN","HLOQUE1",148,0)
 ;
"RTN","HLOQUE1",149,0)
SEQPUR ; Process sequential queue
"RTN","HLOQUE1",150,0)
 N CONF
"RTN","HLOQUE1",151,0)
 D FULL^VALM1
"RTN","HLOQUE1",152,0)
 D OWNSKEY^XUSRB(.CONF,"HLOMGR",DUZ)
"RTN","HLOQUE1",153,0)
 I CONF(0)'=1 D  Q
"RTN","HLOQUE1",154,0)
 . W !,"**** You are not authorized to use this option ****" D PAUSE^VALM1
"RTN","HLOQUE1",155,0)
 N MSGNUM,FLG,MIEN
"RTN","HLOQUE1",156,0)
 S MIEN=""
"RTN","HLOQUE1",157,0)
 I '$D(^HLB("QUEUE","SEQUENCE",HLOQNAM)) D  Q
"RTN","HLOQUE1",158,0)
 . S HLOERR("SEQUENCE")="Queue "_HLOQNAM_" does not exist"
"RTN","HLOQUE1",159,0)
 S MIEN=""
"RTN","HLOQUE1",160,0)
 L +^HLB("QUEUE","SEQUENCE",HLOQNAM):15 I '$T D  Q
"RTN","HLOQUE1",161,0)
 .  W !!,?5,"Sorry, someone else is using that queue - try again later.",!!
"RTN","HLOQUE1",162,0)
 .  S DIR("0")="E"
"RTN","HLOQUE1",163,0)
 .  D ^DIR
"RTN","HLOQUE1",164,0)
 F  S MIEN=$O(^HLB("QUEUE","SEQUENCE",HLOQNAM,MIEN)) Q:MIEN=""  D
"RTN","HLOQUE1",165,0)
 .  S FLG=$$SETPURGE^HLOAPI3(MIEN,HLOPURDT)
"RTN","HLOQUE1",166,0)
 .  I 'FLG D  Q
"RTN","HLOQUE1",167,0)
 .  .  S MSGNUM=$P(^HLB(MIEN,0),"^",1)
"RTN","HLOQUE1",168,0)
 .  .  S HLOERR("PURGE",MSGNUM)="Sequence message "_MSGNUM_"not purged"
"RTN","HLOQUE1",169,0)
 .  .  S $P(^HLB(MIEN,0),"^",21)="MESSAGE GENERATED IN ERROR AND NOT PROCESSED"
"RTN","HLOQUE1",170,0)
 .  K ^HLB("QUEUE","SEQUENCE",HLOQNAM,MIEN)
"RTN","HLOQUE1",171,0)
 .  S HLOCNT=HLOCNT+1
"RTN","HLOQUE1",172,0)
 K ^HLB("QUEUE","SEQUENCE",HLOQNAM)
"RTN","HLOQUE1",173,0)
 L -^HLB("QUEUE","SEQUENCE",HLOQNAM)
"RTN","HLOQUE1",174,0)
 ;
"RTN","HLOQUE1",175,0)
 Q
"RTN","HLOQUE1",176,0)
CLEAN ; Remove variables not needed.
"RTN","HLOQUE1",177,0)
 K HLOLNAM,HLOQNAM,HLOPURDT
"RTN","HLOQUE1",178,0)
 Q
"RTN","HLOQUE1",179,0)
 ;
"RTN","HLOQUE1",180,0)
LMQUES ; Entry point from ListManager for deleting queues.
"RTN","HLOQUE1",181,0)
 N CONF,FAIL,RPTFLG
"RTN","HLOQUE1",182,0)
 D OWNSKEY^XUSRB(.CONF,"HLOMGR",DUZ)
"RTN","HLOQUE1",183,0)
 I CONF(0)'=1 D  Q
"RTN","HLOQUE1",184,0)
 . W !,"**** You are not authorized to use this option ****" D PAUSE^VALM1 Q
"RTN","HLOQUE1",185,0)
 Q:$$VERIFY^HLOQUE1()=-1
"RTN","HLOQUE1",186,0)
 N HLOLNAM,HLOQNAM,HLOPURDT,LOCERR,HLOCNT,TRYAGN,LNAM,QNAM,PURDT
"RTN","HLOQUE1",187,0)
 N HLPARMS,ZTRTN,ZTDESC,ZTDTH,%,ZTIO
"RTN","HLOQUE1",188,0)
 S LOCERR=0
"RTN","HLOQUE1",189,0)
AGAIN ; Entry point for deleting additional queues.
"RTN","HLOQUE1",190,0)
 S (LNKERR,QUEERR,RPTFLG)=0
"RTN","HLOQUE1",191,0)
 K DIR
"RTN","HLOQUE1",192,0)
 I QUETYP="S" D
"RTN","HLOQUE1",193,0)
 . S LOCERR=$$SEQQUE^HLOAPI5
"RTN","HLOQUE1",194,0)
 Q:LOCERR="Q"
"RTN","HLOQUE1",195,0)
 I LOCERR="S" G:$$LMERHD AGAIN
"RTN","HLOQUE1",196,0)
 I QUETYP="O" D
"RTN","HLOQUE1",197,0)
 . ;S LOCERR=$$GETLNK^HLOAPI5
"RTN","HLOQUE1",198,0)
 . ;I LOCERR=0 S LOCERR=$$GETQUE^HLOAPI5
"RTN","HLOQUE1",199,0)
 . S LNKERR=$$GETLNK^HLOAPI5
"RTN","HLOQUE1",200,0)
 . I LNKERR=0 S QUEERR=$$GETQUE^HLOAPI5
"RTN","HLOQUE1",201,0)
 I LNKERR'=0!QUEERR'=0 S RPTFLG=$$LMERHD
"RTN","HLOQUE1",202,0)
 I RPTFLG=1 K DIR G AGAIN
"RTN","HLOQUE1",203,0)
 S VALBCK="R"
"RTN","HLOQUE1",204,0)
 Q:LNKERR'=0!(QUEERR'=0)
"RTN","HLOQUE1",205,0)
 S HLOCNT=0
"RTN","HLOQUE1",206,0)
 D LMPUR
"RTN","HLOQUE1",207,0)
 Q:LOCERR
"RTN","HLOQUE1",208,0)
 S ZTRTN="LMQUES1^HLOQUE1"
"RTN","HLOQUE1",209,0)
 S ZTDESC="HLO QUEUE PURGE"
"RTN","HLOQUE1",210,0)
 S ZTDTH=$H
"RTN","HLOQUE1",211,0)
 S ZTIO=""
"RTN","HLOQUE1",212,0)
 S ZTSAVE("*")=""
"RTN","HLOQUE1",213,0)
 D ^%ZTLOAD
"RTN","HLOQUE1",214,0)
 I '$G(ZTSK) D  Q
"RTN","HLOQUE1",215,0)
 . W !!,?5,"UNABLE TO TASK PURGE JOB",!
"RTN","HLOQUE1",216,0)
 W !!,"Please note that if there are a large number of messages",!
"RTN","HLOQUE1",217,0)
 W "the purging of the queue can take a long time to complete",!
"RTN","HLOQUE1",218,0)
 W !!,?5,"PURGE TASK NUMBER: "_ZTSK,!!
"RTN","HLOQUE1",219,0)
 D RE^VALM4
"RTN","HLOQUE1",220,0)
 I '$$ASKYESNO^HLOUSR2("Would you like to delete another queue","YES")  S VALMBCK="R" Q
"RTN","HLOQUE1",221,0)
 G AGAIN
"RTN","HLOQUE1",222,0)
 Q
"RTN","HLOQUE1",223,0)
LMQUES1 ; Job off the delete queue functionality
"RTN","HLOQUE1",224,0)
 I QUETYP="S" F  D  Q:LOCERR'=""
"RTN","HLOQUE1",225,0)
 .  D SEQPUR^HLOQUE1  ; Kill sequence queues
"RTN","HLOQUE1",226,0)
 .  D SEARCH^HLOUSR4(.HLPARMS)
"RTN","HLOQUE1",227,0)
 .  S LOCERR=1
"RTN","HLOQUE1",228,0)
 .  D SEARCH^HLOUSR4(.HLPARMS)
"RTN","HLOQUE1",229,0)
 I QUETYP="O" F  D  Q:LOCERR'=""
"RTN","HLOQUE1",230,0)
 .  I LOCERR=3 Q:$$LMERHD^HLOQUE1
"RTN","HLOQUE1",231,0)
 .  D HLOPUR^HLOQUE1  ; Kill OUT queues
"RTN","HLOQUE1",232,0)
 .  S LOCERR=1
"RTN","HLOQUE1",233,0)
 .  D OUTQUE^HLOUSR6
"RTN","HLOQUE1",234,0)
 Q
"RTN","HLOQUE1",235,0)
 ;
"RTN","HLOQUE1",236,0)
LMPUR ; Prompt and return point purge date
"RTN","HLOQUE1",237,0)
 S LOCERR=$$GETPUR^HLOAPI5()
"RTN","HLOQUE1",238,0)
 Q
"RTN","HLOQUE1",239,0)
 ;
"RTN","HLOQUE1",240,0)
LMERHD() ; Error handler for LMQUES
"RTN","HLOQUE1",241,0)
 W !,"OOPS.  That was an invalid entry",!
"RTN","HLOQUE1",242,0)
 S LOCERR=$$ASKYESNO^HLOUSR2("Would you like to try again","YES")
"RTN","HLOQUE1",243,0)
 Q LOCERR
"RTN","HLOQUE1",244,0)
 ;
"RTN","HLOQUE1",245,0)
VERIFY() ; Verify that the user REALLY wants to do whatever they are about to do.
"RTN","HLOQUE1",246,0)
 K DIR
"RTN","HLOQUE1",247,0)
 D FULL^VALM1
"RTN","HLOQUE1",248,0)
 W !,"!!!!! WARNING! - What you are about to do can result in lost messages !!!!!"
"RTN","HLOQUE1",249,0)
 ;D PAUSE^VALM1
"RTN","HLOQUE1",250,0)
 ;I $G(DUOUT)!($G(DTOUT)) Q -1
"RTN","HLOQUE1",251,0)
 W !,"!!!!! message sequencing problems and database corruption "
"RTN","HLOQUE1",252,0)
 ;D PAUSE^VALM1
"RTN","HLOQUE1",253,0)
 ;I $G(DUOUT)!($G(DTOUT)) Q -1
"RTN","HLOQUE1",254,0)
 S DIR(0)="YO"
"RTN","HLOQUE1",255,0)
 S DIR("A")="          Are you sure you want to continue? Enter <Yes> to continue"
"RTN","HLOQUE1",256,0)
 S DIR("?")="Enter <Y> to continue."
"RTN","HLOQUE1",257,0)
 D ^DIR
"RTN","HLOQUE1",258,0)
 K DIR
"RTN","HLOQUE1",259,0)
 I $G(DUOUT)!($G(DTOUT))!$G(DIRUT) Q -1
"RTN","HLOQUE1",260,0)
 I Y'=1 Q -1
"RTN","HLOQUE1",261,0)
 S DIR(0)="FO"
"RTN","HLOQUE1",262,0)
 S DIR("A")="  Please verify by entering <ConTinue> EXACTLY as shown "
"RTN","HLOQUE1",263,0)
 S DIR("?")="Enter <ConTinue> to proceed."
"RTN","HLOQUE1",264,0)
 D ^DIR
"RTN","HLOQUE1",265,0)
 K DIR
"RTN","HLOQUE1",266,0)
 I $G(DUOUT)!($G(DTOUT))!$G(DIRUT) Q -1
"RTN","HLOQUE1",267,0)
 Q:X'="ConTinue" -1
"RTN","HLOQUE1",268,0)
 W !
"RTN","HLOQUE1",269,0)
 K DIR
"RTN","HLOQUE1",270,0)
 Q 0
"RTN","HLOQUE1",271,0)
  ;
"RTN","HLOSRVR")
0^10^B77915377^B74637484
"RTN","HLOSRVR",1,0)
HLOSRVR ;ALB/CJM/OAK/PIJ- Server for receiving messages - 10/4/94 1pm ;11/24/2008
"RTN","HLOSRVR",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,130,131,134,137,138,139**;Oct 13, 1995;Build 11
"RTN","HLOSRVR",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOSRVR",4,0)
 ;
"RTN","HLOSRVR",5,0)
GETWORK(WORK) ;
"RTN","HLOSRVR",6,0)
 ;GET WORK function for a single server or a Taskman multi-server
"RTN","HLOSRVR",7,0)
 N LINK
"RTN","HLOSRVR",8,0)
 I '$$CHKSTOP^HLOPROC,$G(WORK("LINK"))]"",$$GETLINK^HLOTLNK(WORK("LINK"),.LINK),+LINK("SERVER") S WORK("PORT")=LINK("PORT") Q 1
"RTN","HLOSRVR",9,0)
 Q 0
"RTN","HLOSRVR",10,0)
 ;
"RTN","HLOSRVR",11,0)
DOWORKS(WORK) ;
"RTN","HLOSRVR",12,0)
 ;DO WORK rtn for a single server (non-concurrent)
"RTN","HLOSRVR",13,0)
 D SERVER(WORK("LINK"))
"RTN","HLOSRVR",14,0)
 Q
"RTN","HLOSRVR",15,0)
DOWORKM(WORK) ;
"RTN","HLOSRVR",16,0)
 ;DO WORK rtn for a Taskman multi-server (Cache systems only)
"RTN","HLOSRVR",17,0)
 D LISTEN^%ZISTCPS(WORK("PORT"),"SERVER^HLOSRVR("""_WORK("LINK")_""")")
"RTN","HLOSRVR",18,0)
 Q
"RTN","HLOSRVR",19,0)
 ;
"RTN","HLOSRVR",20,0)
VMS2(LINKNAME) ;called from a VMS TCP Service once a connection request has been received.  This entry point should be used only if an additional VMS TCPIP Services are being created for HLO.
"RTN","HLOSRVR",21,0)
 ;Input:
"RTN","HLOSRVR",22,0)
 ;   LINKNAME - only pass it in if an additional service is being created on a different port
"RTN","HLOSRVR",23,0)
 Q:'$L(LINKNAME)
"RTN","HLOSRVR",24,0)
 D VMS
"RTN","HLOSRVR",25,0)
 Q
"RTN","HLOSRVR",26,0)
 ;
"RTN","HLOSRVR",27,0)
VMS ;Called from VMS TCP Service once a connection request has been received. This entry point should be used only by the standard HLO service that runs on the standard HLO port.
"RTN","HLOSRVR",28,0)
 Q:$$CHKSTOP^HLOPROC
"RTN","HLOSRVR",29,0)
 D
"RTN","HLOSRVR",30,0)
 .Q:$L($G(LINKNAME))
"RTN","HLOSRVR",31,0)
 .;
"RTN","HLOSRVR",32,0)
 .N PROC,NODE
"RTN","HLOSRVR",33,0)
 .S PROC=$O(^HLD(779.3,"B","VMS TCP LISTENER",0))
"RTN","HLOSRVR",34,0)
 .I PROC S LINKNAME=$P($G(^HLD(779.3,PROC,0)),"^",14) Q:$L(LINKNAME)
"RTN","HLOSRVR",35,0)
 .S NODE=$G(^HLD(779.1,1,0)) I $P(NODE,"^",10) S LINKNAME=$P($G(^HLCS(870,$P(NODE,"^",10),0)),"^") Q:$L(LINKNAME) 
"RTN","HLOSRVR",36,0)
 .S LINKNAME="HLO DEFAULT LISTENER"
"RTN","HLOSRVR",37,0)
 ;
"RTN","HLOSRVR",38,0)
 D SERVER(LINKNAME,"SYS$NET")
"RTN","HLOSRVR",39,0)
 Q
"RTN","HLOSRVR",40,0)
 ;
"RTN","HLOSRVR",41,0)
SERVER(LINKNAME,LOGICAL) ; LINKNAME identifies the logical link, which describes the communication channel to be used
"RTN","HLOSRVR",42,0)
 ;;Start HL*1.6*138 PIJ
"RTN","HLOSRVR",43,0)
 ;;N $ETRAP,$ESTACK S $ETRAP="G ERROR^HLOSRVR1"
"RTN","HLOSRVR",44,0)
 N $ETRAP,$ESTACK S $ETRAP="G ERROR^HLOSRVR3"
"RTN","HLOSRVR",45,0)
 ;;End HL*1.6*138 PIJ
"RTN","HLOSRVR",46,0)
 N HLCSTATE,INQUE
"RTN","HLOSRVR",47,0)
 S INQUE=0
"RTN","HLOSRVR",48,0)
 Q:'$$CONNECT(.HLCSTATE,LINKNAME,.LOGICAL)
"RTN","HLOSRVR",49,0)
 K LINKNAME
"RTN","HLOSRVR",50,0)
 F  Q:'HLCSTATE("CONNECTED")  D  Q:$$CHKSTOP^HLOPROC
"RTN","HLOSRVR",51,0)
 .N HLMSTATE,SENT
"RTN","HLOSRVR",52,0)
 .;
"RTN","HLOSRVR",53,0)
 .;read msg and parse the hdr
"RTN","HLOSRVR",54,0)
 .;HLMSTATE("MSA",1) is set with type of ack to return
"RTN","HLOSRVR",55,0)
 .I $$READMSG^HLOSRVR1(.HLCSTATE,.HLMSTATE) D
"RTN","HLOSRVR",56,0)
 ..;
"RTN","HLOSRVR",57,0)
 ..;send an ack if required and save the MSA segment
"RTN","HLOSRVR",58,0)
 ..I (HLMSTATE("MSA",1)]"") S SENT=$$WRITEACK(.HLCSTATE,.HLMSTATE) D:HLMSTATE("IEN") SAVEACK(.HLMSTATE,SENT)
"RTN","HLOSRVR",59,0)
 ..D:HLMSTATE("IEN") UPDATE(.HLMSTATE,.HLCSTATE)
"RTN","HLOSRVR",60,0)
 ..D:HLCSTATE("COUNTS")>4 SAVECNTS^HLOSTAT(.HLCSTATE)
"RTN","HLOSRVR",61,0)
 ..I $G(HLMSTATE("ACK TO","IEN")),$L($G(HLMSTATE("ACK TO","SEQUENCE QUEUE"))) D ADVANCE^HLOQUE(HLMSTATE("ACK TO","SEQUENCE QUEUE"),+HLMSTATE("ACK TO","IEN"))
"RTN","HLOSRVR",62,0)
 .E  D INQUE() H:HLCSTATE("CONNECTED") 1
"RTN","HLOSRVR",63,0)
 ;
"RTN","HLOSRVR",64,0)
END D CLOSE^HLOT(.HLCSTATE)
"RTN","HLOSRVR",65,0)
 D INQUE()
"RTN","HLOSRVR",66,0)
 D SAVECNTS^HLOSTAT(.HLCSTATE)
"RTN","HLOSRVR",67,0)
 Q
"RTN","HLOSRVR",68,0)
 ;
"RTN","HLOSRVR",69,0)
CONNECT(HLCSTATE,LINKNAME,LOGICAL) ;
"RTN","HLOSRVR",70,0)
 ;sets up HLCSTATE() and opens a server connection
"RTN","HLOSRVR",71,0)
 ;
"RTN","HLOSRVR",72,0)
 N LINK,NODE
"RTN","HLOSRVR",73,0)
 S HLCSTATE("CONNECTED")=0
"RTN","HLOSRVR",74,0)
 Q:'$$GETLINK^HLOTLNK(LINKNAME,.LINK) 0
"RTN","HLOSRVR",75,0)
 Q:+LINK("SERVER")'=1 0
"RTN","HLOSRVR",76,0)
 S HLCSTATE("SERVER")=LINK("SERVER")
"RTN","HLOSRVR",77,0)
 M HLCSTATE("LINK")=LINK
"RTN","HLOSRVR",78,0)
 S HLCSTATE("READ TIMEOUT")=20
"RTN","HLOSRVR",79,0)
 S HLCSTATE("OPEN TIMEOUT")=30
"RTN","HLOSRVR",80,0)
 S HLCSTATE("READ")="" ;buffer for reads
"RTN","HLOSRVR",81,0)
 ;
"RTN","HLOSRVR",82,0)
 ;HLCSTATE("BUFFER",<seg>,<line>)  write buffer
"RTN","HLOSRVR",83,0)
 S HLCSTATE("BUFFER","BYTE COUNT")=0 ;count of bytes in buffer
"RTN","HLOSRVR",84,0)
 S HLCSTATE("BUFFER","SEGMENT COUNT")=0 ;count of segments in buffer
"RTN","HLOSRVR",85,0)
 ;
"RTN","HLOSRVR",86,0)
 S HLCSTATE("COUNTS")=0
"RTN","HLOSRVR",87,0)
 S HLCSTATE("MESSAGE STARTED")=0 ;start of message flag
"RTN","HLOSRVR",88,0)
 S HLCSTATE("MESSAGE ENDED")=0 ;end of message flag
"RTN","HLOSRVR",89,0)
 S NODE=^%ZOSF("OS")
"RTN","HLOSRVR",90,0)
 S HLCSTATE("SYSTEM","OS")=$S(NODE["DSM":"DSM",NODE["OpenM":"CACHE",NODE["G.TM":"G.TM",1:"")
"RTN","HLOSRVR",91,0)
 Q:HLCSTATE("SYSTEM","OS")="" 0
"RTN","HLOSRVR",92,0)
 D  ;get necessary system parameters
"RTN","HLOSRVR",93,0)
 .N SYS,SUB
"RTN","HLOSRVR",94,0)
 .D SYSPARMS^HLOSITE(.SYS)
"RTN","HLOSRVR",95,0)
 .F SUB="MAXSTRING","DOMAIN","STATION","PROCESSING ID","NORMAL PURGE","ERROR PURGE" S HLCSTATE("SYSTEM",SUB)=SYS(SUB)
"RTN","HLOSRVR",96,0)
 .S HLCSTATE("SYSTEM","BUFFER")=SYS("HL7 BUFFER")
"RTN","HLOSRVR",97,0)
 I HLCSTATE("LINK","LLP")="TCP" D
"RTN","HLOSRVR",98,0)
 .D OPEN^HLOTCP(.HLCSTATE,.LOGICAL)
"RTN","HLOSRVR",99,0)
 E  ;no other LLP implemented
"RTN","HLOSRVR",100,0)
 ;
"RTN","HLOSRVR",101,0)
 Q HLCSTATE("CONNECTED")
"RTN","HLOSRVR",102,0)
 ;
"RTN","HLOSRVR",103,0)
INQUE(MSGIEN,PARMS) ;
"RTN","HLOSRVR",104,0)
 ;
"RTN","HLOSRVR",105,0)
 ;** do not immplement the Pass Immediate parameter **
"RTN","HLOSRVR",106,0)
 ;INQUE(MSGIEN,PARMS,IMMEDIATE);
"RTN","HLOSRVR",107,0)
 ;
"RTN","HLOSRVR",108,0)
 ;puts received messages on the incoming queue and sets the B x-refs
"RTN","HLOSRVR",109,0)
 I $G(MSGIEN) S INQUE=INQUE+1 M INQUE(MSGIEN)=PARMS
"RTN","HLOSRVR",110,0)
 ;
"RTN","HLOSRVR",111,0)
 ;** do not immplement the Pass Immediate parameter **
"RTN","HLOSRVR",112,0)
 ;I ('$G(MSGIEN))!(INQUE>20)!($G(IMMEDIATE)) S MSGIEN=0 D
"RTN","HLOSRVR",113,0)
 ;
"RTN","HLOSRVR",114,0)
 I ('$G(MSGIEN))!(INQUE>20) S MSGIEN=0 D
"RTN","HLOSRVR",115,0)
 .F  S MSGIEN=$O(INQUE(MSGIEN)) Q:'MSGIEN  D
"RTN","HLOSRVR",116,0)
 ..S ^HLB("B",INQUE(MSGIEN,"MSGID"),MSGIEN)=""
"RTN","HLOSRVR",117,0)
 ..S ^HLA("B",INQUE(MSGIEN,"DT/TM"),INQUE(MSGIEN,"BODY"))=""
"RTN","HLOSRVR",118,0)
 ..D:INQUE(MSGIEN,"PASS")
"RTN","HLOSRVR",119,0)
 ...N PURGE
"RTN","HLOSRVR",120,0)
 ...S PURGE=+$G(INQUE(MSGIEN,"PURGE"))
"RTN","HLOSRVR",121,0)
 ...S PURGE("ACKTOIEN")=$G(INQUE(MSGIEN,"ACKTOIEN"))
"RTN","HLOSRVR",122,0)
 ...D INQUE^HLOQUE(INQUE(MSGIEN,"FROM"),INQUE(MSGIEN,"QUEUE"),MSGIEN,INQUE(MSGIEN,"ACTION"),.PURGE)
"RTN","HLOSRVR",123,0)
 .K INQUE S INQUE=0
"RTN","HLOSRVR",124,0)
 Q
"RTN","HLOSRVR",125,0)
 ;
"RTN","HLOSRVR",126,0)
SAVEACK(HLMSTATE,SENT) ;
"RTN","HLOSRVR",127,0)
 ;Input:
"RTN","HLOSRVR",128,0)
 ;  SENT - flag = 1 if transmission of ack succeeded, 0 otherwise
"RTN","HLOSRVR",129,0)
 ;
"RTN","HLOSRVR",130,0)
 N NODE,I,XX
"RTN","HLOSRVR",131,0)
 S $P(NODE,"^")=HLMSTATE("MSA","DT/TM OF MESSAGE")
"RTN","HLOSRVR",132,0)
 S $P(NODE,"^",2)=HLMSTATE("MSA","MESSAGE CONTROL ID")
"RTN","HLOSRVR",133,0)
 S $P(NODE,"^",3)="MSA"
"RTN","HLOSRVR",134,0)
 F I=1:1:3 S NODE=NODE_"|"_$G(HLMSTATE("MSA",I))
"RTN","HLOSRVR",135,0)
 S ^HLB(HLMSTATE("IEN"),4)=NODE
"RTN","HLOSRVR",136,0)
 S:SENT $P(^HLB(HLMSTATE("IEN"),0),"^",$S($E(HLMSTATE("MSA",1))="A":18,1:17))=1
"RTN","HLOSRVR",137,0)
 Q
"RTN","HLOSRVR",138,0)
 ;
"RTN","HLOSRVR",139,0)
UPDATE(HLMSTATE,HLCSTATE) ;
"RTN","HLOSRVR",140,0)
 ;Updates status and purge date when appropriate
"RTN","HLOSRVR",141,0)
 ;Also, sets the "B" xrefs, files 777,778, and places message on the incoming queue
"RTN","HLOSRVR",142,0)
 ;
"RTN","HLOSRVR",143,0)
 N PARMS,PURGE,WAIT
"RTN","HLOSRVR",144,0)
 S PARMS("PASS")=0
"RTN","HLOSRVR",145,0)
 I HLMSTATE("STATUS","ACTION")]"",HLMSTATE("STATUS")'="ER" D
"RTN","HLOSRVR",146,0)
 .N IEN
"RTN","HLOSRVR",147,0)
 .S IEN=HLMSTATE("IEN")
"RTN","HLOSRVR",148,0)
 .S PARMS("PASS")=1,$P(^HLB(IEN,0),"^",6)=HLMSTATE("STATUS","QUEUE"),$P(^HLB(IEN,0),"^",10)=$P(HLMSTATE("STATUS","ACTION"),"^"),$P(^HLB(IEN,0),"^",11)=$P(HLMSTATE("STATUS","ACTION"),"^",2)
"RTN","HLOSRVR",149,0)
 D:'PARMS("PASS")  ;if not passing to the app, set the purge date
"RTN","HLOSRVR",150,0)
 .I HLMSTATE("STATUS")="" S HLMSTATE("STATUS")="SU"
"RTN","HLOSRVR",151,0)
 .S:HLMSTATE("BATCH") WAIT=HLCSTATE("SYSTEM","ERROR PURGE")
"RTN","HLOSRVR",152,0)
 .S:'HLMSTATE("BATCH") WAIT=$S(($G(HLMSTATE("ACK TO","STATUS"))="ER"):24*HLCSTATE("SYSTEM","ERROR PURGE"),HLMSTATE("STATUS")="ER":24*HLCSTATE("SYSTEM","ERROR PURGE"),1:HLCSTATE("SYSTEM","NORMAL PURGE"))
"RTN","HLOSRVR",153,0)
 .S PURGE=$$FMADD^XLFDT($$NOW^XLFDT,,WAIT)
"RTN","HLOSRVR",154,0)
 .S $P(^HLB(HLMSTATE("IEN"),0),"^",9)=PURGE
"RTN","HLOSRVR",155,0)
 .S ^HLB("AD","IN",PURGE,HLMSTATE("IEN"))=""
"RTN","HLOSRVR",156,0)
 .;if this is an app ack, purge the original message at the same time
"RTN","HLOSRVR",157,0)
 .I $G(HLMSTATE("ACK TO","IEN")),'HLMSTATE("BATCH") D
"RTN","HLOSRVR",158,0)
 ..S $P(^HLB(+HLMSTATE("ACK TO","IEN"),0),"^",9)=PURGE
"RTN","HLOSRVR",159,0)
 ..S ^HLB("AD","IN",PURGE,+HLMSTATE("ACK TO","IEN"))=""
"RTN","HLOSRVR",160,0)
 ;
"RTN","HLOSRVR",161,0)
 ;if not waiting for an application ack, set the status now even if passing to the app - but don't set the purge until the infiler passes the message
"RTN","HLOSRVR",162,0)
 I HLMSTATE("STATUS")="",($G(HLMSTATE("ACK TO","IEN"))!HLMSTATE("HDR","APP ACK TYPE")'="AL") S HLMSTATE("STATUS")="SU"
"RTN","HLOSRVR",163,0)
 I HLMSTATE("STATUS")'="" S $P(^HLB(HLMSTATE("IEN"),0),"^",20)=HLMSTATE("STATUS") S:$G(HLMSTATE("MSA",3))]"" $P(^HLB(HLMSTATE("IEN"),0),"^",21)=HLMSTATE("MSA",3) D:HLMSTATE("STATUS")'="SU"
"RTN","HLOSRVR",164,0)
 .N APP
"RTN","HLOSRVR",165,0)
 .S APP=HLMSTATE("HDR","RECEIVING APPLICATION") S:APP="" APP="UNKNOWN" S ^HLB("ERRORS",APP,HLMSTATE("DT/TM"),HLMSTATE("IEN"))=""
"RTN","HLOSRVR",166,0)
 .D COUNT^HLOESTAT("IN",$G(HLMSTATE("HDR","RECEIVING APPLICATION")),$G(HLMSTATE("HDR","SENDING APPLICATION")),$S(HLMSTATE("BATCH"):"BATCH",1:$G(HLMSTATE("HDR","MESSAGE TYPE"))),$G(HLMSTATE("HDR","EVENT")))
"RTN","HLOSRVR",167,0)
 ;
"RTN","HLOSRVR",168,0)
 ;set the necessary parms for passing the msg to the app via the infiler
"RTN","HLOSRVR",169,0)
 D:PARMS("PASS")
"RTN","HLOSRVR",170,0)
 .N I,FROM
"RTN","HLOSRVR",171,0)
 .S FROM=HLMSTATE("HDR","SENDING FACILITY",1)
"RTN","HLOSRVR",172,0)
 .I HLMSTATE("HDR","SENDING FACILITY",2)]"" S FROM=FROM_"~"_HLMSTATE("HDR","SENDING FACILITY",2)_"~"_HLMSTATE("HDR","SENDING FACILITY",3)
"RTN","HLOSRVR",173,0)
 .I FROM="" S FROM="UNKNOWN SENDING FACILITY"
"RTN","HLOSRVR",174,0)
 .S PARMS("FROM")=FROM,PARMS("QUEUE")=HLMSTATE("STATUS","QUEUE"),PARMS("ACTION")=HLMSTATE("STATUS","ACTION")
"RTN","HLOSRVR",175,0)
 .I HLMSTATE("STATUS")'="" S PARMS("PURGE")=$S(HLMSTATE("STATUS")="ER":2,$G(HLMSTATE("ACK TO","STATUS"))="ER":2,1:1)
"RTN","HLOSRVR",176,0)
 .S:$G(HLMSTATE("ACK TO","IEN")) PARMS("ACKTOIEN")=HLMSTATE("ACK TO","IEN") ;to insure that the infiler will know to set the purge date at the same time as the initial message
"RTN","HLOSRVR",177,0)
 ;
"RTN","HLOSRVR",178,0)
 S PARMS("BODY")=HLMSTATE("BODY")
"RTN","HLOSRVR",179,0)
 S PARMS("DT/TM")=HLMSTATE("DT/TM")
"RTN","HLOSRVR",180,0)
 S PARMS("MSGID")=HLMSTATE("ID")
"RTN","HLOSRVR",181,0)
 ;
"RTN","HLOSRVR",182,0)
 ;** do not implement the Pass Immediate parameter **
"RTN","HLOSRVR",183,0)
 ;D INQUE(HLMSTATE("IEN"),.PARMS,$G(HLMSTATE("STATUS","PASS IMMEDIATE")))
"RTN","HLOSRVR",184,0)
 ;
"RTN","HLOSRVR",185,0)
 D INQUE(HLMSTATE("IEN"),.PARMS)
"RTN","HLOSRVR",186,0)
 Q
"RTN","HLOSRVR",187,0)
 ;
"RTN","HLOSRVR",188,0)
WRITEACK(HLCSTATE,HLMSTATE) ;
"RTN","HLOSRVR",189,0)
 ;Sends an accept ack
"RTN","HLOSRVR",190,0)
 ;
"RTN","HLOSRVR",191,0)
 ;Input:
"RTN","HLOSRVR",192,0)
 ;  HLCSTATE (pass by reference) defines the communication channel
"RTN","HLOSRVR",193,0)
 ;  HLMSTATE (pass by reference) the message being acked
"RTN","HLOSRVR",194,0)
 ;     ("MSA",1) - value for MSA-1
"RTN","HLOSRVR",195,0)
 ;     ("MSA",2) - value for MSA-2
"RTN","HLOSRVR",196,0)
 ;     ("MSA",3) - value for MSA-3
"RTN","HLOSRVR",197,0)
 ;     ("HDR") - parsed values for the message being ack'd
"RTN","HLOSRVR",198,0)
 ;Output:
"RTN","HLOSRVR",199,0)
 ;  Function returns 1 if successful, 0 otherwise
"RTN","HLOSRVR",200,0)
 ;  HLMSTATE("MSA","MESSAGE CONTROL ID") - the msg id of the ack
"RTN","HLOSRVR",201,0)
 ;  HLMSTATE(,"MSA","DT/TM OF MESSAGE") - from the ack header
"RTN","HLOSRVR",202,0)
 ;
"RTN","HLOSRVR",203,0)
 N HDR,SUB,FS,CS,MSA,ACKID,TIME
"RTN","HLOSRVR",204,0)
 ;Hard-code the delimiters, the standard requires that the receiving system accept the delimiters listed in the header
"RTN","HLOSRVR",205,0)
 S FS="|"
"RTN","HLOSRVR",206,0)
 S CS="^"
"RTN","HLOSRVR",207,0)
 S TIME=$$NOW^XLFDT
"RTN","HLOSRVR",208,0)
 S HLMSTATE("MSA","DT/TM OF MESSAGE")=TIME
"RTN","HLOSRVR",209,0)
 S ACKID=HLCSTATE("SYSTEM","STATION")_" "_$$NEWIEN^HLOF778A("OUT")
"RTN","HLOSRVR",210,0)
 S HLMSTATE("MSA","MESSAGE CONTROL ID")=ACKID
"RTN","HLOSRVR",211,0)
 ;
"RTN","HLOSRVR",212,0)
 S HDR(1)="MSH"_FS_"^~\&"_FS_HLMSTATE("HDR","RECEIVING APPLICATION")_FS_HLCSTATE("SYSTEM","STATION")_CS_HLCSTATE("SYSTEM","DOMAIN")_CS_"DNS"_FS
"RTN","HLOSRVR",213,0)
 S HDR(1)=HDR(1)_HLMSTATE("HDR","SENDING APPLICATION")_FS_HLMSTATE("HDR","SENDING FACILITY",1)_CS_HLMSTATE("HDR","SENDING FACILITY",2)_CS_HLMSTATE("HDR","SENDING FACILITY",3)
"RTN","HLOSRVR",214,0)
 ;
"RTN","HLOSRVR",215,0)
 S HDR(2)=FS_$$HLDATE^HLFNC(TIME,"TS")_FS_FS_"ACK"_FS_ACKID_FS_HLMSTATE("HDR","PROCESSING ID")_FS_"2.4"_FS_FS_FS_"NE"_FS_"NE"
"RTN","HLOSRVR",216,0)
 ;
"RTN","HLOSRVR",217,0)
 S MSA(1)="MSA"_FS
"RTN","HLOSRVR",218,0)
 F SUB=1:1:3 S MSA(1)=MSA(1)_HLMSTATE("MSA",SUB)_FS
"RTN","HLOSRVR",219,0)
 I $$WRITEHDR^HLOT(.HLCSTATE,.HDR),$$WRITESEG^HLOT(.HLCSTATE,.MSA),$$ENDMSG^HLOT(.HLCSTATE) S HLCSTATE("COUNTS","ACKS")=$G(HLCSTATE("COUNTS","ACKS"))+1 Q 1
"RTN","HLOSRVR",220,0)
 S HLMSTATE("MSA","DT/TM OF MESSAGE")=""
"RTN","HLOSRVR",221,0)
 Q 0
"RTN","HLOSRVR1")
0^11^B79956205^B66988549
"RTN","HLOSRVR1",1,0)
HLOSRVR1 ;IRMFO-ALB/CJM/OAK/PIJ - Reading messages, sending acks;03/24/2004  14:43 ;11/10/2008
"RTN","HLOSRVR1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,130,131,133,134,137,138,139**;Oct 13, 1995;Build 11
"RTN","HLOSRVR1",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOSRVR1",4,0)
 ;
"RTN","HLOSRVR1",5,0)
READMSG(HLCSTATE,HLMSTATE) ;
"RTN","HLOSRVR1",6,0)
 ;Reads a message.  The header is parsed. Does these checks:
"RTN","HLOSRVR1",7,0)
 ; 1) Duplicate?
"RTN","HLOSRVR1",8,0)
 ; 2) Wrong Receiving Facility?
"RTN","HLOSRVR1",9,0)
 ; 3) Can the Receiving App accept this message, based message type & event?
"RTN","HLOSRVR1",10,0)
 ; 4) Processing ID must match the receiving system
"RTN","HLOSRVR1",11,0)
 ; 5) Must have an ID
"RTN","HLOSRVR1",12,0)
 ; 6) Header must be BHS or MSH
"RTN","HLOSRVR1",13,0)
 ;
"RTN","HLOSRVR1",14,0)
 ;Output:
"RTN","HLOSRVR1",15,0)
 ;  Function returns 1 if the message was read fully, 0 otherwise
"RTN","HLOSRVR1",16,0)
 ;  HLMSTATE (pass by reference) the message.  It will include the fields for the return ack in HLMSTATE("MSA")
"RTN","HLOSRVR1",17,0)
 ;
"RTN","HLOSRVR1",18,0)
 N ACK,SEG,STORE,I
"RTN","HLOSRVR1",19,0)
 ;
"RTN","HLOSRVR1",20,0)
 S STORE=1
"RTN","HLOSRVR1",21,0)
 Q:'$$READHDR^HLOT(.HLCSTATE,.SEG) 0
"RTN","HLOSRVR1",22,0)
 D SPLITHDR(.SEG)
"RTN","HLOSRVR1",23,0)
 ;
"RTN","HLOSRVR1",24,0)
 ;parse the header, stop if unsuccessful because the server cannot know what to do next
"RTN","HLOSRVR1",25,0)
 I '$$PARSEHDR^HLOPRS(.SEG) D  Q 0
"RTN","HLOSRVR1",26,0)
 .S HLCSTATE("MESSAGE ENDED")=0
"RTN","HLOSRVR1",27,0)
 .D CLOSE^HLOT(.HLCSTATE)
"RTN","HLOSRVR1",28,0)
 D NEWMSG^HLOSRVR2(.HLCSTATE,.HLMSTATE,.SEG)
"RTN","HLOSRVR1",29,0)
 I HLMSTATE("ID")="" D
"RTN","HLOSRVR1",30,0)
 .S STORE=0
"RTN","HLOSRVR1",31,0)
 .I HLMSTATE("HDR","ACCEPT ACK TYPE")="AL" S HLMSTATE("MSA",1)="CE",HLMSTATE("MSA",3)="CONTROL ID MISSING"
"RTN","HLOSRVR1",32,0)
 I STORE,$$DUP(.HLMSTATE) S STORE=0
"RTN","HLOSRVR1",33,0)
 ;
"RTN","HLOSRVR1",34,0)
 ;if the message is not to be stored, just read it and discard the segments
"RTN","HLOSRVR1",35,0)
 I 'STORE D
"RTN","HLOSRVR1",36,0)
 .F  Q:'$$READSEG^HLOT(.HLCSTATE,.SEG)
"RTN","HLOSRVR1",37,0)
 ;
"RTN","HLOSRVR1",38,0)
 E  D
"RTN","HLOSRVR1",39,0)
 .N FS,NEWMSGID
"RTN","HLOSRVR1",40,0)
 .S NEWMSGID=""
"RTN","HLOSRVR1",41,0)
 .S FS=HLMSTATE("HDR","FIELD SEPARATOR")
"RTN","HLOSRVR1",42,0)
 .F  Q:'$$READSEG^HLOT(.HLCSTATE,.SEG)  D
"RTN","HLOSRVR1",43,0)
 ..N MSA,SEGTYPE,OLDMSGID,CODE,IEN,TEXT
"RTN","HLOSRVR1",44,0)
 ..S SEGTYPE=$E($E(SEG(1),1,3)_$E($G(SEG(2)),1,2),1,3)
"RTN","HLOSRVR1",45,0)
 ..I SEGTYPE="MSA" D
"RTN","HLOSRVR1",46,0)
 ...S MSA=SEG(1)_$G(SEG(2))_$G(SEG(3))
"RTN","HLOSRVR1",47,0)
 ...;; ** Start HL*1.6*138 PIJ **
"RTN","HLOSRVR1",48,0)
 ...;;S OLDMSGID=$P(MSA,FS,3),CODE=$P(MSA,FS,2),TEXT=$E($P(MSA,FS,4),1,30)
"RTN","HLOSRVR1",49,0)
 ...S OLDMSGID=$P(MSA,FS,3),CODE=$P(MSA,FS,2)
"RTN","HLOSRVR1",50,0)
 ...S TEXT=$$ESCAPE^HLOPBLD(.HLMSTATE,$P(MSA,FS,4,$L(MSA,"|")))
"RTN","HLOSRVR1",51,0)
 ...;; ** End HL*1.6*138 **
"RTN","HLOSRVR1",52,0)
 ...I $E(CODE,1)'="A" S SEGTYPE="" Q
"RTN","HLOSRVR1",53,0)
 ...S:$P(OLDMSGID,"-")]"" IEN=$O(^HLB("B",$P(OLDMSGID,"-"),0))
"RTN","HLOSRVR1",54,0)
 ...S:$G(IEN) IEN=IEN_"^"_$P(OLDMSGID,"-",2)
"RTN","HLOSRVR1",55,0)
 ..I 'HLMSTATE("BATCH") D
"RTN","HLOSRVR1",56,0)
 ...D:SEGTYPE="MSA"
"RTN","HLOSRVR1",57,0)
 ....S HLMSTATE("ACK TO")=OLDMSGID
"RTN","HLOSRVR1",58,0)
 ....S HLMSTATE("ACK TO","ACK BY")=HLMSTATE("ID")
"RTN","HLOSRVR1",59,0)
 ....S HLMSTATE("ACK TO","STATUS")=$S(CODE="AA":"SU",1:"ER")
"RTN","HLOSRVR1",60,0)
 ....I $G(IEN) D
"RTN","HLOSRVR1",61,0)
 .....S HLMSTATE("ACK TO","IEN")=IEN
"RTN","HLOSRVR1",62,0)
 .....S HLMSTATE("ACK TO","SEQUENCE QUEUE")=$P($G(^HLB(+IEN,5)),"^")
"RTN","HLOSRVR1",63,0)
 ....S HLMSTATE("ACK TO","ERROR TEXT")=TEXT
"RTN","HLOSRVR1",64,0)
 ...D ADDSEG^HLOMSG(.HLMSTATE,.SEG)
"RTN","HLOSRVR1",65,0)
 ..E  D  ;batch
"RTN","HLOSRVR1",66,0)
 ...I SEGTYPE="MSH" D
"RTN","HLOSRVR1",67,0)
 ....D SPLITHDR(.SEG)
"RTN","HLOSRVR1",68,0)
 ....S NEWMSGID=$P(SEG(2),FS,5)
"RTN","HLOSRVR1",69,0)
 ....D ADDMSG2^HLOMSG(.HLMSTATE,.SEG)
"RTN","HLOSRVR1",70,0)
 ...E  D  ;not MSH
"RTN","HLOSRVR1",71,0)
 ....D:SEGTYPE="MSA"
"RTN","HLOSRVR1",72,0)
 .....N SUBIEN S SUBIEN=HLMSTATE("BATCH","CURRENT MESSAGE")
"RTN","HLOSRVR1",73,0)
 .....S HLMSTATE("BATCH","ACK TO",SUBIEN)=OLDMSGID
"RTN","HLOSRVR1",74,0)
 .....S HLMSTATE("BATCH","ACK TO",SUBIEN,"ACK BY")=NEWMSGID
"RTN","HLOSRVR1",75,0)
 .....S HLMSTATE("BATCH","ACK TO",SUBIEN,"STATUS")=$S(CODE="AA":"SU",1:"ER")
"RTN","HLOSRVR1",76,0)
 .....S:$D(IEN) HLMSTATE("BATCH","ACK TO",SUBIEN,"IEN")=IEN
"RTN","HLOSRVR1",77,0)
 ....D ADDSEG^HLOMSG(.HLMSTATE,.SEG)
"RTN","HLOSRVR1",78,0)
 .I HLMSTATE("UNSTORED LINES"),HLCSTATE("MESSAGE ENDED"),$$SAVEMSG^HLOF778(.HLMSTATE)
"RTN","HLOSRVR1",79,0)
 ;
"RTN","HLOSRVR1",80,0)
 I STORE,'HLCSTATE("MESSAGE ENDED") D
"RTN","HLOSRVR1",81,0)
 .;reading failed, don't store
"RTN","HLOSRVR1",82,0)
 .D:HLMSTATE("IEN") DEL778(HLMSTATE("IEN")) D:HLMSTATE("BODY") DEL777(HLMSTATE("BODY"))
"RTN","HLOSRVR1",83,0)
 .S HLMSTATE("IEN")="",HLMSTATE("BODY")=""
"RTN","HLOSRVR1",84,0)
 E  D:STORE
"RTN","HLOSRVR1",85,0)
 .D CHECKMSG(.HLMSTATE)
"RTN","HLOSRVR1",86,0)
 .D ADDAC(.HLMSTATE) ;so future duplicates are detected
"RTN","HLOSRVR1",87,0)
 .D COUNT^HLOSTAT(.HLCSTATE,HLMSTATE("HDR","RECEIVING APPLICATION"),HLMSTATE("HDR","SENDING APPLICATION"),$S(HLMSTATE("BATCH"):"BATCH",1:HLMSTATE("HDR","MESSAGE TYPE")_"~"_HLMSTATE("HDR","EVENT")))
"RTN","HLOSRVR1",88,0)
 ;
"RTN","HLOSRVR1",89,0)
 D:'HLCSTATE("MESSAGE ENDED") CLOSE^HLOT(.HLCSTATE)
"RTN","HLOSRVR1",90,0)
 Q HLCSTATE("MESSAGE ENDED")
"RTN","HLOSRVR1",91,0)
 ;
"RTN","HLOSRVR1",92,0)
ADDAC(HLMSTATE) ;adds the AC xref for duplicates detection
"RTN","HLOSRVR1",93,0)
 ;
"RTN","HLOSRVR1",94,0)
 N FROM
"RTN","HLOSRVR1",95,0)
 S FROM=$S(HLMSTATE("HDR","SENDING FACILITY",2)]"":HLMSTATE("HDR","SENDING FACILITY",2),1:HLMSTATE("HDR","SENDING FACILITY",1))
"RTN","HLOSRVR1",96,0)
 S ^HLB("AC",FROM_HLMSTATE("HDR","SENDING APPLICATION")_HLMSTATE("ID"),HLMSTATE("IEN"))=""
"RTN","HLOSRVR1",97,0)
 Q
"RTN","HLOSRVR1",98,0)
 ;
"RTN","HLOSRVR1",99,0)
DUP(HLMSTATE) ;
"RTN","HLOSRVR1",100,0)
 ;Returns 1 if the message is a duplicate and its ack (if requested) is found, 0 otherwise
"RTN","HLOSRVR1",101,0)
 ;Input:
"RTN","HLOSRVR1",102,0)
 ; HLMSTATE (pass by reference) the message being read
"RTN","HLOSRVR1",103,0)
 ;Output:
"RTN","HLOSRVR1",104,0)
 ;  Function returns 1 if the message is a duplicate, 0 otherwise
"RTN","HLOSRVR1",105,0)
 ;  HLMSTATE (pass by reference) IF the message is a duplicate:
"RTN","HLOSRVR1",106,0)
 ;     returns the prior MSA segment in HLMSTATE("MSA")
"RTN","HLOSRVR1",107,0)
 ;
"RTN","HLOSRVR1",108,0)
 N IEN,FROM,DUP
"RTN","HLOSRVR1",109,0)
 S (IEN,DUP)=0
"RTN","HLOSRVR1",110,0)
 ;
"RTN","HLOSRVR1",111,0)
 ;no way to determine!  Bad header will be rejected
"RTN","HLOSRVR1",112,0)
 Q:(HLMSTATE("ID")="") 0
"RTN","HLOSRVR1",113,0)
 ;
"RTN","HLOSRVR1",114,0)
 S FROM=$S(HLMSTATE("HDR","SENDING FACILITY",2)]"":HLMSTATE("HDR","SENDING FACILITY",2),1:HLMSTATE("HDR","SENDING FACILITY",1))
"RTN","HLOSRVR1",115,0)
 F  S IEN=$O(^HLB("AC",FROM_HLMSTATE("HDR","SENDING APPLICATION")_HLMSTATE("ID"),IEN)) Q:'IEN  D  Q:DUP
"RTN","HLOSRVR1",116,0)
 .I HLMSTATE("HDR","ACCEPT ACK TYPE")="NE" S DUP=1 Q
"RTN","HLOSRVR1",117,0)
 .;need the MSA to return
"RTN","HLOSRVR1",118,0)
 .D  Q
"RTN","HLOSRVR1",119,0)
 ..N NODE
"RTN","HLOSRVR1",120,0)
 ..S NODE=$P($G(^HLB(IEN,4)),"^",3,10)
"RTN","HLOSRVR1",121,0)
 ..S HLMSTATE("MSA",1)=$P(NODE,"|",2)
"RTN","HLOSRVR1",122,0)
 ..Q:$L(HLMSTATE("MSA",1))'=2
"RTN","HLOSRVR1",123,0)
 ..S HLMSTATE("MSA",2)=$P(NODE,"|",3)
"RTN","HLOSRVR1",124,0)
 ..S HLMSTATE("MSA",3)=$P(NODE,"|",4,10)
"RTN","HLOSRVR1",125,0)
 ..S DUP=1
"RTN","HLOSRVR1",126,0)
 ;
"RTN","HLOSRVR1",127,0)
 Q DUP
"RTN","HLOSRVR1",128,0)
 ;
"RTN","HLOSRVR1",129,0)
CHECKMSG(HLMSTATE) ;
"RTN","HLOSRVR1",130,0)
 ;Checks the header & MSA segment, sets HLMSTATE("STATUS","ACTION") if the message needs to be passed, determines if completion status should be set
"RTN","HLOSRVR1",131,0)
 ;Input:
"RTN","HLOSRVR1",132,0)
 ;  HLMSTATE("HDR") - the parsed header segment
"RTN","HLOSRVR1",133,0)
 ;Output:
"RTN","HLOSRVR1",134,0)
 ;  HLMSTATE("STATUS")="ER" if an error is detected
"RTN","HLOSRVR1",135,0)
 ;  HLMSTATE("STATUS","QUEUE") queue to put the message on
"RTN","HLOSRVR1",136,0)
 ;  HLMSTATE("STATUS","ACTION")  <tag^rtn> that is the processing routine for the receiving application
"RTN","HLOSRVR1",137,0)
 ;  HLMSTATE("MSA") - MSA(1)=accept code to be returned, MSA(3)= error txt
"RTN","HLOSRVR1",138,0)
 ;
"RTN","HLOSRVR1",139,0)
 N WANTACK,PASS,ACTION,QUEUE,ERROR
"RTN","HLOSRVR1",140,0)
 M HDR=HLMSTATE("HDR")
"RTN","HLOSRVR1",141,0)
 S ERROR=0
"RTN","HLOSRVR1",142,0)
 I HDR("ACCEPT ACK TYPE")="NE",'HLMSTATE("ORIGINAL MODE") D
"RTN","HLOSRVR1",143,0)
 .S WANTACK=0
"RTN","HLOSRVR1",144,0)
 E  D
"RTN","HLOSRVR1",145,0)
 .S WANTACK=1
"RTN","HLOSRVR1",146,0)
 I HLMSTATE("ORIGINAL MODE") S HLMSTATE("MSA",1)="AE",HLMSTATE("MSA",3)="THIS INTERFACE DOES NOT IMPLEMENT ORIGINAL MODE APPLICATION ACKOWLEDGMENTS",HLMSTATE("STATUS")="ER" Q
"RTN","HLOSRVR1",147,0)
 I $G(HLMSTATE("ACK TO"))="" D  Q:ERROR
"RTN","HLOSRVR1",148,0)
 .;
"RTN","HLOSRVR1",149,0)
 .;** do not immplement the Pass Immediate parameter **
"RTN","HLOSRVR1",150,0)
 .;N IMMEDIATE
"RTN","HLOSRVR1",151,0)
 .;I '$$ACTION^HLOAPP(.HDR,.ACTION,.QUEUE,.IMMEDIATE) S ERROR=1 S:WANTACK HLMSTATE("MSA",1)="CR" S HLMSTATE("MSA",3)="RECEIVING APPLICATION NOT DEFINED",HLMSTATE("STATUS")="ER" Q
"RTN","HLOSRVR1",152,0)
 .;S HLMSTATE("STATUS","ACTION")=$G(ACTION),HLMSTATE("STATUS","QUEUE")=$G(QUEUE),HLMSTATE("STATUS","PASS IMMEDIATE")=$G(IMMEDIATE)
"RTN","HLOSRVR1",153,0)
 .;
"RTN","HLOSRVR1",154,0)
 .I '$$ACTION^HLOAPP(.HDR,.ACTION,.QUEUE) S ERROR=1 S:WANTACK HLMSTATE("MSA",1)="CR" S HLMSTATE("MSA",3)="RECEIVING APPLICATION NOT DEFINED",HLMSTATE("STATUS")="ER" Q
"RTN","HLOSRVR1",155,0)
 .S HLMSTATE("STATUS","ACTION")=$G(ACTION),HLMSTATE("STATUS","QUEUE")=$G(QUEUE)
"RTN","HLOSRVR1",156,0)
 E  D  Q:ERROR  ;this is an app ack
"RTN","HLOSRVR1",157,0)
 .;does the original message exist?
"RTN","HLOSRVR1",158,0)
 .;
"RTN","HLOSRVR1",159,0)
 .;** do not immplement the Pass Immediate parameter **
"RTN","HLOSRVR1",160,0)
 .;N NODE,IMMEDIATE
"RTN","HLOSRVR1",161,0)
 .;
"RTN","HLOSRVR1",162,0)
 .N NODE
"RTN","HLOSRVR1",163,0)
 .S:+$G(HLMSTATE("ACK TO","IEN")) NODE=$G(^HLB(+HLMSTATE("ACK TO","IEN"),0))
"RTN","HLOSRVR1",164,0)
 .I $G(NODE)="" S ERROR=1,HLMSTATE("STATUS")="ER",HLMSTATE("ACK TO","IEN")="" S:WANTACK HLMSTATE("MSA",1)="CE" S HLMSTATE("MSA",3)="INITIAL MESSAGE TO APPLICATION ACKNOWLEDGMENT NOT FOUND" Q
"RTN","HLOSRVR1",165,0)
 .I $P(NODE,"^",7)'="",$P(NODE,"^",7)'=HLMSTATE("ID") S ERROR=1,HLMSTATE("STATUS")="ER",HLMSTATE("ACK TO","IEN")="" S:WANTACK HLMSTATE("MSA",1)="CE" S HLMSTATE("MSA",3)="INITIAL MESSAGE WAS ALREADY ACKED" Q
"RTN","HLOSRVR1",166,0)
 .I ($P(NODE,"^",11)]"") S HLMSTATE("STATUS","ACTION")=$P(NODE,"^",10,11),HLMSTATE("STATUS","QUEUE")=$S($P(NODE,"^",6)]"":$P(NODE,"^",6),1:"DEFAULT")  Q
"RTN","HLOSRVR1",167,0)
 .;processing routine for the app ack wasn't found with the original message, look in the HLO Application Registry
"RTN","HLOSRVR1",168,0)
 .I HLMSTATE("HDR","MESSAGE TYPE")="ACK",HLMSTATE("HDR","EVENT")="" S HDR("EVENT")=$$GETEVENT^HLOCLNT2(+HLMSTATE("ACK TO","IEN"))
"RTN","HLOSRVR1",169,0)
 .;
"RTN","HLOSRVR1",170,0)
 .;** do not immplement the Pass Immediate parameter **
"RTN","HLOSRVR1",171,0)
 .;I $$ACTION^HLOAPP(.HDR,.ACTION,.QUEUE,.IMMEDIATE) S HLMSTATE("STATUS","ACTION")=$G(ACTION),HLMSTATE("STATUS","QUEUE")=$G(QUEUE),HLMSTATE("STATUS","PASS IMMEDIATE")=$G(IMMEDIATE)
"RTN","HLOSRVR1",172,0)
 .;
"RTN","HLOSRVR1",173,0)
 .I $$ACTION^HLOAPP(.HDR,.ACTION,.QUEUE) S HLMSTATE("STATUS","ACTION")=$G(ACTION),HLMSTATE("STATUS","QUEUE")=$G(QUEUE)
"RTN","HLOSRVR1",174,0)
 ;
"RTN","HLOSRVR1",175,0)
 I HDR("PROCESSING ID")'=HLCSTATE("SYSTEM","PROCESSING ID") S:WANTACK HLMSTATE("MSA",1)="CR" S HLMSTATE("STATUS")="ER",HLMSTATE("MSA",3)="SYSTEM PROCESSING ID="_HLCSTATE("SYSTEM","PROCESSING ID") Q
"RTN","HLOSRVR1",176,0)
 ;
"RTN","HLOSRVR1",177,0)
 ;wrong receiving facility?  This is hard to check if the sender is not VistA, because the HL7 standard permits different coding systems to be used. This check is only for DNS or station number.
"RTN","HLOSRVR1",178,0)
 S PASS=0
"RTN","HLOSRVR1",179,0)
 D
"RTN","HLOSRVR1",180,0)
 .;if its an ack to an existing message, don't check the receiving facility
"RTN","HLOSRVR1",181,0)
 .I $G(HLMSTATE("ACK TO"))]"" S PASS=1 Q
"RTN","HLOSRVR1",182,0)
 .I HDR("RECEIVING FACILITY",1)=HLCSTATE("SYSTEM","STATION") S PASS=1 Q
"RTN","HLOSRVR1",183,0)
 .I HDR("RECEIVING FACILITY",3)'="DNS" S PASS=1 Q
"RTN","HLOSRVR1",184,0)
 .I HDR("RECEIVING FACILITY",2)="" S PASS=1 Q
"RTN","HLOSRVR1",185,0)
 .I $P(HDR("RECEIVING FACILITY",2),":")[HLCSTATE("SYSTEM","DOMAIN") S PASS=1 Q
"RTN","HLOSRVR1",186,0)
 .I HLCSTATE("SYSTEM","DOMAIN")[$P(HDR("RECEIVING FACILITY",2),":") S PASS=1 Q
"RTN","HLOSRVR1",187,0)
 I 'PASS S HLMSTATE("STATUS")="ER",HLMSTATE("MSA",3)="RECEIVING FACILITY IS "_HLCSTATE("SYSTEM","DOMAIN") S:WANTACK HLMSTATE("MSA",1)="CE"
"RTN","HLOSRVR1",188,0)
 I PASS,WANTACK S HLMSTATE("MSA",1)="CA"
"RTN","HLOSRVR1",189,0)
 Q
"RTN","HLOSRVR1",190,0)
 ;
"RTN","HLOSRVR1",191,0)
DEL777(IEN777) ;delete a record from file 777 where the read did not complete
"RTN","HLOSRVR1",192,0)
 ;
"RTN","HLOSRVR1",193,0)
 K ^HLA(IEN777,0)
"RTN","HLOSRVR1",194,0)
 Q
"RTN","HLOSRVR1",195,0)
DEL778(IEN778) ;delete a record from file 778 where the read did not complete
"RTN","HLOSRVR1",196,0)
 ;
"RTN","HLOSRVR1",197,0)
 K ^HLB(IEN778,0)
"RTN","HLOSRVR1",198,0)
 Q
"RTN","HLOSRVR1",199,0)
 ;
"RTN","HLOSRVR1",200,0)
SPLITHDR(HDR) ;
"RTN","HLOSRVR1",201,0)
 ;splits hdr segment into two lines, first being just components 1-6
"RTN","HLOSRVR1",202,0)
 ;
"RTN","HLOSRVR1",203,0)
 N TEMP,FS
"RTN","HLOSRVR1",204,0)
 D SQUISH(.HDR)
"RTN","HLOSRVR1",205,0)
 S FS=$E($G(HDR(1)),4)
"RTN","HLOSRVR1",206,0)
 S TEMP(1)=$P($G(HDR(1)),FS,1,6)
"RTN","HLOSRVR1",207,0)
 S TEMP(2)=""
"RTN","HLOSRVR1",208,0)
 I $L(TEMP(1))<$L($G(HDR(1))) S TEMP(2)=FS_$P($G(HDR(1)),FS,7,20)
"RTN","HLOSRVR1",209,0)
 S HDR(2)=TEMP(2)_$G(HDR(2))
"RTN","HLOSRVR1",210,0)
 S HDR(1)=TEMP(1)
"RTN","HLOSRVR1",211,0)
 Q
"RTN","HLOSRVR1",212,0)
 ;
"RTN","HLOSRVR1",213,0)
SQUISH(SEG) ;
"RTN","HLOSRVR1",214,0)
 ;reformat the segment array into full lines
"RTN","HLOSRVR1",215,0)
 ;
"RTN","HLOSRVR1",216,0)
 ;nothing to do if less than 2 lines
"RTN","HLOSRVR1",217,0)
 Q:'$O(SEG(1))
"RTN","HLOSRVR1",218,0)
 ;
"RTN","HLOSRVR1",219,0)
 N A,I,J,K,MAX,COUNT,LEN
"RTN","HLOSRVR1",220,0)
 S MAX=$S($G(HLCSTATE("SYSTEM","MAXSTRING"))>256:HLCSTATE("SYSTEM","MAXSTRING"),1:256)
"RTN","HLOSRVR1",221,0)
 S (COUNT,I)=0,J=1
"RTN","HLOSRVR1",222,0)
 F  S I=$O(SEG(I)) Q:'I  D
"RTN","HLOSRVR1",223,0)
 .S LEN=$L(SEG(I))
"RTN","HLOSRVR1",224,0)
 .F K=1:1:LEN D
"RTN","HLOSRVR1",225,0)
 ..S A(J)=$G(A(J))_$E(SEG(I),K)
"RTN","HLOSRVR1",226,0)
 ..S COUNT=COUNT+1
"RTN","HLOSRVR1",227,0)
 ..I (COUNT>(MAX-1)) S COUNT=0,J=J+1
"RTN","HLOSRVR1",228,0)
 K SEG
"RTN","HLOSRVR1",229,0)
 M SEG=A
"RTN","HLOSRVR1",230,0)
 Q
"RTN","HLOT")
0^6^B3373728^B2729395
"RTN","HLOT",1,0)
HLOT ;IRMFO-ALB/CJM - Services provided by the transport layer;03/24/2004  14:43 ;10/03/2008
"RTN","HLOT",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,131,139**;Oct 13, 1995;Build 11
"RTN","HLOT",3,0)
 ;
"RTN","HLOT",4,0)
 ;**NOTE:  tags of the format ZB* are used by the client-trace debugging tool and should not be removed
"RTN","HLOT",5,0)
 ;
"RTN","HLOT",6,0)
READHDR(HLCSTATE,HDR) ;
"RTN","HLOT",7,0)
ZB10 N SUCCESS,SEG
"RTN","HLOT",8,0)
 N MCODE
"RTN","HLOT",9,0)
 S HLCSTATE("MESSAGE ENDED")=0
"RTN","HLOT",10,0)
 ;**START P139 CJM
"RTN","HLOT",11,0)
 S HLCSTATE("MESSAGE STARTED")=0
"RTN","HLOT",12,0)
 ;**END P139
"RTN","HLOT",13,0)
 S MCODE="S SUCCESS=$$"_HLCSTATE("READ HEADER")_"(.HLCSTATE,.HDR)"
"RTN","HLOT",14,0)
 X MCODE
"RTN","HLOT",15,0)
 ;**START P139 CJM
"RTN","HLOT",16,0)
 I SUCCESS S HLCSTATE("MESSAGE STARTED")=1
"RTN","HLOT",17,0)
 ;**END P139
"RTN","HLOT",18,0)
ZB11 Q SUCCESS
"RTN","HLOT",19,0)
 ;
"RTN","HLOT",20,0)
READSEG(HLCSTATE,SEG) ;
"RTN","HLOT",21,0)
ZB12 N RETURN
"RTN","HLOT",22,0)
 N MCODE
"RTN","HLOT",23,0)
 S MCODE="S RETURN=$$"_HLCSTATE("READ SEGMENT")_"(.HLCSTATE,.SEG)"
"RTN","HLOT",24,0)
 X MCODE
"RTN","HLOT",25,0)
ZB13 Q RETURN
"RTN","HLOT",26,0)
 ;
"RTN","HLOT",27,0)
OPEN(HLCSTATE) ;
"RTN","HLOT",28,0)
 N MCODE
"RTN","HLOT",29,0)
 I '$L(HLCSTATE("OPEN")) S HLCSTATE("CONNECTED")=0 Q
"RTN","HLOT",30,0)
 S MCODE="D "_HLCSTATE("OPEN")_"(.HLCSTATE)"
"RTN","HLOT",31,0)
 X MCODE
"RTN","HLOT",32,0)
 Q
"RTN","HLOT",33,0)
 ;
"RTN","HLOT",34,0)
CLOSE(HLCSTATE) ;
"RTN","HLOT",35,0)
 N MCODE
"RTN","HLOT",36,0)
 S MCODE="D "_HLCSTATE("CLOSE")_"(.HLCSTATE)"
"RTN","HLOT",37,0)
 X MCODE
"RTN","HLOT",38,0)
 S HLCSTATE("CONNECTED")=0
"RTN","HLOT",39,0)
 Q
"RTN","HLOT",40,0)
 ;
"RTN","HLOT",41,0)
WRITESEG(HLCSTATE,SEG) ;
"RTN","HLOT",42,0)
ZB14 N RETURN
"RTN","HLOT",43,0)
 N MCODE
"RTN","HLOT",44,0)
 S MCODE="S RETURN=$$"_HLCSTATE("WRITE SEGMENT")_"(.HLCSTATE,.SEG)"
"RTN","HLOT",45,0)
 X MCODE
"RTN","HLOT",46,0)
ZB15 Q RETURN
"RTN","HLOT",47,0)
 ;
"RTN","HLOT",48,0)
WRITEHDR(HLCSTATE,HDR) ;
"RTN","HLOT",49,0)
ZB16 N SUCCESS
"RTN","HLOT",50,0)
 N MCODE
"RTN","HLOT",51,0)
 S MCODE="S SUCCESS=$$"_HLCSTATE("WRITE HEADER")_"(.HLCSTATE,.HDR)"
"RTN","HLOT",52,0)
 X MCODE
"RTN","HLOT",53,0)
ZB17 Q SUCCESS
"RTN","HLOT",54,0)
 ;
"RTN","HLOT",55,0)
ENDMSG(HLCSTATE) ;
"RTN","HLOT",56,0)
ZB18 N RETURN
"RTN","HLOT",57,0)
 N MCODE
"RTN","HLOT",58,0)
 S MCODE="S RETURN=$$"_HLCSTATE("END MESSAGE")_"(.HLCSTATE)"
"RTN","HLOT",59,0)
 X MCODE
"RTN","HLOT",60,0)
ZB19 Q RETURN
"RTN","HLOTCP")
0^12^B61182306^B54574560
"RTN","HLOTCP",1,0)
HLOTCP ;ALB/CJM- TCP/IP I/O - 10/4/94 1pm ;10/03/2008
"RTN","HLOTCP",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,131,134,137,138,139**;Oct 13, 1995;Build 11
"RTN","HLOTCP",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOTCP",4,0)
 ;
"RTN","HLOTCP",5,0)
OPEN(HLCSTATE,LOGICAL) ;
"RTN","HLOTCP",6,0)
 ;This may be called either in the context of a client or a server.
"RTN","HLOTCP",7,0)
 ;For the server, there are 3 situations:
"RTN","HLOTCP",8,0)
 ; 1) The server is not concurrent.  In this case the TCP device should be opened.
"RTN","HLOTCP",9,0)
 ; 2) The server is concurrent, but this process was spawned by the OS
"RTN","HLOTCP",10,0)
 ;    (via a VMS TCP Service)  In this case, the device should be opened
"RTN","HLOTCP",11,0)
 ;    via the LOGICAL that was passed in.
"RTN","HLOTCP",12,0)
 ;  3) The server is concurrent, but this process was spawned by the
"RTN","HLOTCP",13,0)
 ;     TaskMan multi-listener.  In this case TaskMan already opened the
"RTN","HLOTCP",14,0)
 ;     device.  This case can be determined by the absence of the LOGICAL
"RTN","HLOTCP",15,0)
 ;     input parameter.
"RTN","HLOTCP",16,0)
 ;
"RTN","HLOTCP",17,0)
 N IP,PORT,DNSFLAG
"RTN","HLOTCP",18,0)
 ;
"RTN","HLOTCP",19,0)
 S DNSFLAG=0 ;DNS has not been contacted for IP
"RTN","HLOTCP",20,0)
 ;
"RTN","HLOTCP",21,0)
 S:'$G(HLCSTATE("SERVER")) IP=HLCSTATE("LINK","IP")
"RTN","HLOTCP",22,0)
 S PORT=HLCSTATE("LINK","PORT")
"RTN","HLOTCP",23,0)
 S HLCSTATE("CONNECTED")=0
"RTN","HLOTCP",24,0)
 S HLCSTATE("READ HEADER")="READHDR^HLOTCP"
"RTN","HLOTCP",25,0)
 S HLCSTATE("WRITE HEADER")="WRITEHDR^HLOTCP"
"RTN","HLOTCP",26,0)
 S HLCSTATE("READ SEGMENT")="READSEG^HLOTCP"
"RTN","HLOTCP",27,0)
 S HLCSTATE("WRITE SEGMENT")="WRITESEG^HLOTCP"
"RTN","HLOTCP",28,0)
 S HLCSTATE("END MESSAGE")="ENDMSG^HLOTCP"
"RTN","HLOTCP",29,0)
 S HLCSTATE("CLOSE")="CLOSE^HLOTCP"
"RTN","HLOTCP",30,0)
 S HLCSTATE("TCP BUFFER")=""
"RTN","HLOTCP",31,0)
 S HLCSTATE("TCP BUFFER $X")=0
"RTN","HLOTCP",32,0)
 ;
"RTN","HLOTCP",33,0)
 ;spawned by TaskMan multi-listener? If so, the device has already been opened
"RTN","HLOTCP",34,0)
 I $G(HLCSTATE("SERVER")),$G(HLCSTATE("LINK","SERVER"))="1^M",$G(LOGICAL)="" D  Q
"RTN","HLOTCP",35,0)
 .S HLCSTATE("DEVICE")=IO(0),HLCSTATE("FLUSH")="!",HLCSTATE("TCP BUFFER SIZE")=512
"RTN","HLOTCP",36,0)
 .S HLCSTATE("CONNECTED")=1
"RTN","HLOTCP",37,0)
 ;
"RTN","HLOTCP",38,0)
 ;if no IP, not a server, give DNS a shot
"RTN","HLOTCP",39,0)
 I '$G(HLCSTATE("SERVER")),IP="" S DNSFLAG=1,IP=$$DNS(HLCSTATE("LINK","DOMAIN")),HLCSTATE("LINK","IP")=IP Q:IP=""
"RTN","HLOTCP",40,0)
 ;
"RTN","HLOTCP",41,0)
RETRY ;
"RTN","HLOTCP",42,0)
 ;
"RTN","HLOTCP",43,0)
 I HLCSTATE("SYSTEM","OS")="DSM" D
"RTN","HLOTCP",44,0)
 .S HLCSTATE("TCP BUFFER SIZE")=512
"RTN","HLOTCP",45,0)
 .I $G(LOGICAL)]"" S HLCSTATE("DEVICE")=LOGICAL
"RTN","HLOTCP",46,0)
 .E  S HLCSTATE("DEVICE")=PORT
"RTN","HLOTCP",47,0)
 .S HLCSTATE("FLUSH")="!"
"RTN","HLOTCP",48,0)
 .I $G(HLCSTATE("SERVER")) D
"RTN","HLOTCP",49,0)
 ..O:$G(LOGICAL)]"" HLCSTATE("DEVICE"):(TCPDEV,BLOCKSIZE=512):HLCSTATE("OPEN TIMEOUT")
"RTN","HLOTCP",50,0)
 ..O:$G(LOGICAL)="" HLCSTATE("DEVICE"):(TCPCHAN,BLOCKSIZE=512):HLCSTATE("OPEN TIMEOUT")
"RTN","HLOTCP",51,0)
 ..I $T D
"RTN","HLOTCP",52,0)
 ...S HLCSTATE("CONNECTED")=1
"RTN","HLOTCP",53,0)
 ...U HLCSTATE("DEVICE"):NOECHO
"RTN","HLOTCP",54,0)
 .E  D  ;client
"RTN","HLOTCP",55,0)
 ..O HLCSTATE("DEVICE"):(TCPCHAN,ADDRESS=IP,BLOCKSIZE=512):HLCSTATE("OPEN TIMEOUT")
"RTN","HLOTCP",56,0)
 ..I $T D
"RTN","HLOTCP",57,0)
 ...S HLCSTATE("CONNECTED")=1
"RTN","HLOTCP",58,0)
 ...U HLCSTATE("DEVICE"):NOECHO
"RTN","HLOTCP",59,0)
 E  I HLCSTATE("SYSTEM","OS")="CACHE" D
"RTN","HLOTCP",60,0)
 .S HLCSTATE("FLUSH")="!"
"RTN","HLOTCP",61,0)
 .I $G(LOGICAL)]"" S HLCSTATE("DEVICE")=LOGICAL
"RTN","HLOTCP",62,0)
 .E  S HLCSTATE("DEVICE")="|TCP|"_PORT
"RTN","HLOTCP",63,0)
 .S HLCSTATE("TCP BUFFER SIZE")=512
"RTN","HLOTCP",64,0)
 .I $G(HLCSTATE("SERVER")) D
"RTN","HLOTCP",65,0)
 ..I HLCSTATE("SERVER")="1^S" D  Q
"RTN","HLOTCP",66,0)
 ...;single server (no concurrent connections)
"RTN","HLOTCP",67,0)
 ...O HLCSTATE("DEVICE"):(:PORT:"+A-S":::):HLCSTATE("OPEN TIMEOUT")
"RTN","HLOTCP",68,0)
 ...I $T D
"RTN","HLOTCP",69,0)
 ....N A
"RTN","HLOTCP",70,0)
 ....S HLCSTATE("CONNECTED")=1
"RTN","HLOTCP",71,0)
 ....U HLCSTATE("DEVICE")
"RTN","HLOTCP",72,0)
 ....F  R *A:HLCSTATE("READ TIMEOUT") Q:$T  I $$CHKSTOP^HLOPROC S HLCSTATE("CONNECTED")=0 D CLOSE(.HLCSTATE) Q
"RTN","HLOTCP",73,0)
 ..;
"RTN","HLOTCP",74,0)
 ..;multi-server spawned by OS - VMS TCP Services
"RTN","HLOTCP",75,0)
 ..O HLCSTATE("DEVICE")::HLCSTATE("OPEN TIMEOUT") I '$T S HLCSTATE("CONNECTED")=0 Q
"RTN","HLOTCP",76,0)
 ..S HLCSTATE("CONNECTED")=1
"RTN","HLOTCP",77,0)
 ..U HLCSTATE("DEVICE"):(::"-S")
"RTN","HLOTCP",78,0)
 ..;
"RTN","HLOTCP",79,0)
 .E  D  ;client
"RTN","HLOTCP",80,0)
 ..S HLCSTATE("TCP BUFFER SIZE")=512
"RTN","HLOTCP",81,0)
 ..O HLCSTATE("DEVICE"):(IP:PORT:"-S":::):HLCSTATE("OPEN TIMEOUT")
"RTN","HLOTCP",82,0)
 ..I $T D
"RTN","HLOTCP",83,0)
 ...S HLCSTATE("CONNECTED")=1
"RTN","HLOTCP",84,0)
 E  D  ;any other system but Cache or DSM
"RTN","HLOTCP",85,0)
 .S HLCSTATE("TCP BUFFER SIZE")=256
"RTN","HLOTCP",86,0)
 .D CALL^%ZISTCP(IP,PORT,HLCSTATE("OPEN TIMEOUT"))
"RTN","HLOTCP",87,0)
 .S HLCSTATE("CONNECTED")='POP
"RTN","HLOTCP",88,0)
 .I HLCSTATE("CONNECTED") S HLCSTATE("DEVICE")=IO
"RTN","HLOTCP",89,0)
 ;
"RTN","HLOTCP",90,0)
 ;if not connected, not the server, give DNS a shot if not tried already
"RTN","HLOTCP",91,0)
 I '$G(HLCSTATE("SERVER")),'HLCSTATE("CONNECTED"),'DNSFLAG S DNSFLAG=1,IP=$$DNS(HLCSTATE("LINK","DOMAIN")) I IP]"",IP'=HLCSTATE("LINK","IP") S HLCSTATE("LINK","IP")=IP Q:IP=""  G RETRY
"RTN","HLOTCP",92,0)
 ;
"RTN","HLOTCP",93,0)
 I HLCSTATE("CONNECTED"),DNSFLAG S $P(^HLCS(870,HLCSTATE("LINK","IEN"),400),"^")=IP
"RTN","HLOTCP",94,0)
 Q
"RTN","HLOTCP",95,0)
 ;
"RTN","HLOTCP",96,0)
DNS(DOMAIN) ;
"RTN","HLOTCP",97,0)
 Q $P($$ADDRESS^XLFNSLK(DOMAIN),",")
"RTN","HLOTCP",98,0)
 ;
"RTN","HLOTCP",99,0)
WRITEHDR(HLCSTATE,HDR) ;
"RTN","HLOTCP",100,0)
 ;
"RTN","HLOTCP",101,0)
 ;insure that package buffer is empty
"RTN","HLOTCP",102,0)
 K HLCSTATE("BUFFER")
"RTN","HLOTCP",103,0)
 S HLCSTATE("BUFFER","BYTE COUNT")=0
"RTN","HLOTCP",104,0)
 S HLCSTATE("BUFFER","SEGMENT COUNT")=0
"RTN","HLOTCP",105,0)
 ;
"RTN","HLOTCP",106,0)
 ;Start the message with <SB>, then write the header
"RTN","HLOTCP",107,0)
 N SEG
"RTN","HLOTCP",108,0)
 S SEG(1)=$C(11)_HDR(1)
"RTN","HLOTCP",109,0)
 S SEG(2)=HDR(2)
"RTN","HLOTCP",110,0)
 Q $$WRITESEG(.HLCSTATE,.SEG)
"RTN","HLOTCP",111,0)
 ;
"RTN","HLOTCP",112,0)
WRITESEG(HLCSTATE,SEG) ;
"RTN","HLOTCP",113,0)
 N I,LAST
"RTN","HLOTCP",114,0)
 S HLCSTATE("BUFFER","SEGMENT COUNT")=HLCSTATE("BUFFER","SEGMENT COUNT")+1
"RTN","HLOTCP",115,0)
 S I=0,LAST=$O(SEG(99999),-1)
"RTN","HLOTCP",116,0)
 F  S I=$O(SEG(I)) Q:'I  D
"RTN","HLOTCP",117,0)
 .I HLCSTATE("BUFFER","BYTE COUNT")>HLCSTATE("SYSTEM","BUFFER") D FLUSH
"RTN","HLOTCP",118,0)
 .I I=LAST S SEG(I)=SEG(I)_$C(13)
"RTN","HLOTCP",119,0)
 .S HLCSTATE("BUFFER",HLCSTATE("BUFFER","SEGMENT COUNT"),I)=SEG(I),HLCSTATE("BUFFER","BYTE COUNT")=HLCSTATE("BUFFER","BYTE COUNT")+$L(SEG(I))+20
"RTN","HLOTCP",120,0)
 Q HLCSTATE("CONNECTED")
"RTN","HLOTCP",121,0)
 ;
"RTN","HLOTCP",122,0)
FLUSH ;flushes the HL7 package buffer, and the system TCP buffer when full
"RTN","HLOTCP",123,0)
 N SEGMENT,MAX
"RTN","HLOTCP",124,0)
 S SEGMENT=0
"RTN","HLOTCP",125,0)
 ;
"RTN","HLOTCP",126,0)
 S MAX=HLCSTATE("TCP BUFFER SIZE")-2
"RTN","HLOTCP",127,0)
 ;
"RTN","HLOTCP",128,0)
 U HLCSTATE("DEVICE") I (HLCSTATE("SYSTEM","OS")="CACHE") S HLCSTATE("CONNECTED")=($ZA\8192#2) I 'HLCSTATE("CONNECTED") D CLOSE(.HLCSTATE)
"RTN","HLOTCP",129,0)
 F  S SEGMENT=$O(HLCSTATE("BUFFER",SEGMENT)) Q:'SEGMENT  D
"RTN","HLOTCP",130,0)
 .N I S I=0
"RTN","HLOTCP",131,0)
 .F  S I=$O(HLCSTATE("BUFFER",SEGMENT,I)) Q:'I  D
"RTN","HLOTCP",132,0)
 ..N LINE
"RTN","HLOTCP",133,0)
 ..S LINE=HLCSTATE("BUFFER",SEGMENT,I)
"RTN","HLOTCP",134,0)
 ..;put the line in the TCP buffer, or as much as will fit - flush the buffer when it gets full
"RTN","HLOTCP",135,0)
 ..F  Q:LINE=""  D
"RTN","HLOTCP",136,0)
 ...N INC
"RTN","HLOTCP",137,0)
 ...;INC is how much space is left in the buffer
"RTN","HLOTCP",138,0)
 ...S INC=MAX-HLCSTATE("TCP BUFFER $X")
"RTN","HLOTCP",139,0)
 ...I '($L(LINE)>INC) D
"RTN","HLOTCP",140,0)
 ....S HLCSTATE("TCP BUFFER")=HLCSTATE("TCP BUFFER")_LINE
"RTN","HLOTCP",141,0)
 ....S HLCSTATE("TCP BUFFER $X")=HLCSTATE("TCP BUFFER $X")+$L(LINE)
"RTN","HLOTCP",142,0)
 ....S LINE=""
"RTN","HLOTCP",143,0)
 ...E  D
"RTN","HLOTCP",144,0)
 ....S HLCSTATE("TCP BUFFER")=HLCSTATE("TCP BUFFER")_$E(LINE,1,INC)
"RTN","HLOTCP",145,0)
 ....S HLCSTATE("TCP BUFFER $X")=MAX
"RTN","HLOTCP",146,0)
 ....S LINE=$E(LINE,INC+1,99999)
"RTN","HLOTCP",147,0)
 ...I HLCSTATE("TCP BUFFER $X")=MAX D
"RTN","HLOTCP",148,0)
 ....W HLCSTATE("TCP BUFFER"),@HLCSTATE("FLUSH")
"RTN","HLOTCP",149,0)
 ....S HLCSTATE("TCP BUFFER")="",HLCSTATE("TCP BUFFER $X")=0
"RTN","HLOTCP",150,0)
 K HLCSTATE("BUFFER")
"RTN","HLOTCP",151,0)
 S HLCSTATE("BUFFER","SEGMENT COUNT")=1
"RTN","HLOTCP",152,0)
 S HLCSTATE("BUFFER","BYTE COUNT")=0
"RTN","HLOTCP",153,0)
 Q
"RTN","HLOTCP",154,0)
 ;
"RTN","HLOTCP",155,0)
READSEG(HLCSTATE,SEG) ;
"RTN","HLOTCP",156,0)
 ;
"RTN","HLOTCP",157,0)
 ;Output:
"RTN","HLOTCP",158,0)
 ;  SEG - returns the segment (pass by reference)
"RTN","HLOTCP",159,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOTCP",160,0)
 ;
"RTN","HLOTCP",161,0)
 K SEG
"RTN","HLOTCP",162,0)
 ;**START P139 CJM - if the header segment has been read, and <EB> is encountered before the <CR>, then accept whatever came before <EB> as a segment
"RTN","HLOTCP",163,0)
 Q:HLCSTATE("MESSAGE ENDED") 0
"RTN","HLOTCP",164,0)
 ;**END P139
"RTN","HLOTCP",165,0)
 ;
"RTN","HLOTCP",166,0)
 N SUCCESS,COUNT,BUF
"RTN","HLOTCP",167,0)
 S (COUNT,SUCCESS)=0
"RTN","HLOTCP",168,0)
 ;
"RTN","HLOTCP",169,0)
 ;anything left from last read?
"RTN","HLOTCP",170,0)
 S BUF=HLCSTATE("READ")
"RTN","HLOTCP",171,0)
 S HLCSTATE("READ")=""
"RTN","HLOTCP",172,0)
 I BUF]"" D  ;something was left!
"RTN","HLOTCP",173,0)
 .S COUNT=1
"RTN","HLOTCP",174,0)
 .I BUF[$C(13) D  Q
"RTN","HLOTCP",175,0)
 ..S SEG(1)=$P(BUF,$C(13)),BUF=$P(BUF,$C(13),2,999999)
"RTN","HLOTCP",176,0)
 ..S SUCCESS=1
"RTN","HLOTCP",177,0)
 .;**START P139 CJM
"RTN","HLOTCP",178,0)
 .I HLCSTATE("MESSAGE STARTED"),BUF[$C(28) D  Q
"RTN","HLOTCP",179,0)
 ..S SEG(1)=$P(BUF,$C(28)),BUF=$P(BUF,$C(28),2,999999)
"RTN","HLOTCP",180,0)
 ..S SUCCESS=1
"RTN","HLOTCP",181,0)
 ..S HLCSTATE("MESSAGE ENDED")=1
"RTN","HLOTCP",182,0)
 .;**END P139 CJM
"RTN","HLOTCP",183,0)
 .S SEG(1)=BUF,BUF=""
"RTN","HLOTCP",184,0)
 I 'SUCCESS U HLCSTATE("DEVICE") F  R BUF:HLCSTATE("READ TIMEOUT") Q:'$T  D  Q:SUCCESS
"RTN","HLOTCP",185,0)
 .I BUF[$C(13) S SUCCESS=1,COUNT=COUNT+1,SEG(COUNT)=$P(BUF,$C(13)),BUF=$P(BUF,$C(13),2,999999) Q
"RTN","HLOTCP",186,0)
 .;
"RTN","HLOTCP",187,0)
 .;**START P139 CJM
"RTN","HLOTCP",188,0)
 .I HLCSTATE("MESSAGE STARTED"),BUF[$C(28) S SUCCESS=1,HLCSTATE("MESSAGE ENDED")=1,COUNT=COUNT+1,SEG(COUNT)=$P(BUF,$C(28)),BUF=$P(BUF,$C(28),2,999999) Q
"RTN","HLOTCP",189,0)
 .;**END P139 CJM
"RTN","HLOTCP",190,0)
 .;
"RTN","HLOTCP",191,0)
 .S COUNT=COUNT+1,SEG(COUNT)=BUF
"RTN","HLOTCP",192,0)
 ;
"RTN","HLOTCP",193,0)
 I SUCCESS D
"RTN","HLOTCP",194,0)
 .S HLCSTATE("READ")=BUF ;save the leftover
"RTN","HLOTCP",195,0)
 .I COUNT>1,SEG(COUNT)="" K SEG(COUNT) S COUNT=COUNT-1
"RTN","HLOTCP",196,0)
 ;Cache can return the connection status
"RTN","HLOTCP",197,0)
 E  I (HLCSTATE("SYSTEM","OS")="CACHE") S HLCSTATE("CONNECTED")=($ZA\8192#2) I 'HLCSTATE("CONNECTED") D CLOSE(.HLCSTATE)
"RTN","HLOTCP",198,0)
 ;
"RTN","HLOTCP",199,0)
 ;if the <EB> character was encountered, then there are no more segments in the message, set the end of message flag
"RTN","HLOTCP",200,0)
 I SUCCESS,SEG(COUNT)[$C(28) D
"RTN","HLOTCP",201,0)
 .K SEG
"RTN","HLOTCP",202,0)
 .S SUCCESS=0
"RTN","HLOTCP",203,0)
 .S HLCSTATE("MESSAGE ENDED")=1
"RTN","HLOTCP",204,0)
 Q SUCCESS
"RTN","HLOTCP",205,0)
 ;
"RTN","HLOTCP",206,0)
READHDR(HLCSTATE,HDR) ;
"RTN","HLOTCP",207,0)
 ;reads the next header segment in the message stream, discarding everything that comes before it
"RTN","HLOTCP",208,0)
 ;
"RTN","HLOTCP",209,0)
 N SEG,SUCCESS,J,I
"RTN","HLOTCP",210,0)
 S SUCCESS=0
"RTN","HLOTCP",211,0)
 K HDR
"RTN","HLOTCP",212,0)
 F  Q:'$$READSEG(.HLCSTATE,.SEG)  D  Q:SUCCESS
"RTN","HLOTCP",213,0)
 .S I=0
"RTN","HLOTCP",214,0)
 .;look for the <SB>
"RTN","HLOTCP",215,0)
 .;perhaps the <SB> isn't in the first line
"RTN","HLOTCP",216,0)
 .F  S I=$O(SEG(I)) Q:'I  D  Q:SUCCESS
"RTN","HLOTCP",217,0)
 ..I (SEG(I)'[$C(11)) K SEG(I) Q
"RTN","HLOTCP",218,0)
 ..S SEG(I)=$P(SEG(I),$C(11),2)
"RTN","HLOTCP",219,0)
 ..S SUCCESS=1
"RTN","HLOTCP",220,0)
 ..K:SEG(I)="" SEG(I)
"RTN","HLOTCP",221,0)
 I SUCCESS S (I,J)=0 F  S J=$O(SEG(J)) Q:'J  S I=I+1,HDR(I)=SEG(J)
"RTN","HLOTCP",222,0)
 Q SUCCESS
"RTN","HLOTCP",223,0)
 ;
"RTN","HLOTCP",224,0)
CLOSE(HLCSTATE) ;
"RTN","HLOTCP",225,0)
 CLOSE HLCSTATE("DEVICE")
"RTN","HLOTCP",226,0)
 Q
"RTN","HLOTCP",227,0)
 ;
"RTN","HLOTCP",228,0)
ENDMSG(HLCSTATE)        ;
"RTN","HLOTCP",229,0)
 N SEG
"RTN","HLOTCP",230,0)
 S SEG(1)=$C(28)
"RTN","HLOTCP",231,0)
 I $$WRITESEG(.HLCSTATE,.SEG) D  Q 1
"RTN","HLOTCP",232,0)
 .D FLUSH
"RTN","HLOTCP",233,0)
 .I HLCSTATE("TCP BUFFER $X") D
"RTN","HLOTCP",234,0)
 ..U HLCSTATE("DEVICE")
"RTN","HLOTCP",235,0)
 ..W HLCSTATE("TCP BUFFER"),@HLCSTATE("FLUSH")
"RTN","HLOTCP",236,0)
 ..S HLCSTATE("TCP BUFFER")=""
"RTN","HLOTCP",237,0)
 ..S HLCSTATE("TCP BUFFER $X")=0
"RTN","HLOTCP",238,0)
 Q 0
"RTN","HLOTLNK")
0^7^B25754770^B23891993
"RTN","HLOTLNK",1,0)
HLOTLNK ;IRMFO-ALB/CJM - APIs for the HL Logical Link file;03/24/2004  14:43
"RTN","HLOTLNK",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,130,131,139**;Oct 13, 1995;Build 11
"RTN","HLOTLNK",3,0)
 ;
"RTN","HLOTLNK",4,0)
SETSHUT(LINKIEN) ;
"RTN","HLOTLNK",5,0)
 ;sets the shutdown flag (can not fail - if the link doesn't exist, by definition its shutdown)
"RTN","HLOTLNK",6,0)
 Q:'$G(LINKIEN) 1
"RTN","HLOTLNK",7,0)
 Q:'$D(^HLCS(870,LINKIEN,0)) 1
"RTN","HLOTLNK",8,0)
 S $P(^HLCS(870,LINKIEN,0),"^",16)=1
"RTN","HLOTLNK",9,0)
 Q 1
"RTN","HLOTLNK",10,0)
SETOPEN(LINKIEN) ;
"RTN","HLOTLNK",11,0)
 ;clears the shutdown flag, returns 1 on success, 0 on failure
"RTN","HLOTLNK",12,0)
 Q:'$G(LINKIEN) 0
"RTN","HLOTLNK",13,0)
 Q:'$D(^HLCS(870,LINKIEN,0)) 0
"RTN","HLOTLNK",14,0)
 S $P(^HLCS(870,LINKIEN,0),"^",16)=""
"RTN","HLOTLNK",15,0)
 Q 1
"RTN","HLOTLNK",16,0)
 ;
"RTN","HLOTLNK",17,0)
IFSHUT(LINKNAME) ;
"RTN","HLOTLNK",18,0)
 ;returns 1 if the link was shut down to HLO
"RTN","HLOTLNK",19,0)
 N IEN,LINK
"RTN","HLOTLNK",20,0)
 S LINK=$P($G(LINKNAME),":")
"RTN","HLOTLNK",21,0)
 ;** Start HL*1.6*139 RBN **
"RTN","HLOTLNK",22,0)
 ;Q:LINK=""
"RTN","HLOTLNK",23,0)
 Q:LINK="" 0
"RTN","HLOTLNK",24,0)
 ;** END HL*1.6*139 RBN **
"RTN","HLOTLNK",25,0)
 S IEN=$O(^HLCS(870,"B",LINK,0))
"RTN","HLOTLNK",26,0)
 Q:'IEN 1
"RTN","HLOTLNK",27,0)
 Q:$P($G(^HLCS(870,IEN,0)),"^",16) 1
"RTN","HLOTLNK",28,0)
 Q 0
"RTN","HLOTLNK",29,0)
 ;
"RTN","HLOTLNK",30,0)
DOMAIN(LINKIEN) ;
"RTN","HLOTLNK",31,0)
 ;Returns the domain associated with this link
"RTN","HLOTLNK",32,0)
 ;
"RTN","HLOTLNK",33,0)
 Q:'$G(LINKIEN) ""
"RTN","HLOTLNK",34,0)
 N NODE,DOMAIN
"RTN","HLOTLNK",35,0)
 S DOMAIN=""
"RTN","HLOTLNK",36,0)
 S NODE=$G(^HLCS(870,LINKIEN,0))
"RTN","HLOTLNK",37,0)
 I $P(NODE,"^",7) D
"RTN","HLOTLNK",38,0)
 .S DOMAIN=$P($G(^DIC(4.2,$P(NODE,"^",7),0)),"^")
"RTN","HLOTLNK",39,0)
 .S DOMAIN=$S($L(DOMAIN):"HL7."_DOMAIN,1:"")
"RTN","HLOTLNK",40,0)
 I '$L(DOMAIN) S DOMAIN=$P(NODE,"^",8)
"RTN","HLOTLNK",41,0)
 Q DOMAIN
"RTN","HLOTLNK",42,0)
 ;
"RTN","HLOTLNK",43,0)
PORT(LINKIEN) ;
"RTN","HLOTLNK",44,0)
 ;Returns the HLO port associated with this link
"RTN","HLOTLNK",45,0)
 ;
"RTN","HLOTLNK",46,0)
 Q:'$G(LINKIEN) ""
"RTN","HLOTLNK",47,0)
 N NODE,PORT
"RTN","HLOTLNK",48,0)
 S NODE=$G(^HLCS(870,LINKIEN,400))
"RTN","HLOTLNK",49,0)
 S PORT=$P(NODE,"^",8)
"RTN","HLOTLNK",50,0)
 S:'PORT PORT=$S($P($G(^HLD(779.1,1,0)),"^",3)="P":5001,1:5026)
"RTN","HLOTLNK",51,0)
 Q PORT
"RTN","HLOTLNK",52,0)
 ;
"RTN","HLOTLNK",53,0)
PORT2(LINKNAME) ;given the name of the link, returns its HLO port
"RTN","HLOTLNK",54,0)
 N PORT
"RTN","HLOTLNK",55,0)
 Q:'$L(LINKNAME) ""
"RTN","HLOTLNK",56,0)
 S PORT=$$PORT($O(^HLCS(870,"B",LINKNAME,0)))
"RTN","HLOTLNK",57,0)
 Q:'$L(PORT) ""
"RTN","HLOTLNK",58,0)
 Q PORT
"RTN","HLOTLNK",59,0)
 ;
"RTN","HLOTLNK",60,0)
STATNUM(LINKIEN) ;
"RTN","HLOTLNK",61,0)
 ;Given the ien of the link, this function returns the station #.
"RTN","HLOTLNK",62,0)
 ;
"RTN","HLOTLNK",63,0)
 Q:'$G(LINKIEN) ""
"RTN","HLOTLNK",64,0)
 N INST
"RTN","HLOTLNK",65,0)
 S INST=$P($G(^HLCS(870,LINKIEN,0)),"^",2)
"RTN","HLOTLNK",66,0)
 Q:'INST ""
"RTN","HLOTLNK",67,0)
 Q $P($G(^DIC(4,INST,99)),"^")
"RTN","HLOTLNK",68,0)
 ;
"RTN","HLOTLNK",69,0)
FINDLINK(STATN) ;
"RTN","HLOTLNK",70,0)
 ;Returns the link ien based on the station # =STATN
"RTN","HLOTLNK",71,0)
 ;The link found must have a name starting with "VA", as these are
"RTN","HLOTLNK",72,0)
 ;reserved for officially released links associated with VHA institutions
"RTN","HLOTLNK",73,0)
 ;** EXCEPTION** MPIVA is an official link associated with 200M
"RTN","HLOTLNK",74,0)
 ;
"RTN","HLOTLNK",75,0)
 Q:'$L($G(STATN)) 0
"RTN","HLOTLNK",76,0)
 ;
"RTN","HLOTLNK",77,0)
 N NAME,IEN
"RTN","HLOTLNK",78,0)
 S (NAME,IEN)=""
"RTN","HLOTLNK",79,0)
 F  S NAME=$O(^HLCS(870,"AC",STATN,NAME)) Q:NAME=""  I (NAME'="VA-VIE"),($E(NAME,1,2)="VA")!(NAME="MPIVA") S IEN=$O(^HLCS(870,"AC",STATN,NAME,0)) Q
"RTN","HLOTLNK",80,0)
 Q IEN
"RTN","HLOTLNK",81,0)
 ;
"RTN","HLOTLNK",82,0)
GETLINK(LINKNAME,LINK) ;
"RTN","HLOTLNK",83,0)
 N IEN
"RTN","HLOTLNK",84,0)
 Q:'$L(LINKNAME) 0
"RTN","HLOTLNK",85,0)
 S IEN=$O(^HLCS(870,"B",LINKNAME,0))
"RTN","HLOTLNK",86,0)
 I IEN Q $$GET(IEN,.LINK)
"RTN","HLOTLNK",87,0)
 I LINKNAME="HLO DEFAULT LISTENER" D  Q 1
"RTN","HLOTLNK",88,0)
 .N NODE
"RTN","HLOTLNK",89,0)
 .S LINK("NAME")=LINKNAME
"RTN","HLOTLNK",90,0)
 .S LINK("IEN")=0
"RTN","HLOTLNK",91,0)
 .S LINK("SHUTDOWN")=""
"RTN","HLOTLNK",92,0)
 .S LINK("LLP")="TCP"
"RTN","HLOTLNK",93,0)
 .S LINK("SERVER")="1^"_"M"
"RTN","HLOTLNK",94,0)
 .S NODE=$G(^HLD(779.1,1,0))
"RTN","HLOTLNK",95,0)
 .S LINK("DOMAIN")=$P(NODE,"^",1)
"RTN","HLOTLNK",96,0)
 .S LINK("PORT")=$S($P(NODE,"^",3)="P":5001,$P(NODE,"^",3)="T":5026,1:"")
"RTN","HLOTLNK",97,0)
 .S LINK("IP")=""
"RTN","HLOTLNK",98,0)
 Q 0
"RTN","HLOTLNK",99,0)
GET(IEN,LINK) ;
"RTN","HLOTLNK",100,0)
 N NODE,PTR
"RTN","HLOTLNK",101,0)
 K LINK
"RTN","HLOTLNK",102,0)
 S NODE=$G(^HLCS(870,IEN,0))
"RTN","HLOTLNK",103,0)
 Q:NODE="" 0
"RTN","HLOTLNK",104,0)
 S LINK("NAME")=$P(NODE,"^")
"RTN","HLOTLNK",105,0)
 S LINK("IEN")=IEN
"RTN","HLOTLNK",106,0)
 S LINK("SHUTDOWN")=+$P(NODE,"^",16)
"RTN","HLOTLNK",107,0)
 I $P(NODE,"^",7) D
"RTN","HLOTLNK",108,0)
 .S LINK("DOMAIN")=$P(^DIC(4.2,$P(NODE,"^",7),0),"^")
"RTN","HLOTLNK",109,0)
 .S LINK("DOMAIN")=$S($L(LINK("DOMAIN")):"HL7."_LINK("DOMAIN"),1:"")
"RTN","HLOTLNK",110,0)
 I $G(LINK("DOMAIN"))="" S LINK("DOMAIN")=$P(NODE,"^",8)
"RTN","HLOTLNK",111,0)
 S PTR=$P(NODE,"^",3)
"RTN","HLOTLNK",112,0)
 S LINK("LLP")=$S('PTR:"",1:$P($G(^HLCS(869.1,PTR,0)),"^"))
"RTN","HLOTLNK",113,0)
 S LINK("SERVER")=""
"RTN","HLOTLNK",114,0)
 I LINK("LLP")="TCP" D
"RTN","HLOTLNK",115,0)
 .S LINK("SERVER")=1
"RTN","HLOTLNK",116,0)
 .S NODE=$G(^HLCS(870,IEN,400))
"RTN","HLOTLNK",117,0)
 .S LINK("IP")=$P(NODE,"^")
"RTN","HLOTLNK",118,0)
 .S LINK("PORT")=$P(NODE,"^",8)
"RTN","HLOTLNK",119,0)
 .S:'LINK("PORT") LINK("PORT")=$S($P($G(^HLD(779.1,1,0)),"^",3)="P":5001,1:5026)
"RTN","HLOTLNK",120,0)
 .S:$P(NODE,"^",3)="C" LINK("SERVER")=0
"RTN","HLOTLNK",121,0)
 .I LINK("SERVER") S LINK("SERVER")=LINK("SERVER")_"^"_$P(NODE,"^",3)
"RTN","HLOTLNK",122,0)
 Q 1
"RTN","HLOTLNK",123,0)
 ;
"RTN","HLOTLNK",124,0)
SET1(LINK,MDOMAIN) ;
"RTN","HLOTLNK",125,0)
 N DOMAIN
"RTN","HLOTLNK",126,0)
 Q:'$L(MDOMAIN)
"RTN","HLOTLNK",127,0)
 S DOMAIN=$P($G(^DIC(4.2,MDOMAIN,0)),"^")
"RTN","HLOTLNK",128,0)
 S DOMAIN=$S($L(DOMAIN):"HL7."_DOMAIN,1:"")
"RTN","HLOTLNK",129,0)
 I DOMAIN'="" S ^HLCS(870,"AD","TCP",DOMAIN,LINK)=""
"RTN","HLOTLNK",130,0)
 Q
"RTN","HLOTLNK",131,0)
KILL1(LINK,MDOMAIN) ;
"RTN","HLOTLNK",132,0)
 N DOMAIN
"RTN","HLOTLNK",133,0)
 Q:'$L(MDOMAIN)
"RTN","HLOTLNK",134,0)
 S DOMAIN=$P($G(^DIC(4.2,MDOMAIN,0)),"^")
"RTN","HLOTLNK",135,0)
 S DOMAIN=$S($L(DOMAIN):"HL7."_DOMAIN,1:"")
"RTN","HLOTLNK",136,0)
 I DOMAIN'="" K ^HLCS(870,"AD","TCP",DOMAIN,LINK)
"RTN","HLOTLNK",137,0)
 Q
"RTN","HLOTLNK",138,0)
SET2(LINK,DOMAIN) ;
"RTN","HLOTLNK",139,0)
 I DOMAIN'="" S ^HLCS(870,"AD","TCP",DOMAIN,LINK)=""
"RTN","HLOTLNK",140,0)
 Q
"RTN","HLOTLNK",141,0)
KILL2(LINK,DOMAIN) ;
"RTN","HLOTLNK",142,0)
 I DOMAIN'="" K ^HLCS(870,"AD","TCP",DOMAIN,LINK)
"RTN","HLOTLNK",143,0)
 Q
"RTN","HLOTLNK",144,0)
SET3(LINK,DEVICE) ;
"RTN","HLOTLNK",145,0)
 Q:'DEVICE
"RTN","HLOTLNK",146,0)
 S ^HLCS(870,"AD","HLLP",DEVICE,LINK)=""
"RTN","HLOTLNK",147,0)
 Q
"RTN","HLOTLNK",148,0)
KILL3(LINK,DEVICE) ;
"RTN","HLOTLNK",149,0)
 Q:'DEVICE
"RTN","HLOTLNK",150,0)
 S ^HLCS(870,"AD","HLLP",DEVICE,LINK)=""
"RTN","HLOTLNK",151,0)
 Q
"RTN","HLOTLNK",152,0)
LLP(LINKNAME) ;
"RTN","HLOTLNK",153,0)
 ;finds the type of LLP for a named link
"RTN","HLOTLNK",154,0)
 N IEN,LLP
"RTN","HLOTLNK",155,0)
 S IEN=$O(^HLCS(870,"B",LINKNAME,0))
"RTN","HLOTLNK",156,0)
 Q:'IEN ""
"RTN","HLOTLNK",157,0)
 S LLP=$P($G(^HLCS(870,IEN,0)),"^",3)
"RTN","HLOTLNK",158,0)
 Q:'LLP ""
"RTN","HLOTLNK",159,0)
 Q $P($G(^HLCS(869.1,LLP,0)),"^")
"RTN","HLOTLNK",160,0)
 ;
"RTN","HLOTLNK",161,0)
DEVICE(LINKNAME) ;
"RTN","HLOTLNK",162,0)
 N IEN
"RTN","HLOTLNK",163,0)
 S IEN=$O(^HLCS(870,"B",LINKNAME,0))
"RTN","HLOTLNK",164,0)
 Q:'IEN ""
"RTN","HLOTLNK",165,0)
 Q $P($G(^HLCS(870,IEN,200)),"^")
"RTN","HLOTLNK",166,0)
 ;
"RTN","HLOTLNK",167,0)
RTRNLNK(COMP1,COMP2,COMP3) ;
"RTN","HLOTLNK",168,0)
 ;based on the sending facility from the original header, this function finds the return link, or "" if not successful
"RTN","HLOTLNK",169,0)
 ;Inputs:
"RTN","HLOTLNK",170,0)
 ;  COMP1,COMP2,COMP3 - 3 components of the sending facility from the original message
"RTN","HLOTLNK",171,0)
 ;
"RTN","HLOTLNK",172,0)
 N LINK,IEN
"RTN","HLOTLNK",173,0)
 S LINK=""
"RTN","HLOTLNK",174,0)
 I $G(COMP3)="DNS",$P($G(COMP2),":")]"" S LINK=$O(^HLCS(870,"AD","TCP",$P(COMP2,":"),""))
"RTN","HLOTLNK",175,0)
 I LINK="",$L($G(COMP1)) S IEN=$$FINDLINK(COMP1) S:IEN LINK=$P($G(^HLCS(870,IEN,0)),"^")
"RTN","HLOTLNK",176,0)
 Q LINK
"RTN","HLOTLNK",177,0)
 ;
"RTN","HLOTLNK",178,0)
 ;HLLP is not implemented in HLO
"RTN","HLOTLNK",179,0)
 ;I LLP="HLLP" N DEVICE S DEVICE=$$DEVICE(FROMLINK) I DEVICE Q $O(^HLCS(870,"AD","TCP",DEVICE,""))
"RTN","HLOTLNK",180,0)
 ;Q ""
"RTN","HLOTLNK",181,0)
 ;
"RTN","HLOTLNK",182,0)
CHKLINK(LINK) ;
"RTN","HLOTLNK",183,0)
 Q:'$L(LINK) 0
"RTN","HLOTLNK",184,0)
 Q:'$O(^HLCS(870,"B",LINK,0)) 0
"RTN","HLOTLNK",185,0)
 Q 1
"RTN","HLOUSR")
0^1^B90546721^B82341168
"RTN","HLOUSR",1,0)
HLOUSR ;ALB/CJM/OAK/PIJ -ListManager Screen for viewing system status;12 JUN 1997 10:00 am ;11/21/2008
"RTN","HLOUSR",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,130,134,137,138,139**;Oct 13, 1995;Build 11
"RTN","HLOUSR",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOUSR",4,0)
 ;
"RTN","HLOUSR",5,0)
EN ;
"RTN","HLOUSR",6,0)
 ;
"RTN","HLOUSR",7,0)
 N HLSCREEN,TESTOPEN,HLRFRSH,HLPARMS
"RTN","HLOUSR",8,0)
 D WAIT^DICD
"RTN","HLOUSR",9,0)
 D EN^VALM("HLO SYSTEM MONITOR")
"RTN","HLOUSR",10,0)
 Q
"RTN","HLOUSR",11,0)
 ;
"RTN","HLOUSR",12,0)
BRIEF ;
"RTN","HLOUSR",13,0)
 N COUNT,LINK,QUE,FROM,TIME,STATUS,TEMP,DIR,TODAY,LIST,LNKMSG
"RTN","HLOUSR",14,0)
 S HLRFRSH="BRIEF^HLOUSR"
"RTN","HLOUSR",15,0)
 S (HLSCREEN,VALMSG)="Brief System Status"
"RTN","HLOUSR",16,0)
 S VALMCNT=16
"RTN","HLOUSR",17,0)
 ;K @VALMAR
"RTN","HLOUSR",18,0)
 D CLEAN^VALM10
"RTN","HLOUSR",19,0)
 S VALMBG=1
"RTN","HLOUSR",20,0)
 S VALMBCK="R"
"RTN","HLOUSR",21,0)
 S VALMDDF("COL 1")="COL1^1^80^"
"RTN","HLOUSR",22,0)
 K VALMDDF("COL 2"),VALMDDF("COL 3"),VALMDDF("COL 4"),VALMDDF("COL 5")
"RTN","HLOUSR",23,0)
 D CHGCAP^VALM("COL 1"," Brief Operational Overview")
"RTN","HLOUSR",24,0)
 S @VALMAR@(1,0)="SYSTEM STATUS:             "_$S($$CHKSTOP^HLOPROC:"STOPPED",1:"RUNNING")
"RTN","HLOUSR",25,0)
 S @VALMAR@(2,0)="PROCESS MANAGER:           "_$S($$RUNNING:"RUNNING",1:"STOPPED")
"RTN","HLOUSR",26,0)
 ;
"RTN","HLOUSR",27,0)
 S TIME=$P($G(TESTOPEN("LISTENER")),"^",2)
"RTN","HLOUSR",28,0)
 I TIME,$$FMDIFF^XLFDT($$NOW^XLFDT,TIME,2)<300 D
"RTN","HLOUSR",29,0)
 .S STATUS=+TESTOPEN("LISTENER")
"RTN","HLOUSR",30,0)
 E  D
"RTN","HLOUSR",31,0)
 .S STATUS=0
"RTN","HLOUSR",32,0)
 .S LINK=$P($G(^HLD(779.1,1,0)),"^",10)
"RTN","HLOUSR",33,0)
 .I LINK S LINK=$P($G(^HLCS(870,LINK,0)),"^") Q:'$L(LINK)  S STATUS=$$IFOPEN^HLOUSR1(LINK)
"RTN","HLOUSR",34,0)
 .;
"RTN","HLOUSR",35,0)
 .;** P139 start CJM**
"RTN","HLOUSR",36,0)
 .I 'STATUS D
"RTN","HLOUSR",37,0)
 ..N SYS,POP,IO,IOF,IOST
"RTN","HLOUSR",38,0)
 ..D SYSPARMS^HLOSITE(.SYS)
"RTN","HLOUSR",39,0)
 ..D CALL^%ZISTCP("0.0.0.0",SYS("PORT"),5)
"RTN","HLOUSR",40,0)
 ..S STATUS='POP
"RTN","HLOUSR",41,0)
 ..C:STATUS IO
"RTN","HLOUSR",42,0)
 ..S:'STATUS LNKMSG=" Please restart the VMS TCPIP SERVICE FOR THE HLO LISTENER"
"RTN","HLOUSR",43,0)
 ..D:'STATUS CNTRL^VALM10(3,43,85,IOINHI,IOINORM)
"RTN","HLOUSR",44,0)
 .S TESTOPEN("LISTENER")=STATUS_"^"_$$NOW^XLFDT
"RTN","HLOUSR",45,0)
 S @VALMAR@(3,0)="STANDARD LISTENER:         "_$S(STATUS:"OPERATIONAL",1:"NOT OPERATIONAL ")_$G(LNKMSG)
"RTN","HLOUSR",46,0)
 ;** P139 end **
"RTN","HLOUSR",47,0)
 ;
"RTN","HLOUSR",48,0)
 S @VALMAR@(4,0)="TASKMAN:                   "_$S($$TM^%ZTLOAD:"RUNNING",1:"NOT RUNNING")
"RTN","HLOUSR",49,0)
 ;
"RTN","HLOUSR",50,0)
 S (LIST,LINK)=""
"RTN","HLOUSR",51,0)
 F  S LINK=$O(^HLTMP("FAILING LINKS",LINK)) Q:LINK=""  D  I $L(LIST)>60 S LIST=LIST_",..." Q
"RTN","HLOUSR",52,0)
 .N TIME,QUE,LINKARY
"RTN","HLOUSR",53,0)
 .I $$GETLINK^HLOTLNK($P(LINK,":"),.LINKARY)
"RTN","HLOUSR",54,0)
 .S TIME=$G(^HLTMP("FAILING LINKS",LINK)) Q:TIME=""
"RTN","HLOUSR",55,0)
 .I '$G(LINKARY("SHUTDOWN")),TIME="" Q
"RTN","HLOUSR",56,0)
 .I '$G(LINKARY("SHUTDOWN")),($$HDIFF^XLFDT($H,TIME,2)<300) Q
"RTN","HLOUSR",57,0)
 .;;***patch HL*1.6*138 start
"RTN","HLOUSR",58,0)
 .S LIST=LIST_$S($L(LIST):", ",1:"")_LINK
"RTN","HLOUSR",59,0)
 .;;.S LIST=LIST_$S($L(LIST):", ",1:"")_$P(LINK,":")
"RTN","HLOUSR",60,0)
 .;; ***patch HL*1.6*138 end
"RTN","HLOUSR",61,0)
 S @VALMAR@(5,0)="DOWN LINKS: "_LIST
"RTN","HLOUSR",62,0)
 S @VALMAR@(6,0)="CLIENT LINK PROCESSES:     "_+$G(^HLC("HL7 PROCESS COUNTS","RUNNING","OUTGOING CLIENT LINK"))
"RTN","HLOUSR",63,0)
 S @VALMAR@(7,0)="IN-FILER PROCESSES:        "_+$G(^HLC("HL7 PROCESS COUNTS","RUNNING","INCOMING QUEUES"))
"RTN","HLOUSR",64,0)
 S COUNT=0,LINK=""
"RTN","HLOUSR",65,0)
 F  S LINK=$O(^HLC("QUEUECOUNT","OUT",LINK)) Q:LINK=""  D
"RTN","HLOUSR",66,0)
 .S QUE=""
"RTN","HLOUSR",67,0)
 .F  S QUE=$O(^HLC("QUEUECOUNT","OUT",LINK,QUE)) Q:QUE=""  D
"RTN","HLOUSR",68,0)
 ..S TEMP=$G(^HLC("QUEUECOUNT","OUT",LINK,QUE))
"RTN","HLOUSR",69,0)
 ..S:TEMP>0 COUNT=COUNT+TEMP
"RTN","HLOUSR",70,0)
 S @VALMAR@(8,0)="MESSAGES PENDING ON OUT QUEUES:    "_$$RJ(+COUNT,7)_"     ON SEQUENCE QUEUES:  "_$$RJ(+$G(^HLC("QUEUECOUNT","SEQUENCE")),7)
"RTN","HLOUSR",71,0)
 S TEMP="STOPPED OUTGOING QUEUES: "
"RTN","HLOUSR",72,0)
 S COUNT=0,QUE=""
"RTN","HLOUSR",73,0)
 F  S QUE=$O(^HLTMP("STOPPED QUEUES","OUT",QUE)) Q:QUE=""  S COUNT=COUNT+1 Q:COUNT>4  S:COUNT=1 TEMP=TEMP_QUE S:"23"[COUNT TEMP=TEMP_"; "_QUE S:COUNT=4 TEMP=TEMP_" ..."
"RTN","HLOUSR",74,0)
 S @VALMAR@(9,0)=TEMP
"RTN","HLOUSR",75,0)
 S COUNT=0,QUE=""
"RTN","HLOUSR",76,0)
 F  S QUE=$O(^HLC("QUEUECOUNT","IN",QUE)) Q:QUE=""  D
"RTN","HLOUSR",77,0)
 .S FROM=""
"RTN","HLOUSR",78,0)
 .F  S FROM=$O(^HLC("QUEUECOUNT","IN",QUE,FROM)) Q:FROM=""  D
"RTN","HLOUSR",79,0)
 ..S TEMP=$G(^HLC("QUEUECOUNT","IN",QUE,FROM))
"RTN","HLOUSR",80,0)
 ..S:TEMP>0 COUNT=COUNT+TEMP
"RTN","HLOUSR",81,0)
 S @VALMAR@(10,0)="MESSAGES PENDING ON APPLICATIONS: "_$$RJ(+COUNT,7)
"RTN","HLOUSR",82,0)
 S TEMP="STOPPED INCOMING QUEUES: "
"RTN","HLOUSR",83,0)
 S COUNT=0,QUE=""
"RTN","HLOUSR",84,0)
 F  S QUE=$O(^HLTMP("STOPPED QUEUES","IN",QUE)) Q:QUE=""  S COUNT=COUNT+1 Q:COUNT>4  S:COUNT=1 TEMP=TEMP_QUE S:"23"[COUNT TEMP=TEMP_"; "_QUE S:COUNT=4 TEMP=TEMP_" ..."
"RTN","HLOUSR",85,0)
 S @VALMAR@(11,0)=TEMP
"RTN","HLOUSR",86,0)
 S @VALMAR@(12,0)="FILE 777 RECORD COUNT:         "_$$RJ($P($G(^HLTMP("FILE 777 RECORD COUNT")),"^"),10)_"     --> as of "_$$FMTE^XLFDT($P($G(^HLTMP("FILE 777 RECORD COUNT")),"^",2))
"RTN","HLOUSR",87,0)
 S @VALMAR@(13,0)="FILE 778 RECORD COUNT:         "_$$RJ($P($G(^HLTMP("FILE 778 RECORD COUNT")),"^"),10)_"     --> as of "_$$FMTE^XLFDT($P($G(^HLTMP("FILE 778 RECORD COUNT")),"^",2))
"RTN","HLOUSR",88,0)
 S TODAY=$$DT^XLFDT
"RTN","HLOUSR",89,0)
 S @VALMAR@(14,0)="MESSAGES SENT TODAY:           "_$$RJ($$ADD("OUT"),10)
"RTN","HLOUSR",90,0)
 S @VALMAR@(15,0)="MESSAGES RECEIVED TODAY:       "_$$RJ($$ADD("IN"),10)
"RTN","HLOUSR",91,0)
 S @VALMAR@(16,0)="MESSAGE ERRORS TODAY:          "_$$RJ($$ADD("EOUT")+$$ADD("EIN"),10)
"RTN","HLOUSR",92,0)
 Q
"RTN","HLOUSR",93,0)
ADD(DIR) ;
"RTN","HLOUSR",94,0)
 N RAP,SAP,TIME,TOTAL,TYPE
"RTN","HLOUSR",95,0)
 S TOTAL=0
"RTN","HLOUSR",96,0)
 S TIME=TODAY-.0001
"RTN","HLOUSR",97,0)
 F  S TIME=$O(^HLSTATS(DIR,"HOURLY",TIME)) Q:'TIME  Q:((TIME\1)>TODAY)  D
"RTN","HLOUSR",98,0)
 .S SAP=""
"RTN","HLOUSR",99,0)
 .F  S SAP=$O(^HLSTATS(DIR,"HOURLY",TIME,SAP)) Q:SAP=""  D
"RTN","HLOUSR",100,0)
 ..Q:SAP="ACCEPT ACK"
"RTN","HLOUSR",101,0)
 ..S RAP=""
"RTN","HLOUSR",102,0)
 ..F  S RAP=$O(^HLSTATS(DIR,"HOURLY",TIME,SAP,RAP)) Q:RAP=""  D
"RTN","HLOUSR",103,0)
 ...S TYPE=""
"RTN","HLOUSR",104,0)
 ...F  S TYPE=$O(^HLSTATS(DIR,"HOURLY",TIME,SAP,RAP,TYPE)) Q:TYPE=""  D
"RTN","HLOUSR",105,0)
 ....S TOTAL=TOTAL+$G(^HLSTATS(DIR,"HOURLY",TIME,SAP,RAP,TYPE))
"RTN","HLOUSR",106,0)
 Q TOTAL
"RTN","HLOUSR",107,0)
 ;
"RTN","HLOUSR",108,0)
HELP ;
"RTN","HLOUSR",109,0)
 S X="?" D DISP^XQORM1 W !!
"RTN","HLOUSR",110,0)
 Q
"RTN","HLOUSR",111,0)
 ;
"RTN","HLOUSR",112,0)
EXIT ;
"RTN","HLOUSR",113,0)
 D CLEAN^VALM10
"RTN","HLOUSR",114,0)
 D CLEAR^VALM1
"RTN","HLOUSR",115,0)
 Q
"RTN","HLOUSR",116,0)
 ;
"RTN","HLOUSR",117,0)
EXPND ;
"RTN","HLOUSR",118,0)
 Q
"RTN","HLOUSR",119,0)
 ;
"RTN","HLOUSR",120,0)
PROCS ;
"RTN","HLOUSR",121,0)
 S HLRFRSH="PROCS^HLOUSR"
"RTN","HLOUSR",122,0)
 ;K @VALMAR
"RTN","HLOUSR",123,0)
 D CLEAN^VALM10
"RTN","HLOUSR",124,0)
 S VALMCNT=0
"RTN","HLOUSR",125,0)
 S VALMBCK="R"
"RTN","HLOUSR",126,0)
 S VALMDDF("COL 1")="COL 1^1^34^"
"RTN","HLOUSR",127,0)
 S VALMDDF("COL 2")="COL 2^35^10^MIN^H"
"RTN","HLOUSR",128,0)
 S VALMDDF("COL 3")="COL 3^47^10^MAX^H"
"RTN","HLOUSR",129,0)
 S VALMDDF("COL 4")="COL 4^59^10^#RUNNING^H"
"RTN","HLOUSR",130,0)
 S VALMDDF("COL 5")="COL 5^71^10^#QUEUED^IOBON"
"RTN","HLOUSR",131,0)
 D CHGCAP^VALM("COL 1"," Process Type")
"RTN","HLOUSR",132,0)
 N IEN
"RTN","HLOUSR",133,0)
 S IEN=0
"RTN","HLOUSR",134,0)
 F  S IEN=$O(^HLD(779.3,"C",1,IEN)) Q:'IEN  D
"RTN","HLOUSR",135,0)
 .N PROC
"RTN","HLOUSR",136,0)
 .Q:'$$GETPROC^HLOPROC1(IEN,.PROC)
"RTN","HLOUSR",137,0)
 .Q:PROC("NAME")="VMS TCP LISTENER"
"RTN","HLOUSR",138,0)
 .S VALMCNT=VALMCNT+1
"RTN","HLOUSR",139,0)
 .S @VALMAR@(VALMCNT,0)=$$LJ(PROC("NAME"),30)_$$RJ(PROC("MINIMUM"),6)_$$RJ(PROC("MAXIMUM"),12)_$$RJ(+$G(^HLC("HL7 PROCESS COUNTS","RUNNING",PROC("NAME"))),14)_$$RJ(+$G(^HLC("HL7 PROCESS COUNTS","QUEUED",PROC("NAME"))),12)
"RTN","HLOUSR",140,0)
 S VALMCNT=VALMCNT+1,@VALMAR@(VALMCNT,0)=""
"RTN","HLOUSR",141,0)
 S IEN=""
"RTN","HLOUSR",142,0)
 F  S IEN=$O(^HLTMP("HL7 RUNNING PROCESSES",IEN)) Q:IEN=""  D
"RTN","HLOUSR",143,0)
 .N NODE
"RTN","HLOUSR",144,0)
 .S NODE=$G(^HLTMP("HL7 RUNNING PROCESSES",IEN))
"RTN","HLOUSR",145,0)
 .Q:NODE=""
"RTN","HLOUSR",146,0)
 .S VALMCNT=VALMCNT+1
"RTN","HLOUSR",147,0)
 .S @VALMAR@(VALMCNT,0)="$J: "_$$LJ(IEN,9)_" ->"_$$CJ($P(NODE,"^",3),28)_"<- started at "_$$HTE^XLFDT($P(NODE,"^"))
"RTN","HLOUSR",148,0)
 Q
"RTN","HLOUSR",149,0)
 ;
"RTN","HLOUSR",150,0)
INQUEUE ;
"RTN","HLOUSR",151,0)
 N FROM
"RTN","HLOUSR",152,0)
 D CLEAN^VALM10
"RTN","HLOUSR",153,0)
 ;K @VALMAR
"RTN","HLOUSR",154,0)
 S HLRFRSH="INQUEUE^HLOUSR"
"RTN","HLOUSR",155,0)
 S (HLSCREEN,VALMSG)="Incoming Queues ('!' = stopped queues)"
"RTN","HLOUSR",156,0)
 S VALMCNT=0
"RTN","HLOUSR",157,0)
 S VALMBCK="R"
"RTN","HLOUSR",158,0)
 S VALMDDF("COL 1")="COL 1^1^40^ From^H"
"RTN","HLOUSR",159,0)
 S VALMDDF("COL 2")="COL 2^45^20^Queue^H"
"RTN","HLOUSR",160,0)
 S VALMDDF("COL 3")="COL 3^70^10^Count^H"
"RTN","HLOUSR",161,0)
 K VALMDDF("COL 4"),VALMDDF("COL 5")
"RTN","HLOUSR",162,0)
 D CHGCAP^VALM("COL 1"," From")
"RTN","HLOUSR",163,0)
 S FROM=""
"RTN","HLOUSR",164,0)
 F  S FROM=$O(^HLC("QUEUECOUNT","IN",FROM)) Q:FROM=""  D
"RTN","HLOUSR",165,0)
 .N COUNT,QUE,SHOW
"RTN","HLOUSR",166,0)
 .S SHOW=$$LJ(FROM,40)_"  "
"RTN","HLOUSR",167,0)
 .S QUE=""
"RTN","HLOUSR",168,0)
 .F  S QUE=$O(^HLC("QUEUECOUNT","IN",FROM,QUE)) Q:QUE=""  D
"RTN","HLOUSR",169,0)
 ..S COUNT=$G(^HLC("QUEUECOUNT","IN",FROM,QUE))
"RTN","HLOUSR",170,0)
 ..Q:COUNT<0
"RTN","HLOUSR",171,0)
 ..S VALMCNT=VALMCNT+1
"RTN","HLOUSR",172,0)
 ..S @VALMAR@(VALMCNT,0)=SHOW_$$LJ($S($$STOPPED^HLOQUE("IN",QUE):"!",1:"")_QUE,21)_" "_$$RJ(COUNT,10)
"RTN","HLOUSR",173,0)
 ..S SHOW=$$LJ("",40)_"  "
"RTN","HLOUSR",174,0)
 Q
"RTN","HLOUSR",175,0)
VIEWLINK ;
"RTN","HLOUSR",176,0)
 N C,QUIT,LINK,LINKARY,TEMP
"RTN","HLOUSR",177,0)
 S (QUIT,C,LINK)=""
"RTN","HLOUSR",178,0)
 S VALMBCK="R"
"RTN","HLOUSR",179,0)
 ;
"RTN","HLOUSR",180,0)
 ;currently HL7 (Optimized) only does TCP
"RTN","HLOUSR",181,0)
 S LINK=$$ASKLINK
"RTN","HLOUSR",182,0)
 Q:LINK=""
"RTN","HLOUSR",183,0)
 Q:'$$GETLINK^HLOTLNK(LINK,.LINKARY)
"RTN","HLOUSR",184,0)
 S LINK=LINK_":"_LINKARY("PORT")
"RTN","HLOUSR",185,0)
 W !,"Hit any key to stop...",!
"RTN","HLOUSR",186,0)
 F  D  Q:QUIT
"RTN","HLOUSR",187,0)
 .N COUNT,QUE
"RTN","HLOUSR",188,0)
 .S (COUNT,QUE)=""
"RTN","HLOUSR",189,0)
 .F  S QUE=$O(^HLC("QUEUECOUNT","OUT",LINK,QUE)) Q:QUE=""  S TEMP=$G(^HLC("QUEUECOUNT","OUT",LINK,QUE)) S:TEMP>0 COUNT=COUNT+TEMP
"RTN","HLOUSR",190,0)
 .W $C(13),"                             ",$C(13),"MESSAGES PENDING TRANSMISSION: ",IOBON,$$RJ(+COUNT,10),IOBOFF
"RTN","HLOUSR",191,0)
 .R *C:1 I $T S QUIT=1
"RTN","HLOUSR",192,0)
 Q
"RTN","HLOUSR",193,0)
 ;
"RTN","HLOUSR",194,0)
CJ(STRING,LEN) ;
"RTN","HLOUSR",195,0)
 Q $$CJ^XLFSTR($E(STRING,1,LEN),LEN)
"RTN","HLOUSR",196,0)
LJ(STRING,LEN) ;
"RTN","HLOUSR",197,0)
 Q $$LJ^XLFSTR($E(STRING,1,LEN),LEN)
"RTN","HLOUSR",198,0)
RJ(STRING,LEN) ;
"RTN","HLOUSR",199,0)
 Q $$RJ^XLFSTR($E(STRING,1,LEN),LEN)
"RTN","HLOUSR",200,0)
 ;
"RTN","HLOUSR",201,0)
RUNNING() ;Process Manager running?
"RTN","HLOUSR",202,0)
 N RUNNING
"RTN","HLOUSR",203,0)
 L +^HLTMP("PROCESS MANAGER"):0
"RTN","HLOUSR",204,0)
 S RUNNING='$T
"RTN","HLOUSR",205,0)
 I 'RUNNING L -^HLTMP("PROCESS MANAGER")
"RTN","HLOUSR",206,0)
 Q RUNNING
"RTN","HLOUSR",207,0)
 ;
"RTN","HLOUSR",208,0)
TESTLINK ;
"RTN","HLOUSR",209,0)
 N LINKNAME,OK,PORT,LINK
"RTN","HLOUSR",210,0)
 S VALMBCK="R"
"RTN","HLOUSR",211,0)
 S LINKNAME=$$ASKLINK
"RTN","HLOUSR",212,0)
 Q:LINKNAME=""
"RTN","HLOUSR",213,0)
 ;**P138 START
"RTN","HLOUSR",214,0)
 S PORT=$$ASKPORT^HLOUSRA(LINKNAME)
"RTN","HLOUSR",215,0)
 Q:'PORT
"RTN","HLOUSR",216,0)
 S LINK=LINKNAME_":"_PORT
"RTN","HLOUSR",217,0)
 ;S OK=$$IFOPEN^HLOUSR1(LINKNAME)
"RTN","HLOUSR",218,0)
 S OK=$$IFOPEN^HLOUSR1(LINK)
"RTN","HLOUSR",219,0)
 ;** P138 END
"RTN","HLOUSR",220,0)
 I OK W !,LINK_" IS operational..."
"RTN","HLOUSR",221,0)
 E  W !,LINK_" is NOT operational..."
"RTN","HLOUSR",222,0)
 W !,"Hit any key to continue..."
"RTN","HLOUSR",223,0)
 R *C:DTIME
"RTN","HLOUSR",224,0)
 Q
"RTN","HLOUSR",225,0)
 ;
"RTN","HLOUSR",226,0)
ASKLINK() ;
"RTN","HLOUSR",227,0)
 N DIC,TCP,X,Y,DTOUT,DUOUT
"RTN","HLOUSR",228,0)
 S DIC=870
"RTN","HLOUSR",229,0)
 S DIC(0)="AENQ"
"RTN","HLOUSR",230,0)
 S TCP=$O(^HLCS(869.1,"B","TCP",0))
"RTN","HLOUSR",231,0)
 S DIC("A")="Select a TCP link:"
"RTN","HLOUSR",232,0)
 S DIC("S")="I $P(^(0),U,3)=TCP"
"RTN","HLOUSR",233,0)
 D FULL^VALM1
"RTN","HLOUSR",234,0)
 D ^DIC
"RTN","HLOUSR",235,0)
 I +Y'=-1,'$D(DTOUT),'$D(DUOUT) Q $P(Y,"^",2)
"RTN","HLOUSR",236,0)
 Q ""
"RTN","HLOUSR",237,0)
 ;
"RTN","HLOUSR",238,0)
STOP ;
"RTN","HLOUSR",239,0)
 I '$$ASKYESNO^HLOUSR2("Are you SURE that you want to stop sending and receiving messages","NO") S VALMBCK="" Q
"RTN","HLOUSR",240,0)
 ;
"RTN","HLOUSR",241,0)
 D STOPHL7^HLOPROC1
"RTN","HLOUSR",242,0)
 S VALMBCK="R",VALMSG="HL7 (Optimized) has been stopped...."
"RTN","HLOUSR",243,0)
 H 5
"RTN","HLOUSR",244,0)
 D @HLRFRSH
"RTN","HLOUSR",245,0)
 ;D:HLSCREEN="Brief System Status" BRIEF^HLOUSR
"RTN","HLOUSR",246,0)
 ;D:HLSCREEN="Running Processes" PROCS^HLOUSR
"RTN","HLOUSR",247,0)
 Q
"RTN","HLOUSR",248,0)
 ;
"RTN","HLOUSR",249,0)
UPDMODE ;realtime
"RTN","HLOUSR",250,0)
 Q:'$L(HLRFRSH)
"RTN","HLOUSR",251,0)
 N TOP,BOTTOM,DX,DY,IOTM,IOBM,LINE,OLD,OLDCNT
"RTN","HLOUSR",252,0)
 S OLDCNT=VALMCNT
"RTN","HLOUSR",253,0)
 W !!!!!,IOINHI,"Hit any key to escape realtime display mode...",IOINORM
"RTN","HLOUSR",254,0)
 S IOTM=20,IOBM=23 W @IOSTBM
"RTN","HLOUSR",255,0)
 S TOP=VALMBG
"RTN","HLOUSR",256,0)
 S BOTTOM=TOP+20
"RTN","HLOUSR",257,0)
 F LINE=TOP:1:BOTTOM D
"RTN","HLOUSR",258,0)
 .I LINE>VALMCNT S @VALMAR@(LINE,0)=$$LJ(" ",80) Q
"RTN","HLOUSR",259,0)
 .S @VALMAR@(LINE,0)=$$LJ($G(@VALMAR@(LINE,0)),80)
"RTN","HLOUSR",260,0)
 F LINE=TOP:1:BOTTOM D
"RTN","HLOUSR",261,0)
 .S OLD(LINE)=$G(@VALMAR@(LINE,0))
"RTN","HLOUSR",262,0)
 F LINE=17:1:BOTTOM D
"RTN","HLOUSR",263,0)
 .S DX=50,DY=22 X IOXY W !
"RTN","HLOUSR",264,0)
 .D WRITE^VALM10(LINE)
"RTN","HLOUSR",265,0)
 D  F  R *C:4 Q:$T  D
"RTN","HLOUSR",266,0)
 .D @HLRFRSH
"RTN","HLOUSR",267,0)
 .;**START PATCH 138**
"RTN","HLOUSR",268,0)
 .S OLDCNT=VALMCNT
"RTN","HLOUSR",269,0)
 .;**END PATCH 138**
"RTN","HLOUSR",270,0)
 .F LINE=TOP:1:BOTTOM D
"RTN","HLOUSR",271,0)
 ..I LINE>VALMCNT S @VALMAR@(LINE,0)=$$LJ(" ",80) Q
"RTN","HLOUSR",272,0)
 ..S @VALMAR@(LINE,0)=$$LJ($G(@VALMAR@(LINE,0)),80)
"RTN","HLOUSR",273,0)
 .S VALMCNT=BOTTOM
"RTN","HLOUSR",274,0)
 .F LINE=TOP:1:BOTTOM IF OLD(LINE)'=$G(@VALMAR@(LINE,0)) D
"RTN","HLOUSR",275,0)
 ..S OLD(LINE)=$G(@VALMAR@(LINE,0))
"RTN","HLOUSR",276,0)
 ..S DX=50,DY=22 X IOXY W !
"RTN","HLOUSR",277,0)
 ..D WRITE^VALM10(LINE)
"RTN","HLOUSR",278,0)
 ;**START PATCH 138**
"RTN","HLOUSR",279,0)
 S VALMCNT=OLDCNT
"RTN","HLOUSR",280,0)
 I VALMCNT<VALMBG S VALMBG=VALMCNT
"RTN","HLOUSR",281,0)
 ;**END PATCH 138**
"RTN","HLOUSR",282,0)
 S VALMBCK="R"
"RTN","HLOUSR",283,0)
 Q
"RTN","HLOUSR",284,0)
 ;
"RTN","HLOUSR",285,0)
EDITSITE ;
"RTN","HLOUSR",286,0)
 ;edit HLO System Parameters
"RTN","HLOUSR",287,0)
 N DR,DA,DIE
"RTN","HLOUSR",288,0)
 S DA=$O(^HLD(779.1,0))
"RTN","HLOUSR",289,0)
 Q:'DA
"RTN","HLOUSR",290,0)
 S DIE="^HLD(779.1,"
"RTN","HLOUSR",291,0)
 S DR="[HLO EDIT SYSTEM PARAMETERS]"
"RTN","HLOUSR",292,0)
 D ^DIE
"RTN","HLOUSR",293,0)
 Q
"RTN","HLOUSR3")
0^14^B66849245^B66058788
"RTN","HLOUSR3",1,0)
HLOUSR3 ;ALB/CJM/RBN -ListManager Screen for viewing messages(continued);12 JUN 1997 10:00 am ;10/30/2008
"RTN","HLOUSR3",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,134,138,139**;Oct 13, 1995;Build 11
"RTN","HLOUSR3",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOUSR3",4,0)
 ;
"RTN","HLOUSR3",5,0)
 ;
"RTN","HLOUSR3",6,0)
EN ; Main entry point.
"RTN","HLOUSR3",7,0)
 N HLPARMS
"RTN","HLOUSR3",8,0)
 D FULL^VALM1
"RTN","HLOUSR3",9,0)
 I '$$ASK(.HLPARMS) S VALMBCK="R" Q
"RTN","HLOUSR3",10,0)
 D WAIT^DICD
"RTN","HLOUSR3",11,0)
 D EN^VALM("HLO MESSAGE SEARCH")
"RTN","HLOUSR3",12,0)
 Q
"RTN","HLOUSR3",13,0)
SEARCH ; Find a message.
"RTN","HLOUSR3",14,0)
 N I,APP,START,END,DIR,MSG,EVENT,TIME
"RTN","HLOUSR3",15,0)
 D EXIT
"RTN","HLOUSR3",16,0)
 S I=""
"RTN","HLOUSR3",17,0)
 F  S I=$O(HLPARMS(I)) Q:I=""  S @I=HLPARMS(I)
"RTN","HLOUSR3",18,0)
 K HLPARMS
"RTN","HLOUSR3",19,0)
 S (VALMCNT,I)=0
"RTN","HLOUSR3",20,0)
 S TIME=START
"RTN","HLOUSR3",21,0)
 F  S TIME=$O(^HLB("SEARCH",DIR,TIME)) Q:'TIME  Q:TIME>END  Q:VALMCNT>MAX  D
"RTN","HLOUSR3",22,0)
 .N SAPP S SAPP=""
"RTN","HLOUSR3",23,0)
 .S:APP'="" SAPP=$O(^HLB("SEARCH",DIR,TIME,APP),-1)
"RTN","HLOUSR3",24,0)
 .F  S SAPP=$O(^HLB("SEARCH",DIR,TIME,SAPP)) Q:SAPP=""  Q:$E(SAPP,1,$L(APP))]APP  Q:VALMCNT>MAX  D:$E(SAPP,1,$L(APP))=APP
"RTN","HLOUSR3",25,0)
 ..N SMSG S SMSG=""
"RTN","HLOUSR3",26,0)
 ..S:MSG'="" SMSG=$O(^HLB("SEARCH",DIR,TIME,SAPP,MSG),-1)
"RTN","HLOUSR3",27,0)
 ..F  S SMSG=$O(^HLB("SEARCH",DIR,TIME,SAPP,SMSG)) Q:SMSG=""  Q:$E(SMSG,1,$L(MSG))]MSG  Q:VALMCNT>MAX  D:$E(SMSG,1,$L(MSG))=MSG
"RTN","HLOUSR3",28,0)
 ...N SEVENT S SEVENT=""
"RTN","HLOUSR3",29,0)
 ...S:EVENT'="" SEVENT=$O(^HLB("SEARCH",DIR,TIME,SAPP,SMSG,EVENT),-1)
"RTN","HLOUSR3",30,0)
 ...F  S SEVENT=$O(^HLB("SEARCH",DIR,TIME,SAPP,SMSG,SEVENT)) Q:SEVENT=""  Q:$E(SEVENT,1,$L(EVENT))]EVENT  Q:VALMCNT>MAX  D:$E(SEVENT,1,$L(EVENT))=EVENT
"RTN","HLOUSR3",31,0)
 ....N IEN
"RTN","HLOUSR3",32,0)
 ....S IEN=""
"RTN","HLOUSR3",33,0)
 ....F  S IEN=$O(^HLB("SEARCH",DIR,TIME,SAPP,SMSG,SEVENT,IEN)) Q:IEN=""  Q:VALMCNT>MAX  D ADDTO(DIR,TIME,SAPP,SMSG,SEVENT,IEN)
"RTN","HLOUSR3",34,0)
 ;
"RTN","HLOUSR3",35,0)
 ;
"RTN","HLOUSR3",36,0)
END ; Return to List Manager.
"RTN","HLOUSR3",37,0)
 S VALMBCK="R"
"RTN","HLOUSR3",38,0)
 ;
"RTN","HLOUSR3",39,0)
 Q
"RTN","HLOUSR3",40,0)
ADDTO(DIR,TIME,APP,MSG,EVENT,IEN) ; Add message to queue.
"RTN","HLOUSR3",41,0)
 N HDR,FS,LOC,MSGID
"RTN","HLOUSR3",42,0)
 S MSGID=$S($P(IEN,"^",2):$P($G(^HLB(+IEN,3,$P(IEN,"^",2),0)),"^",2),1:$P($G(^HLB(IEN,0)),"^",1))
"RTN","HLOUSR3",43,0)
 S HDR=$G(^HLB(+IEN,1))
"RTN","HLOUSR3",44,0)
 S FS=$E(HDR,4)
"RTN","HLOUSR3",45,0)
 I FS'="" D
"RTN","HLOUSR3",46,0)
 .I DIR="IN" S LOC=$P(HDR,FS,4)
"RTN","HLOUSR3",47,0)
 .I DIR'="IN" S LOC=$P(HDR,FS,6)
"RTN","HLOUSR3",48,0)
 E  S LOC=""
"RTN","HLOUSR3",49,0)
 S @VALMAR@($$I,0)=$$LJ(MSGID,25)_$$LJ(APP,30)_" "_MSG_"~"_EVENT
"RTN","HLOUSR3",50,0)
 D CNTRL^VALM10(VALMCNT,1,25,IOINHI,IOINORM)
"RTN","HLOUSR3",51,0)
 S @VALMAR@($$I,0)="     "_$$LJ($$FMTE^XLFDT(TIME,2),20)_$$LJ(LOC,60)
"RTN","HLOUSR3",52,0)
 S @VALMAR@($$I,0)=""
"RTN","HLOUSR3",53,0)
 Q
"RTN","HLOUSR3",54,0)
LJ(STRING,LEN) ;
"RTN","HLOUSR3",55,0)
 Q $$LJ^XLFSTR(STRING,LEN)
"RTN","HLOUSR3",56,0)
 ;
"RTN","HLOUSR3",57,0)
I() ;
"RTN","HLOUSR3",58,0)
 S VALMCNT=VALMCNT+1
"RTN","HLOUSR3",59,0)
 Q VALMCNT
"RTN","HLOUSR3",60,0)
 ;
"RTN","HLOUSR3",61,0)
ASK(PARMS) ; Ask for parameter values.
"RTN","HLOUSR3",62,0)
 N SUB
"RTN","HLOUSR3",63,0)
 F SUB="START","END","EVENT","APP","MSG","DIR" S PARMS(SUB)=""
"RTN","HLOUSR3",64,0)
 S PARMS("START")=$$ASKBEGIN^HLOUSR2()
"RTN","HLOUSR3",65,0)
 Q:'PARMS("START") 0
"RTN","HLOUSR3",66,0)
 S PARMS("END")=$$ASKEND^HLOUSR2(PARMS("START"))
"RTN","HLOUSR3",67,0)
 Q:'PARMS("END") 0
"RTN","HLOUSR3",68,0)
 S PARMS("APP")=$$ASKAPP()
"RTN","HLOUSR3",69,0)
 Q:PARMS("APP")=-1 0
"RTN","HLOUSR3",70,0)
 S PARMS("MSG")=$$ASKMSG()
"RTN","HLOUSR3",71,0)
 Q:PARMS("MSG")=-1 0
"RTN","HLOUSR3",72,0)
 S PARMS("EVENT")=$$ASKEVENT()
"RTN","HLOUSR3",73,0)
 Q:PARMS("EVENT")=-1 0
"RTN","HLOUSR3",74,0)
 S PARMS("DIR")=$$ASKDIR()
"RTN","HLOUSR3",75,0)
 Q:PARMS("DIR")=-1 0
"RTN","HLOUSR3",76,0)
 ;** P139 START CJM
"RTN","HLOUSR3",77,0)
 S PARMS("DIR")=$S(PARMS("DIR")="I":"IN",PARMS("DIR")="i":"IN",1:"OUT")
"RTN","HLOUSR3",78,0)
 ;** P139 END CJM
"RTN","HLOUSR3",79,0)
 S PARMS("MAX")=$$ASKMAX()
"RTN","HLOUSR3",80,0)
 Q:'(PARMS("MAX")>-1) 0
"RTN","HLOUSR3",81,0)
 Q 1
"RTN","HLOUSR3",82,0)
 ;
"RTN","HLOUSR3",83,0)
ASKMAX() ; Ask for the maximum number of messages.
"RTN","HLOUSR3",84,0)
 N DIR
"RTN","HLOUSR3",85,0)
 S DIR(0)="N^1:30000:0"
"RTN","HLOUSR3",86,0)
 S DIR("A")="Maximum List Size"
"RTN","HLOUSR3",87,0)
 S DIR("B")=1000
"RTN","HLOUSR3",88,0)
 S DIR("?",1)="In case a large number of messages meet your search criteria, what are the"
"RTN","HLOUSR3",89,0)
 S DIR("?")="maximum number of messages to display? (30,000 maximum)"
"RTN","HLOUSR3",90,0)
 D ^DIR
"RTN","HLOUSR3",91,0)
 Q:$D(DTOUT)!$D(DUOUT) -1
"RTN","HLOUSR3",92,0)
 Q 3*(X-1)
"RTN","HLOUSR3",93,0)
ASKAPP() ; Ask for application name.
"RTN","HLOUSR3",94,0)
 N DIR
"RTN","HLOUSR3",95,0)
 S DIR(0)="FO^0:60"
"RTN","HLOUSR3",96,0)
 S DIR("A")="Application"
"RTN","HLOUSR3",97,0)
 S DIR("?",1)="Enter the name of the application, or '^' to exit."
"RTN","HLOUSR3",98,0)
 S DIR("?")="You can enter just the first part of the name."
"RTN","HLOUSR3",99,0)
 D ^DIR
"RTN","HLOUSR3",100,0)
 Q:$D(DTOUT)!$D(DUOUT) -1
"RTN","HLOUSR3",101,0)
 Q X
"RTN","HLOUSR3",102,0)
ASKMSG() ;
"RTN","HLOUSR3",103,0)
 N DIR
"RTN","HLOUSR3",104,0)
 S DIR(0)="FO^0:3"
"RTN","HLOUSR3",105,0)
 S DIR("A")="HL7 Message Type"
"RTN","HLOUSR3",106,0)
 S DIR("?",1)="Enter the 3 character message type (e.g. MFN, ADT), or '^' to exit."
"RTN","HLOUSR3",107,0)
 S DIR("?")="You can enter just the first character or two."
"RTN","HLOUSR3",108,0)
 D ^DIR
"RTN","HLOUSR3",109,0)
 Q:$D(DTOUT)!$D(DUOUT) -1
"RTN","HLOUSR3",110,0)
 Q X
"RTN","HLOUSR3",111,0)
ASKEVENT() ; Ask for event.
"RTN","HLOUSR3",112,0)
 N DIR
"RTN","HLOUSR3",113,0)
 S DIR(0)="FO^0:3"
"RTN","HLOUSR3",114,0)
 S DIR("A")="HL7 Event"
"RTN","HLOUSR3",115,0)
 S DIR("?",1)="Enter the 3 character event type, or '^' to exit."
"RTN","HLOUSR3",116,0)
 S DIR("?")="You can enter just the first character or two."
"RTN","HLOUSR3",117,0)
 D ^DIR
"RTN","HLOUSR3",118,0)
 Q:$D(DTOUT)!$D(DUOUT) -1
"RTN","HLOUSR3",119,0)
 Q X
"RTN","HLOUSR3",120,0)
ASKDIR() ; Ask message direction
"RTN","HLOUSR3",121,0)
 N DIR
"RTN","HLOUSR3",122,0)
 S DIR(0)="S^I:INCOMING;O:OUTGOING"
"RTN","HLOUSR3",123,0)
 S DIR("A")="Incoming or Outgoing"
"RTN","HLOUSR3",124,0)
 S DIR("?",1)="Are you searching for an incoming message or an outgoing message?"
"RTN","HLOUSR3",125,0)
 S DIR("?")="You can enter '^' to exit"
"RTN","HLOUSR3",126,0)
 D ^DIR
"RTN","HLOUSR3",127,0)
 Q:$D(DTOUT)!$D(DUOUT) -1
"RTN","HLOUSR3",128,0)
 Q X
"RTN","HLOUSR3",129,0)
HDR ; Set the List Manager header
"RTN","HLOUSR3",130,0)
 S VALMHDR(1)="MsgID                    Application                    MsgType"
"RTN","HLOUSR3",131,0)
 Q
"RTN","HLOUSR3",132,0)
HLP ;
"RTN","HLOUSR3",133,0)
 Q
"RTN","HLOUSR3",134,0)
EXIT ; Clean up and exit back to List Manager
"RTN","HLOUSR3",135,0)
 D CLEAN^VALM10
"RTN","HLOUSR3",136,0)
 D CLEAR^VALM1
"RTN","HLOUSR3",137,0)
 S VALMBCK="R"
"RTN","HLOUSR3",138,0)
 Q
"RTN","HLOUSR3",139,0)
 ;
"RTN","HLOUSR3",140,0)
SETPURGE ; Set a message up for purging.
"RTN","HLOUSR3",141,0)
 N MSG,DIR
"RTN","HLOUSR3",142,0)
 S VALMBCK="R"
"RTN","HLOUSR3",143,0)
 Q:'$G(MSGIEN)
"RTN","HLOUSR3",144,0)
 Q:'$$GETMSG^HLOMSG(+MSGIEN,.MSG)
"RTN","HLOUSR3",145,0)
 I MSG("STATUS")="",'MSG("STATUS","PURGE") W !,"Can not set purge yet!" D PAUSE^VALM1 Q
"RTN","HLOUSR3",146,0)
 S DIR(0)="D^"_DT_":"_$$FMADD^XLFDT(DT,+45)_":E"
"RTN","HLOUSR3",147,0)
 S DIR("A")="When should the message be purged?"
"RTN","HLOUSR3",148,0)
 D ^DIR
"RTN","HLOUSR3",149,0)
 D:Y SETPURGE^HLOAPI3(+MSGIEN,Y),DISPLAY^HLOUSR1
"RTN","HLOUSR3",150,0)
 Q
"RTN","HLOUSR3",151,0)
SCREEN() ;  Screen for message purge status.
"RTN","HLOUSR3",152,0)
 N TRUE
"RTN","HLOUSR3",153,0)
 S TRUE=1
"RTN","HLOUSR3",154,0)
 I $P($G(X),"^",3)="SET PURGE" D  Q TRUE
"RTN","HLOUSR3",155,0)
 .N MSG
"RTN","HLOUSR3",156,0)
 .I '$G(MSGIEN) S TRUE=0 Q
"RTN","HLOUSR3",157,0)
 .I '$$GETMSG^HLOMSG(+MSGIEN,.MSG) S TRUE=0 Q
"RTN","HLOUSR3",158,0)
 .I MSG("STATUS")="",'MSG("STATUS","PURGE") S TRUE=0
"RTN","HLOUSR3",159,0)
 S:'TRUE VALMBCK="R"
"RTN","HLOUSR3",160,0)
 Q TRUE
"RTN","HLOUSR3",161,0)
 ;;**Start Patch HL*1.6.138 **
"RTN","HLOUSR3",162,0)
 ;;The following three subroutines have been added for HL*1.6*138 - RBN
"RTN","HLOUSR3",163,0)
 ;;
"RTN","HLOUSR3",164,0)
RESEND ; If outbound message has been sent, resends it.
"RTN","HLOUSR3",165,0)
 N CONF
"RTN","HLOUSR3",166,0)
 D OWNSKEY^XUSRB(.CONF,"HLOMGR",DUZ)
"RTN","HLOUSR3",167,0)
 I CONF(0)'=1 D  Q
"RTN","HLOUSR3",168,0)
 . W !,"**** You are not authorized to use this option ****" D PAUSE^VALM1 Q
"RTN","HLOUSR3",169,0)
 Q:$$VERIFY^HLOQUE1()=-1
"RTN","HLOUSR3",170,0)
 N MSG,DIR,ERROR,FLG,OLDIEN,SYS
"RTN","HLOUSR3",171,0)
 S OLDIEN=MSGIEN
"RTN","HLOUSR3",172,0)
 I $G(OPT1DIS) D  K OPT1DIS Q
"RTN","HLOUSR3",173,0)
 . W !,"Sorry that option is not available for this message." D PAUSE^VALM1 Q
"RTN","HLOUSR3",174,0)
 S VALMBCK="R"
"RTN","HLOUSR3",175,0)
 Q:'$G(MSGIEN)
"RTN","HLOUSR3",176,0)
 Q:'$$GETMSG^HLOMSG(+MSGIEN,.MSG)
"RTN","HLOUSR3",177,0)
 I MSG("DIRECTION")'="OUT" W !,"Message is not an outbound message" D PAUSE^VALM1 Q
"RTN","HLOUSR3",178,0)
 I MSG("STATUS")="",'MSG("DT/TM") W !,"Message has not been sent!" D PAUSE^VALM1 Q
"RTN","HLOUSR3",179,0)
 S MSGIEN=$$RESEND^HLOAPI3(+MSGIEN,.ERROR)
"RTN","HLOUSR3",180,0)
 I $G(ERROR) W ERROR D PAUSE^VALM1 Q
"RTN","HLOUSR3",181,0)
 W !,"The message has been copied to MsgID ",MSGIEN," which will be displayed next"
"RTN","HLOUSR3",182,0)
 I $$ASKYESNO^HLOUSR2("Do you want the original message purged?","NO") D
"RTN","HLOUSR3",183,0)
 . D SYSPARMS^HLOSITE(.SYS)
"RTN","HLOUSR3",184,0)
 . S HLOPURDT=$$FMADD^XLFDT($$NOW^XLFDT,0,SYS("ERROR PURGE"),0,0)
"RTN","HLOUSR3",185,0)
 . S FLG=$$SETPURGE^HLOAPI3(OLDIEN,HLOPURDT)
"RTN","HLOUSR3",186,0)
 S FLG=$$GETMSG^HLOMSG(+MSGIEN,.MSG)
"RTN","HLOUSR3",187,0)
 D DISPLAY^HLOUSR1
"RTN","HLOUSR3",188,0)
 Q
"RTN","HLOUSR3",189,0)
 ;
"RTN","HLOUSR3",190,0)
REPROC ; If inbound message has been processed, reprocesses it.
"RTN","HLOUSR3",191,0)
 N CONF
"RTN","HLOUSR3",192,0)
 D FULL^VALM1
"RTN","HLOUSR3",193,0)
 D OWNSKEY^XUSRB(.CONF,"HLOMGR",DUZ)
"RTN","HLOUSR3",194,0)
 I CONF(0)'=1 D  Q
"RTN","HLOUSR3",195,0)
 . W !,"**** You are not authorized to use this option ****" D PAUSE^VALM1 Q
"RTN","HLOUSR3",196,0)
 Q:$$VERIFY^HLOQUE1()=-1
"RTN","HLOUSR3",197,0)
 N MSG,DIR,ERROR,SYSPARM
"RTN","HLOUSR3",198,0)
 I $G(OPT2DIS) D  K OPT2DIS Q
"RTN","HLOUSR3",199,0)
 . W !,"Sorry that option is not available for this message." D PAUSE^VALM1 Q
"RTN","HLOUSR3",200,0)
 S VALMBCK="R"
"RTN","HLOUSR3",201,0)
 Q:'$G(MSGIEN)
"RTN","HLOUSR3",202,0)
 Q:'$$GETMSG^HLOMSG(+MSGIEN,.MSG)
"RTN","HLOUSR3",203,0)
 I MSG("DIRECTION")'="IN" W !,"Message is not an inbound message" D PAUSE^VALM1 Q
"RTN","HLOUSR3",204,0)
 I MSG("STATUS")="",'MSG("STATUS","APP HANDOFF") W !,"Message has not been processed" D PAUSE^VALM1 Q
"RTN","HLOUSR3",205,0)
 I '$$PROCNOW^HLOAPI3(+MSGIEN,"",.ERROR) W ERROR D PAUSE^VALM1 Q
"RTN","HLOUSR3",206,0)
 W !,"Done!  The message has been reprocessed by the application."
"RTN","HLOUSR3",207,0)
 S DIR(0)="D^"_DT_":"_$$FMADD^XLFDT(DT,+45)_":E"
"RTN","HLOUSR3",208,0)
 I '$$ASKYESNO^HLOUSR2("Do you want to purge the message?","NO") D
"RTN","HLOUSR3",209,0)
 . D SYSPARMS^HLOSITE(.SYSPARM)
"RTN","HLOUSR3",210,0)
 . S HLOPURDT=$$FMADD^XLFDT($$NOW^XLFDT,0,SYSPARM("ERROR PURGE"),0,0)
"RTN","HLOUSR3",211,0)
 . S FLG=$$SETPURGE^HLOAPI3(MSGIEN,HLOPURDT)
"RTN","HLOUSR3",212,0)
 Q
"RTN","HLOUSR3",213,0)
 ;
"RTN","HLOUSR3",214,0)
MSGPREP ; Enable or disable menu options
"RTN","HLOUSR3",215,0)
 N MSG,FDA,ERR
"RTN","HLOUSR3",216,0)
 D GETMSG^HLOMSG(MSGIEN,.MSG)
"RTN","HLOUSR3",217,0)
 I 'MSG("DT/TM") D            ; Message has not been sent/processed
"RTN","HLOUSR3",218,0)
 .  S (OPT1DIS,OPT2DIS)=1
"RTN","HLOUSR3",219,0)
 I MSG("DIRECTION")="OUT" D   ; Msg outbound and sent ; disable MP
"RTN","HLOUSR3",220,0)
 .  S OPT2DIS=1
"RTN","HLOUSR3",221,0)
 I MSG("DIRECTION")="IN" D    ; Msg inbound and sent ; disable MR
"RTN","HLOUSR3",222,0)
 .  S OPT1DIS=1
"RTN","HLOUSR3",223,0)
 S VALMBCK="R"
"RTN","HLOUSR3",224,0)
 Q
"RTN","HLOUSR3",225,0)
 ;;**End Patch HL*1.6*138 **
"VER")
8.0^22.0
"^DD",779.1,779.1,0)
FIELD^^.12^12
"^DD",779.1,779.1,0,"DDA")
N
"^DD",779.1,779.1,0,"DT")
3080428
"^DD",779.1,779.1,0,"IX","B",779.1,.01)

"^DD",779.1,779.1,0,"NM","HLO SYSTEM PARAMETERS")

"^DD",779.1,779.1,0,"VRPK")
HL
"^DD",779.1,779.1,.01,0)
DOMAIN NAME^RF^^0;1^K:$L(X)>64!($L(X)<3)!'(X'?1P.E) X
"^DD",779.1,779.1,.01,1,0)
^.1
"^DD",779.1,779.1,.01,1,1,0)
779.1^B
"^DD",779.1,779.1,.01,1,1,1)
S ^HLD(779.1,"B",$E(X,1,60),DA)=""
"^DD",779.1,779.1,.01,1,1,2)
K ^HLD(779.1,"B",$E(X,1,60),DA)
"^DD",779.1,779.1,.01,3)
The domain name for this system.  It will be used to populate component 2 of the Sending Facility field of the HL7 message header.
"^DD",779.1,779.1,.01,21,0)
^^2^2^3040805^
"^DD",779.1,779.1,.01,21,1,0)
The domain name for this system.  It will be used to populate component 2
"^DD",779.1,779.1,.01,21,2,0)
of the Sending Facility field of the HL7 message headers.
"^DD",779.1,779.1,.01,"DT")
3040805
"^DD",779.1,779.1,.02,0)
STATION NUMBER^F^^0;2^K:$L(X)>7!($L(X)<3) X
"^DD",779.1,779.1,.02,3)
Enter the station number with suffix that this system belongs under.  It will be used in component 1 of the Sending Facility field of the HL7 message header.
"^DD",779.1,779.1,.02,"DT")
3040805
"^DD",779.1,779.1,.03,0)
PRODUCTION ID^RS^P:production;T:training;^0;3^Q
"^DD",779.1,779.1,.03,3)
ENTER P if this is a production system, T otherwise.
"^DD",779.1,779.1,.03,"DT")
3040805
"^DD",779.1,779.1,.04,0)
MAXIMUM STRING LENGTH^NJ5,0^^0;4^K:+X'=X!(X>99999)!(X<1)!(X?.E1"."1N.N) X
"^DD",779.1,779.1,.04,3)
This is the maximum length for strings built by HLO when local applications create new messages to send.
"^DD",779.1,779.1,.04,21,0)
^^4^4^3050706^
"^DD",779.1,779.1,.04,21,1,0)
This parameter determines the maximum length for strings that HLO will create
"^DD",779.1,779.1,.04,21,2,0)
when messages are being built.  It doesn't apply to servers, as the size of
"^DD",779.1,779.1,.04,21,3,0)
input buffer used by TCP/IP determines the maximum string length created by a
"^DD",779.1,779.1,.04,21,4,0)
single read.
"^DD",779.1,779.1,.04,"DT")
3050706
"^DD",779.1,779.1,.05,0)
BUFFER SIZE FOR HL7 (BYTES)^NJ5,0^^0;5^K:+X'=X!(X>20000)!(X<10000)!(X?.E1"."1.N) X
"^DD",779.1,779.1,.05,3)
This parameter represents the size of the buffer used by HLO for its background processes.  It defaults to 15000 bytes, but may be set from 10,000 bytes to 20,000 bytes.
"^DD",779.1,779.1,.05,"DT")
3050805
"^DD",779.1,779.1,.06,0)
BUFFER SIZE FOR USER (BYTES)^NJ5,0^^0;6^K:+X'=X!(X>10000)!(X<512)!(X?.E1"."1.N) X
"^DD",779.1,779.1,.06,3)
This parameter is the size of the buffer used by HLO in the context of an online user.  It defaults to 5000, but may be reset to between 512 and 10000 bytes.
"^DD",779.1,779.1,.06,"DT")
3050805
"^DD",779.1,779.1,.07,0)
NORMAL MSG RETENTION (HOURS)^NJ2,0^^0;7^K:+X'=X!(X>96)!(X<36)!(X?.E1"."1.N) X
"^DD",779.1,779.1,.07,3)
How many hours should successfully completed messages remain on your system? (36-96 hours, defaults to 36 hours) 
"^DD",779.1,779.1,.07,21,0)
^^7^7^3050317^^^
"^DD",779.1,779.1,.07,21,1,0)
This field controls the purging of HL7 messages whose completion status
"^DD",779.1,779.1,.07,21,2,0)
is SUCCESSFUL. It is in hours, since messages normally should be purged 
"^DD",779.1,779.1,.07,21,3,0)
very soon after completion, with an allowed range of 36 to 94 hours.
"^DD",779.1,779.1,.07,21,4,0)
 
"^DD",779.1,779.1,.07,21,5,0)
36 is the default because this 1) will result in most messages being purged
"^DD",779.1,779.1,.07,21,6,0)
at night and 2) provides sufficient time for the Capacity Planning statistics
"^DD",779.1,779.1,.07,21,7,0)
to be extracted. 
"^DD",779.1,779.1,.07,"DT")
3050317
"^DD",779.1,779.1,.08,0)
BAD MESSAGE RETENTION (DAYS)^NJ2,0^^0;8^K:+X'=X!(X>45)!(X<5)!(X?.E1"."1.N) X
"^DD",779.1,779.1,.08,3)
How many days should message with errors remain on your system?  (7-45 days, defaults to 7 days)
"^DD",779.1,779.1,.08,21,0)
^^4^4^3041115^
"^DD",779.1,779.1,.08,21,1,0)
This field controls the purging of HL7 messages that do not complete
"^DD",779.1,779.1,.08,21,2,0)
successfully.  The period should be reasonably long to allow
"^DD",779.1,779.1,.08,21,3,0)
investigation, but because of the extremely high daily volume of
"^DD",779.1,779.1,.08,21,4,0)
messages purging must occur quickly.
"^DD",779.1,779.1,.08,"DT")
3041115
"^DD",779.1,779.1,.09,0)
HLO ON/OFF SWITCH^S^0:OFF;1:ON;^0;9^Q
"^DD",779.1,779.1,.09,3)
Set to 0 to turn off messaging and all HL7 processes.
"^DD",779.1,779.1,.09,"DT")
3050503
"^DD",779.1,779.1,.1,0)
HLO STANDARD LISTENER^*P870'^HLCS(870,^0;10^S DIC("S")="I ($P($G(^HLCS(870,Y,400)),""^"",3)=""M"")!($P($G(^HLCS(870,Y,400)),""^"",3)=""S"")" D ^DIC K DIC S DIC=$G(DIE),X=+Y K:Y<0 X
"^DD",779.1,779.1,.1,3)
Select an entry from the HL Logical Link file that is the listener that remote applications will normally connect to.
"^DD",779.1,779.1,.1,12)
This screen allows only server entries to be selected.
"^DD",779.1,779.1,.1,12.1)
S DIC("S")="I ($P($G(^HLCS(870,Y,400)),""^"",3)=""M"")!($P($G(^HLCS(870,Y,400)),""^"",3)=""S"")"
"^DD",779.1,779.1,.1,"DT")
3050601
"^DD",779.1,779.1,.11,0)
HLO RECOUNT ON/OFF FLAG^S^0:OFF;1:ON;^0;11^Q
"^DD",779.1,779.1,.11,3)
Set to 1 to disallow update of queues when a recount is being performed.
"^DD",779.1,779.1,.11,"DT")
3071025
"^DD",779.1,779.1,.12,0)
UNSENT MSG RETENTION (DAYS)^NJ3,0^^0;12^K:+X'=X!(X>999)!(X<1)!(X?.E1"."1.N) X
"^DD",779.1,779.1,.12,3)
How many days should an unsent message be kept before it is purged? (default value is 45 days)
"^DD",779.1,779.1,.12,"DT")
3080723
"^DD",779.2,779.2,0)
FIELD^^.12^14
"^DD",779.2,779.2,0,"DDA")
N
"^DD",779.2,779.2,0,"DT")
3081002
"^DD",779.2,779.2,0,"IX","B",779.2,.01)

"^DD",779.2,779.2,0,"NM","HLO APPLICATION REGISTRY")

"^DD",779.2,779.2,0,"VRPK")
HL
"^DD",779.2,779.2,.01,0)
APPLICATION NAME^RF^^0;1^K:$L(X)>60!($L(X)<3)!'(X'?1P.E) X
"^DD",779.2,779.2,.01,.1)

"^DD",779.2,779.2,.01,1,0)
^.1
"^DD",779.2,779.2,.01,1,1,0)
779.2^B
"^DD",779.2,779.2,.01,1,1,1)
S ^HLD(779.2,"B",$E(X,1,60),DA)=""
"^DD",779.2,779.2,.01,1,1,2)
K ^HLD(779.2,"B",$E(X,1,60),DA)
"^DD",779.2,779.2,.01,3)
Answer must be 3-60 characters in length. It must be unique and should be name-spaced.
"^DD",779.2,779.2,.01,"DT")
3081110
"^DD",779.2,779.2,.02,0)
RESPONSE LINK (OPTIONAL)^FX^^0;2^K:'$$CHKLINK^HLOTLNK(X) X
"^DD",779.2,779.2,.02,3)
If the return link cannot be identified via the Sending Facility (i.e., sent via an IE), what link should the application ack be sent through?
"^DD",779.2,779.2,.02,21,0)
^^5^5^3041116^^
"^DD",779.2,779.2,.02,21,1,0)
This field applies only if: 1) The receiving application is expected to 
"^DD",779.2,779.2,.02,21,2,0)
return application acknowledgments.  2) The initial message is  received 
"^DD",779.2,779.2,.02,21,3,0)
indirectly through the IE, and the  receiving application in turn does 
"^DD",779.2,779.2,.02,21,4,0)
not want to send the application acknowledgment directly back to the 
"^DD",779.2,779.2,.02,21,5,0)
sending facility identified in the message header.  
"^DD",779.2,779.2,.02,"DT")
3041116
"^DD",779.2,779.2,.03,0)
DEFAULT PRIVATE IN-QUEUE^F^^0;3^K:$L(X)>20!($L(X)<3) X
"^DD",779.2,779.2,.03,3)
You may create an optional default private in-queue by entering a unique name up to 20 characters in length. Queues specified for specific message types take precedence.
"^DD",779.2,779.2,.03,"DT")
3050317
"^DD",779.2,779.2,.04,0)
BATCH ACTION TAG^F^^0;4^K:$L(X)>8!($L(X)<1) X
"^DD",779.2,779.2,.04,3)
If the application utilizes batch messages, the action to perform upon receipt of the message should be entered in the BATCH ACTION TAG and BATCH ACTION ROUTINE fields as <tag>^<routine>.
"^DD",779.2,779.2,.04,"DT")
3040814
"^DD",779.2,779.2,.05,0)
BATCH ACTION ROUTINE^F^^0;5^K:$L(X)>8!($L(X)<3) X
"^DD",779.2,779.2,.05,3)
If the application utilizes batch messages, the action to perform upon receipt of the message should be entered in the BATCH ACTION TAG and BATCH ACTION ROUTINE fields as <tag>^<routine>.
"^DD",779.2,779.2,.05,"DT")
3040814
"^DD",779.2,779.2,.06,0)
DEFAULT ACTION TAG^F^^0;6^K:$L(X)>8!($L(X)<1) X
"^DD",779.2,779.2,.06,3)
You can enter the action to perform upon  receipt of a message where no other action applies by entering the DEFAULT ACTION TAG and DEFAULT ACTION ROUTINE fields as <tag>^<routine>. 
"^DD",779.2,779.2,.06,"DT")
3040815
"^DD",779.2,779.2,.07,0)
DEFAULT ACTION ROUTINE^F^^0;7^K:$L(X)>8!($L(X)<3) X
"^DD",779.2,779.2,.07,3)
You can enter the action to perform upon receipt of a message where no other action applies by entering the DEFAULT ACTION TAG and DEFAULT ACTION ROUTINE fields as <tag>^<routine>.
"^DD",779.2,779.2,.07,"DT")
3040814
"^DD",779.2,779.2,.08,0)
BATCH PRIVATE IN-QUEUE^F^^0;8^K:$L(X)>20!($L(X)<3) X
"^DD",779.2,779.2,.08,3)
You may establish a private queue for your batch messages by entering a unique name (name-spaced) up to 20 characters long.
"^DD",779.2,779.2,.08,"DT")
3050317
"^DD",779.2,779.2,.09,0)
APPLICATION SPECIFIC LISTENER^*P870'X^HLCS(870,^0;9^S DIC("S")="I $P($G(^HLCS(870,Y,400)),""^"",3)'="""",""SM""[$P(^HLCS(870,Y,400),""^"",3)" D ^DIC K DIC S DIC=$G(DIE),X=+Y K:Y<0 X
"^DD",779.2,779.2,.09,3)
If your application requires its own listener (HIGHLY DISCOURAGED), enter it here.
"^DD",779.2,779.2,.09,12)
The link entered must be a listener.
"^DD",779.2,779.2,.09,12.1)
S DIC("S")="I $P($G(^HLCS(870,Y,400)),""^"",3)'="""",""SM""[$P(^HLCS(870,Y,400),""^"",3)"
"^DD",779.2,779.2,.09,21,0)
^^6^6^3050503^
"^DD",779.2,779.2,.09,21,1,0)
Applications are highly discouraged from establishing their own listeners.  The
"^DD",779.2,779.2,.09,21,2,0)
use of the multi-listeners provide concurrent processing of many connections
"^DD",779.2,779.2,.09,21,3,0)
over the same port, so a dedicated listener will not provide an application
"^DD",779.2,779.2,.09,21,4,0)
with a performance boost, while it will cause the site additional work to
"^DD",779.2,779.2,.09,21,5,0)
maintain. So before establishing a dedicated listener, the application
"^DD",779.2,779.2,.09,21,6,0)
developer should verify the need.
"^DD",779.2,779.2,.09,"DT")
3061120
"^DD",779.2,779.2,.1,0)
SEQUENCE EXCEPTION TAG^F^^0;10^K:$L(X)>8!($L(X)<1) X
"^DD",779.2,779.2,.1,3)
What is the tag to invoke the sequencing exception routine at?
"^DD",779.2,779.2,.1,"DT")
3070705
"^DD",779.2,779.2,.11,0)
SEQUENCE EXCEPTION ROUTINE^F^^0;11^K:$L(X)>8!($L(X)<1) X
"^DD",779.2,779.2,.11,3)
What routine should be invoked when a sequencing exception is encountered?
"^DD",779.2,779.2,.11,"DT")
3070705
"^DD",779.2,779.2,.12,0)
SEQUENCING TIMEOUT^NJ4,0^^0;12^K:+X'=X!(X>9999)!(X<5)!(X?.E1"."1.N) X
"^DD",779.2,779.2,.12,3)
Enter how long to wait for an applicaiton ack used in sequencing before rasing an exception.  Enter between 5 (minutes) and 9999 (minutes). 
"^DD",779.2,779.2,.12,"DT")
3070726
"^DD",779.2,779.2,1,0)
MESSAGE TYPE ACTIONS^779.21I^^1;0
"^DD",779.2,779.2,1,21,0)
^^2^2^3070103^^
"^DD",779.2,779.2,1,21,1,0)

"^DD",779.2,779.2,1,21,2,0)

"^DD",779.2,779.2,2,0)
Package File Link^RP9.4'^DIC(9.4,^2;1^Q
"^DD",779.2,779.2,2,3)
Enter the package responsible for these messages.
"^DD",779.2,779.2,2,21,0)
^^3^3^3050919^^
"^DD",779.2,779.2,2,21,1,0)
This field holds a pointer to the Package File for the Package 
"^DD",779.2,779.2,2,21,2,0)
responsible for these messages.
"^DD",779.2,779.2,2,21,3,0)

"^DD",779.2,779.2,2,"DT")
3050919
"^DD",779.2,779.21,0)
MESSAGE TYPE ACTIONS SUB-FIELD^^.07^7
"^DD",779.2,779.21,0,"DT")
3081002
"^DD",779.2,779.21,0,"ID",.02)
W "   ",$P(^(0),U,2)
"^DD",779.2,779.21,0,"ID",.06)
W "   ",$P(^(0),U,6)
"^DD",779.2,779.21,0,"IX","B",779.21,.01)

"^DD",779.2,779.21,0,"NM","MESSAGE TYPE ACTIONS")

"^DD",779.2,779.21,0,"UP")
779.2
"^DD",779.2,779.21,.01,0)
HL7 MESSAGE TYPE^MF^^0;1^K:$L(X)>3!($L(X)<3) X
"^DD",779.2,779.21,.01,1,0)
^.1
"^DD",779.2,779.21,.01,1,1,0)
779.21^B
"^DD",779.2,779.21,.01,1,1,1)
S ^HLD(779.2,DA(1),1,"B",$E(X,1,30),DA)=""
"^DD",779.2,779.21,.01,1,1,2)
K ^HLD(779.2,DA(1),1,"B",$E(X,1,30),DA)
"^DD",779.2,779.21,.01,3)
Enter the 3 character HL7 Message Type.
"^DD",779.2,779.21,.01,21,0)
^^3^3^3040814^
"^DD",779.2,779.21,.01,21,1,0)
An application should use this multiple to define the action that the receiving
"^DD",779.2,779.21,.01,21,2,0)
application needs to perform upon receipt of a specific type of HL7 message,
"^DD",779.2,779.21,.01,21,3,0)
identified by the HL7 MESSAGE TYPE and HL7 EVENT fields.
"^DD",779.2,779.21,.01,"DT")
3081002
"^DD",779.2,779.21,.02,0)
HL7 EVENT^RF^^0;2^K:$L(X)>3!($L(X)<3) X
"^DD",779.2,779.21,.02,3)
Enter the 3 character HL7 event type.
"^DD",779.2,779.21,.02,"DT")
3081002
"^DD",779.2,779.21,.03,0)
PRIVATE IN-QUEUE^F^^0;3^K:$L(X)>20!($L(X)<3) X
"^DD",779.2,779.21,.03,3)
You may create a private in-queue for message of this type by entering a unique name up to 20 characters long.
"^DD",779.2,779.21,.03,"DT")
3050919
"^DD",779.2,779.21,.04,0)
ACTION TAG^F^^0;4^K:$L(X)>8!($L(X)<1) X
"^DD",779.2,779.21,.04,3)
You must enter the action to perform upon receipt of this type by entering the ACTION TAG and ACTION ROUTINE fields as <tag>^<routine>. The tag is optional. 
"^DD",779.2,779.21,.04,"DT")
3040815
"^DD",779.2,779.21,.05,0)
ACTION ROUTINE^RF^^0;5^K:$L(X)>8!($L(X)<3) X
"^DD",779.2,779.21,.05,3)
You must enter the action to perform upon receipt of this type by entering the ACTION TAG and ACTION ROUTINE fields as <tag>^<routine>.
"^DD",779.2,779.21,.05,"DT")
3050919
"^DD",779.2,779.21,.06,0)
HL7 VERSION^F^^0;6^K:$L(X)>20!($L(X)<1) X
"^DD",779.2,779.21,.06,3)
Leave blank UNLESS this action applies only to a specific version of the message!  Enter the version exactly as it will appear in the message header.
"^DD",779.2,779.21,.06,"DT")
3081002
"^DD",779.2,779.21,.07,0)
INACTIVE^S^1:INACTIVE;^0;7^Q
"^DD",779.2,779.21,.07,3)
Enter '1' to stop the application from generating messages of this type.
"^DD",779.2,779.21,.07,21,0)
^^4^4^3060621^
"^DD",779.2,779.21,.07,21,1,0)
This flag is made available to the application, but it is up to the application
"^DD",779.2,779.21,.07,21,2,0)
to honor it.   In otherwords, its up to the application to check the flag and
"^DD",779.2,779.21,.07,21,3,0)
decide whether or not to generate messages of this type.
"^DD",779.2,779.21,.07,21,4,0)

"^DD",779.2,779.21,.07,"DT")
3060621
"^DD",779.3,779.3,.02,0)
ACTIVE^S^0:NO;1:YES;^0;2^Q
"^DD",779.3,779.3,.02,1,0)
^.1
"^DD",779.3,779.3,.02,1,1,0)
779.3^C
"^DD",779.3,779.3,.02,1,1,1)
S ^HLD(779.3,"C",$E(X,1,30),DA)=""
"^DD",779.3,779.3,.02,1,1,2)
K ^HLD(779.3,"C",$E(X,1,30),DA)
"^DD",779.3,779.3,.02,1,1,"%D",0)
^^2^2^3081106^
"^DD",779.3,779.3,.02,1,1,"%D",1,0)
Used to find active process types.
"^DD",779.3,779.3,.02,1,1,"%D",2,0)

"^DD",779.3,779.3,.02,1,1,"DT")
3081106
"^DD",779.3,779.3,.02,3)
Enter 1 to activate these processes, 0 to inactivate.
"^DD",779.3,779.3,.02,21,0)
^^4^4^3050805^^^^
"^DD",779.3,779.3,.02,21,1,0)
A flag that indicates whether or not this type of process is active under 
"^DD",779.3,779.3,.02,21,2,0)
the HLO Process Manager. Some processes may not apply to some 
"^DD",779.3,779.3,.02,21,3,0)
systems, for example, a particular site may not use the Taskman 
"^DD",779.3,779.3,.02,21,4,0)
multi-listener. 
"^DD",779.3,779.3,.02,"DT")
3081106
"^DIC",779.1,779.1,0)
HLO SYSTEM PARAMETERS^779.1
"^DIC",779.1,779.1,0,"GL")
^HLD(779.1,
"^DIC",779.1,779.1,"%",0)
^1.005^^0
"^DIC",779.1,779.1,"%D",0)
^1.001^2^2^3050801^^^^
"^DIC",779.1,779.1,"%D",1,0)
This file contains parameters used by the HLO (HL7 Optimized)
"^DIC",779.1,779.1,"%D",2,0)
that are specific to the system the software is installed on.
"^DIC",779.1,"B","HLO SYSTEM PARAMETERS",779.1)

"^DIC",779.2,779.2,0)
HLO APPLICATION REGISTRY^779.2
"^DIC",779.2,779.2,0,"GL")
^HLD(779.2,
"^DIC",779.2,779.2,"%",0)
^1.005^^0
"^DIC",779.2,779.2,"%D",0)
^^12^12^3050801^^^^
"^DIC",779.2,779.2,"%D",1,0)
This file is used to register sending and receiving applications for HL7
"^DIC",779.2,779.2,"%D",2,0)
messaging. For receiving applications, the process of registration consists of
"^DIC",779.2,779.2,"%D",3,0)
registering what messages the application is prepared to receive.
"^DIC",779.2,779.2,"%D",4,0)

"^DIC",779.2,779.2,"%D",5,0)
For both sending and receiving applications, it is necessary to specify
"^DIC",779.2,779.2,"%D",6,0)
what package the application belongs to.  For sending applications, that is
"^DIC",779.2,779.2,"%D",7,0)
the only field that applies, other than the name of the sending application.
"^DIC",779.2,779.2,"%D",8,0)

"^DIC",779.2,779.2,"%D",9,0)
An application can be either a sender or a receiver of messages, or both. In 
"^DIC",779.2,779.2,"%D",10,0)
order for an application to receive messages, it must specify an action 
"^DIC",779.2,779.2,"%D",11,0)
(M tag^routine) for each type of message that it is capable of receiving, or a
"^DIC",779.2,779.2,"%D",12,0)
default action that applies when no messsage-specific action is defined.
"^DIC",779.2,"B","HLO APPLICATION REGISTRY",779.2)

"BLD",1102,6)
^115
**END**
**END**
