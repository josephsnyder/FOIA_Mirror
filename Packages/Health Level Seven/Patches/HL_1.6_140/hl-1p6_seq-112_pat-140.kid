Released HL*1.6*140 SEQ #112
Extracted from mail message
**KIDS**:HL*1.6*140^

**INSTALL NAME**
HL*1.6*140
"BLD",1074,0)
HL*1.6*140^HEALTH LEVEL SEVEN^0^3080502^y
"BLD",1074,4,0)
^9.64PA^870^1
"BLD",1074,4,870,0)
870
"BLD",1074,4,870,2,0)
^9.641^870^1
"BLD",1074,4,870,2,870,0)
HL LOGICAL LINK  (File-top level)
"BLD",1074,4,870,2,870,1,0)
^9.6411^400.09^1
"BLD",1074,4,870,2,870,1,400.09,0)
TCP/IP OPENFAIL TIMEOUT
"BLD",1074,4,870,222)
y^n^p^^^^n^^n
"BLD",1074,4,870,224)

"BLD",1074,4,"APDD",870,870)

"BLD",1074,4,"APDD",870,870,400.09)

"BLD",1074,4,"B",870,870)

"BLD",1074,6.3)
5
"BLD",1074,"KRN",0)
^9.67PA^779.2^20
"BLD",1074,"KRN",.4,0)
.4
"BLD",1074,"KRN",.401,0)
.401
"BLD",1074,"KRN",.402,0)
.402
"BLD",1074,"KRN",.403,0)
.403
"BLD",1074,"KRN",.403,"NM",0)
^9.68A^1^1
"BLD",1074,"KRN",.403,"NM",1,0)
HL7 LOGICAL LINK    FILE #870^870^0
"BLD",1074,"KRN",.403,"NM","B","HL7 LOGICAL LINK    FILE #870",1)

"BLD",1074,"KRN",.5,0)
.5
"BLD",1074,"KRN",.84,0)
.84
"BLD",1074,"KRN",3.6,0)
3.6
"BLD",1074,"KRN",3.8,0)
3.8
"BLD",1074,"KRN",9.2,0)
9.2
"BLD",1074,"KRN",9.8,0)
9.8
"BLD",1074,"KRN",9.8,"NM",0)
^9.68A^8^8
"BLD",1074,"KRN",9.8,"NM",1,0)
HLCSIN^^0^B37729374
"BLD",1074,"KRN",9.8,"NM",2,0)
HLCSLM^^0^B44880128
"BLD",1074,"KRN",9.8,"NM",3,0)
HLTP3^^0^B75311331
"BLD",1074,"KRN",9.8,"NM",4,0)
HLCSTCP1^^0^B73767277
"BLD",1074,"KRN",9.8,"NM",5,0)
HLCSTCP4^^0^B45823270
"BLD",1074,"KRN",9.8,"NM",6,0)
HLCSTCP^^0^B47334373
"BLD",1074,"KRN",9.8,"NM",7,0)
HLCSTCP2^^0^B70352129
"BLD",1074,"KRN",9.8,"NM",8,0)
HLMA^^0^B52398960
"BLD",1074,"KRN",9.8,"NM","B","HLCSIN",1)

"BLD",1074,"KRN",9.8,"NM","B","HLCSLM",2)

"BLD",1074,"KRN",9.8,"NM","B","HLCSTCP",6)

"BLD",1074,"KRN",9.8,"NM","B","HLCSTCP1",4)

"BLD",1074,"KRN",9.8,"NM","B","HLCSTCP2",7)

"BLD",1074,"KRN",9.8,"NM","B","HLCSTCP4",5)

"BLD",1074,"KRN",9.8,"NM","B","HLMA",8)

"BLD",1074,"KRN",9.8,"NM","B","HLTP3",3)

"BLD",1074,"KRN",19,0)
19
"BLD",1074,"KRN",19.1,0)
19.1
"BLD",1074,"KRN",101,0)
101
"BLD",1074,"KRN",409.61,0)
409.61
"BLD",1074,"KRN",771,0)
771
"BLD",1074,"KRN",779.2,0)
779.2
"BLD",1074,"KRN",870,0)
870
"BLD",1074,"KRN",8989.51,0)
8989.51
"BLD",1074,"KRN",8989.52,0)
8989.52
"BLD",1074,"KRN",8994,0)
8994
"BLD",1074,"KRN","B",.4,.4)

"BLD",1074,"KRN","B",.401,.401)

"BLD",1074,"KRN","B",.402,.402)

"BLD",1074,"KRN","B",.403,.403)

"BLD",1074,"KRN","B",.5,.5)

"BLD",1074,"KRN","B",.84,.84)

"BLD",1074,"KRN","B",3.6,3.6)

"BLD",1074,"KRN","B",3.8,3.8)

"BLD",1074,"KRN","B",9.2,9.2)

"BLD",1074,"KRN","B",9.8,9.8)

"BLD",1074,"KRN","B",19,19)

"BLD",1074,"KRN","B",19.1,19.1)

"BLD",1074,"KRN","B",101,101)

"BLD",1074,"KRN","B",409.61,409.61)

"BLD",1074,"KRN","B",771,771)

"BLD",1074,"KRN","B",779.2,779.2)

"BLD",1074,"KRN","B",870,870)

"BLD",1074,"KRN","B",8989.51,8989.51)

"BLD",1074,"KRN","B",8989.52,8989.52)

"BLD",1074,"KRN","B",8994,8994)

"BLD",1074,"QUES",0)
^9.62^^
"BLD",1074,"REQB",0)
^9.611^2^2
"BLD",1074,"REQB",1,0)
HL*1.6*122^2
"BLD",1074,"REQB",2,0)
HL*1.6*123^2
"BLD",1074,"REQB","B","HL*1.6*122",1)

"BLD",1074,"REQB","B","HL*1.6*123",2)

"FIA",870)
HL LOGICAL LINK
"FIA",870,0)
^HLCS(870,
"FIA",870,0,0)
870
"FIA",870,0,1)
y^n^p^^^^n^^n
"FIA",870,0,10)

"FIA",870,0,11)

"FIA",870,0,"RLRO")

"FIA",870,0,"VR")
1.6^HL
"FIA",870,870)
1
"FIA",870,870,400.09)

"KRN",.403,30,-1)
0^1
"KRN",.403,30,0)
HL7 LOGICAL LINK^@^@^^2990706.1207^^^870^0^0^1
"KRN",.403,30,40,0)
^.4031I^5^5
"KRN",.403,30,40,1,0)
1^^1,1
"KRN",.403,30,40,1,1)
Page 1
"KRN",.403,30,40,1,40,0)
^.4032IP^144^2
"KRN",.403,30,40,1,40,143,0)
HL7 LL HEADER1^1^1,1^d
"KRN",.403,30,40,1,40,144,0)
HL7 LL BLK1^2^2,1^e
"KRN",.403,30,40,2,0)
3^^3,3^^^1^14,77
"KRN",.403,30,40,2,1)
Page 3
"KRN",.403,30,40,2,40,0)
^.4032IP^145^1
"KRN",.403,30,40,2,40,145,0)
HL7 LLP HLLP^1^1,2^e
"KRN",.403,30,40,2,40,145,1)

"KRN",.403,30,40,3,0)
5^^3,3^^^1^17,77
"KRN",.403,30,40,3,1)
Page 5
"KRN",.403,30,40,3,40,0)
^.4032IP^146^1
"KRN",.403,30,40,3,40,146,0)
HL7 LLP TCP^1^1,2^e
"KRN",.403,30,40,3,40,146,1)

"KRN",.403,30,40,4,0)
2^^3,3^^^1^7,77
"KRN",.403,30,40,4,1)
Page 2
"KRN",.403,30,40,4,40,0)
^.4032IP^147^1
"KRN",.403,30,40,4,40,147,0)
HL7 LLP MAIL^1^1,2^e
"KRN",.403,30,40,4,40,147,1)

"KRN",.403,30,40,5,0)
4^^3,3^^^1^14,77
"KRN",.403,30,40,5,1)
Page 4
"KRN",.403,30,40,5,40,0)
^.4032IP^148^1
"KRN",.403,30,40,5,40,148,0)
HL7 LLP X3.28^1^1,2^e
"KRN",.403,30,40,5,40,148,1)

"KRN",.404,143,0)
HL7 LL HEADER1^870^
"KRN",.404,143,40,0)
^.4044I^3^2
"KRN",.404,143,40,1,0)
1^HL7 LOGICAL LINK^1
"KRN",.404,143,40,1,2)
^^1,27
"KRN",.404,143,40,3,0)
3^--------------------------------------------------------------------------------^1
"KRN",.404,143,40,3,2)
^^2,1
"KRN",.404,144,0)
HL7 LL BLK1^870
"KRN",.404,144,40,0)
^.4044I^8^8
"KRN",.404,144,40,1,0)
1^NODE^3
"KRN",.404,144,40,1,1)
.01
"KRN",.404,144,40,1,2)
4,23^10^4,17
"KRN",.404,144,40,1,4)
1
"KRN",.404,144,40,2,0)
2^INSTITUTION^3
"KRN",.404,144,40,2,1)
.02
"KRN",.404,144,40,2,2)
6,23^30^6,10
"KRN",.404,144,40,3,0)
3^MAILMAN DOMAIN^3
"KRN",.404,144,40,3,1)
.03
"KRN",.404,144,40,3,2)
8,23^30^8,7
"KRN",.404,144,40,4,0)
6^LLP TYPE^3
"KRN",.404,144,40,4,1)
2
"KRN",.404,144,40,4,2)
14,23^30^14,13
"KRN",.404,144,40,4,4)
1
"KRN",.404,144,40,4,10)
S DDSSTACK="PAGE "_(1+X)
"KRN",.404,144,40,5,0)
4^AUTOSTART^3
"KRN",.404,144,40,5,1)
4.5
"KRN",.404,144,40,5,2)
10,23^8^10,12
"KRN",.404,144,40,6,0)
5^QUEUE SIZE^3
"KRN",.404,144,40,6,1)
21
"KRN",.404,144,40,6,2)
12,23^6^12,11
"KRN",.404,144,40,6,3)
10
"KRN",.404,144,40,7,0)
7^DNS DOMAIN^3
"KRN",.404,144,40,7,1)
.08
"KRN",.404,144,40,7,2)
16,23^30^16,11
"KRN",.404,144,40,8,0)
8^DESCRIPTION^3
"KRN",.404,144,40,8,1)
1
"KRN",.404,144,40,8,2)
4,67^1^4,54
"KRN",.404,145,0)
HL7 LLP HLLP^870
"KRN",.404,145,40,0)
^.4044I^11^10
"KRN",.404,145,40,1,0)
1^HLLP LOWER LEVEL PARAMETERS^1
"KRN",.404,145,40,1,2)
^^1,24
"KRN",.404,145,40,2,0)
2^^3
"KRN",.404,145,40,2,1)
.01
"KRN",.404,145,40,2,2)
2,24^30
"KRN",.404,145,40,2,4)
^^^1
"KRN",.404,145,40,4,0)
9^BLOCK SIZE^3
"KRN",.404,145,40,4,1)
200.03
"KRN",.404,145,40,4,2)
11,15^3^11,3
"KRN",.404,145,40,5,0)
3^HLLP DEVICE^3
"KRN",.404,145,40,5,1)
200.01
"KRN",.404,145,40,5,2)
5,15^30^5,2
"KRN",.404,145,40,6,0)
6^RE-TRANSMISION ATTEMPTS^3
"KRN",.404,145,40,6,1)
200.02
"KRN",.404,145,40,6,2)
7,70^2^7,45
"KRN",.404,145,40,7,0)
5^READ TIMEOUT^3
"KRN",.404,145,40,7,1)
200.04
"KRN",.404,145,40,7,2)
7,15^3^7,1
"KRN",.404,145,40,8,0)
7^ACK TIMEOUT^3
"KRN",.404,145,40,8,1)
200.05
"KRN",.404,145,40,8,2)
9,15^3^9,2
"KRN",.404,145,40,9,0)
8^LLP START BLOCK^3
"KRN",.404,145,40,9,1)
200.06
"KRN",.404,145,40,9,2)
9,70^2^9,53
"KRN",.404,145,40,10,0)
10^LLP END BLOCK^3
"KRN",.404,145,40,10,1)
200.07
"KRN",.404,145,40,10,2)
11,70^2^11,55
"KRN",.404,145,40,11,0)
4^PROTOCOL ID VERSION^3
"KRN",.404,145,40,11,1)
200.08
"KRN",.404,145,40,11,2)
5,70^3^5,49
"KRN",.404,146,0)
HL7 LLP TCP^870
"KRN",.404,146,40,0)
^.4044I^18^16
"KRN",.404,146,40,1,0)
1^TCP LOWER LEVEL PARAMETERS^1
"KRN",.404,146,40,1,2)
^^1,23
"KRN",.404,146,40,2,0)
2^^3
"KRN",.404,146,40,2,1)
.01
"KRN",.404,146,40,2,2)
2,23^30
"KRN",.404,146,40,2,4)
^^^1
"KRN",.404,146,40,4,0)
7^RE-TRANSMISION ATTEMPTS^3
"KRN",.404,146,40,4,1)
200.02
"KRN",.404,146,40,4,2)
9,64^2^9,39
"KRN",.404,146,40,5,0)
10^BLOCK SIZE^3
"KRN",.404,146,40,5,1)
200.03
"KRN",.404,146,40,5,2)
11,17^3^11,5
"KRN",.404,146,40,6,0)
8^READ TIMEOUT^3
"KRN",.404,146,40,6,1)
200.04
"KRN",.404,146,40,6,2)
10,17^3^10,3
"KRN",.404,146,40,7,0)
6^ACK TIMEOUT^3
"KRN",.404,146,40,7,1)
200.05
"KRN",.404,146,40,7,2)
9,17^3^9,4
"KRN",.404,146,40,8,0)
15^UNI-DIRECTIONAL WAIT^3
"KRN",.404,146,40,8,1)
200.09
"KRN",.404,146,40,8,2)
14,64^2^14,42
"KRN",.404,146,40,9,0)
4^TCP/IP ADDRESS^3
"KRN",.404,146,40,9,1)
400.01
"KRN",.404,146,40,9,2)
5,24^40^5,8
"KRN",.404,146,40,10,0)
5^TCP/IP PORT^3
"KRN",.404,146,40,10,1)
400.02
"KRN",.404,146,40,10,2)
6,24^5^6,11
"KRN",.404,146,40,11,0)
3^TCP/IP SERVICE TYPE^3
"KRN",.404,146,40,11,1)
400.03
"KRN",.404,146,40,11,2)
4,24^15^4,3
"KRN",.404,146,40,11,13)
I X'="C" F HLI=200.02,200.09,400.04,400.05 D UNED^DDSUTL(HLI,"","",1)
"KRN",.404,146,40,12,0)
13^PERSISTENT^3
"KRN",.404,146,40,12,1)
400.04
"KRN",.404,146,40,12,2)
13,64^3^13,52
"KRN",.404,146,40,13,0)
14^RETENTION^3
"KRN",.404,146,40,13,1)
400.05
"KRN",.404,146,40,13,2)
14,15^6^14,4
"KRN",.404,146,40,14,0)
12^STARTUP NODE^3
"KRN",.404,146,40,14,1)
400.06
"KRN",.404,146,40,14,2)
13,15^20^13,1
"KRN",.404,146,40,15,0)
9^EXCEED RE-TRANSMIT ACTION^3
"KRN",.404,146,40,15,1)
200.021
"KRN",.404,146,40,15,2)
10,64^10^10,37
"KRN",.404,146,40,15,4)
0
"KRN",.404,146,40,16,0)
11^SAY HELO^3
"KRN",.404,146,40,16,1)
400.07
"KRN",.404,146,40,16,2)
11,64^3^11,54
"KRN",.404,146,40,17,0)
5.1^TCP/IP PORT (OPTIMIZED)^3
"KRN",.404,146,40,17,1)
400.08
"KRN",.404,146,40,17,2)
7,36^5^7,11
"KRN",.404,146,40,18,0)
11.1^TCP/IP OPENFAIL TIMEOUT^3
"KRN",.404,146,40,18,1)
400.09
"KRN",.404,146,40,18,2)
12,64^2^12,39
"KRN",.404,147,0)
HL7 LLP MAIL^870
"KRN",.404,147,40,0)
^.4044I^5^3
"KRN",.404,147,40,1,0)
1^MAILMAN LOWER LEVEL PARAMETERS^1
"KRN",.404,147,40,1,2)
^^1,23
"KRN",.404,147,40,4,0)
2^MAIL GROUP^3
"KRN",.404,147,40,4,1)
100.01
"KRN",.404,147,40,4,2)
4,23^30^4,11
"KRN",.404,147,40,4,4)
0
"KRN",.404,147,40,5,0)
3^^3
"KRN",.404,147,40,5,1)
.01
"KRN",.404,147,40,5,2)
2,23^30
"KRN",.404,147,40,5,4)
^^^1
"KRN",.404,148,0)
HL7 LLP X3.28^870
"KRN",.404,148,40,0)
^.4044I^10^9
"KRN",.404,148,40,1,0)
1^X3.28 LOWER LEVEL PARAMETERS^1
"KRN",.404,148,40,1,2)
^^1,23
"KRN",.404,148,40,2,0)
2^^3
"KRN",.404,148,40,2,1)
.01
"KRN",.404,148,40,2,2)
2,23^30
"KRN",.404,148,40,2,4)
^^^1
"KRN",.404,148,40,4,0)
3^X3.28 DEVICE^3
"KRN",.404,148,40,4,1)
300.01
"KRN",.404,148,40,4,2)
5,24^30^5,10
"KRN",.404,148,40,5,0)
4^MAXIMUM MESSAGE SIZE^3
"KRN",.404,148,40,5,1)
300.02
"KRN",.404,148,40,5,2)
7,24^5^7,2
"KRN",.404,148,40,6,0)
5^MAXIMUM BLOCK SIZE^3
"KRN",.404,148,40,6,1)
300.03
"KRN",.404,148,40,6,2)
7,69^3^7,49
"KRN",.404,148,40,7,0)
6^TIMER A^3
"KRN",.404,148,40,7,1)
300.04
"KRN",.404,148,40,7,2)
9,24^2^9,15
"KRN",.404,148,40,8,0)
8^TIMER B^3
"KRN",.404,148,40,8,1)
300.05
"KRN",.404,148,40,8,2)
11,24^2^11,15
"KRN",.404,148,40,9,0)
7^TIMER D^3
"KRN",.404,148,40,9,1)
300.06
"KRN",.404,148,40,9,2)
9,69^2^9,60
"KRN",.404,148,40,10,0)
9^TIMER E^3
"KRN",.404,148,40,10,1)
300.07
"KRN",.404,148,40,10,2)
11,69^3^11,60
"MBREQ")
0
"ORD",8,.403)
.403;8;;;EDEOUT^DIFROMSO(.403,DA,"",XPDA);FPRE^DIFROMSI(.403,"",XPDA);EPRE^DIFROMSI(.403,DA,$E("N",$G(XPDNEW)),XPDA,"",OLDA);;EPOST^DIFROMSI(.403,DA,"",XPDA);DEL^DIFROMSK(.403,"",%)
"ORD",8,.403,0)
FORM
"PKG",9,-1)
1^1
"PKG",9,0)
HEALTH LEVEL SEVEN^HL^DHCP IMPLEMENTATION OF HEALTH LEVEL SEVEN^
"PKG",9,20,0)
^9.402P^^
"PKG",9,22,0)
^9.49I^1^1
"PKG",9,22,1,0)
1.6^2980130^2980130^6
"PKG",9,22,1,"PAH",1,0)
140^3080502
"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
NO
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
NO
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
NO
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
8
"RTN","HLCSIN")
0^1^B37729374^B34245145
"RTN","HLCSIN",1,0)
HLCSIN ;ALB/JRP - INCOMING FILER;01-MAY-95 ;03/17/2008  17:15
"RTN","HLCSIN",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**2,30,14,19,62,109,115,122,140**;Oct 13, 1995;Build 5
"RTN","HLCSIN",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLCSIN",4,0)
STARTIN ;Main entry point for incoming background filer
"RTN","HLCSIN",5,0)
 ;Create/find entry denoting this filer in the INCOMING FILER TASK
"RTN","HLCSIN",6,0)
 ; NUMBER multiple (field #20) of the HL COMMUNICATION SERVER PARAMETER
"RTN","HLCSIN",7,0)
 ; file (#869.3)
"RTN","HLCSIN",8,0)
 N HLFLG,HLEXIT,HLPTRFLR
"RTN","HLCSIN",9,0)
 ;
"RTN","HLCSIN",10,0)
 ; patch HL*1.6*122
"RTN","HLCSIN",11,0)
 ;; N HLDUZ,DUZ  ; patch HL*1.6*122 TEST v2: DUZ code removed
"RTN","HLCSIN",12,0)
 N HLDUZ
"RTN","HLCSIN",13,0)
 S HLDUZ=+$G(DUZ)
"RTN","HLCSIN",14,0)
 ;
"RTN","HLCSIN",15,0)
 S HLPTRFLR=+$$CRTFLR^HLCSUTL1(ZTSK,"IN")
"RTN","HLCSIN",16,0)
 ;Loop through Logical Links and check for incoming messages
"RTN","HLCSIN",17,0)
 S HLEXIT=0
"RTN","HLCSIN",18,0)
 ; patch HL*1.6*122 TEST v2: DUZ code removed
"RTN","HLCSIN",19,0)
 ; patch HL*1.6*122, set DUZ for application proxy user
"RTN","HLCSIN",20,0)
 ;; D PROXY^HLCSTCP4
"RTN","HLCSIN",21,0)
 S HLPTRFLR("$J")=$J
"RTN","HLCSIN",22,0)
 F  D  Q:HLEXIT
"RTN","HLCSIN",23,0)
 . S HLFLG=0
"RTN","HLCSIN",24,0)
 . D DEFACK(.HLPTRFLR,.HLFLG,.HLEXIT) Q:HLEXIT
"RTN","HLCSIN",25,0)
 . D ACKNOW(.HLPTRFLR,.HLFLG,.HLEXIT) Q:HLEXIT
"RTN","HLCSIN",26,0)
 . Q:HLFLG
"RTN","HLCSIN",27,0)
 . I $$HDIFF^XLFDT($H,$G(HLPTRFLR("LASTDEL")),2)>3600 D  Q
"RTN","HLCSIN",28,0)
 . . S HLPTRFLR("LASTDEL")=$H    ; maintain queue sizes
"RTN","HLCSIN",29,0)
 . . D DELQUE(.HLPTRFLR,.HLEXIT) ; no more than once an hour.
"RTN","HLCSIN",30,0)
 . ; patch HL*1.6*122
"RTN","HLCSIN",31,0)
 . ; H 5
"RTN","HLCSIN",32,0)
 . H 1
"RTN","HLCSIN",33,0)
 . D CHKUPD(.HLPTRFLR,.HLEXIT) Q:HLEXIT
"RTN","HLCSIN",34,0)
 S ZTSTOP=1 ;Asked to stop
"RTN","HLCSIN",35,0)
 D DELFLR^HLCSUTL1(HLPTRFLR,"IN") ;Delete entry denoting this filer
"RTN","HLCSIN",36,0)
 S ZTREQ="@"
"RTN","HLCSIN",37,0)
 Q
"RTN","HLCSIN",38,0)
DEFACK(HLPTRFLR,HLFLG,HLEXIT) ; Process TCP links with a deferred response
"RTN","HLCSIN",39,0)
 N HLXX,HLD0,HLPCT
"RTN","HLCSIN",40,0)
 S HLXX=0
"RTN","HLCSIN",41,0)
 F  S HLXX=$O(^HLMA("AC","I",HLXX)) Q:'HLXX  D  Q:HLEXIT
"RTN","HLCSIN",42,0)
 . ; HL*1.6*122, check the in-queue stop flag
"RTN","HLCSIN",43,0)
 . Q:$P($G(^HLCS(870,HLXX,0)),"^",9)
"RTN","HLCSIN",44,0)
 . D CHKUPD(.HLPTRFLR,.HLEXIT) Q:HLEXIT
"RTN","HLCSIN",45,0)
 . ; patch HL*1.6*109: Does another filer have this?
"RTN","HLCSIN",46,0)
 . ; L +^HLMA("AC","I",HLXX):0 Q:'$T
"RTN","HLCSIN",47,0)
 . ; patch HL*1.6*140 - change the lock node, it conflicts with
"RTN","HLCSIN",48,0)
 . ; lock defined in routine, HLCSREP.
"RTN","HLCSIN",49,0)
 . ; L +^HLMA("AC","I",HLXX):2 Q:'$T  ; patch HL*1.6*122
"RTN","HLCSIN",50,0)
 . L +^HLMA("IN-FILER","AC","I",HLXX):2 Q:'$T  ; patch HL*1.6*122
"RTN","HLCSIN",51,0)
 . S HLD0=0,HLFLG=1
"RTN","HLCSIN",52,0)
 . ; HL*1.6*109 changes in for loop below, and post-quit code placed
"RTN","HLCSIN",53,0)
 . ; on following lines.
"RTN","HLCSIN",54,0)
 . S HLPCT=0 ; Counter whether filer should stop every 100th entry.
"RTN","HLCSIN",55,0)
 .;**109 - insure queue last processed at least 2 seconds ago
"RTN","HLCSIN",56,0)
 . ; patch HL*1.6*140
"RTN","HLCSIN",57,0)
 . ; I ($$HDIFF^XLFDT($H,$G(^XTMP("HL7-AC","I",HLXX)),2)<2) L -^HLMA("AC","I",HLXX) Q
"RTN","HLCSIN",58,0)
 . I ($$HDIFF^XLFDT($H,$G(^XTMP("HL7-AC","I",HLXX)),2)<2) L -^HLMA("IN-FILER","AC","I",HLXX) Q
"RTN","HLCSIN",59,0)
 . F  S HLD0=$O(^HLMA("AC","I",HLXX,HLD0)) Q:'HLD0!(HLEXIT)  D
"RTN","HLCSIN",60,0)
 .. ; patch HL*1.6*122 start
"RTN","HLCSIN",61,0)
 .. ; patch HL*1.6*122 TEST v2: DUZ code removed
"RTN","HLCSIN",62,0)
 .. ; DUZ comparison/reset for application proxy user
"RTN","HLCSIN",63,0)
 .. ;; D HLDUZ^HLCSTCP4
"RTN","HLCSIN",64,0)
 .. D HLDUZ2^HLCSTCP4
"RTN","HLCSIN",65,0)
 .. ; protect HLDUZ
"RTN","HLCSIN",66,0)
 .. N HLDUZ
"RTN","HLCSIN",67,0)
 .. S HLPCT=HLPCT+1
"RTN","HLCSIN",68,0)
 .. I '(HLPCT#100) D CHKUPD(.HLPTRFLR,.HLEXIT) Q:HLEXIT
"RTN","HLCSIN",69,0)
 .. ; L +^HLMA(HLD0):0 Q:'$T
"RTN","HLCSIN",70,0)
 .. F  L +^HLMA(HLD0):30 Q:$T  H 1
"RTN","HLCSIN",71,0)
 .. I '$$CHECKAC("I",HLXX,HLD0) L -^HLMA(HLD0) Q  ;-> Quit if not a valid AC xref
"RTN","HLCSIN",72,0)
 .. D DEFACK^HLTP3(HLXX,HLD0)
"RTN","HLCSIN",73,0)
 .. D DEQUE^HLCSREP(HLXX,"I",HLD0)
"RTN","HLCSIN",74,0)
 .. L -^HLMA(HLD0)
"RTN","HLCSIN",75,0)
 . ; patch HL*1.6*122 end
"RTN","HLCSIN",76,0)
 . ;**109 -add dt/tm stamp to time queue last processed
"RTN","HLCSIN",77,0)
 . S ^XTMP("HL7-AC","I",HLXX)=$H
"RTN","HLCSIN",78,0)
 . ;**109 -unlock the queue
"RTN","HLCSIN",79,0)
 . ; patch HL*1.6*140
"RTN","HLCSIN",80,0)
 . ; L -^HLMA("AC","I",HLXX)
"RTN","HLCSIN",81,0)
 . L -^HLMA("IN-FILER","AC","I",HLXX)
"RTN","HLCSIN",82,0)
 Q
"RTN","HLCSIN",83,0)
 ;
"RTN","HLCSIN",84,0)
CHECKAC(WAY,IEN870,IEN773) ; If AC xref shouldn't exist, kill it...
"RTN","HLCSIN",85,0)
 ;
"RTN","HLCSIN",86,0)
 ; Check status and if 3 (processed) kill XREF...
"RTN","HLCSIN",87,0)
 I $P($G(^HLMA(+IEN773,"P")),U)=3 D  QUIT "" ;->
"RTN","HLCSIN",88,0)
 .  D DEQUE^HLCSREP(IEN870,WAY,IEN773)
"RTN","HLCSIN",89,0)
 ;
"RTN","HLCSIN",90,0)
 ; Add other checks here in the future...
"RTN","HLCSIN",91,0)
 ;
"RTN","HLCSIN",92,0)
 Q 1
"RTN","HLCSIN",93,0)
 ;
"RTN","HLCSIN",94,0)
ACKNOW(HLPTRFLR,HLFLG,HLEXIT) ; Process Logical Link's IN-queue for received message
"RTN","HLCSIN",95,0)
 N HLXX,HLD0,HLD1
"RTN","HLCSIN",96,0)
 S HLXX=0
"RTN","HLCSIN",97,0)
 F  S HLXX=$O(^HLCS(870,"AISTAT","P",HLXX)) Q:'HLXX  D  Q:HLEXIT
"RTN","HLCSIN",98,0)
 . ; HL*1.6*122, check the in-queue stop flag
"RTN","HLCSIN",99,0)
 . Q:$P($G(^HLCS(870,HLXX,0)),"^",9)
"RTN","HLCSIN",100,0)
 . D CHKUPD(.HLPTRFLR,.HLEXIT) Q:HLEXIT
"RTN","HLCSIN",101,0)
 . ; HL*1.6*109: Does another filer have this?
"RTN","HLCSIN",102,0)
 . ; L +^HLCS(870,HLXX,"INFILER"):0 Q:'$T
"RTN","HLCSIN",103,0)
 . L +^HLCS(870,HLXX,"INFILER"):2 Q:'$T  ; patch HL*1.6*122
"RTN","HLCSIN",104,0)
 . F  D CHKUPD(.HLPTRFLR,.HLEXIT) Q:HLEXIT  S HLD0=$$DEQUEUE^HLCSQUE(HLXX,"IN") Q:+HLD0<0  D
"RTN","HLCSIN",105,0)
 .. ;
"RTN","HLCSIN",106,0)
 .. ; patch HL*1.6*122 start
"RTN","HLCSIN",107,0)
 .. ; clean variables except Kernel related variables
"RTN","HLCSIN",108,0)
 .. D
"RTN","HLCSIN",109,0)
 ... ; protect variables defined in STARTIN^HLCSIN
"RTN","HLCSIN",110,0)
 ... N HLFLG,HLEXIT,HLPTRFLR
"RTN","HLCSIN",111,0)
 ... N HLDUZ
"RTN","HLCSIN",112,0)
 ... ; protect variables defined in ACKNOW^HLCSIN
"RTN","HLCSIN",113,0)
 ... N HLXX,HLD0,HLD1
"RTN","HLCSIN",114,0)
 ... D KILL^XUSCLEAN
"RTN","HLCSIN",115,0)
 .. ;
"RTN","HLCSIN",116,0)
 .. ; patch HL*1.6*122 TEST v2: DUZ code removed
"RTN","HLCSIN",117,0)
 .. ; DUZ comparison/reset for application proxy user
"RTN","HLCSIN",118,0)
 .. ;; D HLDUZ^HLCSTCP4
"RTN","HLCSIN",119,0)
 .. D HLDUZ2^HLCSTCP4
"RTN","HLCSIN",120,0)
 .. ; protect HLDUZ
"RTN","HLCSIN",121,0)
 .. N HLDUZ
"RTN","HLCSIN",122,0)
 .. ;Make sure message is ready to be received
"RTN","HLCSIN",123,0)
 .. S HLFLG=1
"RTN","HLCSIN",124,0)
 .. S HLD1=$P(HLD0,"^",2)
"RTN","HLCSIN",125,0)
 .. S HLD0=+HLD0 ; At this point, HLD0=HLXX
"RTN","HLCSIN",126,0)
 .. I $P($G(^HLCS(870,HLD0,1,HLD1,0)),"^",3)'="A" D  Q
"RTN","HLCSIN",127,0)
 ... D MONITOR^HLCSDR2("D",2,HLD0,HLD1,"IN") ;Set status to DONE
"RTN","HLCSIN",128,0)
 .. D RECEIVE^HLMA0(HLD0,HLD1) ;Process received message
"RTN","HLCSIN",129,0)
 .. D MONITOR^HLCSDR2("D",2,HLD0,HLD1,"IN") ;Set status to DONE
"RTN","HLCSIN",130,0)
 . ; patch HL*1.6*122 end
"RTN","HLCSIN",131,0)
 . I HLD0<0,$D(^HLCS(870,"AISTAT","P",HLXX)) D
"RTN","HLCSIN",132,0)
 . . S HLD1=0 ; Make sure there aren't any loose xrefs hanging around.
"RTN","HLCSIN",133,0)
 . . F  S HLD1=$O(^HLCS(870,"AISTAT","P",HLXX,HLD1)) Q:'HLD1  D
"RTN","HLCSIN",134,0)
 . . . ;I '$D(^HLCS(870,HLXX,1,HLD1,0)) K ^HLCS(870,"AISTAT","P",HLXX,HLD1)
"RTN","HLCSIN",135,0)
 . . . I $P($G(^HLCS(870,HLXX,1,HLD1,0)),U,2)'="P" K ^HLCS(870,"AISTAT","P",HLXX,HLD1)
"RTN","HLCSIN",136,0)
 . L -^HLCS(870,HLXX,"INFILER")
"RTN","HLCSIN",137,0)
 Q
"RTN","HLCSIN",138,0)
DELQUE(HLPTRFLR,HLEXIT) ; Delete messages outside the 'queue size' window.
"RTN","HLCSIN",139,0)
 N HLDIR,HLXX,HLFRONT
"RTN","HLCSIN",140,0)
 S HLDIR=1,HLXX=0
"RTN","HLCSIN",141,0)
 F  S HLXX=$O(^HLCS(870,HLXX)) Q:'HLXX  D  Q:HLEXIT
"RTN","HLCSIN",142,0)
 . D CHKUPD(.HLPTRFLR,.HLEXIT) Q:HLEXIT
"RTN","HLCSIN",143,0)
 . ; patch HL*1.6*122, comment out, no need to lock
"RTN","HLCSIN",144,0)
 . ; L +^HLCS(870,HLXX,"IN QUEUE FRONT POINTER"):0 Q:'$T
"RTN","HLCSIN",145,0)
 . S HLFRONT=$G(^HLCS(870,HLXX,"IN QUEUE FRONT POINTER"))
"RTN","HLCSIN",146,0)
 . ; patch HL*1.6*122, comment out
"RTN","HLCSIN",147,0)
 . ; L -^HLCS(870,HLXX,"IN QUEUE FRONT POINTER")
"RTN","HLCSIN",148,0)
 . D DELETE^HLCSQUE1(HLXX,HLDIR,HLFRONT)
"RTN","HLCSIN",149,0)
 Q
"RTN","HLCSIN",150,0)
CHKUPD(HLPTRFLR,HLEXIT) ;
"RTN","HLCSIN",151,0)
 Q:$$HDIFF^XLFDT($H,$G(HLPTRFLR("LASTUP")),2)<15
"RTN","HLCSIN",152,0)
 D SETFLRDH^HLCSUTL1(HLPTRFLR,"IN") ; Update LAST KNOWN $H (field #.03) for filer
"RTN","HLCSIN",153,0)
 S HLPTRFLR("LASTUP")=$H
"RTN","HLCSIN",154,0)
 D CHK4STOP^HLCSUTL2(HLPTRFLR,"IN",.HLEXIT) Q:HLEXIT
"RTN","HLCSIN",155,0)
 Q
"RTN","HLCSLM")
0^2^B44880128^B44055037
"RTN","HLCSLM",1,0)
HLCSLM ;SFCIOFO/AC - HL7 LINK MANAGER ;03/19/2008  10:01
"RTN","HLCSLM",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**49,57,109,123,140**;Oct 13, 1995;Build 5
"RTN","HLCSLM",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLCSLM",4,0)
 ;
"RTN","HLCSLM",5,0)
EN ;Entry point for start up task
"RTN","HLCSLM",6,0)
 N %,HLEVLCHK,HLTSKCNT
"RTN","HLCSLM",7,0)
 F %=1:1:10 L +^HLCS("HLCSLM"):2 Q:$T
"RTN","HLCSLM",8,0)
 E  Q
"RTN","HLCSLM",9,0)
 I $G(ZTQUEUED) S Y=$$PSET^%ZTLOAD(ZTQUEUED)
"RTN","HLCSLM",10,0)
 D INIT,SAVDOLRH
"RTN","HLCSLM",11,0)
 D SETNM^%ZOSV($E("HLmgr:"_$G(ZTQUEUED),1,15))
"RTN","HLCSLM",12,0)
 ;
"RTN","HLCSLM",13,0)
LOOP ;
"RTN","HLCSLM",14,0)
 D CHKQUE
"RTN","HLCSLM",15,0)
 I $$CKLMSTOP G EXIT
"RTN","HLCSLM",16,0)
 D SAVDOLRH
"RTN","HLCSLM",17,0)
 D CHECKMST^HLEVMST ;HL*1.6*109 - Make sure event monitor current
"RTN","HLCSLM",18,0)
 ; patch HL*1.6*140
"RTN","HLCSLM",19,0)
 ; H 10
"RTN","HLCSLM",20,0)
 H 5
"RTN","HLCSLM",21,0)
 G LOOP
"RTN","HLCSLM",22,0)
 ;
"RTN","HLCSLM",23,0)
EXIT N HLJ,X
"RTN","HLCSLM",24,0)
 S X=1
"RTN","HLCSLM",25,0)
 F  L +^HLCS(869.3,X,5):2 Q:$T
"RTN","HLCSLM",26,0)
 ;52=Link Manager task number
"RTN","HLCSLM",27,0)
 S HLJ(869.3,X_",",52)="@"
"RTN","HLCSLM",28,0)
 D FILE^HLDIE("","HLJ","","EXIT","HLCSLM") ;HL*1.6*109
"RTN","HLCSLM",29,0)
 L -^HLCS(869.3,X,5)
"RTN","HLCSLM",30,0)
 L -^HLCS("HLCSLM")
"RTN","HLCSLM",31,0)
 Q
"RTN","HLCSLM",32,0)
 ;
"RTN","HLCSLM",33,0)
SAVDOLRH ;Save Last Known $H
"RTN","HLCSLM",34,0)
 N HLJ,X
"RTN","HLCSLM",35,0)
 S X=1
"RTN","HLCSLM",36,0)
 F  L +^HLCS(869.3,X,5):2 Q:$T
"RTN","HLCSLM",37,0)
 ;54=LM LAST KNOWN $H
"RTN","HLCSLM",38,0)
 S HLJ(869.3,X_",",54)=$H
"RTN","HLCSLM",39,0)
 D FILE^HLDIE("","HLJ","","SAVDOLRH","HLCSLM") ;HL*1.6*109
"RTN","HLCSLM",40,0)
 L -^HLCS(869.3,X,5)
"RTN","HLCSLM",41,0)
 Q
"RTN","HLCSLM",42,0)
 ;
"RTN","HLCSLM",43,0)
CHKQUE ;Check queues for messages to send
"RTN","HLCSLM",44,0)
 ;HLTSKCNT(logical link)=task #^$H
"RTN","HLCSLM",45,0)
 N HLDA,HLDP,HLMSG,HLTSK,Y
"RTN","HLCSLM",46,0)
 S (HLDA,HLMSG)=""
"RTN","HLCSLM",47,0)
 F HLDP=0:0 S HLDP=+$O(^HLMA("AC","O",HLDP)) Q:HLDP'>0  S HLMSG=+$O(^(HLDP,0)) I HLMSG D  L -^HLCS("HLCSLSM",HLDP)
"RTN","HLCSLM",48,0)
 .;quit if persistent link
"RTN","HLCSLM",49,0)
 .Q:$P($G(^HLCS(870,HLDP,400)),U,4)="Y"
"RTN","HLCSLM",50,0)
 .L +^HLCS("HLCSLSM",HLDP):0 E  K HLTSKCNT(HLDP) Q
"RTN","HLCSLM",51,0)
 .Q:'$$LLOK(+HLDP)
"RTN","HLCSLM",52,0)
 .;get tasknumber from file 870 and HLTSKCNT array
"RTN","HLCSLM",53,0)
 .S Y=$$TASKNUM(HLDP),HLTSK=$G(HLTSKCNT(HLDP))
"RTN","HLCSLM",54,0)
 . ;
"RTN","HLCSLM",55,0)
 . ;patch HL*1.6*123 start
"RTN","HLCSLM",56,0)
 . S HLDP("TASK-ACTIVE")=0
"RTN","HLCSLM",57,0)
 . ;
"RTN","HLCSLM",58,0)
 . I Y D
"RTN","HLCSLM",59,0)
 .. N ZTSK
"RTN","HLCSLM",60,0)
 .. S ZTSK=Y
"RTN","HLCSLM",61,0)
 .. ; Check status of task
"RTN","HLCSLM",62,0)
 .. D STAT^%ZTLOAD
"RTN","HLCSLM",63,0)
 .. I "12"[ZTSK(1) S HLDP("TASK-ACTIVE")=1
"RTN","HLCSLM",64,0)
 . Q:HLDP("TASK-ACTIVE")
"RTN","HLCSLM",65,0)
 . ;
"RTN","HLCSLM",66,0)
 . I HLTSK D
"RTN","HLCSLM",67,0)
 .. N ZTSK
"RTN","HLCSLM",68,0)
 .. S ZTSK=+HLTSK
"RTN","HLCSLM",69,0)
 .. ; Check status of task
"RTN","HLCSLM",70,0)
 .. D STAT^%ZTLOAD
"RTN","HLCSLM",71,0)
 .. I "12"[ZTSK(1) S HLDP("TASK-ACTIVE")=1
"RTN","HLCSLM",72,0)
 . Q:HLDP("TASK-ACTIVE")
"RTN","HLCSLM",73,0)
 . ;
"RTN","HLCSLM",74,0)
 . ;no tasknumber, link not running nor queued, task it
"RTN","HLCSLM",75,0)
 . I 'HLTSK!'Y D TASKLSUB(HLDP),SAVTSK(HLDP) Q
"RTN","HLCSLM",76,0)
 ; comment out the following lines
"RTN","HLCSLM",77,0)
 ; .;link was tasked, check time
"RTN","HLCSLM",78,0)
 ; .S Y=$P(HLTSK,U,2)
"RTN","HLCSLM",79,0)
 ; .;check that time task is less than 30 minutes
"RTN","HLCSLM",80,0)
 ; .Q:$$HDIFF^XLFDT($H,Y,2)<1800
"RTN","HLCSLM",81,0)
 ; .;shutdown and send alert
"RTN","HLCSLM",82,0)
 ; .D SDFLD^HLCSTCP,EXITS^HLCSTCP("Shutdown"),SNDALERT
"RTN","HLCSLM",83,0)
 ; loop through links that have been tasked
"RTN","HLCSLM",84,0)
 ; F HLDP=0:0 S HLDP=$O(HLTSKCNT(HLDP)) Q:HLDP'>0  K:'$D(^HLMA("AC","O",HLDP)) HLTSKCNT(HLDP)
"RTN","HLCSLM",85,0)
 F HLDP=0:0 S HLDP=$O(HLTSKCNT(HLDP)) Q:HLDP'>0  D
"RTN","HLCSLM",86,0)
 . N ZTSK
"RTN","HLCSLM",87,0)
 . S ZTSK=+HLTSKCNT(HLDP)
"RTN","HLCSLM",88,0)
 . ; Check status of task
"RTN","HLCSLM",89,0)
 . D STAT^%ZTLOAD
"RTN","HLCSLM",90,0)
 . ; kill HLTSKCNT(HLDP) if process is not active
"RTN","HLCSLM",91,0)
 . I "12"'[ZTSK(1) K HLTSKCNT(HLDP)
"RTN","HLCSLM",92,0)
 ; patch HL*1.6*123 end
"RTN","HLCSLM",93,0)
 Q
"RTN","HLCSLM",94,0)
 ;
"RTN","HLCSLM",95,0)
INIT ;Create Task number and clear Stop flag.
"RTN","HLCSLM",96,0)
 N HLJ,X
"RTN","HLCSLM",97,0)
 S X=1
"RTN","HLCSLM",98,0)
 F  L +^HLCS(869.3,X,5):2 Q:$T
"RTN","HLCSLM",99,0)
 ;52=Link Manager task number,53=Stop Link Manager
"RTN","HLCSLM",100,0)
 S HLJ(869.3,X_",",52)=$G(ZTQUEUED)
"RTN","HLCSLM",101,0)
 S HLJ(869.3,X_",",53)="@"
"RTN","HLCSLM",102,0)
 D FILE^HLDIE("","HLJ","","INIT","HLCSLM") ;HL*1.6*109
"RTN","HLCSLM",103,0)
 L -^HLCS(869.3,X,5)
"RTN","HLCSLM",104,0)
 Q
"RTN","HLCSLM",105,0)
TASKNUM(X) ;Look-up task number
"RTN","HLCSLM",106,0)
 N %,DA,Y
"RTN","HLCSLM",107,0)
 S DA=X
"RTN","HLCSLM",108,0)
 ;
"RTN","HLCSLM",109,0)
 ;**109**
"RTN","HLCSLM",110,0)
 ;F  L +^HLCS(870,+DA,0):2 Q:$T
"RTN","HLCSLM",111,0)
 ;
"RTN","HLCSLM",112,0)
 S Y=$$GET1^DIQ(870,DA_",",11)
"RTN","HLCSLM",113,0)
 ;
"RTN","HLCSLM",114,0)
 ;**109
"RTN","HLCSLM",115,0)
 ;L -^HLCS(870,+DA,0)
"RTN","HLCSLM",116,0)
 ;
"RTN","HLCSLM",117,0)
 Q Y
"RTN","HLCSLM",118,0)
STATUS(X) ;Status of task
"RTN","HLCSLM",119,0)
 N Y,ZTSK
"RTN","HLCSLM",120,0)
 S ZTSK=X
"RTN","HLCSLM",121,0)
 D STAT^%ZTLOAD
"RTN","HLCSLM",122,0)
 S Y=ZTSK(1)
"RTN","HLCSLM",123,0)
 Q Y
"RTN","HLCSLM",124,0)
 ;
"RTN","HLCSLM",125,0)
LLOK(X) ;Function to check whether LL ok.
"RTN","HLCSLM",126,0)
 ;return value 1 = ok, 0 = not ok.
"RTN","HLCSLM",127,0)
 Q:'$G(X)
"RTN","HLCSLM",128,0)
 N HLDP,HLDP0,HLPARM4,HLTYPTR
"RTN","HLCSLM",129,0)
 S HLDP=+X,HLDP0=$G(^HLCS(870,HLDP,0)),HLPARM4=$G(^(400)) Q:HLDP0="" 0
"RTN","HLCSLM",130,0)
 ;must be a client
"RTN","HLCSLM",131,0)
 Q:$P(HLPARM4,U,3)'="C" 0
"RTN","HLCSLM",132,0)
 ;
"RTN","HLCSLM",133,0)
 ; patch HL*1.6*123
"RTN","HLCSLM",134,0)
 ;shutdown LLP must be 0
"RTN","HLCSLM",135,0)
 ; Q:$P(HLDP0,U,15)'=0 0
"RTN","HLCSLM",136,0)
 ; change to 1, in case the data is empty
"RTN","HLCSLM",137,0)
 Q:$P(HLDP0,U,15)=1 0
"RTN","HLCSLM",138,0)
 ;
"RTN","HLCSLM",139,0)
 ;must have LLP Type of TCP
"RTN","HLCSLM",140,0)
 S HLTYPTR=+$P(HLDP0,U,3) Q:$P($G(^HLCS(869.1,HLTYPTR,0)),U)'="TCP" 0
"RTN","HLCSLM",141,0)
 Q 1
"RTN","HLCSLM",142,0)
 ;
"RTN","HLCSLM",143,0)
SAVTSK(X) ;
"RTN","HLCSLM",144,0)
 N HLDP,HLJ
"RTN","HLCSLM",145,0)
 S HLDP=X
"RTN","HLCSLM",146,0)
 ;
"RTN","HLCSLM",147,0)
 ;**109**
"RTN","HLCSLM",148,0)
 F  L +^HLCS(870,HLDP,0):2 Q:$T
"RTN","HLCSLM",149,0)
 ;
"RTN","HLCSLM",150,0)
 ;4=status,10=Time Stopped,9=Time Started,11=Task Number,3=Online ?
"RTN","HLCSLM",151,0)
 S X=$NA(HLJ(870,HLDP_",")),@X@(11)=$G(ZTSK)
"RTN","HLCSLM",152,0)
 ;S HLJ(870,HLDP_",",11)=$G(ZTSK)
"RTN","HLCSLM",153,0)
 D FILE^HLDIE("","HLJ","","SAVTSK","HLCSLM") ; HL*1.6*109
"RTN","HLCSLM",154,0)
 S HLTSKCNT(HLDP)=$G(ZTSK)_"^"_$H
"RTN","HLCSLM",155,0)
 ;
"RTN","HLCSLM",156,0)
 ;**109**
"RTN","HLCSLM",157,0)
 L -^HLCS(870,HLDP,0)
"RTN","HLCSLM",158,0)
 ;
"RTN","HLCSLM",159,0)
 Q
"RTN","HLCSLM",160,0)
 ;
"RTN","HLCSLM",161,0)
STRTSTOP ;ENTRY POINT TO START/STOP TCP LINK MANAGER
"RTN","HLCSLM",162,0)
 N DIR,DIRUT,Y
"RTN","HLCSLM",163,0)
 L +^HLCS("HLCSLM"):3 E  D  Q
"RTN","HLCSLM",164,0)
 .W !,*7,"Link Manager already running!"
"RTN","HLCSLM",165,0)
 .W ! S DIR(0)="YO",DIR("A")="Would you like to stop the Link Manager now",DIR("B")="NO" D ^DIR K DIR
"RTN","HLCSLM",166,0)
 .I $D(DIRUT)!'Y Q
"RTN","HLCSLM",167,0)
 .D STOPLM
"RTN","HLCSLM",168,0)
 W !,*7,"Link Manager is NOT currently running!"
"RTN","HLCSLM",169,0)
 W ! S DIR(0)="YO",DIR("A")="Would you like to start the Link Manager now",DIR("B")="YES" D ^DIR K DIR
"RTN","HLCSLM",170,0)
 I '$D(DIRUT)&Y D TASKLM
"RTN","HLCSLM",171,0)
 L -^HLCS("HLCSLM")
"RTN","HLCSLM",172,0)
 Q
"RTN","HLCSLM",173,0)
 ;
"RTN","HLCSLM",174,0)
STOPLM ;ENTRY POINT TO STOP LINK MANAGER
"RTN","HLCSLM",175,0)
 N DIC,X,Y,DTOUT,DUOUT,DLAYGO,DIE,DA,DR
"RTN","HLCSLM",176,0)
 S DIC="^HLCS(869.3,"
"RTN","HLCSLM",177,0)
 S X=1
"RTN","HLCSLM",178,0)
 D ^DIC
"RTN","HLCSLM",179,0)
 S DA=+Y,DIE=DIC
"RTN","HLCSLM",180,0)
 S DR="53////1"
"RTN","HLCSLM",181,0)
 D ^DIE
"RTN","HLCSLM",182,0)
 W !,"Link Manager has been asked to stop"
"RTN","HLCSLM",183,0)
 Q
"RTN","HLCSLM",184,0)
STAT() ;Status of LINK MANAGER--up, down or unable to determine.
"RTN","HLCSLM",185,0)
 N %,DA,X,Y
"RTN","HLCSLM",186,0)
 S DA=1
"RTN","HLCSLM",187,0)
 S X=$$GET1^DIQ(869.3,DA_",",52)
"RTN","HLCSLM",188,0)
 Q:X']"" 0
"RTN","HLCSLM",189,0)
 S X=$$GET1^DIQ(869.3,DA_",",54)
"RTN","HLCSLM",190,0)
 Q:X']"" 0
"RTN","HLCSLM",191,0)
 I $$HDIFF^XLFDT($H,X,2)>500 Q 0
"RTN","HLCSLM",192,0)
 Q 1
"RTN","HLCSLM",193,0)
 ;
"RTN","HLCSLM",194,0)
TASKLSUB(X) ;Task LINK SUB-MANAGER.
"RTN","HLCSLM",195,0)
 ;This may be a place to log the time which the LINK SUBMANAGER is tasked.
"RTN","HLCSLM",196,0)
 N HLDP,HLDP0,HLDAPP,HLTYPTR,HLBGR,HLENV,HLPARM,HLPARM4,HLQUIT,ZTRTN,ZTDESC,ZTCPU,ZTSAVE
"RTN","HLCSLM",197,0)
 ;ZTSK is not Newed here because it will be needed by SAVTSK.
"RTN","HLCSLM",198,0)
 S HLDP=X,HLDP0=$G(^HLCS(870,HLDP,0)),HLPARM4=$G(^(400))
"RTN","HLCSLM",199,0)
 ; Q:"N"'[$P(HLPARM4,U,4)  ; patch HL*1.6*123: comment out
"RTN","HLCSLM",200,0)
 ;quit if no LLP TYPE
"RTN","HLCSLM",201,0)
 S HLDAPP=$P(HLDP0,U),HLTYPTR=$P(HLDP0,U,3) Q:'HLTYPTR
"RTN","HLCSLM",202,0)
 S HLBGR=$G(^HLCS(869.1,HLTYPTR,100)),HLENV=$G(^(200))
"RTN","HLCSLM",203,0)
 I HLENV'="" K HLQUIT X HLENV Q:$D(HLQUIT)
"RTN","HLCSLM",204,0)
 S ZTRTN="^HLCSLSM",HLBGR=$P(HLBGR," ",2)
"RTN","HLCSLM",205,0)
 S ZTDESC=HLDAPP_" Low Level Protocol",ZTSAVE("HLDP")="",ZTSAVE("HLBGR")=""
"RTN","HLCSLM",206,0)
 S ZTIO="",ZTDTH=$H
"RTN","HLCSLM",207,0)
 ;get startup node
"RTN","HLCSLM",208,0)
 I $P(HLPARM4,U,6),$D(^%ZIS(14.7,+$P(HLPARM4,U,6),0)) S ZTCPU=$P(^(0),U)
"RTN","HLCSLM",209,0)
 D ^%ZTLOAD
"RTN","HLCSLM",210,0)
 D MON^HLCSTCP("Tasked") ;HL*1.6*123
"RTN","HLCSLM",211,0)
 Q
"RTN","HLCSLM",212,0)
 ;
"RTN","HLCSLM",213,0)
TASKLM ;Task Link Manager
"RTN","HLCSLM",214,0)
 ;Declare variables
"RTN","HLCSLM",215,0)
 N ZTRTN,ZTDESC,ZTIO,ZTDTH,ZTSK,TMP
"RTN","HLCSLM",216,0)
 S ZTIO=""
"RTN","HLCSLM",217,0)
 S ZTDTH=$H
"RTN","HLCSLM",218,0)
 ;Task Link Manager
"RTN","HLCSLM",219,0)
 S ZTRTN="EN^HLCSLM"
"RTN","HLCSLM",220,0)
 S ZTDESC="HL7 Link Manager"
"RTN","HLCSLM",221,0)
 ;Call TaskMan
"RTN","HLCSLM",222,0)
 D ^%ZTLOAD
"RTN","HLCSLM",223,0)
 I $G(ZTSK) W !,"Link Manager queued as task number ",ZTSK
"RTN","HLCSLM",224,0)
 E  W $C(7),!!,"Unable to start/restart Link Manager"
"RTN","HLCSLM",225,0)
 Q
"RTN","HLCSLM",226,0)
 ;
"RTN","HLCSLM",227,0)
CKLMSTOP() ;Check whether Link Manager should stop
"RTN","HLCSLM",228,0)
 N PTRMAIN,NODE5,STOP
"RTN","HLCSLM",229,0)
 S PTRMAIN=+$O(^HLCS(869.3,0))
"RTN","HLCSLM",230,0)
 L +^HLCS(869.3,PTRMAIN,5):1
"RTN","HLCSLM",231,0)
 I $T L -^HLCS(869.3,PTRMAIN,5)
"RTN","HLCSLM",232,0)
 S NODE5=$G(^HLCS(869.3,PTRMAIN,5))
"RTN","HLCSLM",233,0)
 S STOP=+$P(NODE5,"^",3)
"RTN","HLCSLM",234,0)
 Q:STOP STOP
"RTN","HLCSLM",235,0)
 S STOP=$$S^%ZTLOAD
"RTN","HLCSLM",236,0)
 Q STOP
"RTN","HLCSLM",237,0)
 ;
"RTN","HLCSLM",238,0)
SNDALERT ;Send Alert
"RTN","HLCSLM",239,0)
 N XQA,XQAMSG,XQAOPT,XQAROU,XQAID,Z
"RTN","HLCSLM",240,0)
 S Z=$P($$PARAM^HLCS2,U,8) Q:Z=""
"RTN","HLCSLM",241,0)
 S XQA("G."_Z)="",XQAMSG="HL7 Logical Link "_$P(^HLCS(870,HLDP,0),U)_" shutdown due to TaskMan unable to process task request"
"RTN","HLCSLM",242,0)
 D SETUP^XQALERT
"RTN","HLCSLM",243,0)
 Q
"RTN","HLCSTCP")
0^6^B47334373^B46918121
"RTN","HLCSTCP",1,0)
HLCSTCP ;SFIRMFO/TNV-ALB/JFP,PKE - (TCP/IP) MLLP ;04/15/2008  10:58
"RTN","HLCSTCP",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**19,43,49,57,58,64,84,109,133,122,140**;Oct 13, 1995;Build 5
"RTN","HLCSTCP",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLCSTCP",4,0)
 ;
"RTN","HLCSTCP",5,0)
 ; This is an implementation of the HL7 Minimal Lower Layer Protocol
"RTN","HLCSTCP",6,0)
 ; taskman entry/startup option, HLDP defined in menu entry.
"RTN","HLCSTCP",7,0)
 ;
"RTN","HLCSTCP",8,0)
 Q:'$D(HLDP)
"RTN","HLCSTCP",9,0)
 ; patch HL*1.6*122 start
"RTN","HLCSTCP",10,0)
 L +^HLCS("HLTCPLINK",HLDP):5 I '$T D  Q
"RTN","HLCSTCP",11,0)
 . D MON^HLCSTCP("TskLcked")
"RTN","HLCSTCP",12,0)
 N HLCSOUT,HLDBACK,HLDBSIZE,HLDREAD,HLDRETR,HLRETRA,HLDWAIT,HLOS,HLTCPADD,HLTCPCS,HLTCPLNK,HLTCPORT,HLTCPRET
"RTN","HLCSTCP",13,0)
 N HLZRULE
"RTN","HLCSTCP",14,0)
 ;HLCSOUT= 1-error
"RTN","HLCSTCP",15,0)
 I '$$INIT D EXITS("Init Error") Q
"RTN","HLCSTCP",16,0)
 S HLDP("$J")=$J
"RTN","HLCSTCP",17,0)
 S HLDP("$J",0,"LENGTH")=$L(HLDP("$J"))
"RTN","HLCSTCP",18,0)
 ; Start the client
"RTN","HLCSTCP",19,0)
 I $G(HLTCPCS)="C" D  Q
"RTN","HLCSTCP",20,0)
 . S HLDP("$J",0,"START")=HLDP("$J",0,"LENGTH")-8+$L(HLTCPORT)+$L(HLDP)
"RTN","HLCSTCP",21,0)
 . I HLDP("$J",0,"START")<1 S HLDP("$J",0,"START")=1
"RTN","HLCSTCP",22,0)
 . S HLDP("$J",0)=$E(HLDP("$J"),HLDP("$J",0,"START"),HLDP("$J",0,"LENGTH"))
"RTN","HLCSTCP",23,0)
 . ; identify process for ^%SY
"RTN","HLCSTCP",24,0)
 . ; D SETNM^%ZOSV($E("HLClnt:"_HLDP,1,15))
"RTN","HLCSTCP",25,0)
 . D SETNM^%ZOSV($E("HLc:"_HLTCPORT_"-"_HLDP_"-"_HLDP("$J",0),1,15))
"RTN","HLCSTCP",26,0)
 . K HLDP("$J",0)
"RTN","HLCSTCP",27,0)
 . D ST1
"RTN","HLCSTCP",28,0)
 . F  D ^HLCSTCP2 Q:$$STOP!$G(HLCSOUT)
"RTN","HLCSTCP",29,0)
 . ; I $G(HLCSOUT)=1 D MON("Error") H 1 Q
"RTN","HLCSTCP",30,0)
 . I $G(HLCSOUT)=1 D  Q
"RTN","HLCSTCP",31,0)
 .. D MON("Error") H 1
"RTN","HLCSTCP",32,0)
 .. L -^HLCS("HLTCPLINK",HLDP)
"RTN","HLCSTCP",33,0)
 . I $G(HLCSOUT)=2 D EXITS("Inactive") Q
"RTN","HLCSTCP",34,0)
 . D EXITS("Shutdown")
"RTN","HLCSTCP",35,0)
 ;
"RTN","HLCSTCP",36,0)
 S HLDP("$J",0,"START")=HLDP("$J",0,"LENGTH")-9+$L(HLTCPORT)
"RTN","HLCSTCP",37,0)
 I HLDP("$J",0,"START")<1 S HLDP("$J",0,"START")=1
"RTN","HLCSTCP",38,0)
 S HLDP("$J",0)=$E(HLDP("$J"),HLDP("$J",0,"START"),HLDP("$J",0,"LENGTH"))
"RTN","HLCSTCP",39,0)
 ; identify process for ^%SY
"RTN","HLCSTCP",40,0)
 ; D SETNM^%ZOSV($E("HLSrv:"_HLDP,1,15))
"RTN","HLCSTCP",41,0)
 D SETNM^%ZOSV($E("HLs:"_HLTCPORT_"-"_HLDP("$J",0),1,15))
"RTN","HLCSTCP",42,0)
 K HLDP("$J",0)
"RTN","HLCSTCP",43,0)
 ; to stop the listener via updated Kernel API, need to pass the
"RTN","HLCSTCP",44,0)
 ; listener logical link (HLDP)
"RTN","HLCSTCP",45,0)
 S HLZRULE="S HLDP="_HLDP_" S ZISQUIT=$$STOP^HLCSTCP"
"RTN","HLCSTCP",46,0)
 ;single threaded listener
"RTN","HLCSTCP",47,0)
 I $G(HLTCPCS)="S" D  Q
"RTN","HLCSTCP",48,0)
 . D ST1,MON("Listen"),LISTEN^%ZISTCP(HLTCPORT,"SERVER^HLCSTCP("""_HLDP_""")",HLZRULE)
"RTN","HLCSTCP",49,0)
 . I $$STOP D EXITS("Shutdown") Q
"RTN","HLCSTCP",50,0)
 . D EXITS("Openfail")
"RTN","HLCSTCP",51,0)
 ;
"RTN","HLCSTCP",52,0)
 ;multi-threaded listener (for OpenM/NT)
"RTN","HLCSTCP",53,0)
 I ($G(HLTCPCS)'="M")!(^%ZOSF("OS")'["OpenM") D  Q
"RTN","HLCSTCP",54,0)
 . L -^HLCS("HLTCPLINK",HLDP)
"RTN","HLCSTCP",55,0)
 I $$OS^%ZOSV["VMS" L -^HLCS("HLTCPLINK",HLDP) Q
"RTN","HLCSTCP",56,0)
 D ST1,MON("Listen"),LISTEN^%ZISTCPS(HLTCPORT,"SERVERS^HLCSTCP("""_HLDP_""")",HLZRULE)
"RTN","HLCSTCP",57,0)
 ; update status of listener
"RTN","HLCSTCP",58,0)
 I $$STOP D EXITS("Shutdown") Q
"RTN","HLCSTCP",59,0)
 D EXITS("Openfail")
"RTN","HLCSTCP",60,0)
 ; HL*1.6*122 end
"RTN","HLCSTCP",61,0)
 Q
"RTN","HLCSTCP",62,0)
 ;
"RTN","HLCSTCP",63,0)
SERVER(HLDP) ; single server using Taskman
"RTN","HLCSTCP",64,0)
 I '$$INIT D EXITS("Init error") Q
"RTN","HLCSTCP",65,0)
 D ^HLCSTCP1
"RTN","HLCSTCP",66,0)
 I $$STOP D CLOSE^%ZISTCP,EXITS("Shutdown") S IO("C")="" Q
"RTN","HLCSTCP",67,0)
 Q:$G(HLCSOUT)=1
"RTN","HLCSTCP",68,0)
 D MON("Idle")
"RTN","HLCSTCP",69,0)
 Q
"RTN","HLCSTCP",70,0)
 ;
"RTN","HLCSTCP",71,0)
SERVERS(HLDP) ; Multi-threaded server using Taskman
"RTN","HLCSTCP",72,0)
 I '$$INIT D EXITS("Init error") Q
"RTN","HLCSTCP",73,0)
 G LISTEN
"RTN","HLCSTCP",74,0)
 ;
"RTN","HLCSTCP",75,0)
 ;multiple process servers, called from an external utility
"RTN","HLCSTCP",76,0)
MSM ;MSM entry point, called from User-Defined Services
"RTN","HLCSTCP",77,0)
 ;HLDP=ien in the HL LOWER LEVEL PROTOCOL PARAMETER file for the
"RTN","HLCSTCP",78,0)
 ;HL7 Multi-Threaded SERVER
"RTN","HLCSTCP",79,0)
 S (IO,IO(0))=$P
"RTN","HLCSTCP",80,0)
 G LISTEN
"RTN","HLCSTCP",81,0)
 ;
"RTN","HLCSTCP",82,0)
LISTEN ;
"RTN","HLCSTCP",83,0)
 N HLLSTN,HLCSOUT,HLDBACK,HLDBSIZE,HLDREAD,HLDRETR,HLRETRA,HLDWAIT,HLOS,HLTCPADD,HLTCPCS,HLTCPLNK,HLTCPORT,HLTCPRET
"RTN","HLCSTCP",84,0)
 I '$$INIT D ^%ZTER Q
"RTN","HLCSTCP",85,0)
 ; patch HL*1.6*122 start
"RTN","HLCSTCP",86,0)
 S HLDP("$J")=$J
"RTN","HLCSTCP",87,0)
 S HLDP("$J",0,"LENGTH")=$L(HLDP("$J"))
"RTN","HLCSTCP",88,0)
 S HLDP("$J",0,"START")=HLDP("$J",0,"LENGTH")-9+$L(HLTCPORT)
"RTN","HLCSTCP",89,0)
 I HLDP("$J",0,"START")<1 S HLDP("$J",0,"START")=1
"RTN","HLCSTCP",90,0)
 S HLDP("$J",0)=$E(HLDP("$J"),HLDP("$J",0,"START"),HLDP("$J",0,"LENGTH"))
"RTN","HLCSTCP",91,0)
 ; identify process for ^%SY
"RTN","HLCSTCP",92,0)
 ; D SETNM^%ZOSV($E("HLSrv:"_HLDP,1,15))
"RTN","HLCSTCP",93,0)
 D SETNM^%ZOSV($E("HLs:"_HLTCPORT_"-"_HLDP("$J",0),1,15))
"RTN","HLCSTCP",94,0)
 K HLDP("$J",0)
"RTN","HLCSTCP",95,0)
 ; patch HL*1.6*122 end
"RTN","HLCSTCP",96,0)
 ;HLLSTN used to identify a listener to tag MON
"RTN","HLCSTCP",97,0)
 S HLLSTN=1
"RTN","HLCSTCP",98,0)
 ;increment job count, run server
"RTN","HLCSTCP",99,0)
 D UPDT(1),^HLCSTCP1,EXITM
"RTN","HLCSTCP",100,0)
 Q
"RTN","HLCSTCP",101,0)
 ;
"RTN","HLCSTCP",102,0)
DCOPEN(HLDP) ;open direct connect - called from HLMA2
"RTN","HLCSTCP",103,0)
 Q:'$$INIT 0
"RTN","HLCSTCP",104,0)
 Q:HLTCPADD=""!(HLTCPORT="") 0
"RTN","HLCSTCP",105,0)
 Q:'$$OPEN^HLCSTCP2 0
"RTN","HLCSTCP",106,0)
 Q 1
"RTN","HLCSTCP",107,0)
 ;
"RTN","HLCSTCP",108,0)
INIT() ; Initialize Variables
"RTN","HLCSTCP",109,0)
 ; HLDP should be set to the IEN or name of Logical Link, file 870
"RTN","HLCSTCP",110,0)
 S HLOS=$P($G(^%ZOSF("OS")),"^")
"RTN","HLCSTCP",111,0)
 N DA,DIQUIET,DR,TMP,X,Y
"RTN","HLCSTCP",112,0)
 ; patch HL*1.6*140
"RTN","HLCSTCP",113,0)
 ; S IOF=$$FLUSHCHR^%ZISTCP ; HL*1.6*122 set device flush character
"RTN","HLCSTCP",114,0)
 S HLTCPLNK("IOF")=$$FLUSHCHR^%ZISTCP
"RTN","HLCSTCP",115,0)
 S DIQUIET=1
"RTN","HLCSTCP",116,0)
 D DT^DICRW
"RTN","HLCSTCP",117,0)
 I 'HLDP S HLDP=$O(^HLCS(870,"B",HLDP,0)) I 'HLDP Q 0
"RTN","HLCSTCP",118,0)
 S DA=HLDP
"RTN","HLCSTCP",119,0)
 ; patch HL*1.6*122 for field 400.09
"RTN","HLCSTCP",120,0)
 S DR="200.02;200.021;200.022;200.03;200.04;200.05;200.09;400.01;400.02;400.03;400.04;400.05;400.09"
"RTN","HLCSTCP",121,0)
 D GETS^DIQ(870,DA,DR,"IN","TMP","TMP")
"RTN","HLCSTCP",122,0)
 ;
"RTN","HLCSTCP",123,0)
 I $D(TMP("DIERR")) QUIT 0
"RTN","HLCSTCP",124,0)
 ; -- re-transmit attempts
"RTN","HLCSTCP",125,0)
 S HLDRETR=+$G(TMP(870,DA_",",200.02,"I"))
"RTN","HLCSTCP",126,0)
 S HLDRETR("CLOSE")=+$G(TMP(870,DA_",",200.022,"I"))
"RTN","HLCSTCP",127,0)
 ; -- exceed re-transmit action
"RTN","HLCSTCP",128,0)
 S HLRETRA=$G(TMP(870,DA_",",200.021,"I"))
"RTN","HLCSTCP",129,0)
 ; -- block size
"RTN","HLCSTCP",130,0)
 S HLDBSIZE=+$G(TMP(870,DA_",",200.03,"I"))
"RTN","HLCSTCP",131,0)
 ; -- read timeout
"RTN","HLCSTCP",132,0)
 S HLDREAD=+$G(TMP(870,DA_",",200.04,"I"))
"RTN","HLCSTCP",133,0)
 ; -- ack timeout
"RTN","HLCSTCP",134,0)
 S HLDBACK=+$G(TMP(870,DA_",",200.05,"I"))
"RTN","HLCSTCP",135,0)
 ; -- uni-directional wait
"RTN","HLCSTCP",136,0)
 S HLDWAIT=$G(TMP(870,DA_",",200.09,"I"))
"RTN","HLCSTCP",137,0)
 ; -- tcp address
"RTN","HLCSTCP",138,0)
 S HLTCPADD=$G(TMP(870,DA_",",400.01,"I"))
"RTN","HLCSTCP",139,0)
 ; -- tcp port
"RTN","HLCSTCP",140,0)
 S HLTCPORT=$G(TMP(870,DA_",",400.02,"I"))
"RTN","HLCSTCP",141,0)
 ; -- tcp/ip service type
"RTN","HLCSTCP",142,0)
 S HLTCPCS=$G(TMP(870,DA_",",400.03,"I"))
"RTN","HLCSTCP",143,0)
 ; -- link persistence
"RTN","HLCSTCP",144,0)
 S HLTCPLNK=$G(TMP(870,DA_",",400.04,"I"))
"RTN","HLCSTCP",145,0)
 ; -- retention
"RTN","HLCSTCP",146,0)
 S HLTCPRET=$G(TMP(870,DA_",",400.05,"I"))
"RTN","HLCSTCP",147,0)
 ;
"RTN","HLCSTCP",148,0)
 ; patch HL*1.6*140
"RTN","HLCSTCP",149,0)
 ; patch HL*1.6*122 for field 400.09
"RTN","HLCSTCP",150,0)
 ; -- tcp/ip openfail timeout
"RTN","HLCSTCP",151,0)
 ; S HLTCPLNK("TIMEOUT")=$G(TMP(870,DA_",",400.09,"I"))
"RTN","HLCSTCP",152,0)
 S HLTCPLNK("TIMEOUT")=+$G(TMP(870,DA_",",400.09,"I"))
"RTN","HLCSTCP",153,0)
 ;
"RTN","HLCSTCP",154,0)
 ; -- set defaults in case something's not set
"RTN","HLCSTCP",155,0)
 S:HLDREAD=0 HLDREAD=10
"RTN","HLCSTCP",156,0)
 S:HLDBACK=0 HLDBACK=60
"RTN","HLCSTCP",157,0)
 ; patch HL*1.6*122
"RTN","HLCSTCP",158,0)
 ; S:HLDBSIZE=0 HLDBSIZE=245
"RTN","HLCSTCP",159,0)
 S:HLDBSIZE<245 HLDBSIZE=245
"RTN","HLCSTCP",160,0)
 S:HLDRETR=0 HLDRETR=5
"RTN","HLCSTCP",161,0)
 S:HLTCPRET="" X=$P($$PARAM^HLCS2,U,12),HLTCPRET=$S(X:X,1:15)
"RTN","HLCSTCP",162,0)
 ;
"RTN","HLCSTCP",163,0)
 ; patch HL*1.6*140, the defaut is 30
"RTN","HLCSTCP",164,0)
 ; patch HL*1.6*122 for field 400.09
"RTN","HLCSTCP",165,0)
 ; S:HLTCPLNK("TIMEOUT")=0 HLTCPLNK("TIMEOUT")=5
"RTN","HLCSTCP",166,0)
 S:(HLTCPLNK("TIMEOUT")<1) HLTCPLNK("TIMEOUT")=30
"RTN","HLCSTCP",167,0)
 ;
"RTN","HLCSTCP",168,0)
 Q 1
"RTN","HLCSTCP",169,0)
 ;
"RTN","HLCSTCP",170,0)
ST1 ;record startup in 870 for single server
"RTN","HLCSTCP",171,0)
 ;4=status 9=Time Started, 10=Time Stopped, 11=Task Number 
"RTN","HLCSTCP",172,0)
 ;14=Shutdown LLP, 3=LLP Online, 18=Gross Errors
"RTN","HLCSTCP",173,0)
 N HLJ,X
"RTN","HLCSTCP",174,0)
 ; HL*1.6*122 remove unnecessary locks
"RTN","HLCSTCP",175,0)
 ;F  L +^HLCS(870,HLDP,0):2 Q:$T
"RTN","HLCSTCP",176,0)
 S X="HLJ(870,"""_HLDP_","")"
"RTN","HLCSTCP",177,0)
 S @X@(4)="Init",(@X@(10),@X@(18))="@",@X@(14)=0
"RTN","HLCSTCP",178,0)
 I HLTCPCS["C" S @X@(3)=$S(HLTCPLNK["Y":"PC",1:"NC")
"RTN","HLCSTCP",179,0)
 E  S @X@(3)=$S(HLTCPCS["S":"SS",HLTCPCS["M":"MS",1:"")
"RTN","HLCSTCP",180,0)
 I @X@(3)'="NC" S @X@(9)=$$NOW^XLFDT
"RTN","HLCSTCP",181,0)
 S:$G(ZTSK) @X@(11)=ZTSK
"RTN","HLCSTCP",182,0)
 D FILE^HLDIE("","HLJ","","ST1","HLCSTCP") ;HL*1.6*109
"RTN","HLCSTCP",183,0)
 ;L -^HLCS(870,HLDP,0)
"RTN","HLCSTCP",184,0)
 Q
"RTN","HLCSTCP",185,0)
 ;
"RTN","HLCSTCP",186,0)
MON(Y) ;Display current state & check for shutdown
"RTN","HLCSTCP",187,0)
 ;don't display for multiple server
"RTN","HLCSTCP",188,0)
 Q:$G(HLLSTN)
"RTN","HLCSTCP",189,0)
 ; HL*1.6*122 remove unnecessary locks
"RTN","HLCSTCP",190,0)
 ;F  L +^HLCS(870,HLDP,0):2 Q:$T
"RTN","HLCSTCP",191,0)
 S $P(^HLCS(870,HLDP,0),U,5)=Y
"RTN","HLCSTCP",192,0)
 ;L -^HLCS(870,HLDP,0)
"RTN","HLCSTCP",193,0)
 Q:'$D(HLTRACE)
"RTN","HLCSTCP",194,0)
 N X U IO(0)
"RTN","HLCSTCP",195,0)
 W !,"IN State: ",Y
"RTN","HLCSTCP",196,0)
 I '$$STOP D
"RTN","HLCSTCP",197,0)
 . ; patch HL*1.6*122
"RTN","HLCSTCP",198,0)
 . ; R !,"Type Q to Quit: ",X#1:1
"RTN","HLCSTCP",199,0)
 . R !,"Type Q to Quit: ",X:1
"RTN","HLCSTCP",200,0)
 . ; I $L(X),"Qq"[X S $P(^HLCS(870,HLDP,0),U,15)=1
"RTN","HLCSTCP",201,0)
 . I $L(X),"Qq"[$E(X) S $P(^HLCS(870,HLDP,0),U,15)=1
"RTN","HLCSTCP",202,0)
 . ; patch HL*1.6*122 end
"RTN","HLCSTCP",203,0)
 U IO
"RTN","HLCSTCP",204,0)
 Q
"RTN","HLCSTCP",205,0)
UPDT(Y) ;update job count for multiple servers,X=1 increment
"RTN","HLCSTCP",206,0)
 N HLJ,X
"RTN","HLCSTCP",207,0)
 ;
"RTN","HLCSTCP",208,0)
 ; HL*1.6*122 start
"RTN","HLCSTCP",209,0)
 ; F  L +^HLCS(870,HLDP,0):2 Q:$T
"RTN","HLCSTCP",210,0)
 Q:'$G(HLDP)
"RTN","HLCSTCP",211,0)
 Q:'$D(^HLCS(870,"E","M",HLDP))
"RTN","HLCSTCP",212,0)
 F  L +^HLCS(870,HLDP,0):10 Q:$T  H 1
"RTN","HLCSTCP",213,0)
 ; S X=+$P(^HLCS(870,HLDP,0),U,5),$P(^(0),U,5)=$S(Y:X+1,1:X-1)_" server"
"RTN","HLCSTCP",214,0)
 S X=+$P(^HLCS(870,HLDP,0),U,5)
"RTN","HLCSTCP",215,0)
 I X<0 S X=0
"RTN","HLCSTCP",216,0)
 S $P(^HLCS(870,HLDP,0),U,5)=$S(Y:(X+1),X<1:0,1:X-1)_" server"
"RTN","HLCSTCP",217,0)
 ;if incrementing, set the Device Type field to Multi-Server
"RTN","HLCSTCP",218,0)
 ; I X S HLJ(870,HLDP_",",3)="MS" D FILE^HLDIE("","HLJ","","UPDT","HLCSTCP")
"RTN","HLCSTCP",219,0)
 I $P(^HLCS(870,HLDP,0),"^",4)']"" S $P(^HLCS(870,HLDP,0),"^",4)="MS"
"RTN","HLCSTCP",220,0)
 ; HL*1.6*122 end
"RTN","HLCSTCP",221,0)
 ;
"RTN","HLCSTCP",222,0)
 L -^HLCS(870,HLDP,0)
"RTN","HLCSTCP",223,0)
 Q
"RTN","HLCSTCP",224,0)
STOP() ;stop flag set
"RTN","HLCSTCP",225,0)
 N X
"RTN","HLCSTCP",226,0)
 F  L +^HLCS(870,HLDP,0):2 Q:$T
"RTN","HLCSTCP",227,0)
 S X=+$P(^HLCS(870,HLDP,0),U,15)
"RTN","HLCSTCP",228,0)
 L -^HLCS(870,HLDP,0)
"RTN","HLCSTCP",229,0)
 Q X
"RTN","HLCSTCP",230,0)
 ;
"RTN","HLCSTCP",231,0)
LLCNT(DP,Y,Z) ;update Logical Link counters
"RTN","HLCSTCP",232,0)
 ;DP=ien of Logical Link in file 870
"RTN","HLCSTCP",233,0)
 ;Y: 1=msg rec, 2=msg proc, 3=msg to send, 4=msg sent
"RTN","HLCSTCP",234,0)
 ;Z: ""=add to counter, 1=subtract from counter
"RTN","HLCSTCP",235,0)
 Q:'$D(^HLCS(870,+$G(DP),0))!('$G(Y))
"RTN","HLCSTCP",236,0)
 N P,X
"RTN","HLCSTCP",237,0)
 S P=$S(Y<3:"IN",1:"OUT")_" QUEUE "_$S(Y#2:"BACK",1:"FRONT")_" POINTER"
"RTN","HLCSTCP",238,0)
 ; patch HL*1.6*122 start
"RTN","HLCSTCP",239,0)
 ; F  L +^HLCS(870,DP,P):2 Q:$T
"RTN","HLCSTCP",240,0)
 ; S X=+$G(^HLCS(870,DP,P)),^(P)=X+$S($G(Z):-1,1:1)
"RTN","HLCSTCP",241,0)
 I '$L($G(OS)) N OS S OS=$G(^%ZOSF("OS"))
"RTN","HLCSTCP",242,0)
 I OS'["DSM",OS'["OpenM" D
"RTN","HLCSTCP",243,0)
 . F  L +^HLCS(870,DP,P):10 Q:$T  H 1
"RTN","HLCSTCP",244,0)
 . S X=+$G(^HLCS(870,DP,P)),^(P)=X+$S($G(Z):-1,1:1)
"RTN","HLCSTCP",245,0)
 . L -^HLCS(870,DP,P)
"RTN","HLCSTCP",246,0)
 E  D
"RTN","HLCSTCP",247,0)
 . S X=$I(^HLCS(870,DP,P),$S($G(Z):-1,1:1))
"RTN","HLCSTCP",248,0)
 ; L -^HLCS(870,DP,P)
"RTN","HLCSTCP",249,0)
 ; patch HL*1.6*122 end
"RTN","HLCSTCP",250,0)
 Q
"RTN","HLCSTCP",251,0)
SDFLD ; set Shutdown? field to yes
"RTN","HLCSTCP",252,0)
 Q:'$G(HLDP)
"RTN","HLCSTCP",253,0)
 ; HL*1.6*122 remove unnecessary lock and call to FM
"RTN","HLCSTCP",254,0)
 S $P(^HLCS(870,HLDP,0),U,15)=1
"RTN","HLCSTCP",255,0)
 ;N HLJ,X
"RTN","HLCSTCP",256,0)
 ;F  L +^HLCS(870,HLDP,0):2 Q:$T
"RTN","HLCSTCP",257,0)
 ;14=Shutdown LLP?
"RTN","HLCSTCP",258,0)
 ;S HLJ(870,HLDP_",",14)=1
"RTN","HLCSTCP",259,0)
 ;D FILE^HLDIE("","HLJ","","SDFLD","HLCSTCP") ;HL*1.6*109
"RTN","HLCSTCP",260,0)
 ;L -^HLCS(870,HLDP,0)
"RTN","HLCSTCP",261,0)
 Q
"RTN","HLCSTCP",262,0)
 ;
"RTN","HLCSTCP",263,0)
EXITS(Y) ; shutdown and clean up the listener process for either
"RTN","HLCSTCP",264,0)
 ; single-threaded or multi-threaded
"RTN","HLCSTCP",265,0)
 N HLJ,X
"RTN","HLCSTCP",266,0)
 F  L +^HLCS(870,HLDP,0):2 Q:$T
"RTN","HLCSTCP",267,0)
 ;4=status,10=Time Stopped,9=Time Started,11=Task Number
"RTN","HLCSTCP",268,0)
 S X="HLJ(870,"""_HLDP_","")"
"RTN","HLCSTCP",269,0)
 S @X@(4)=Y,@X@(11)="@"
"RTN","HLCSTCP",270,0)
 S:$G(HLCSOUT)'=2 @X@(10)=$$NOW^XLFDT,@X@(9)="@"
"RTN","HLCSTCP",271,0)
 D FILE^HLDIE("","HLJ","","EXITS","HLCSTCP") ; HL*1.6*109
"RTN","HLCSTCP",272,0)
 L -^HLCS(870,HLDP,0)
"RTN","HLCSTCP",273,0)
 I $D(ZTQUEUED) S ZTREQ="@"
"RTN","HLCSTCP",274,0)
 ; HL*1.6*122
"RTN","HLCSTCP",275,0)
 L -^HLCS("HLTCPLINK",HLDP)
"RTN","HLCSTCP",276,0)
 Q
"RTN","HLCSTCP",277,0)
 ;
"RTN","HLCSTCP",278,0)
EXITM ;Multiple service shutdown and clean up
"RTN","HLCSTCP",279,0)
 ; shutdown and clean up a connection spawned by the listener
"RTN","HLCSTCP",280,0)
 ; process for a multi-threaded listener
"RTN","HLCSTCP",281,0)
 D UPDT(0)
"RTN","HLCSTCP",282,0)
 I $D(ZTQUEUED) S ZTREQ="@"
"RTN","HLCSTCP",283,0)
 Q
"RTN","HLCSTCP1")
0^4^B73767277^B70690150
"RTN","HLCSTCP1",1,0)
HLCSTCP1 ;SFIRMFO/RSD - BI-DIRECTIONAL TCP ;04/15/08  11:11
"RTN","HLCSTCP1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**19,43,57,64,71,133,132,122,140**;OCT 13,1995;Build 5
"RTN","HLCSTCP1",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLCSTCP1",4,0)
 ;Receiver
"RTN","HLCSTCP1",5,0)
 ;connection is initiated by sender and listener accepts connection
"RTN","HLCSTCP1",6,0)
 ;and calls this routine
"RTN","HLCSTCP1",7,0)
 ;
"RTN","HLCSTCP1",8,0)
 N $ETRAP,$ESTACK S $ETRAP="D ERROR^HLCSTCP1"
"RTN","HLCSTCP1",9,0)
 N HLMIEN,HLASTMSG
"RTN","HLCSTCP1",10,0)
 ;
"RTN","HLCSTCP1",11,0)
 ; patch HL*1.6*140, save IO
"RTN","HLCSTCP1",12,0)
 S HLTCPORT("IO")=IO ;RWF
"RTN","HLCSTCP1",13,0)
 ; patch HL*1.6*122 start
"RTN","HLCSTCP1",14,0)
 ; variable to replace ^TMP
"RTN","HLCSTCP1",15,0)
 N HLTMBUF
"RTN","HLCSTCP1",16,0)
 ;
"RTN","HLCSTCP1",17,0)
 ; for HL7 application proxy user
"RTN","HLCSTCP1",18,0)
 ;; N HLDUZ,DUZ  ; patch HL*1.6*122 TEST v2: DUZ code removed
"RTN","HLCSTCP1",19,0)
 N HLDUZ
"RTN","HLCSTCP1",20,0)
 S HLDUZ=+$G(DUZ)
"RTN","HLCSTCP1",21,0)
 ;
"RTN","HLCSTCP1",22,0)
 D MON^HLCSTCP("Open")
"RTN","HLCSTCP1",23,0)
 ; K ^TMP("HLCSTCP",$J,0)
"RTN","HLCSTCP1",24,0)
 S HLMIEN=0,HLASTMSG=""
"RTN","HLCSTCP1",25,0)
 ;
"RTN","HLCSTCP1",26,0)
 ; patch HL*1.6*122 TEST v2: DUZ code removed
"RTN","HLCSTCP1",27,0)
 ; set DUZ for application proxy user
"RTN","HLCSTCP1",28,0)
 ;; D PROXY^HLCSTCP4
"RTN","HLCSTCP1",29,0)
 ;
"RTN","HLCSTCP1",30,0)
 F  D  Q:$$STOP^HLCSTCP  I 'HLMIEN D MON^HLCSTCP("Idle") H 3
"RTN","HLCSTCP1",31,0)
 . ; clean variables
"RTN","HLCSTCP1",32,0)
 . D CLEANVAR^HLCSTCP4
"RTN","HLCSTCP1",33,0)
 . ; patch HL*1.6*140, restore the saved IO
"RTN","HLCSTCP1",34,0)
 . S IO=HLTCPORT("IO") ;RWF
"RTN","HLCSTCP1",35,0)
 . S HLMIEN=$$READ
"RTN","HLCSTCP1",36,0)
 . Q:'HLMIEN
"RTN","HLCSTCP1",37,0)
 . ;
"RTN","HLCSTCP1",38,0)
 . ; patch HL*1.6*122 TEST v2: DUZ code removed
"RTN","HLCSTCP1",39,0)
 . ; DUZ comparison/reset for application proxy user
"RTN","HLCSTCP1",40,0)
 . ;; D HLDUZ^HLCSTCP4
"RTN","HLCSTCP1",41,0)
 . D HLDUZ2^HLCSTCP4
"RTN","HLCSTCP1",42,0)
 . ; protect HLDUZ
"RTN","HLCSTCP1",43,0)
 . N HLDUZ
"RTN","HLCSTCP1",44,0)
 . D PROCESS
"RTN","HLCSTCP1",45,0)
 ; patch HL*1.6*122 end
"RTN","HLCSTCP1",46,0)
 Q
"RTN","HLCSTCP1",47,0)
 ;
"RTN","HLCSTCP1",48,0)
PROCESS ;check message and reply
"RTN","HLCSTCP1",49,0)
 ;HLDP=LL in 870
"RTN","HLCSTCP1",50,0)
 N HLTCP,HLTCPI,HLTCPO
"RTN","HLCSTCP1",51,0)
 S HLTCP="",HLTCPO=HLDP,HLTCPI=+HLMIEN
"RTN","HLCSTCP1",52,0)
 ;update monitor, msg. received
"RTN","HLCSTCP1",53,0)
 D LLCNT^HLCSTCP(HLDP,1)
"RTN","HLCSTCP1",54,0)
 D NEW^HLTP3(HLMIEN)
"RTN","HLCSTCP1",55,0)
 ;I IO'=HLTCPORT("IO") D ^%ZTER ;RWF
"RTN","HLCSTCP1",56,0)
 ;update monitor, msg. processed
"RTN","HLCSTCP1",57,0)
 D LLCNT^HLCSTCP(HLDP,2)
"RTN","HLCSTCP1",58,0)
 Q
"RTN","HLCSTCP1",59,0)
 ;
"RTN","HLCSTCP1",60,0)
READ() ;read 1 message, returns ien in 773^ien in 772 for message
"RTN","HLCSTCP1",61,0)
 D MON^HLCSTCP("Reading")
"RTN","HLCSTCP1",62,0)
 N HLDB,HLDT,HLDEND,HLACKWT,HLDSTRT,HLHDR,HLIND1,HLINE,HLMSG,HLRDOUT,HLRS,HLX,X
"RTN","HLCSTCP1",63,0)
 ;HLDSTRT=start char., HLDEND=end char., HLRS=record separator
"RTN","HLCSTCP1",64,0)
 S HLDSTRT=$C(11),HLDEND=$C(28),HLRS=$C(13)
"RTN","HLCSTCP1",65,0)
 ;HLRDOUT=exit read loop, HLINE=line count, HLIND1=ien 773^ien 772
"RTN","HLCSTCP1",66,0)
 ;HLHDR=have a header, HLTMBUF()=excess from last read, HLACKWT=wait for ack
"RTN","HLCSTCP1",67,0)
 ; HL*1.6*122 start
"RTN","HLCSTCP1",68,0)
 ; S (HLRDOUT,HLINE,HLIND1,HLHDR)=0,HLX=$G(^TMP("HLCSTCP",$J,0)),HLACKWT=HLDBACK
"RTN","HLCSTCP1",69,0)
 S (HLRDOUT,HLINE,HLIND1,HLHDR)=0,HLX=$G(HLTMBUF(0)),HLACKWT=HLDBACK
"RTN","HLCSTCP1",70,0)
 N HLBUFF,HLXX,MAXWAIT
"RTN","HLCSTCP1",71,0)
 ; based on patch 132 for readtime
"RTN","HLCSTCP1",72,0)
 S MAXWAIT=$S((HLACKWT>HLDREAD):HLACKWT,1:HLDREAD)
"RTN","HLCSTCP1",73,0)
 S HLRS("START-FLAG")=0
"RTN","HLCSTCP1",74,0)
 S HLTMBUF(0)=""
"RTN","HLCSTCP1",75,0)
 ; variable used to store data in HLBUFF
"RTN","HLCSTCP1",76,0)
 S HLX(1)=$G(HLTMBUF(1))
"RTN","HLCSTCP1",77,0)
 S HLTMBUF(1)=""
"RTN","HLCSTCP1",78,0)
 S HLBUFF("START")=0
"RTN","HLCSTCP1",79,0)
 S HLBUFF("END")=0
"RTN","HLCSTCP1",80,0)
 I (HLX]"")!(HLX(1)]"") D
"RTN","HLCSTCP1",81,0)
 . I (HLX[HLDSTRT)!(HLX(1)[HLDSTRT) D
"RTN","HLCSTCP1",82,0)
 .. S HLBUFF("START")=1
"RTN","HLCSTCP1",83,0)
 . I (HLX[HLDEND)!(HLX(1)[HLDEND) D
"RTN","HLCSTCP1",84,0)
 .. S HLBUFF("END")=1
"RTN","HLCSTCP1",85,0)
 F  D RDBLK Q:HLRDOUT
"RTN","HLCSTCP1",86,0)
 ;**132**
"RTN","HLCSTCP1",87,0)
 ;switch to null device if opened to prevent 'leakage'
"RTN","HLCSTCP1",88,0)
 I $G(IO(0))]"",IO(0)'=IO U IO(0)
"RTN","HLCSTCP1",89,0)
 ;
"RTN","HLCSTCP1",90,0)
 ;save any excess for next time
"RTN","HLCSTCP1",91,0)
 S:HLX]"" HLTMBUF(0)=HLX
"RTN","HLCSTCP1",92,0)
 S:HLX(1)]"" HLTMBUF(1)=HLX(1)
"RTN","HLCSTCP1",93,0)
 I +HLIND1,'$P(HLIND1,U,3) D DELMSG(HLIND1) S HLIND1=0
"RTN","HLCSTCP1",94,0)
 Q HLIND1
"RTN","HLCSTCP1",95,0)
 ;
"RTN","HLCSTCP1",96,0)
RDBLK ;
"RTN","HLCSTCP1",97,0)
 ; initialize
"RTN","HLCSTCP1",98,0)
 S HLBUFF=""
"RTN","HLCSTCP1",99,0)
 ;
"RTN","HLCSTCP1",100,0)
 ;S HLDB=HLDBSIZE-$L(HLX)
"RTN","HLCSTCP1",101,0)
 ; store the total length of HLX and HLX(1) in HLDB(1)
"RTN","HLCSTCP1",102,0)
 S HLDB(1)=$L(HLX)+$L(HLX(1))
"RTN","HLCSTCP1",103,0)
 ;
"RTN","HLCSTCP1",104,0)
 ;**132 **
"RTN","HLCSTCP1",105,0)
 ;U IO R X#HLDB:HLDREAD
"RTN","HLCSTCP1",106,0)
 ; U IO R X#HLDB:MAXWAIT
"RTN","HLCSTCP1",107,0)
 ;
"RTN","HLCSTCP1",108,0)
 ; remove the readcount to speedup GT.M
"RTN","HLCSTCP1",109,0)
 U IO
"RTN","HLCSTCP1",110,0)
 R:(HLDB(1)<HLDBSIZE) HLBUFF:MAXWAIT
"RTN","HLCSTCP1",111,0)
 ;
"RTN","HLCSTCP1",112,0)
 I HLBUFF]"" D
"RTN","HLCSTCP1",113,0)
 . I HLBUFF[HLDSTRT,(HLBUFF("START")=0) D
"RTN","HLCSTCP1",114,0)
 .. ; remove the extraneous text prefixing the "START" char
"RTN","HLCSTCP1",115,0)
 .. I $P(HLBUFF,HLDSTRT)]"" S HLBUFF=HLDSTRT_$P(HLBUFF,HLDSTRT,2,99)
"RTN","HLCSTCP1",116,0)
 .. S HLBUFF("START")=1
"RTN","HLCSTCP1",117,0)
 . ;
"RTN","HLCSTCP1",118,0)
 . I HLBUFF[HLDEND,(HLBUFF("END")=0) S HLBUFF("END")=1
"RTN","HLCSTCP1",119,0)
 ; detect disconnect for GT.M
"RTN","HLCSTCP1",120,0)
 I $G(^%ZOSF("OS"))["GT.M",$DEVICE S $ECODE=",UREAD,"
"RTN","HLCSTCP1",121,0)
 ; timedout, <clean up>, quit
"RTN","HLCSTCP1",122,0)
 ;I '$T,X="",HLX="" S HLACKWT=HLACKWT-HLDREAD D:HLACKWT<0&'HLHDR CLEAN Q
"RTN","HLCSTCP1",123,0)
 ;I '$T,X="",HLX="" D:'HLHDR CLEAN Q
"RTN","HLCSTCP1",124,0)
 ; patch HL*1.6*140
"RTN","HLCSTCP1",125,0)
 ; I '$T,HLBUFF="",HLX="",HLX(1)="" D  Q
"RTN","HLCSTCP1",126,0)
 I HLBUFF="",HLX="",HLX(1)="" D  Q
"RTN","HLCSTCP1",127,0)
 . D:('HLHDR)&('HLIND1) CLEAN
"RTN","HLCSTCP1",128,0)
 ;add incoming line to what wasn't processed in last read
"RTN","HLCSTCP1",129,0)
 ;S HLX=$G(HLX)_X
"RTN","HLCSTCP1",130,0)
 ; get block of characters from read buffer HLBUFF
"RTN","HLCSTCP1",131,0)
 ; every 'for-loop' deal with one read at most, and one message at most
"RTN","HLCSTCP1",132,0)
 ; if HLX is not empty, loop continues even no data is read
"RTN","HLCSTCP1",133,0)
 ; quit, if both HLDBUFF and HLX(1) are empty, means one read is done
"RTN","HLCSTCP1",134,0)
 ; quit, when HLRDOUT is set to 1, means one message is encountered
"RTN","HLCSTCP1",135,0)
 ; an "end"
"RTN","HLCSTCP1",136,0)
 ; F  D  Q:HLXX=""!(HLRDOUT)
"RTN","HLCSTCP1",137,0)
 F  D  Q:(HLRDOUT)!(HLBUFF=""&(HLX(1)=""))
"RTN","HLCSTCP1",138,0)
 . ;
"RTN","HLCSTCP1",139,0)
 . ; if HLX(1) is not empty
"RTN","HLCSTCP1",140,0)
 . I HLX(1)]"" D
"RTN","HLCSTCP1",141,0)
 .. ; hldb(2) is the number of characters extracted from hlx(1)
"RTN","HLCSTCP1",142,0)
 .. ; to be concatenated with hlx
"RTN","HLCSTCP1",143,0)
 .. S HLDB(2)=HLDBSIZE-$L(HLX)
"RTN","HLCSTCP1",144,0)
 .. ; hlx(2) stores the first hldb(2) characters extracted
"RTN","HLCSTCP1",145,0)
 .. ; from hlx(1)
"RTN","HLCSTCP1",146,0)
 .. S HLX(2)=$E(HLX(1),1,HLDB(2))
"RTN","HLCSTCP1",147,0)
 .. S HLX(1)=$E(HLX(1),HLDB(2)+1,$L(HLX(1)))
"RTN","HLCSTCP1",148,0)
 .. S HLX=$G(HLX)_HLX(2)
"RTN","HLCSTCP1",149,0)
 . ;
"RTN","HLCSTCP1",150,0)
 . ; if HLX(1) is empty, and HLBUFF contains data
"RTN","HLCSTCP1",151,0)
 . ; all the data in hlx(1) need to be extracted first
"RTN","HLCSTCP1",152,0)
 . I HLX(1)="",HLBUFF]"" D
"RTN","HLCSTCP1",153,0)
 .. S HLDB=HLDBSIZE-$L(HLX)
"RTN","HLCSTCP1",154,0)
 .. S HLXX=$E(HLBUFF,1,HLDB)
"RTN","HLCSTCP1",155,0)
 .. S HLBUFF=$E(HLBUFF,HLDB+1,$L(HLBUFF))
"RTN","HLCSTCP1",156,0)
 .. S HLX=$G(HLX)_HLXX
"RTN","HLCSTCP1",157,0)
 . ; quit when HLX is empty
"RTN","HLCSTCP1",158,0)
 . Q:(HLX="")
"RTN","HLCSTCP1",159,0)
 . ; ** 132 **
"RTN","HLCSTCP1",160,0)
 . ; if no segment end, HLX not full, go back for more
"RTN","HLCSTCP1",161,0)
 . I $L(HLX)<HLDBSIZE,HLX'[HLRS,HLX'[HLDEND Q
"RTN","HLCSTCP1",162,0)
 . ;add incoming line to what wasn't processed
"RTN","HLCSTCP1",163,0)
 . D RDBLK2
"RTN","HLCSTCP1",164,0)
 ;
"RTN","HLCSTCP1",165,0)
 ; it is possible one message is encountered an "end" and other
"RTN","HLCSTCP1",166,0)
 ; messages left in buffer,HLBUFF, save it in HLX for next run
"RTN","HLCSTCP1",167,0)
 I HLBUFF]"" D
"RTN","HLCSTCP1",168,0)
 . ; variable HLBUFF may remain data with size more than HLDBSIZE
"RTN","HLCSTCP1",169,0)
 . ; variable HLBUFF is not empty, only if the total length of
"RTN","HLCSTCP1",170,0)
 . ; HLX and HLX(1) is less than HLDBSIZE and HLX(1) should be
"RTN","HLCSTCP1",171,0)
 . ; empty when the command s hlx(1)=$g(hlx(1))_hlbuff is executed
"RTN","HLCSTCP1",172,0)
 . ; use hlx(1) to store the data of hlbuff to avoid "MAXTRING" error
"RTN","HLCSTCP1",173,0)
 . S HLX(1)=$G(HLX(1))_HLBUFF
"RTN","HLCSTCP1",174,0)
 . S HLBUFF=""
"RTN","HLCSTCP1",175,0)
 Q
"RTN","HLCSTCP1",176,0)
 ;
"RTN","HLCSTCP1",177,0)
RDBLK2 ;data stream: <sb>dddd<cr><eb><cr>
"RTN","HLCSTCP1",178,0)
 ; HL*1.6*122 end
"RTN","HLCSTCP1",179,0)
 ; look for segment= <CR>
"RTN","HLCSTCP1",180,0)
 F  Q:HLX'[HLRS  D  Q:HLRDOUT
"RTN","HLCSTCP1",181,0)
 . ; Get the first piece, save the rest of the line
"RTN","HLCSTCP1",182,0)
 . S HLINE=HLINE+1,HLMSG(HLINE,0)=$P(HLX,HLRS),HLX=$P(HLX,HLRS,2,999)
"RTN","HLCSTCP1",183,0)
 . ; check for start block, Quit if no ien
"RTN","HLCSTCP1",184,0)
 . I HLMSG(HLINE,0)[HLDSTRT!HLHDR D  Q
"RTN","HLCSTCP1",185,0)
 .. S HLRS("START-FLAG")=1 ; HL*1.6*122
"RTN","HLCSTCP1",186,0)
 .. D:HLMSG(HLINE,0)[HLDSTRT
"RTN","HLCSTCP1",187,0)
 ... S X=$L(HLMSG(HLINE,0),HLDSTRT)
"RTN","HLCSTCP1",188,0)
 ... S:X>2 HLMSG(HLINE,0)=HLDSTRT_$P(HLMSG(HLINE,0),HLDSTRT,X)
"RTN","HLCSTCP1",189,0)
 ... S HLMSG(HLINE,0)=$P(HLMSG(HLINE,0),HLDSTRT,2)
"RTN","HLCSTCP1",190,0)
 ... D RESET:(HLINE>1)
"RTN","HLCSTCP1",191,0)
 .. ;
"RTN","HLCSTCP1",192,0)
 .. ; patch HL*1.6*122
"RTN","HLCSTCP1",193,0)
 .. ; if the first line less than 10 characters
"RTN","HLCSTCP1",194,0)
 .. I HLHDR,$L(HLMSG(1,0))<10,$D(HLMSG(2,0)) D
"RTN","HLCSTCP1",195,0)
 ... S HLMSG(1,0)=HLMSG(1,0)_$E(HLMSG(2,0),1,10)
"RTN","HLCSTCP1",196,0)
 ... S HLMSG(2,0)=$E(HLMSG(2,0),11,9999999)
"RTN","HLCSTCP1",197,0)
 .. ;
"RTN","HLCSTCP1",198,0)
 .. ;ping message
"RTN","HLCSTCP1",199,0)
 .. I $E(HLMSG(1,0),1,9)="MSH^PING^" D PING Q
"RTN","HLCSTCP1",200,0)
 .. ; get next ien to store
"RTN","HLCSTCP1",201,0)
 .. D MIEN^HLCSTCP4
"RTN","HLCSTCP1",202,0)
 .. K HLMSG
"RTN","HLCSTCP1",203,0)
 .. S (HLINE,HLHDR)=0
"RTN","HLCSTCP1",204,0)
 . ; check for end block; <eb><cr>
"RTN","HLCSTCP1",205,0)
 . I HLMSG(HLINE,0)[HLDEND D
"RTN","HLCSTCP1",206,0)
 .. ; patch HL*1.6*122 start
"RTN","HLCSTCP1",207,0)
 .. ;no msg. ien
"RTN","HLCSTCP1",208,0)
 .. ; Q:'HLIND1
"RTN","HLCSTCP1",209,0)
 .. I 'HLIND1 D CLEAN Q
"RTN","HLCSTCP1",210,0)
 .. ; Kill just the last line if no data before HLDEND
"RTN","HLCSTCP1",211,0)
 .. I $P(HLMSG(HLINE,0),HLDEND)']"" D
"RTN","HLCSTCP1",212,0)
 ... K HLMSG(HLINE,0) S HLINE=HLINE-1
"RTN","HLCSTCP1",213,0)
 .. E  S HLMSG(HLINE,0)=$P(HLMSG(HLINE,0),HLDEND)
"RTN","HLCSTCP1",214,0)
 .. ; patch HL*1.6*122 end
"RTN","HLCSTCP1",215,0)
 .. ;
"RTN","HLCSTCP1",216,0)
 .. ; move into 772
"RTN","HLCSTCP1",217,0)
 .. D SAVE(.HLMSG,"^HL(772,"_+$P(HLIND1,U,2)_",""IN"")")
"RTN","HLCSTCP1",218,0)
 .. ;mark that end block has been received
"RTN","HLCSTCP1",219,0)
 .. ;HLIND1=ien in 773^ien in 772^1 if end block was received
"RTN","HLCSTCP1",220,0)
 .. S $P(HLIND1,U,3)=1
"RTN","HLCSTCP1",221,0)
 .. S HLBUFF("HLIND1")=HLIND1
"RTN","HLCSTCP1",222,0)
 .. ;reset variables for next message
"RTN","HLCSTCP1",223,0)
 .. D CLEAN
"RTN","HLCSTCP1",224,0)
 . ;add blank line for carriage return
"RTN","HLCSTCP1",225,0)
 . I HLINE'=0,HLMSG(HLINE,0)]"" S HLINE=HLINE+1,HLMSG(HLINE,0)=""
"RTN","HLCSTCP1",226,0)
 Q:HLRDOUT
"RTN","HLCSTCP1",227,0)
 ;If the line is long and no <CR> move it into the array.
"RTN","HLCSTCP1",228,0)
 I ($L(HLX)=HLDBSIZE),(HLX'[HLRS),(HLX'[HLDEND),(HLX'[HLDSTRT) D  Q
"RTN","HLCSTCP1",229,0)
 . S HLINE=HLINE+1,HLMSG(HLINE,0)=HLX,HLX=""
"RTN","HLCSTCP1",230,0)
 ;have start block but no record separator
"RTN","HLCSTCP1",231,0)
 I HLX[HLDSTRT D  Q
"RTN","HLCSTCP1",232,0)
 . ;check for more than 1 start block
"RTN","HLCSTCP1",233,0)
 . S X=$L(HLX,HLDSTRT) S:X>2 HLX=HLDSTRT_$P(HLX,HLDSTRT,X)
"RTN","HLCSTCP1",234,0)
 . ;
"RTN","HLCSTCP1",235,0)
 . ; patch HL*1.6*122
"RTN","HLCSTCP1",236,0)
 . ; S:$L($P(HLX,HLDSTRT,2))>8 HLINE=HLINE+1,HLMSG(HLINE,0)=$P(HLX,HLDSTRT,2),HLX="",HLHDR=1
"RTN","HLCSTCP1",237,0)
 . S HLINE=HLINE+1,HLMSG(HLINE,0)=$P(HLX,HLDSTRT,2),HLX="",HLHDR=1
"RTN","HLCSTCP1",238,0)
 . ;
"RTN","HLCSTCP1",239,0)
 . D RESET:(HLHDR&(HLINE>1))
"RTN","HLCSTCP1",240,0)
 ;if no ien, reset
"RTN","HLCSTCP1",241,0)
 ; patch HL*1.6*122
"RTN","HLCSTCP1",242,0)
 ; I 'HLIND1 D CLEAN Q
"RTN","HLCSTCP1",243,0)
 I (HLRS("START-FLAG")=1),'HLIND1 D CLEAN Q
"RTN","HLCSTCP1",244,0)
 ; big message-merge from local to global every 100 lines
"RTN","HLCSTCP1",245,0)
 I (HLINE-$O(HLMSG(0)))>100 D
"RTN","HLCSTCP1",246,0)
 . M ^HL(772,+$P(HLIND1,U,2),"IN")=HLMSG
"RTN","HLCSTCP1",247,0)
 . ; reset working array
"RTN","HLCSTCP1",248,0)
 . K HLMSG
"RTN","HLCSTCP1",249,0)
 Q
"RTN","HLCSTCP1",250,0)
 ;
"RTN","HLCSTCP1",251,0)
SAVE(SRC,DEST) ;save into global & set top node
"RTN","HLCSTCP1",252,0)
 ;SRC=source array (passed by ref.), DEST=destination global
"RTN","HLCSTCP1",253,0)
 ;
"RTN","HLCSTCP1",254,0)
 ; patch HL*1.6*122: MPI-client/server
"RTN","HLCSTCP1",255,0)
 I DEST["HLMA" D
"RTN","HLCSTCP1",256,0)
 . F  L +^HLMA(+HLIND1):10 Q:$T  H 1
"RTN","HLCSTCP1",257,0)
 E  D
"RTN","HLCSTCP1",258,0)
 . F  L +^HL(772,+$P(HLIND1,U,2)):10 Q:$T  H 1
"RTN","HLCSTCP1",259,0)
 ;
"RTN","HLCSTCP1",260,0)
 M @DEST=SRC
"RTN","HLCSTCP1",261,0)
 S @DEST@(0)="^^"_HLINE_"^"_HLINE_"^"_DT_"^"
"RTN","HLCSTCP1",262,0)
 ;
"RTN","HLCSTCP1",263,0)
 I DEST["HLMA" L -^HLMA(+HLIND1)
"RTN","HLCSTCP1",264,0)
 E  L -^HL(772,+$P(HLIND1,U,2))
"RTN","HLCSTCP1",265,0)
 ;
"RTN","HLCSTCP1",266,0)
 Q
"RTN","HLCSTCP1",267,0)
 ;
"RTN","HLCSTCP1",268,0)
DELMSG(HLMAMT) ;delete message from Message Administration/Message Text files.
"RTN","HLCSTCP1",269,0)
 N DIK,DA
"RTN","HLCSTCP1",270,0)
 S DA=+HLMAMT,DIK="^HLMA("
"RTN","HLCSTCP1",271,0)
 D ^DIK
"RTN","HLCSTCP1",272,0)
 S DA=$P(HLMAMT,U,2),DIK="^HL(772,"
"RTN","HLCSTCP1",273,0)
 D ^DIK
"RTN","HLCSTCP1",274,0)
 Q
"RTN","HLCSTCP1",275,0)
PING ;process PING message
"RTN","HLCSTCP1",276,0)
 S X=HLMSG(1,0)
"RTN","HLCSTCP1",277,0)
 ; patch HL*1.6*140, flush character- HLTCPLNK("IOF")
"RTN","HLCSTCP1",278,0)
 ; I X[HLDEND U IO W X,! D
"RTN","HLCSTCP1",279,0)
 I X[HLDEND U IO W X,HLTCPLNK("IOF") D
"RTN","HLCSTCP1",280,0)
 . ; switch to null device if opened to prevent 'leakage'
"RTN","HLCSTCP1",281,0)
 . I $G(IO(0))]"",$G(IO(0))'=IO U IO(0)
"RTN","HLCSTCP1",282,0)
CLEAN ;reset var. for next message
"RTN","HLCSTCP1",283,0)
 K HLMSG
"RTN","HLCSTCP1",284,0)
 S HLINE=0,HLRDOUT=1
"RTN","HLCSTCP1",285,0)
 Q
"RTN","HLCSTCP1",286,0)
 ;
"RTN","HLCSTCP1",287,0)
ERROR ; Error trap for disconnect error and return back to the read loop.
"RTN","HLCSTCP1",288,0)
 ; patch HL*1.6*122
"RTN","HLCSTCP1",289,0)
 ; move to routine HLCSTCP4 (splitted-size over 10000)
"RTN","HLCSTCP1",290,0)
 D ERROR1^HLCSTCP4
"RTN","HLCSTCP1",291,0)
 Q
"RTN","HLCSTCP1",292,0)
 ;
"RTN","HLCSTCP1",293,0)
CC(X) ;cleanup and close
"RTN","HLCSTCP1",294,0)
 D MON^HLCSTCP(X)
"RTN","HLCSTCP1",295,0)
 H 2
"RTN","HLCSTCP1",296,0)
 Q
"RTN","HLCSTCP1",297,0)
RESET ;reset info as a result of no end block
"RTN","HLCSTCP1",298,0)
 N %
"RTN","HLCSTCP1",299,0)
 S HLMSG(1,0)=HLMSG(HLINE,0)
"RTN","HLCSTCP1",300,0)
 F %=2:1:HLINE K HLMSG(%,0)
"RTN","HLCSTCP1",301,0)
 S HLINE=1
"RTN","HLCSTCP1",302,0)
 Q
"RTN","HLCSTCP2")
0^7^B70352129^B68574650
"RTN","HLCSTCP2",1,0)
HLCSTCP2 ;SFIRMFO/RSD - BI-DIRECTIONAL TCP ;04/16/2008  16:20
"RTN","HLCSTCP2",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**19,43,49,57,63,64,66,67,76,77,87,109,133,122,140**;Oct 13,1995;Build 5
"RTN","HLCSTCP2",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLCSTCP2",4,0)
 ;Sender 
"RTN","HLCSTCP2",5,0)
 ;Request connection, send outbound message(s) delimited by MLLP
"RTN","HLCSTCP2",6,0)
 ;Input : HLDP=Logical Link to use
"RTN","HLCSTCP2",7,0)
 ; Set up error trap
"RTN","HLCSTCP2",8,0)
 N $ETRAP,$ESTACK S $ETRAP="D ERROR^HLCSTCP2"
"RTN","HLCSTCP2",9,0)
 N HLMSG,HLPORT,HLRETRY,HLRETMG,HLTCPO,POP
"RTN","HLCSTCP2",10,0)
 ;HLRETRY=number of retranmission for this link,HLRETMG=alert sent
"RTN","HLCSTCP2",11,0)
 S HLTCPO=HLDP,HLMSG="",(HLRETRY,HLRETMG)=0
"RTN","HLCSTCP2",12,0)
 ;
"RTN","HLCSTCP2",13,0)
 ; patch 122
"RTN","HLCSTCP2",14,0)
 ; patch 133
"RTN","HLCSTCP2",15,0)
 ; set IO(0) to the null device
"RTN","HLCSTCP2",16,0)
 I $G(^%ZOSF("OS"))]"",^%ZOSF("OS")'["GT.M" D
"RTN","HLCSTCP2",17,0)
 . S IO(0)=$S(^%ZOSF("OS")["OpenM":$S($$OS^%ZOSV()["VMS":"_NLA0:",$$OS^%ZOSV()["UNIX":"/dev/null",1:$P),^%ZOSF("OS")["DSM":"_NLA0:",1:$P)
"RTN","HLCSTCP2",18,0)
 . O IO(0) U IO(0)
"RTN","HLCSTCP2",19,0)
 ;
"RTN","HLCSTCP2",20,0)
 ;persistent conection, open connection first, HLPORT=open port
"RTN","HLCSTCP2",21,0)
 I $G(HLTCPLNK)["Y" F  Q:$$OPEN  G EXIT:$$STOP^HLCSTCP H 1
"RTN","HLCSTCP2",22,0)
 F  D QUE Q:$$STOP^HLCSTCP  D:'HLMSG  Q:$G(HLCSOUT)
"RTN","HLCSTCP2",23,0)
 . ;no messages to send
"RTN","HLCSTCP2",24,0)
 . D MON^HLCSTCP("Idle") H 3
"RTN","HLCSTCP2",25,0)
 . ;persistent connection, no retention
"RTN","HLCSTCP2",26,0)
 . Q:$G(HLTCPLNK)["Y"
"RTN","HLCSTCP2",27,0)
 . D MON^HLCSTCP("Retention")
"RTN","HLCSTCP2",28,0)
 . N % I 0
"RTN","HLCSTCP2",29,0)
 . ;if message comes in or ask to stop
"RTN","HLCSTCP2",30,0)
 . F %=1:1:HLTCPRET H 1 I $$STOP^HLCSTCP!$O(^HLMA("AC","O",HLDP,0)) Q
"RTN","HLCSTCP2",31,0)
 . E  S HLCSOUT=2 Q
"RTN","HLCSTCP2",32,0)
 . Q:$$STOP^HLCSTCP
"RTN","HLCSTCP2",33,0)
 . D MON^HLCSTCP("Idle")
"RTN","HLCSTCP2",34,0)
 ;Close port
"RTN","HLCSTCP2",35,0)
 I $D(HLPORT) D CLOSE^%ZISTCP K HLPORT
"RTN","HLCSTCP2",36,0)
EXIT Q
"RTN","HLCSTCP2",37,0)
 ;
"RTN","HLCSTCP2",38,0)
QUE ; -- Check "OUT" queue for processing IF there is a message do it
"RTN","HLCSTCP2",39,0)
 ; and then check the link if it open or not
"RTN","HLCSTCP2",40,0)
 N HL,HLN,HLARR,HLHDR,HLI,HLJ,HLMSA,HLRESP,HLRESLT,HLRETRM,HLTCP,HLTCPI,X,Z,HLREREAD
"RTN","HLCSTCP2",41,0)
 N HLTMBUF
"RTN","HLCSTCP2",42,0)
 D MON^HLCSTCP("CheckOut")
"RTN","HLCSTCP2",43,0)
 ;HLMSG=next msg, set at tag DONE
"RTN","HLCSTCP2",44,0)
 I 'HLMSG S HLMSG=+$O(^HLMA("AC","O",HLDP,0)),HLRETRY=0 Q:'HLMSG
"RTN","HLCSTCP2",45,0)
 ;
"RTN","HLCSTCP2",46,0)
 S HLI=+$G(^HLMA(HLMSG,0)),HLJ=$O(^("MSH",0)),HLTCP=""
"RTN","HLCSTCP2",47,0)
 ;don't have message text or MSH, kill x-ref and decrement 'to send'
"RTN","HLCSTCP2",48,0)
 ;
"RTN","HLCSTCP2",49,0)
 ; patch HL*1.6*122: MPI-client/server
"RTN","HLCSTCP2",50,0)
 ; I 'HLI!'HLJ K ^HLMA("AC","O",HLDP,HLMSG) D LLCNT^HLCSTCP(HLDP,3,1) S HLMSG=0 Q
"RTN","HLCSTCP2",51,0)
 I 'HLI!'HLJ D  Q
"RTN","HLCSTCP2",52,0)
 . F  L +^HLMA("AC","O",HLDP,HLMSG):10 Q:$T  H 1
"RTN","HLCSTCP2",53,0)
 . K ^HLMA("AC","O",HLDP,HLMSG)
"RTN","HLCSTCP2",54,0)
 . L -^HLMA("AC","O",HLDP,HLMSG)
"RTN","HLCSTCP2",55,0)
 . D LLCNT^HLCSTCP(HLDP,3,1)
"RTN","HLCSTCP2",56,0)
 . S HLMSG=0
"RTN","HLCSTCP2",57,0)
 ;
"RTN","HLCSTCP2",58,0)
 ;update msg status to 'being transmitted'; if cancelled decrement link and quit
"RTN","HLCSTCP2",59,0)
 I '$$CHKMSG(1.5) D LLCNT^HLCSTCP(HLDP,3,1) S HLMSG=0 Q
"RTN","HLCSTCP2",60,0)
 ;number of retransmissions for message
"RTN","HLCSTCP2",61,0)
 S HLRETRM=+$P(^HLMA(HLMSG,"P"),U,5)
"RTN","HLCSTCP2",62,0)
 ;retries exceeded, HLRETRA:action i=ignore, r=restart, s=shutdown
"RTN","HLCSTCP2",63,0)
 ;quit if restart or shutdown, link is going down
"RTN","HLCSTCP2",64,0)
 I HLRETRY>HLDRETR D  Q:"I"'[HLRETRA
"RTN","HLCSTCP2",65,0)
 . D MON^HLCSTCP("Error")
"RTN","HLCSTCP2",66,0)
 . ;only 1 alert per link up time, don't send if restart
"RTN","HLCSTCP2",67,0)
 . D:'HLRETMG&(HLRETRA'="R")
"RTN","HLCSTCP2",68,0)
 .. ;send alert
"RTN","HLCSTCP2",69,0)
 .. N XQA,XQAMSG,XQAOPT,XQAROU,XQAID,Z
"RTN","HLCSTCP2",70,0)
 .. ;get mailgroup from file 869.3
"RTN","HLCSTCP2",71,0)
 .. S HLRETMG=1,Z=$P($$PARAM^HLCS2,U,8) Q:Z=""
"RTN","HLCSTCP2",72,0)
 .. S XQA("G."_Z)="",XQAMSG=$$HTE^XLFDT($H,2)_" HL7 LL "_$P(^HLCS(870,HLDP,0),U)_" exceeded retries. LL will "_$S(HLRETRA="S":"shutdown.",HLRETRA="R":"restart.",1:"keep trying.")
"RTN","HLCSTCP2",73,0)
 .. D SETUP^XQALERT
"RTN","HLCSTCP2",74,0)
 . ;quit if action is ignore
"RTN","HLCSTCP2",75,0)
 . Q:"I"[HLRETRA
"RTN","HLCSTCP2",76,0)
 . ;this will shutdown this link
"RTN","HLCSTCP2",77,0)
 . S HLCSOUT=1
"RTN","HLCSTCP2",78,0)
 . ;action is shutdown, set shutdown flag so LM won't restart
"RTN","HLCSTCP2",79,0)
 . S:HLRETRA="S" $P(^HLCS(870,HLDP,0),U,15)=1
"RTN","HLCSTCP2",80,0)
 . D STATUS^HLTF0(HLMSG,4,103,"LLP Exceeded Retry Param")
"RTN","HLCSTCP2",81,0)
 I '$$OPEN Q
"RTN","HLCSTCP2",82,0)
 D MON^HLCSTCP("Send")
"RTN","HLCSTCP2",83,0)
 ; -- data passed in global array, success=1
"RTN","HLCSTCP2",84,0)
 I $$WRITE(HLMSG)<0 Q
"RTN","HLCSTCP2",85,0)
 S (HLTCP,HLTCPI)=HLMSG,HLRETRY=HLRETRY+1,HLRETRM=HLRETRM+1
"RTN","HLCSTCP2",86,0)
 ;update status to awaiting response, decrement link if cancelled
"RTN","HLCSTCP2",87,0)
 I '$$CHKMSG(1.7) D LLCNT^HLCSTCP(HLDP,3,1) S HLMSG=0 Q
"RTN","HLCSTCP2",88,0)
 ;set transmission count, get ACKTIMEOUT override
"RTN","HLCSTCP2",89,0)
 S $P(^HLMA(HLMSG,"P"),U,5)=HLRETRM I $P(^("P"),U,7) S HLN("ACKTIME")=+$P(^("P"),U,7)
"RTN","HLCSTCP2",90,0)
 ;get header of message just sent
"RTN","HLCSTCP2",91,0)
 K HLJ M HLJ=^HLMA(HLMSG,"MSH")
"RTN","HLCSTCP2",92,0)
 ;first component of sending app.
"RTN","HLCSTCP2",93,0)
 S HLN("ECH")=$$P^HLTPCK2(.HLJ,2),HLN("SAN")=$P($$P^HLTPCK2(.HLJ,3),$E(HLN("ECH")))
"RTN","HLCSTCP2",94,0)
 ;msg type, msg. id, commit ack, and app. ack parameter
"RTN","HLCSTCP2",95,0)
 S HLN("TYPE")=$$P^HLTPCK2(.HLJ,1),HLN("MID")=$$P^HLTPCK2(.HLJ,10),HLN("ACAT")=$$P^HLTPCK2(.HLJ,15),HLN("APAT")=$$P^HLTPCK2(.HLJ,16)
"RTN","HLCSTCP2",96,0)
 ;MSA segment, message is a response, can't have an a. ack.
"RTN","HLCSTCP2",97,0)
 S Z=$$MSA^HLTP3(+^HLMA(HLMSG,0)) I Z]"" S:HLN("ACAT")="" HLN("ACAT")="NE" S HLN("APAT")="NE"
"RTN","HLCSTCP2",98,0)
 ;for batch/file with commit ack, reset c. ack and a. ack variables
"RTN","HLCSTCP2",99,0)
 I "BHS,FHS"[HLN("TYPE") S Z=$E(HLJ(1,0),5),X=$$P^HLTPCK2(.HLJ,9),HLN("ACAT")=$P(X,Z,5),HLN("APAT")=$P(X,Z,6),HLN("MID")=$$P^HLTPCK2(.HLJ,11)
"RTN","HLCSTCP2",100,0)
 ;get event protocol
"RTN","HLCSTCP2",101,0)
 S HLN("EID")=+$P(^HLMA(HLMSG,0),U,8),X=$G(^ORD(101,HLN("EID"),770))
"RTN","HLCSTCP2",102,0)
 ;set link counter to msg sent
"RTN","HLCSTCP2",103,0)
 D LLCNT^HLCSTCP(HLDP,4)
"RTN","HLCSTCP2",104,0)
 ;commit and app. ack is never, update status to complete and hang UNI-DIRECTIONAL WAIT
"RTN","HLCSTCP2",105,0)
 I HLN("ACAT")="NE",HLN("APAT")="NE" D  Q
"RTN","HLCSTCP2",106,0)
 .D DONE(3)
"RTN","HLCSTCP2",107,0)
 .;
"RTN","HLCSTCP2",108,0)
 .;
"RTN","HLCSTCP2",109,0)
 .H $G(HLDWAIT)
"RTN","HLCSTCP2",110,0)
 ;
"RTN","HLCSTCP2",111,0)
 ;do structure is to stack error
"RTN","HLCSTCP2",112,0)
 D
"RTN","HLCSTCP2",113,0)
 . N $ETRAP,$ESTACK S $ETRAP="D RDERR^HLCSTCP2"
"RTN","HLCSTCP2",114,0)
 . ;HL*1.6*87: Read acknowledgement.  
"RTN","HLCSTCP2",115,0)
 . ;Loop to re-read from buffer when receiving incorrect ack.
"RTN","HLCSTCP2",116,0)
 . F  D  Q:'+$G(HLREREAD)
"RTN","HLCSTCP2",117,0)
 .. S HLREREAD=1
"RTN","HLCSTCP2",118,0)
 .. ;override ack timeout
"RTN","HLCSTCP2",119,0)
 .. I $G(HLN("ACKTIME")) N HLDBACK S HLDBACK=HLN("ACKTIME")
"RTN","HLCSTCP2",120,0)
 .. ;check for response, quit if no-response, msg will be resent
"RTN","HLCSTCP2",121,0)
 .. ;HLRESP=ien 773^ien 772 for response message
"RTN","HLCSTCP2",122,0)
 .. S HLRESP=$$READ^HLCSTCP1()
"RTN","HLCSTCP2",123,0)
 .. ;if no response, decrement counter and quit
"RTN","HLCSTCP2",124,0)
 .. I 'HLRESP D  Q
"RTN","HLCSTCP2",125,0)
 ...D LLCNT^HLCSTCP(HLDP,4,1)
"RTN","HLCSTCP2",126,0)
 ...S HLREREAD="0^No Response"
"RTN","HLCSTCP2",127,0)
 ...;check if the port needs to be closed and re-opened before the next re-transmission attempt
"RTN","HLCSTCP2",128,0)
 ...I $G(HLDRETRY("CLOSE")) D CLOSE^%ZISTCP K HLPORT
"RTN","HLCSTCP2",129,0)
 .. ;X 0=re-read msg, 1=commit ack, 3=app ack success, 4=error
"RTN","HLCSTCP2",130,0)
 .. S X=$$RSP^HLTP31(HLRESP,.HLN)
"RTN","HLCSTCP2",131,0)
 .. ;X=0, re-read msg. Incorrect ack (bad MSH,MSA,msg id,or sending app)
"RTN","HLCSTCP2",132,0)
 .. Q:'X 
"RTN","HLCSTCP2",133,0)
 .. ;commit ack - done
"RTN","HLCSTCP2",134,0)
 .. I X=1 D  S HLREREAD="0^Commit Ack" Q
"RTN","HLCSTCP2",135,0)
 ... ;don't need app. ack, set status to complete
"RTN","HLCSTCP2",136,0)
 ... I "NE"[HLN("APAT") D  Q
"RTN","HLCSTCP2",137,0)
 ....D DONE(3)
"RTN","HLCSTCP2",138,0)
 ....;
"RTN","HLCSTCP2",139,0)
 ... ;response is deferred, set status to awaiting ack
"RTN","HLCSTCP2",140,0)
 ... D DONE(2)
"RTN","HLCSTCP2",141,0)
 ...;
"RTN","HLCSTCP2",142,0)
 .. ;Error, HLRESLT=error number^error message from HLTP3
"RTN","HLCSTCP2",143,0)
 .. I X=4 D  Q
"RTN","HLCSTCP2",144,0)
 ... D DONE(4,+$G(HLRESLT),$P($G(HLRESLT),U,2))
"RTN","HLCSTCP2",145,0)
 ...;
"RTN","HLCSTCP2",146,0)
 ... S HLREREAD="0^Error"
"RTN","HLCSTCP2",147,0)
 .. ;app ack was successful
"RTN","HLCSTCP2",148,0)
 .. D DONE(3) S HLREREAD="0^App Ack"
"RTN","HLCSTCP2",149,0)
 ..;
"RTN","HLCSTCP2",150,0)
 Q
"RTN","HLCSTCP2",151,0)
 ;
"RTN","HLCSTCP2",152,0)
DCSEND ;direct connect
"RTN","HLCSTCP2",153,0)
 ; Set up error trap
"RTN","HLCSTCP2",154,0)
 N $ETRAP,$ESTACK S $ETRAP="D ERROR^HLCSTCP2"
"RTN","HLCSTCP2",155,0)
 ; patch HL*1.6*122
"RTN","HLCSTCP2",156,0)
 N HLTMBUF
"RTN","HLCSTCP2",157,0)
 ;override ack timeout
"RTN","HLCSTCP2",158,0)
 I $G(HLP("ACKTIME")) N HLDBACK S HLDBACK=HLP("ACKTIME")
"RTN","HLCSTCP2",159,0)
 I $$WRITE(HLMSG)<0 D:$G(HLERROR)]""  Q  ;HL*1.6*77
"RTN","HLCSTCP2",160,0)
 .  D STATUS^HLTF0(HLMSG,4,$P(HLERROR,"^"),$P(HLERROR,"^",2),1) ;HL*1.6*77
"RTN","HLCSTCP2",161,0)
 .  D LLCNT^HLCSTCP(HLDP,3,1)
"RTN","HLCSTCP2",162,0)
 D LLCNT^HLCSTCP(HLDP,4)
"RTN","HLCSTCP2",163,0)
 ;do structure is to stack error
"RTN","HLCSTCP2",164,0)
 D
"RTN","HLCSTCP2",165,0)
 . N $ETRAP,$ESTACK S $ETRAP="D RDERR^HLCSTCP2"
"RTN","HLCSTCP2",166,0)
 . ;HLRESP=ien 773^ien 772 for response message
"RTN","HLCSTCP2",167,0)
 . S HLRESP=$$READ^HLCSTCP1()
"RTN","HLCSTCP2",168,0)
 ;
"RTN","HLCSTCP2",169,0)
 D DONE(3):$G(HLRESP),DONE(4,108,$S($G(HLERROR)]"":$P(HLERROR,"^",2),1:"No response")):'$G(HLRESP)
"RTN","HLCSTCP2",170,0)
 I $G(HLERROR)']"" D
"RTN","HLCSTCP2",171,0)
 .D MON^HLCSTCP("Idle")
"RTN","HLCSTCP2",172,0)
 .I '$G(HLRESP) S HLERROR="108^No response"
"RTN","HLCSTCP2",173,0)
 ;Close port
"RTN","HLCSTCP2",174,0)
 I $D(HLPORT) D CLOSE^%ZISTCP K HLPORT
"RTN","HLCSTCP2",175,0)
 Q
"RTN","HLCSTCP2",176,0)
 ;
"RTN","HLCSTCP2",177,0)
DONE(ST,ERR,ERRMSG) ;set status to complete
"RTN","HLCSTCP2",178,0)
 ;ST=status, ERR=error ien, ERRMSG=error msg
"RTN","HLCSTCP2",179,0)
 D STATUS^HLTF0(HLMSG,ST,$G(ERR),$G(ERRMSG),1)
"RTN","HLCSTCP2",180,0)
 ;
"RTN","HLCSTCP2",181,0)
 D DEQUE^HLCSREP(HLDP,"O",HLMSG)
"RTN","HLCSTCP2",182,0)
 ;
"RTN","HLCSTCP2",183,0)
 ;check for more msg.
"RTN","HLCSTCP2",184,0)
 I $G(HLPRIO)'="I" S HLMSG=+$O(^HLMA("AC","O",HLDP,0)),HLRETRY=0
"RTN","HLCSTCP2",185,0)
 Q
"RTN","HLCSTCP2",186,0)
 ;
"RTN","HLCSTCP2",187,0)
CHKMSG(HLI) ;check status of message and update if not cancelled
"RTN","HLCSTCP2",188,0)
 ;input: HLI=new status, HLMSG=ien of msg in 773
"RTN","HLCSTCP2",189,0)
 ;returns 1=msg was updated, 0=msg has been canceled
"RTN","HLCSTCP2",190,0)
 N X
"RTN","HLCSTCP2",191,0)
 ;
"RTN","HLCSTCP2",192,0)
 ; New HL*1.6*77 code starting here...
"RTN","HLCSTCP2",193,0)
 I '$D(^HLMA(HLMSG,"P")) D  Q 0
"RTN","HLCSTCP2",194,0)
 .  S HLERROR="2^Missing status field"
"RTN","HLCSTCP2",195,0)
 .  D STATUS^HLTF0(HLMSG,4,$P(HLERROR,U),$P(HLERROR,U,2),1)
"RTN","HLCSTCP2",196,0)
 .;
"RTN","HLCSTCP2",197,0)
 . D DEQUE^HLCSREP(HLDP,"O",HLMSG)
"RTN","HLCSTCP2",198,0)
 ;
"RTN","HLCSTCP2",199,0)
 ; End of HL*1.6*77
"RTN","HLCSTCP2",200,0)
 ;
"RTN","HLCSTCP2",201,0)
 ;get status, quit if msg was cancelled
"RTN","HLCSTCP2",202,0)
 ;
"RTN","HLCSTCP2",203,0)
 S X=+^HLMA(HLMSG,"P") Q:X=3 0
"RTN","HLCSTCP2",204,0)
 ;
"RTN","HLCSTCP2",205,0)
 ;update status if it is different
"RTN","HLCSTCP2",206,0)
 I $G(HLI),HLI'=X D STATUS^HLTF0(HLMSG,HLI)
"RTN","HLCSTCP2",207,0)
 ;
"RTN","HLCSTCP2",208,0)
 Q 1
"RTN","HLCSTCP2",209,0)
 ;
"RTN","HLCSTCP2",210,0)
WRITE(HLDA) ; write message in HL7 format
"RTN","HLCSTCP2",211,0)
 ;  HLDA       - ien of message in 773
"RTN","HLCSTCP2",212,0)
 ;             - start block $C(11)
"RTN","HLCSTCP2",213,0)
 ;             - end block $C(28)
"RTN","HLCSTCP2",214,0)
 ;             - record separator $C(13)
"RTN","HLCSTCP2",215,0)
 ;Output(s): 1 - Successful
"RTN","HLCSTCP2",216,0)
 ;           -1 - Unsuccessful
"RTN","HLCSTCP2",217,0)
 ;
"RTN","HLCSTCP2",218,0)
 N HLDA2,HLAR,HLI,LINENO,X,CRCOUNT
"RTN","HLCSTCP2",219,0)
 S CRCOUNT=0
"RTN","HLCSTCP2",220,0)
 ;set error trap, used when called from HLTP3
"RTN","HLCSTCP2",221,0)
 ;
"RTN","HLCSTCP2",222,0)
 ; New HL*1.6*77 code starts here...
"RTN","HLCSTCP2",223,0)
 N $ETRAP,$ESTACK S $ETRAP="D ERROR^HLCSTCP2"
"RTN","HLCSTCP2",224,0)
 I $G(^HLMA(HLDA,0))'>0 D  Q -1
"RTN","HLCSTCP2",225,0)
 .  S HLERROR="2^Message Text pointer missing"
"RTN","HLCSTCP2",226,0)
 S HLDA2=+$G(^HLMA(HLDA,0))
"RTN","HLCSTCP2",227,0)
 ; End of HL*1.6*77 modifications...
"RTN","HLCSTCP2",228,0)
 ;
"RTN","HLCSTCP2",229,0)
 Q:'$G(^HLMA(HLDA,0)) -1 ;HL*1.6*77
"RTN","HLCSTCP2",230,0)
 ; header is in ^HLMA(, message is in ^HL(772,
"RTN","HLCSTCP2",231,0)
 S LINENO=1,HLI=0,HLAR="^HLMA(HLDA,""MSH"")"
"RTN","HLCSTCP2",232,0)
 U IO
"RTN","HLCSTCP2",233,0)
 D  W $C(13) S HLAR="^HL(772,HLDA2,""IN"")",HLI=0 D
"RTN","HLCSTCP2",234,0)
 . F  S HLI=$O(@HLAR@(HLI)) Q:'HLI  S X=$G(^(HLI,0)) D
"RTN","HLCSTCP2",235,0)
 .. ;first line, need start block char.
"RTN","HLCSTCP2",236,0)
 .. S:LINENO=1 X=$C(11)_X
"RTN","HLCSTCP2",237,0)
 .. ; HL*1.6*122
"RTN","HLCSTCP2",238,0)
 .. ; I X]"" W X,!
"RTN","HLCSTCP2",239,0)
 .. N LENGTH
"RTN","HLCSTCP2",240,0)
 .. S LENGTH=$L(X)
"RTN","HLCSTCP2",241,0)
 .. ; buffer should be limited to 512
"RTN","HLCSTCP2",242,0)
 .. I LENGTH>512 D
"RTN","HLCSTCP2",243,0)
 ... N X1
"RTN","HLCSTCP2",244,0)
 ... F  Q:LENGTH<512  D
"RTN","HLCSTCP2",245,0)
 .... S X1=$E(X,1,512),X=$E(X,513,999999)
"RTN","HLCSTCP2",246,0)
 .... S LENGTH=$L(X)
"RTN","HLCSTCP2",247,0)
 .... ; patch HL*1.6*140
"RTN","HLCSTCP2",248,0)
 .... ; W X1,@IOF
"RTN","HLCSTCP2",249,0)
 .... W X1,@HLTCPLNK("IOF")
"RTN","HLCSTCP2",250,0)
 .. ;
"RTN","HLCSTCP2",251,0)
 .. ; @HLTCPLNK("IOF") (! or #) for flush character
"RTN","HLCSTCP2",252,0)
 .. I X]"" W X,@HLTCPLNK("IOF") S CRCOUNT=0
"RTN","HLCSTCP2",253,0)
 .. ;send CR
"RTN","HLCSTCP2",254,0)
 .. I X="" W $C(13) S CRCOUNT=CRCOUNT+1
"RTN","HLCSTCP2",255,0)
 .. ; prevent from maxstring error
"RTN","HLCSTCP2",256,0)
 .. I CRCOUNT>200 W @HLTCPLNK("IOF") S CRCOUNT=0
"RTN","HLCSTCP2",257,0)
 .. S LINENO=LINENO+1
"RTN","HLCSTCP2",258,0)
 ; Sends end block for this message
"RTN","HLCSTCP2",259,0)
 S X=$C(28)_$C(13)
"RTN","HLCSTCP2",260,0)
 ; U IO W X,!
"RTN","HLCSTCP2",261,0)
 U IO W X,@HLTCPLNK("IOF")
"RTN","HLCSTCP2",262,0)
 ;switch to null device
"RTN","HLCSTCP2",263,0)
 I $G(IO(0))'="",$G(IO(0))'=IO U IO(0)
"RTN","HLCSTCP2",264,0)
 Q 1
"RTN","HLCSTCP2",265,0)
 ;
"RTN","HLCSTCP2",266,0)
OPEN() ; -- Open TCP/IP device (Client)
"RTN","HLCSTCP2",267,0)
 ;HLPORT=port, defined only if port is open
"RTN","HLCSTCP2",268,0)
 ;HLPORTA=number of attempted opens
"RTN","HLCSTCP2",269,0)
 I $D(HLPORT) S IO=HLPORT D  Q 1
"RTN","HLCSTCP2",270,0)
 . U IO
"RTN","HLCSTCP2",271,0)
 . I HLOS["OpenM" X "U IO:(::""-M"")" ;use packet mode on Cache'
"RTN","HLCSTCP2",272,0)
 N HLDOM,HLI,HLIP,HLPORTA
"RTN","HLCSTCP2",273,0)
 G OPENA^HLCSTCP3
"RTN","HLCSTCP2",274,0)
 ;
"RTN","HLCSTCP2",275,0)
RDERR D RDERR^HLCSTCP4 Q
"RTN","HLCSTCP2",276,0)
ERROR D ERROR^HLCSTCP4 Q
"RTN","HLCSTCP2",277,0)
 ;
"RTN","HLCSTCP2",278,0)
CC(X) ;cleanup and close
"RTN","HLCSTCP2",279,0)
 D MON^HLCSTCP(X)
"RTN","HLCSTCP2",280,0)
 I $D(HLPORT) D CLOSE^%ZISTCP K HLPORT
"RTN","HLCSTCP2",281,0)
 ; patch HL*1.6*140
"RTN","HLCSTCP2",282,0)
 ; H 2
"RTN","HLCSTCP2",283,0)
 H 1
"RTN","HLCSTCP2",284,0)
 Q
"RTN","HLCSTCP4")
0^5^B45823270^B39383548
"RTN","HLCSTCP4",1,0)
HLCSTCP4 ;SFIRMFO/RSD - BI-DIRECTIONAL TCP ;04/16/08  14:20
"RTN","HLCSTCP4",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109,122,140**;Oct 13,1995;Build 5
"RTN","HLCSTCP4",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLCSTCP4",4,0)
 ;
"RTN","HLCSTCP4",5,0)
 Q
"RTN","HLCSTCP4",6,0)
 ; RDERR & ERROR moved from HLCSTCP2 on 12/2/2003 - LJA
"RTN","HLCSTCP4",7,0)
 ;
"RTN","HLCSTCP4",8,0)
RDERR ; Error during read process, decrement counter
"RTN","HLCSTCP4",9,0)
 D LLCNT^HLCSTCP(HLDP,4,1)
"RTN","HLCSTCP4",10,0)
ERROR ; Error trap
"RTN","HLCSTCP4",11,0)
 ; OPEN ERROR-retry.
"RTN","HLCSTCP4",12,0)
 ; WRITE ERROR (SERVER DISCONNECT)-close channel, retry
"RTN","HLCSTCP4",13,0)
 ;
"RTN","HLCSTCP4",14,0)
 ;**109**
"RTN","HLCSTCP4",15,0)
 ;I $G(HLMSG) L -^HLMA(HLMSG)
"RTN","HLCSTCP4",16,0)
 ;
"RTN","HLCSTCP4",17,0)
 ; patch HL*1.6*122 start
"RTN","HLCSTCP4",18,0)
 N STOP
"RTN","HLCSTCP4",19,0)
 S STOP=0
"RTN","HLCSTCP4",20,0)
 I $G(HLDP) S STOP=$$STOP^HLCSTCP
"RTN","HLCSTCP4",21,0)
 ; patch HL*1.6*140
"RTN","HLCSTCP4",22,0)
 S $ETRAP="D HALT^ZU" ;RWF
"RTN","HLCSTCP4",23,0)
 S HLTCP("$ZA\8192#2")=""
"RTN","HLCSTCP4",24,0)
 I (^%ZOSF("OS")["OpenM") D
"RTN","HLCSTCP4",25,0)
 . S HLTCP("$ZA")=$ZA
"RTN","HLCSTCP4",26,0)
 . ; For TCP devices $ZA\8192#2: the device is currently in the
"RTN","HLCSTCP4",27,0)
 . ; Connected state talking to a remote host.
"RTN","HLCSTCP4",28,0)
 . S HLTCP("$ZA\8192#2")=$ZA\8192#2
"RTN","HLCSTCP4",29,0)
 ;
"RTN","HLCSTCP4",30,0)
 S HLTCPERR("ERR-$ZE")=$$EC^%ZOSV
"RTN","HLCSTCP4",31,0)
 ; I $$EC^%ZOSV["OPENERR"!($$EC^%ZOSV["NOTOPEN")!($$EC^%ZOSV["DEVNOTOPN") D CC^HLCSTCP2("Op-err") S:$G(HLPRIO)="I" HLERROR="15^Open Related Error" D UNWIND^%ZTER Q
"RTN","HLCSTCP4",32,0)
 I $$EC^%ZOSV["OPENERR"!($$EC^%ZOSV["NOTOPEN")!($$EC^%ZOSV["DEVNOTOPN") D  G:STOP H2^XUSCLEAN Q
"RTN","HLCSTCP4",33,0)
 . D CC^HLCSTCP2("Op-err")
"RTN","HLCSTCP4",34,0)
 . S:$G(HLPRIO)="I" HLERROR="15^Open Related Error"
"RTN","HLCSTCP4",35,0)
 . I STOP D  Q
"RTN","HLCSTCP4",36,0)
 .. D CC^HLCSTCP2("Shutdown: (with 'Op-err')")
"RTN","HLCSTCP4",37,0)
 . I 'STOP D UNWIND^%ZTER
"RTN","HLCSTCP4",38,0)
 ; patch HL*1.6*140 start
"RTN","HLCSTCP4",39,0)
 ; I $$EC^%ZOSV["WRITE" D  G:STOP!(HLTCP("$ZA\8192#2")=0) H2^XUSCLEAN Q
"RTN","HLCSTCP4",40,0)
 I $$EC^%ZOSV["WRITE" D  G:STOP!(HLTCP("$ZA\8192#2")) H2^XUSCLEAN Q
"RTN","HLCSTCP4",41,0)
 . ; S:$G(HLPRIO)="I" HLERROR="108^Write Error"
"RTN","HLCSTCP4",42,0)
 . I $G(HLPRIO)="I" D  Q
"RTN","HLCSTCP4",43,0)
 .. S HLERROR="108^Write Error"
"RTN","HLCSTCP4",44,0)
 .. D CC^HLCSTCP2("Wr-err")
"RTN","HLCSTCP4",45,0)
 .. D UNWIND^%ZTER
"RTN","HLCSTCP4",46,0)
 . ;
"RTN","HLCSTCP4",47,0)
 . I STOP D  Q
"RTN","HLCSTCP4",48,0)
 .. D ^%ZTER,CC^HLCSTCP2("Shutdown: (with 'Wr-err')")
"RTN","HLCSTCP4",49,0)
 . E  D  Q
"RTN","HLCSTCP4",50,0)
 .. I HLTCP("$ZA\8192#2") D ^%ZTER,CC^HLCSTCP2("Wr-err") Q
"RTN","HLCSTCP4",51,0)
 .. E  D  Q
"RTN","HLCSTCP4",52,0)
 ... D CC^HLCSTCP2("Halt (Wr): (Disconnected with 'Wr-err')")
"RTN","HLCSTCP4",53,0)
 ... D UNWIND^%ZTER
"RTN","HLCSTCP4",54,0)
 ;
"RTN","HLCSTCP4",55,0)
 ; I $$EC^%ZOSV["READ" D CC^HLCSTCP2("Rd-err") S:$G(HLPRIO)="I" HLERROR="108^Read Error" D UNWIND^%ZTER Q
"RTN","HLCSTCP4",56,0)
 ; I $$EC^%ZOSV["READ" D  G:STOP!(HLTCP("$ZA\8192#2")=0) H2^XUSCLEAN Q
"RTN","HLCSTCP4",57,0)
 I $$EC^%ZOSV["READ" D  G:STOP!(HLTCP("$ZA\8192#2")) H2^XUSCLEAN Q
"RTN","HLCSTCP4",58,0)
 . ; S:$G(HLPRIO)="I" HLERROR="108^Read Error"
"RTN","HLCSTCP4",59,0)
 . I $G(HLPRIO)="I" D  Q
"RTN","HLCSTCP4",60,0)
 .. S HLERROR="108^Read Error"
"RTN","HLCSTCP4",61,0)
 .. D CC^HLCSTCP2("Rd-err")
"RTN","HLCSTCP4",62,0)
 .. D UNWIND^%ZTER
"RTN","HLCSTCP4",63,0)
 . ;
"RTN","HLCSTCP4",64,0)
 . I STOP D  Q
"RTN","HLCSTCP4",65,0)
 .. D ^%ZTER,CC^HLCSTCP2("Shutdown: (with 'Rd-err')")
"RTN","HLCSTCP4",66,0)
 . E  D  Q
"RTN","HLCSTCP4",67,0)
 .. I HLTCP("$ZA\8192#2") D ^%ZTER,CC^HLCSTCP2("Rd-err") Q
"RTN","HLCSTCP4",68,0)
 .. E  D  Q
"RTN","HLCSTCP4",69,0)
 ... D CC^HLCSTCP2("Halt (Rd): (Disconnected with 'Rd-err')")
"RTN","HLCSTCP4",70,0)
 ... D UNWIND^%ZTER
"RTN","HLCSTCP4",71,0)
 ;
"RTN","HLCSTCP4",72,0)
 ; S HLCSOUT=1 D ^%ZTER,CC^HLCSTCP2("Error"),SDFLD^HLCSTCP
"RTN","HLCSTCP4",73,0)
 ; S:$G(HLPRIO)="I" HLERROR="9^Error"
"RTN","HLCSTCP4",74,0)
 D ^%ZTER
"RTN","HLCSTCP4",75,0)
 I $G(HLPRIO)="I" D  Q
"RTN","HLCSTCP4",76,0)
 . S HLERROR="9^Error"
"RTN","HLCSTCP4",77,0)
 . D CC^HLCSTCP2("Error")
"RTN","HLCSTCP4",78,0)
 . D UNWIND^%ZTER
"RTN","HLCSTCP4",79,0)
 ;
"RTN","HLCSTCP4",80,0)
 I STOP D  Q
"RTN","HLCSTCP4",81,0)
 . D CC^HLCSTCP2("Shutdown: (with 'Error')")
"RTN","HLCSTCP4",82,0)
 . D H2^XUSCLEAN
"RTN","HLCSTCP4",83,0)
 ;
"RTN","HLCSTCP4",84,0)
 D CC^HLCSTCP2("Error")
"RTN","HLCSTCP4",85,0)
 ; patch HL*1.6*122 end
"RTN","HLCSTCP4",86,0)
 D H2^XUSCLEAN
"RTN","HLCSTCP4",87,0)
 ; patch HL*1.6*140 end
"RTN","HLCSTCP4",88,0)
 Q
"RTN","HLCSTCP4",89,0)
 ;
"RTN","HLCSTCP4",90,0)
PROXY ; set DUZ for application proxy user
"RTN","HLCSTCP4",91,0)
 ;
"RTN","HLCSTCP4",92,0)
 ; removed the execution: patch 122 TEST v2
"RTN","HLCSTCP4",93,0)
 Q
"RTN","HLCSTCP4",94,0)
 ;
"RTN","HLCSTCP4",95,0)
 ;; S HLDUZ=+$$APFIND^XUSAP("HLSEVEN,APPLICATION PROXY")
"RTN","HLCSTCP4",96,0)
 ;; S DUZ=HLDUZ
"RTN","HLCSTCP4",97,0)
 ;; D DUZ^XUP(DUZ)
"RTN","HLCSTCP4",98,0)
 ;; Q
"RTN","HLCSTCP4",99,0)
 ;
"RTN","HLCSTCP4",100,0)
HLDUZ ; compare DUZ and set DUZ to application proxy user
"RTN","HLCSTCP4",101,0)
 ;
"RTN","HLCSTCP4",102,0)
 ; removed the execution: patch 122 TEST v2
"RTN","HLCSTCP4",103,0)
 Q
"RTN","HLCSTCP4",104,0)
 ;
"RTN","HLCSTCP4",105,0)
 ;; I '$G(HLDUZ) D PROXY
"RTN","HLCSTCP4",106,0)
 ;
"RTN","HLCSTCP4",107,0)
HLDUZ2 ; compare DUZ and HLDUZ
"RTN","HLCSTCP4",108,0)
 I $G(DUZ)'=HLDUZ D
"RTN","HLCSTCP4",109,0)
 . S DUZ=HLDUZ
"RTN","HLCSTCP4",110,0)
 . D DUZ^XUP(DUZ)
"RTN","HLCSTCP4",111,0)
 Q
"RTN","HLCSTCP4",112,0)
 ;
"RTN","HLCSTCP4",113,0)
CLEANVAR ; clean variables for server, called from HLCSTCP1
"RTN","HLCSTCP4",114,0)
 ;
"RTN","HLCSTCP4",115,0)
 ; clean variables except Kernel related variables
"RTN","HLCSTCP4",116,0)
 ; protect variables defined in HLCSTCP
"RTN","HLCSTCP4",117,0)
 N HLDP
"RTN","HLCSTCP4",118,0)
 N HLCSOUT,HLDBACK,HLDBSIZE,HLDREAD,HLDRETR,HLRETRA,HLDWAIT,HLOS
"RTN","HLCSTCP4",119,0)
 N HLTCPADD,HLTCPCS,HLTCPLNK,HLTCPORT,HLTCPRET,HLCSFAIL,HLZRULE
"RTN","HLCSTCP4",120,0)
 ;
"RTN","HLCSTCP4",121,0)
 ; protect variables defined in LISTEN^HLCSTCP
"RTN","HLCSTCP4",122,0)
 ; N HLLSTN,HLCSOUT,HLDBACK,HLDBSIZE,HLDREAD,HLDRETR,HLRETRA,HLDWAIT
"RTN","HLCSTCP4",123,0)
 ; N HLOS,HLTCPADD,HLTCPCS,HLTCPLNK,HLTCPORT,HLTCPRET,HLCSFAIL
"RTN","HLCSTCP4",124,0)
 N HLLSTN
"RTN","HLCSTCP4",125,0)
 ;
"RTN","HLCSTCP4",126,0)
 ; protect variables defined in CACHEVMS^HLCSTCP and EN^HLCSTCP
"RTN","HLCSTCP4",127,0)
 N %
"RTN","HLCSTCP4",128,0)
 ; protect variables defined in this routine HLCSTCP1
"RTN","HLCSTCP4",129,0)
 N $ETRAP,$ESTACK
"RTN","HLCSTCP4",130,0)
 N HLMIEN,HLASTMSG
"RTN","HLCSTCP4",131,0)
 N HLTMBUF
"RTN","HLCSTCP4",132,0)
 N HLDUZ,DUZ
"RTN","HLCSTCP4",133,0)
 ; Kernel variables for single listener
"RTN","HLCSTCP4",134,0)
 N ZISOS,ZRULE
"RTN","HLCSTCP4",135,0)
 ;
"RTN","HLCSTCP4",136,0)
 D KILL^XUSCLEAN
"RTN","HLCSTCP4",137,0)
 Q
"RTN","HLCSTCP4",138,0)
MIEN ; sets HLIND1=ien in 773^ien in 772 for message
"RTN","HLCSTCP4",139,0)
 N HLMID,X
"RTN","HLCSTCP4",140,0)
 I HLIND1 D
"RTN","HLCSTCP4",141,0)
 . S:'$G(^HLMA(+HLIND1,0)) HLIND1=0
"RTN","HLCSTCP4",142,0)
 . S:'$G(^HL(772,+$P(HLIND1,U,2),0)) HLIND1=0
"RTN","HLCSTCP4",143,0)
 ;msg. id is 10th of MSH & 11th for BSH or FSH
"RTN","HLCSTCP4",144,0)
 S X=10+($E(HLMSG(1,0),1,3)'="MSH"),HLMID=$$PMSH(.HLMSG,X)
"RTN","HLCSTCP4",145,0)
 ;if HLIND1 is set, kill old message, use HLIND1 for new
"RTN","HLCSTCP4",146,0)
 ;message, it means we never got end block for 1st msg.
"RTN","HLCSTCP4",147,0)
 I HLIND1 D  Q
"RTN","HLCSTCP4",148,0)
 . ;get pointer to 772, kill header
"RTN","HLCSTCP4",149,0)
 . ;
"RTN","HLCSTCP4",150,0)
 . ; patch HL*1.6*122: MPI-client/server
"RTN","HLCSTCP4",151,0)
 . F  L +^HLMA(+HLIND1):10 Q:$T  H 1
"RTN","HLCSTCP4",152,0)
 . K ^HLMA(+HLIND1,"MSH")
"RTN","HLCSTCP4",153,0)
 . L -^HLMA(+HLIND1)
"RTN","HLCSTCP4",154,0)
 . ;
"RTN","HLCSTCP4",155,0)
 . I $D(^HL(772,+$P(HLIND1,U,2),"IN")) K ^("IN")
"RTN","HLCSTCP4",156,0)
 . S X=$$MAID^HLTF(+HLIND1,HLMID)
"RTN","HLCSTCP4",157,0)
 . D SAVE^HLCSTCP1(.HLMSG,"^HLMA("_+HLIND1_",""MSH"")")
"RTN","HLCSTCP4",158,0)
 . S:$P(HLIND1,U,3) $P(HLIND1,U,3)=""
"RTN","HLCSTCP4",159,0)
 D TCP^HLTF(.HLMID,.X,.HLDT)
"RTN","HLCSTCP4",160,0)
 S HLBUFF("IEN773")=X
"RTN","HLCSTCP4",161,0)
 I 'X D  Q
"RTN","HLCSTCP4",162,0)
 . ;error - record and reset array
"RTN","HLCSTCP4",163,0)
 . ;killing HLLSTN will allow MON^HLCSTCP to work with multi-server
"RTN","HLCSTCP4",164,0)
 . D CLEAN^HLCSTCP1 K HLLSTN
"RTN","HLCSTCP4",165,0)
 . ;error 100=LLP could not en-queue the message, reset array
"RTN","HLCSTCP4",166,0)
 . D MONITOR^HLCSDR2(100,19,HLDP),MON^HLCSTCP("ERROR") H 30
"RTN","HLCSTCP4",167,0)
 ;HLIND1=ien in 773^ien in 772
"RTN","HLCSTCP4",168,0)
 S HLIND1=X_U_+$G(^HLMA(X,0))
"RTN","HLCSTCP4",169,0)
 S HLBUFF("HLIND1")=HLIND1
"RTN","HLCSTCP4",170,0)
 ;save MSH into 773
"RTN","HLCSTCP4",171,0)
 D SAVE^HLCSTCP1(.HLMSG,"^HLMA("_+HLIND1_",""MSH"")")
"RTN","HLCSTCP4",172,0)
 Q
"RTN","HLCSTCP4",173,0)
 ;
"RTN","HLCSTCP4",174,0)
PMSH(MSH,P) ;get piece P from MSH array (passed by ref.)
"RTN","HLCSTCP4",175,0)
 N FS,I,L,L1,L2,X,Y
"RTN","HLCSTCP4",176,0)
 S FS=$E(MSH(1,0),4),(L2,Y)=0,X=""
"RTN","HLCSTCP4",177,0)
 F I=1:1 S L1=$L($G(MSH(I,0)),FS),L=L1+Y-1 D  Q:$L(X)!'$D(MSH(I,0))
"RTN","HLCSTCP4",178,0)
 . S:L1=1 L=L+1
"RTN","HLCSTCP4",179,0)
 . S:P'>L X=$P($G(MSH(I-1,0)),FS,P-L2)_$P($G(MSH(I,0)),FS,(P-Y))
"RTN","HLCSTCP4",180,0)
 . S L2=Y,Y=L
"RTN","HLCSTCP4",181,0)
 Q X
"RTN","HLCSTCP4",182,0)
 ;
"RTN","HLCSTCP4",183,0)
ERROR1 ;
"RTN","HLCSTCP4",184,0)
 ; moved from ERROR^HLCSTCP1
"RTN","HLCSTCP4",185,0)
 ; Error trap for disconnect error and return back to the read loop.
"RTN","HLCSTCP4",186,0)
 ; patch HL*1.6*122 start
"RTN","HLCSTCP4",187,0)
 ; patch HL*1.6*140
"RTN","HLCSTCP4",188,0)
 ; S $ETRAP="D HALT^ZU" ;RWF
"RTN","HLCSTCP4",189,0)
 S $ETRAP="H 1 D HALT^ZU" ;RWF
"RTN","HLCSTCP4",190,0)
 I (^%ZOSF("OS")["OpenM") D
"RTN","HLCSTCP4",191,0)
 . S HLTCP("$ZA")=$ZA
"RTN","HLCSTCP4",192,0)
 . ; For TCP devices $ZA\8192#2: the device is currently in the
"RTN","HLCSTCP4",193,0)
 . ; Connected state talking to a remote host.
"RTN","HLCSTCP4",194,0)
 . S HLTCP("$ZA\8192#2")=$ZA\8192#2
"RTN","HLCSTCP4",195,0)
 . I HLTCP("$ZA\8192#2")=0 D
"RTN","HLCSTCP4",196,0)
 .. ; decrement counter of multi-listener
"RTN","HLCSTCP4",197,0)
 .. I $D(^HLCS(870,"E","M",+$G(HLDP))) D EXITM^HLCSTCP
"RTN","HLCSTCP4",198,0)
 .. ; process terminated
"RTN","HLCSTCP4",199,0)
 .. D H2^XUSCLEAN
"RTN","HLCSTCP4",200,0)
 ; patch HL*1.6*140
"RTN","HLCSTCP4",201,0)
 ;S $ETRAP="D UNWIND^%ZTER" ;RWF
"RTN","HLCSTCP4",202,0)
 ; I $$EC^%ZOSV["READ"!($$EC^%ZOSV["NOTOPEN")!($$EC^%ZOSV["DEVNOTOPN") D UNWIND^%ZTER Q
"RTN","HLCSTCP4",203,0)
 I ($$EC^%ZOSV["NOTOPEN")!($$EC^%ZOSV["DEVNOTOPN") D  Q
"RTN","HLCSTCP4",204,0)
 . ; if it is not a multi-listener
"RTN","HLCSTCP4",205,0)
 . I '$D(^HLCS(870,"E","M",+$G(HLDP))) D CC^HLCSTCP1("Open-err")
"RTN","HLCSTCP4",206,0)
 . D UNWIND^%ZTER
"RTN","HLCSTCP4",207,0)
 I $$EC^%ZOSV["READ" D  Q
"RTN","HLCSTCP4",208,0)
 . ; if it is not a multi-listener
"RTN","HLCSTCP4",209,0)
 . I '$D(^HLCS(870,"E","M",+$G(HLDP))) D CC^HLCSTCP1("Rd-err")
"RTN","HLCSTCP4",210,0)
 . D UNWIND^%ZTER
"RTN","HLCSTCP4",211,0)
 ;
"RTN","HLCSTCP4",212,0)
 ; I $$EC^%ZOSV["WRITE" D CC("Wr-err") D UNWIND^%ZTER Q
"RTN","HLCSTCP4",213,0)
 I $$EC^%ZOSV["WRITE" D  Q
"RTN","HLCSTCP4",214,0)
 . ; if it is not a multi-listener
"RTN","HLCSTCP4",215,0)
 . I '$D(^HLCS(870,"E","M",+$G(HLDP))) D CC^HLCSTCP1("Wr-err")
"RTN","HLCSTCP4",216,0)
 . D UNWIND^%ZTER
"RTN","HLCSTCP4",217,0)
 ;
"RTN","HLCSTCP4",218,0)
 ; for GT.M
"RTN","HLCSTCP4",219,0)
 I $ECODE["UREAD" D  Q
"RTN","HLCSTCP4",220,0)
 . ; if it is not a multi-listener
"RTN","HLCSTCP4",221,0)
 . I '$D(^HLCS(870,"E","M",+$G(HLDP))) D CC^HLCSTCP1("Rd-err")
"RTN","HLCSTCP4",222,0)
 . D UNWIND^%ZTER
"RTN","HLCSTCP4",223,0)
 ;
"RTN","HLCSTCP4",224,0)
 ; S HLCSOUT=1 D ^%ZTER,CC("Error")
"RTN","HLCSTCP4",225,0)
 S HLCSOUT=1
"RTN","HLCSTCP4",226,0)
 D ^%ZTER
"RTN","HLCSTCP4",227,0)
 ; if it is not a multi-listener
"RTN","HLCSTCP4",228,0)
 I '$D(^HLCS(870,"E","M",+$G(HLDP))) D CC^HLCSTCP1("Error")
"RTN","HLCSTCP4",229,0)
 ; patch HL*1.6*122 end
"RTN","HLCSTCP4",230,0)
 ;
"RTN","HLCSTCP4",231,0)
 D UNWIND^%ZTER
"RTN","HLCSTCP4",232,0)
 Q
"RTN","HLCSTCP4",233,0)
 ;
"RTN","HLCSTCP4",234,0)
CLRMCNTR ;
"RTN","HLCSTCP4",235,0)
 ; clear the counter to set as "0 server" for multi-listener
"RTN","HLCSTCP4",236,0)
 ; HL*1.6*122 start
"RTN","HLCSTCP4",237,0)
 Q:'$G(HLDP)
"RTN","HLCSTCP4",238,0)
 Q:'$D(^HLCS(870,"E","M",HLDP))
"RTN","HLCSTCP4",239,0)
 S $P(^HLCS(870,HLDP,0),"^",4)="MS"
"RTN","HLCSTCP4",240,0)
 S $P(^HLCS(870,HLDP,0),U,5)="0 server"
"RTN","HLCSTCP4",241,0)
 Q
"RTN","HLCSTCP4",242,0)
 ;
"RTN","HLCSTCP4",243,0)
CREATUSR ;
"RTN","HLCSTCP4",244,0)
 ; patch HL*1.6*122 TEST v2: DUZ code removed
"RTN","HLCSTCP4",245,0)
 ; create application proxy users for listeners and incoming filer
"RTN","HLCSTCP4",246,0)
 ;; N HLTEMP
"RTN","HLCSTCP4",247,0)
 ;; S HLTEMP=$$CREATE^XUSAP("HLSEVEN,APPLICATION PROXY","#")
"RTN","HLCSTCP4",248,0)
 Q
"RTN","HLMA")
0^8^B52398960^B50301067
"RTN","HLMA",1,0)
HLMA ;AISC/SAW-Message Administration Module ;05/02/2008  10:27
"RTN","HLMA",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**19,43,58,63,66,82,91,109,115,133,132,122,140**;Oct 13, 1995;Build 5
"RTN","HLMA",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLMA",4,0)
GENERATE(HLEID,HLARYTYP,HLFORMAT,HLRESLT,HLMTIEN,HLP) ;
"RTN","HLMA",5,0)
 ;Entry point to generate a deferred message
"RTN","HLMA",6,0)
 ;
"RTN","HLMA",7,0)
 ;This is a subroutine call with parameter passing.  It returns a
"RTN","HLMA",8,0)
 ;value in the variable HLRESLT with 1 to 3 pieces separated by uparrows
"RTN","HLMA",9,0)
 ;as follows:  1st message ID^error code^error description
"RTN","HLMA",10,0)
 ;If no error occurs, only the first piece is returned equal to a unique
"RTN","HLMA",11,0)
 ;ID for the 1st message.  If message was sent to more than 1 subscriber
"RTN","HLMA",12,0)
 ;than the other message IDs will be in the array HLRESLT(n)=ID
"RTN","HLMA",13,0)
 ;Otherwise, three pieces are returned with the
"RTN","HLMA",14,0)
 ;first piece equal to the message ID, if one was assigned, otherwise 0
"RTN","HLMA",15,0)
 ;
"RTN","HLMA",16,0)
 ;Required Input Parameters
"RTN","HLMA",17,0)
 ;     HLEID = Name or IEN of event driver protocol in the Protocol file
"RTN","HLMA",18,0)
 ;  HLARYTYP = Array type.  One of the following codes:
"RTN","HLMA",19,0)
 ;               LM = local array containing a single message
"RTN","HLMA",20,0)
 ;               LB = local array containig a batch of messages
"RTN","HLMA",21,0)
 ;               GM = global array containing a single message
"RTN","HLMA",22,0)
 ;               GB = global array containing a batch of messages
"RTN","HLMA",23,0)
 ;  HLFORMAT = Format of array, 1 for pre-formatted in HL7 format,
"RTN","HLMA",24,0)
 ;               otherwise 0
"RTN","HLMA",25,0)
 ;NOTE:  The parameter HLRESLT must be passed by reference
"RTN","HLMA",26,0)
 ;   HLRESLT = The variable that will be returned to the calling
"RTN","HLMA",27,0)
 ;               application as descibed above
"RTN","HLMA",28,0)
 ;Optional Parameters
"RTN","HLMA",29,0)
 ;   HLMTIEN = IEN of entry in Message Text file where the message
"RTN","HLMA",30,0)
 ;               being generated is to be stored.  This parameter is
"RTN","HLMA",31,0)
 ;               only passed for a batch type message
"RTN","HLMA",32,0)
 ;NOTE:  The parameter HLP used for the following parameters must be
"RTN","HLMA",33,0)
 ;       passed by reference
"RTN","HLMA",34,0)
 ;  HLP("SECURITY") = A 1 to 40 character string
"RTN","HLMA",35,0)
 ;   HLP("CONTPTR") = Continuation pointer, a 1 to 180 character string
"RTN","HLMA",36,0)
 ; HLP("NAMESPACE") = Passed in by application namespace - HL*1.6*91
"RTN","HLMA",37,0)
 ; HLP("EXCLUDE SUBSCRIBER",<n=1,2,3...>)=<subscriber protocol ien> or
"RTN","HLMA",38,0)
 ;   <subscriber protocol name> - A list of protocols to dynamically
"RTN","HLMA",39,0)
 ;   drop from the event protocol's subscriber multiple.
"RTN","HLMA",40,0)
 ;
"RTN","HLMA",41,0)
 ;can't have link open when generating new message
"RTN","HLMA",42,0)
 N HLTCP,HLTCPO,HLPRIO,HLMIDAR
"RTN","HLMA",43,0)
 S HLPRIO="D"
"RTN","HLMA",44,0)
 S HLRESLT=""
"RTN","HLMA",45,0)
 ;Check for required parameters
"RTN","HLMA",46,0)
CONT ;
"RTN","HLMA",47,0)
 I $G(HLEID)']""!($G(HLARYTYP)']"")!($G(HLFORMAT)']"") D  G EXIT
"RTN","HLMA",48,0)
 . S HLRESLT="0^7^"_$G(^HL(771.7,7,0))_" at GENERATE^HLMA entry point"
"RTN","HLMA",49,0)
 I 'HLEID S HLEID=$O(^ORD(101,"B",HLEID,0)) I 'HLEID S HLRESLT="0^1^"_$G(^HL(771.7,1,0)) G EXIT
"RTN","HLMA",50,0)
 N HLRESLT1,HLRESLTA S (HLRESLTA,HLRESLT1)=""
"RTN","HLMA",51,0)
 I "GL"'[$E(HLARYTYP) S HLRESLT="0^4^"_$G(^HL(771.7,4,0)) G EXIT
"RTN","HLMA",52,0)
 I $L($G(HLP("SECURITY")))>40 S HLRESLT="0^6^"_$G(^HL(771.7,6,0)) G EXIT
"RTN","HLMA",53,0)
 I $L($G(HLP("CONTPTR")))>180 S HLRESLT="0^11^"_$G(^HL(771.7,11,0)) G EXIT
"RTN","HLMA",54,0)
 I $D(HLL("LINKS")) D  G:$G(HLRESLT)]"" EXIT
"RTN","HLMA",55,0)
 . N I,HLPNAM,HLPIEN,HLLNAM,HLLIEN
"RTN","HLMA",56,0)
 . S I=0
"RTN","HLMA",57,0)
 . F  S I=$O(HLL("LINKS",I)) Q:'I  D  Q:$G(HLRESLT)]""
"RTN","HLMA",58,0)
 . . S HLPNAM=$P(HLL("LINKS",I),U)
"RTN","HLMA",59,0)
 . . S HLPIEN=+$O(^ORD(101,"B",HLPNAM,0))
"RTN","HLMA",60,0)
 . . I $P($G(^ORD(101,HLPIEN,0)),U,4)'="S" S HLRESLT="0^15^Invalid Subscriber Protocol in HLL('LINKS'): "_HLL("LINKS",I) Q
"RTN","HLMA",61,0)
 . . S HLLNAM=$P(HLL("LINKS",I),U,2)
"RTN","HLMA",62,0)
 . . S HLLIEN=+$O(^HLCS(870,"B",HLLNAM,0))
"RTN","HLMA",63,0)
 . . I '$D(^HLCS(870,HLLIEN,0)) S HLRESLT="0^15^Invalid HL Node in HLL('LINKS'): "_HLL("LINKS",I) Q
"RTN","HLMA",64,0)
 ;Extract data from Protocol file
"RTN","HLMA",65,0)
 D EVENT^HLUTIL1(HLEID,"15,20,771",.HLN)
"RTN","HLMA",66,0)
 S HLENROU=$G(HLN(20)),HLEXROU=$G(HLN(15))
"RTN","HLMA",67,0)
 S HLP("GROUTINE")=$G(HLN(771)) K HLN I HLP("GROUTINE")']"",'HLFORMAT S HLRESLT="0^3^"_$G(^HL(771.7,3,0)) G EXIT
"RTN","HLMA",68,0)
 ;Create message ID and Message Text IEN if Message Text IEN not
"RTN","HLMA",69,0)
 ;previously created ('$G(HLMTIEN))
"RTN","HLMA",70,0)
 I '$G(HLMTIEN) D CREATE^HLTF(.HLMID,.HLMTIEN,.HLDT,.HLDT1)
"RTN","HLMA",71,0)
 ;Get message ID if Message Text IEN already created
"RTN","HLMA",72,0)
 I '$G(HLMID) D
"RTN","HLMA",73,0)
 .S HLDT=$G(^HL(772,HLMTIEN,0)),HLMID=$P(HLDT,"^",6),HLDT=+HLDT
"RTN","HLMA",74,0)
 .S HLDT1=$$HLDATE^HLFNC(HLDT)
"RTN","HLMA",75,0)
 S HLMIDAR=0,HLRESLT=HLMID,HLP("DT")=HLDT,HLP("DTM")=HLDT1
"RTN","HLMA",76,0)
 ;Execute entry action for event driver protocol
"RTN","HLMA",77,0)
 I HLENROU]"" X HLENROU
"RTN","HLMA",78,0)
 ;Invoke transaction processor
"RTN","HLMA",79,0)
 K HLDT,HLDT1,HLENROU
"RTN","HLMA",80,0)
 D GENERATE^HLTP(HLMID,HLMTIEN,HLEID,HLARYTYP,HLFORMAT,.HLRESLT1,.HLP)
"RTN","HLMA",81,0)
 ;HLMIDAR is array of message IDs, only set for broadcast messages
"RTN","HLMA",82,0)
 I HLMIDAR K HLMIDAR("N") M HLRESLT=HLMIDAR
"RTN","HLMA",83,0)
 S HLRESLT=HLRESLT_"^"_HLRESLT1
"RTN","HLMA",84,0)
 ;
"RTN","HLMA",85,0)
 ; patch HL*1.6*122
"RTN","HLMA",86,0)
 S HLRESLT("HLMID")=$G(HLMIDAR("HLMID"))
"RTN","HLMA",87,0)
 S HLRESLT("IEN773")=$G(HLMIDAR("IEN773"))
"RTN","HLMA",88,0)
 ;
"RTN","HLMA",89,0)
 ;Execute exit action for event driver protocol
"RTN","HLMA",90,0)
 I HLEXROU]"" X HLEXROU
"RTN","HLMA",91,0)
EXIT ;Update status if Message Text file entry has been created
"RTN","HLMA",92,0)
 K HLTCP
"RTN","HLMA",93,0)
 I $D(HLMTIEN) D STATUS^HLTF0(HLMTIEN,$S($P(HLRESLT,"^",2):4,1:3),$S($P(HLRESLT,"^",2):$P(HLRESLT,"^",2),1:""),$S($P(HLRESLT,"^",2):$P(HLRESLT,"^",3),1:""))
"RTN","HLMA",94,0)
 K HLDT,HLDT1,HLMID,HLRESLT1,HLENROU,HLEXROU
"RTN","HLMA",95,0)
 Q
"RTN","HLMA",96,0)
DIRECT(HLEID,HLARYTYP,HLFORMAT,HLRESLT,HLMTIENO,HLP) ;
"RTN","HLMA",97,0)
 ;Entry point to generate an immediate message, must be TCP Logical Link
"RTN","HLMA",98,0)
 ;Input:
"RTN","HLMA",99,0)
 ;  The same as GENERATE,with one additional subscript to the HLP input 
"RTN","HLMA",100,0)
 ;  array:
"RTN","HLMA",101,0)
 ; 
"RTN","HLMA",102,0)
 ;  HLP("OPEN TIMEOUT") (optional, pass by reference) a number between 
"RTN","HLMA",103,0)
 ;    1 and 120 that specifies how many seconds the DIRECT CONNECT should
"RTN","HLMA",104,0)
 ;    try to open a connection before failing.  It is killed upon 
"RTN","HLMA",105,0)
 ;    completion.
"RTN","HLMA",106,0)
 ; 
"RTN","HLMA",107,0)
 N HLTCP,HLTCPO,HLPRIO,HLSAN,HLN,HLMIDAR,HLMTIENR,ZMID,HLDIRECT
"RTN","HLMA",108,0)
 ; patch HL*1.6*140- to protect application who call this entry
"RTN","HLMA",109,0)
 N IO,IOF,ION,IOT,IOST,POP
"RTN","HLMA",110,0)
 S HLRESLT=""
"RTN","HLMA",111,0)
 ;HLMTIENO=ien passed in, batch message
"RTN","HLMA",112,0)
 S HLMTIEN=$G(HLMTIENO)
"RTN","HLMA",113,0)
 I $G(HLP("OPEN TIMEOUT")),((HLP("OPEN TIMEOUT")\1)'=+HLP("OPEN TIMEOUT"))!HLP("OPEN TIMEOUT")>120 Q "0^4^INVALID OPEN TIMEOUT PARAMETER"
"RTN","HLMA",114,0)
 I $G(HLP("OPEN TIMEOUT")) D
"RTN","HLMA",115,0)
 .S HLDIRECT("OPEN TIMEOUT")=HLP("OPEN TIMEOUT")
"RTN","HLMA",116,0)
 .K HLP("OPEN TIMEOUT")
"RTN","HLMA",117,0)
 K HL,HLMTIENO
"RTN","HLMA",118,0)
 D INIT^HLFNC2(HLEID,.HL)
"RTN","HLMA",119,0)
 I $G(HL) S HLRESLT="0^"_HL Q
"RTN","HLMA",120,0)
 S HLPRIO="I" D CONT
"RTN","HLMA",121,0)
 ;HLMTIENO=original msg. ien in file 772, HLMTIENR=response ien set in HLMA2
"RTN","HLMA",122,0)
 S HLMTIENO=HLMTIEN,HLMTIEN=$G(HLMTIENR)
"RTN","HLMA",123,0)
 ;Set special HL variables
"RTN","HLMA",124,0)
 S HLQUIT=0,HLNODE="",HLNEXT="D HLNEXT^HLCSUTL"
"RTN","HLMA",125,0)
 Q
"RTN","HLMA",126,0)
 ;
"RTN","HLMA",127,0)
CLOSE(LOGLINK) ;close connection that was open in tag DIRECT
"RTN","HLMA",128,0)
 Q
"RTN","HLMA",129,0)
PING ;ping another VAMC to test Link
"RTN","HLMA",130,0)
 ;set HLQUIET =1 to skip writes
"RTN","HLMA",131,0)
 ;look for HLTPUT to get turnaround time over network.
"RTN","HLMA",132,0)
 N DA,DIC,HLDP,HLDPNM,HLDPDM,HLCSOUT,HLDBSIZE,HLDREAD,HLOS,HLTCPADD,HLTCPCS,HLTCPLNK,HLTCPORT,HLTCPRET,HLCSFAIL,HLPARAM
"RTN","HLMA",133,0)
 N HCS,HCSCMD,HLCS,HCSDAT,HCSER,HCSEXIT,HCSTRACE,HLDT1,HLDRETR,HLRETRA,HLDBACK,HLDWAIT,HLTCPCS,INPUT,OUTPUT,POP,X,Y,HLX1,HLX2
"RTN","HLMA",134,0)
 S HLQUIET=$G(HLQUIET)
"RTN","HLMA",135,0)
 S HLCS="",HCSTRACE="C: ",POP=1,INPUT="INPUT",OUTPUT="OUTPUT"
"RTN","HLMA",136,0)
 S DIC="^HLCS(870,",DIC(0)="QEAMZ"
"RTN","HLMA",137,0)
 D ^DIC Q:Y<0
"RTN","HLMA",138,0)
 S HLDP=+Y,HLDPNM=Y(0,0),HLDPDM=$P($$PARAM^HLCS2,U,2)
"RTN","HLMA",139,0)
 ;I $P($G(^HLCS(870,HLDP,400)),U)="" W !,"Missing IP Address" Q
"RTN","HLMA",140,0)
 D SETUP^HLCSAC G:HLCS PINGQ
"RTN","HLMA",141,0)
 ; patch HL*1.6*122
"RTN","HLMA",142,0)
 G:$$DONTPING^HLMA4 PINGQ
"RTN","HLMA",143,0)
 ;PING header=MSH^PING^domain^PING^logical link^datetime
"RTN","HLMA",144,0)
 S INPUT(1)="MSH^PING^"_HLDPDM_"^PING^"_HLDPNM_"^"_$$HTE^XLFDT($H)
"RTN","HLMA",145,0)
 D OPEN^HLCSAC
"RTN","HLMA",146,0)
 I HLCS D DNS G:HLCS PINGQ
"RTN","HLMA",147,0)
 D
"RTN","HLMA",148,0)
 . N $ETRAP,$ESTACK S $ETRAP="D PINGERR^HLMA"
"RTN","HLMA",149,0)
 . ;non-standard HL7 header; start block,header,end block
"RTN","HLMA",150,0)
 . S HLX1=$H
"RTN","HLMA",151,0)
 . ;
"RTN","HLMA",152,0)
 . ; HL*1.6*122 start
"RTN","HLMA",153,0)
 . ; replace flush character '!' with @IOF (! or #)
"RTN","HLMA",154,0)
 . ; W $C(11)_INPUT(1)_$C(28)_$C(13),! ;HL*1.6*115, restored ! char
"RTN","HLMA",155,0)
 . ; patch HL*1.6*140, flush character- HLTCPLNK("IOF")
"RTN","HLMA",156,0)
 . ; W $C(11)_INPUT(1)_$C(28)_$C(13),@IOF
"RTN","HLMA",157,0)
 . W $C(11)_INPUT(1)_$C(28)_$C(13),@HLTCPLNK("IOF")
"RTN","HLMA",158,0)
 . ; HL*1.6*122 end
"RTN","HLMA",159,0)
 . ;
"RTN","HLMA",160,0)
 . ;read response
"RTN","HLMA",161,0)
 . R X:HLDREAD
"RTN","HLMA",162,0)
 . S HLX2=$H
"RTN","HLMA",163,0)
 . S X=$P(X,$C(28)),HLCS=$S(X=INPUT(1):"PING worked",X="":"No response",1:"Incorrect response")
"RTN","HLMA",164,0)
 . ;Get roundtrip time
"RTN","HLMA",165,0)
 . K HLTPUT I X]"" S HLTPUT=$$HDIFF^XLFDT(HLX2,HLX1,2)
"RTN","HLMA",166,0)
 D CLOSE^%ZISTCP
"RTN","HLMA",167,0)
PINGQ ;write back status and quit
"RTN","HLMA",168,0)
 I 'HLQUIET W !,HLCS,!
"RTN","HLMA",169,0)
 Q
"RTN","HLMA",170,0)
PINGERR ;process errors from PING
"RTN","HLMA",171,0)
 S $ETRAP="G UNWIND^%ZTER",HLCS="-1^Error"
"RTN","HLMA",172,0)
 ;I $ZE["READ" S HLCS="-1^Error during read"
"RTN","HLMA",173,0)
 ;I $ZE["WRITE" S HLCS="-1^Error during write"
"RTN","HLMA",174,0)
 ; HL*1.6*115, SACC compliance
"RTN","HLMA",175,0)
 I $$EC^%ZOSV["READ" S HLCS="-1^Error during read"
"RTN","HLMA",176,0)
 I $$EC^%ZOSV["WRITE" S HLCS="-1^Error during write"
"RTN","HLMA",177,0)
 G UNWIND^%ZTER
"RTN","HLMA",178,0)
DNS ;
"RTN","HLMA",179,0)
 ;openfail-try DNS lookup-Link must contain point to Domain Name
"RTN","HLMA",180,0)
 S POP=$G(POP)
"RTN","HLMA",181,0)
 S HLQUIET=$G(HLQUIET)
"RTN","HLMA",182,0)
 I 'HLQUIET W !,"Calling DNS"
"RTN","HLMA",183,0)
 N HLDOM,HLIP S HLCS=""
"RTN","HLMA",184,0)
 S HLDOM=$P(^HLCS(870,HLDP,0),U,7)
"RTN","HLMA",185,0)
 ; patch HL*1.6*122 start
"RTN","HLMA",186,0)
 S HLDOM("DNS")=$P($G(^HLCS(870,+$G(HLDP),0)),"^",8)
"RTN","HLMA",187,0)
 ; I 'HLDOM,'HLQUIET W !,"Domain Unknown" Q
"RTN","HLMA",188,0)
 I 'HLDOM,($L(HLDOM("DNS"),".")<3) D  Q
"RTN","HLMA",189,0)
 . I 'HLQUIET W !,"Domain Unknown"
"RTN","HLMA",190,0)
 . S HLCS="-1^Connection Fail"
"RTN","HLMA",191,0)
 ; patch HL*1.6*122 end
"RTN","HLMA",192,0)
 I HLDOM S HLDOM=$P(^DIC(4.2,HLDOM,0),U)
"RTN","HLMA",193,0)
 ; patch HL*1.6*122
"RTN","HLMA",194,0)
 ; I HLDOM]"" D  Q:'POP
"RTN","HLMA",195,0)
 I HLDOM]""!($L(HLDOM("DNS"),".")>2) D  Q:'POP
"RTN","HLMA",196,0)
 . I HLDOM["VA.GOV"&(HLDOM'[".MED.") S HLDOM=$P(HLDOM,".VA.GOV")_".MED.VA.GOV"
"RTN","HLMA",197,0)
 . I HLTCPORT=5000 S HLDOM="HL7."_HLDOM
"RTN","HLMA",198,0)
 . I HLTCPORT=5500 S HLDOM="MPI."_HLDOM
"RTN","HLMA",199,0)
 . ; patch HL*1.6*122
"RTN","HLMA",200,0)
 . I ($L(HLDOM("DNS"),".")>2) S HLDOM=HLDOM("DNS")
"RTN","HLMA",201,0)
 . I 'HLQUIET W !,"Domain, "_HLDOM
"RTN","HLMA",202,0)
 . I 'HLQUIET W !,"Port: ",HLTCPORT
"RTN","HLMA",203,0)
 . S HLIP=$$ADDRESS^XLFNSLK(HLDOM)
"RTN","HLMA",204,0)
 . I HLIP]"",'HLQUIET W !,"DNS Returned: ",HLIP
"RTN","HLMA",205,0)
 . I HLIP]"" D
"RTN","HLMA",206,0)
 . . ;If more than one IP returned, try each, cache successful open
"RTN","HLMA",207,0)
 . . N HLI,HLJ,HLIP1
"RTN","HLMA",208,0)
 . . F HLJ=1:1:$L(HLIP,",") D  Q:'POP
"RTN","HLMA",209,0)
 . . . S HLIP1=$P(HLIP,",",HLJ)
"RTN","HLMA",210,0)
 . . . F HLI=1:1:HLDRETR W:'HLQUIET !,"Trying ",HLIP1 D CALL^%ZISTCP(HLIP1,HLTCPORT,1) Q:'POP
"RTN","HLMA",211,0)
 . . . I 'POP S $P(^HLCS(870,HLDP,400),U)=HLIP1
"RTN","HLMA",212,0)
 . . . U IO
"RTN","HLMA",213,0)
 I POP S HLCS="-1^DNS Lookup Failed"
"RTN","HLTP3")
0^3^B75311331^B75102682
"RTN","HLTP3",1,0)
HLTP3 ;SFIRMFO/RSD - Transaction Processor for TCP ;03/17/2008  11:26
"RTN","HLTP3",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**19,43,57,58,59,66,69,109,115,108,116,117,125,120,133,122,140**;Oct 13, 1995;Build 5
"RTN","HLTP3",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLTP3",4,0)
 ;
"RTN","HLTP3",5,0)
 Q
"RTN","HLTP3",6,0)
NEW(X) ;process new msg. ien in 773^ien in 772
"RTN","HLTP3",7,0)
 ;HLMTIENS=ien in #773; HLMTIEN=ien in #772
"RTN","HLTP3",8,0)
 ;HLHDRO=original header;  HLHDR=response header
"RTN","HLTP3",9,0)
 ;set error trap
"RTN","HLTP3",10,0)
 N $ETRAP,$ESTACK S $ETRAP="D ERROR^HLTP3"
"RTN","HLTP3",11,0)
 N HL,HLEID,HLEIDS,HLERR,HLHDR,HLHDRO,HLMTIEN,HLMTIENS,HLJ,HLMSA,HLQUIT,HLNODE,HLNEXT,HLRESLTA,HLDONE1,HLASTRSP,HLRESLT
"RTN","HLTP3",12,0)
 S HLRESLT=""
"RTN","HLTP3",13,0)
 D INIT^HLTP3A
"RTN","HLTP3",14,0)
 ;error with header, return commit/app reject
"RTN","HLTP3",15,0)
 I $G(HLRESLT) D  Q
"RTN","HLTP3",16,0)
 . ;set status & unlock record
"RTN","HLTP3",17,0)
 . D STATUS^HLTF0(HLMTIENS,4,,,1),EXIT
"RTN","HLTP3",18,0)
 . ;quit if no commit or app ack
"RTN","HLTP3",19,0)
 . I $G(HL("ACAT"))="NE",$G(HL("APAT"))="NE" Q
"RTN","HLTP3",20,0)
 . S X=$S($G(HL("ACAT"))="AL":"CR",1:"AR")
"RTN","HLTP3",21,0)
 . ;HLTCP=ien of acknowledgment msg. from ACK^HLTP4
"RTN","HLTP3",22,0)
 . D ACK^HLTP4(X,$P(HLRESLT,U,2)) Q:'$G(HLTCP)
"RTN","HLTP3",23,0)
 . ;write ack back
"RTN","HLTP3",24,0)
 . S X=$$WRITE^HLCSTCP2(HLTCP)
"RTN","HLTP3",25,0)
 . ;update counter to sent
"RTN","HLTP3",26,0)
 . D LLCNT^HLCSTCP(HLDP,4)
"RTN","HLTP3",27,0)
 . ;update status of ack
"RTN","HLTP3",28,0)
 . D STATUS^HLTF0(HLTCP,3,,,1)
"RTN","HLTP3",29,0)
 ;
"RTN","HLTP3",30,0)
 ;check for duplicate msg., use rec. app and msg. id x-ref
"RTN","HLTP3",31,0)
 ; patch HL*1.6*120
"RTN","HLTP3",32,0)
 I $G(HL("MID"))]"",$G(HL("RAP")) S X=$O(^HLMA("AH",HL("RAP"),HL("MID"),0)) D  Q:'$D(HLMTIENS)
"RTN","HLTP3",33,0)
 . ;HLASTMSG=last ien received during this connection
"RTN","HLTP3",34,0)
 . ;if no duplicate, save msg. ien and quit
"RTN","HLTP3",35,0)
 . I X=HLMTIENS!'X S HLASTMSG=HLMTIENS Q
"RTN","HLTP3",36,0)
 . N MSH,OIENS
"RTN","HLTP3",37,0)
 . S (OIENS,Y)=X D  S Y=HLMTIENS D
"RTN","HLTP3",38,0)
 .. ;combine MSH into single string
"RTN","HLTP3",39,0)
 .. S MSH(Y)="",I=0 F  S I=$O(^HLMA(Y,"MSH",I)) Q:'I  S MSH(Y)=MSH(Y)_$G(^(I,0))
"RTN","HLTP3",40,0)
 .; patch 117 & 125, check if identical
"RTN","HLTP3",41,0)
 .I MSH(HLMTIENS)'=MSH(OIENS) S HLASTMSG=HLMTIENS Q
"RTN","HLTP3",42,0)
 .;
"RTN","HLTP3",43,0)
 . ;msg is duplicate, set status
"RTN","HLTP3",44,0)
 . D STATUS^HLTF0(HLMTIENS,4,109,"Duplicate with ien "_OIENS,1),EXIT
"RTN","HLTP3",45,0)
 . ;msg was resent, ignore it.
"RTN","HLTP3",46,0)
 . I HLASTMSG=HLMTIENS K HLMTIENS Q
"RTN","HLTP3",47,0)
 . ;find original response and send back
"RTN","HLTP3",48,0)
 . S HLASTRSP=$O(^HLMA("AF",OIENS,OIENS))
"RTN","HLTP3",49,0)
 ;
"RTN","HLTP3",50,0)
 ;Quit if this is ack to ack
"RTN","HLTP3",51,0)
 I $G(HL("ACK")) D  Q
"RTN","HLTP3",52,0)
 . ;Update status of original ack message
"RTN","HLTP3",53,0)
 . D STATUS^HLTF0(HL("MTIENS"),3,,,1),STATUS^HLTF0(HLMTIENS,3,,,1)
"RTN","HLTP3",54,0)
 . ;unlock record
"RTN","HLTP3",55,0)
 . D EXIT
"RTN","HLTP3",56,0)
 ;
"RTN","HLTP3",57,0)
 ;enhance ack., send commit, quit if not an ack, msg will be processed by filer
"RTN","HLTP3",58,0)
 I $G(HL("ACAT"))="AL" D  Q:'$G(HL("MTIENS"))
"RTN","HLTP3",59,0)
 . ;msg is a resend, HLASTRSP=ien of original response
"RTN","HLTP3",60,0)
 .I $G(HLASTRSP) D
"RTN","HLTP3",61,0)
 ..S HLTCP=HLASTRSP
"RTN","HLTP3",62,0)
 ..D LLCNT^HLCSTCP(HLDP,3)
"RTN","HLTP3",63,0)
 . E  D  Q:'$G(HLTCP)
"RTN","HLTP3",64,0)
 ..D ACK^HLTP4("CA") ;**109** LLCNT^HLCSTCP(HLDP,3) called in ACK^HLTP4
"RTN","HLTP3",65,0)
 . S X=$$WRITE^HLCSTCP2(HLTCP)
"RTN","HLTP3",66,0)
 . D LLCNT^HLCSTCP(HLDP,4),STATUS^HLTF0(HLTCP,3,,,1):'$G(HLASTRSP)
"RTN","HLTP3",67,0)
 . S HLTCP=""
"RTN","HLTP3",68,0)
 . ;if not an ack, set status to awaiting processing **109** and put on in queue
"RTN","HLTP3",69,0)
 . I '$G(HL("MTIENS")),'$G(HLASTRSP) D STATUS^HLTF0(HLMTIENS,9),EXIT,SETINQUE^HLTP31
"RTN","HLTP3",70,0)
 ;
"RTN","HLTP3",71,0)
 ;enhance ack., no commit & no app ack
"RTN","HLTP3",72,0)
 I $G(HL("ACAT"))="NE",$G(HL("APAT"))="NE" D  Q
"RTN","HLTP3",73,0)
 . ;set status to awaiting processing, **109** and put on in queue
"RTN","HLTP3",74,0)
 . I '$G(HLASTRSP) D STATUS^HLTF0(HLMTIENS,9),EXIT,SETINQUE^HLTP31
"RTN","HLTP3",75,0)
 ;
"RTN","HLTP3",76,0)
 ; patch HL*1.6*120 start
"RTN","HLTP3",77,0)
 ;resending old response, msg is a resend
"RTN","HLTP3",78,0)
 ; do not re-send duplicate when $G(HL("ACAT"))="AL"
"RTN","HLTP3",79,0)
 I $G(HLASTRSP),$G(HL("ACAT"))'="AL" S HLTCP=HLASTRSP G ACK
"RTN","HLTP3",80,0)
 ; quit if duplicate
"RTN","HLTP3",81,0)
 Q:$G(HLASTRSP)
"RTN","HLTP3",82,0)
 ; patch HL*1.6*120 end
"RTN","HLTP3",83,0)
 ;
"RTN","HLTP3",84,0)
CONT ;continue processing an enhance ack msg. called from DEFACK
"RTN","HLTP3",85,0)
 ;Set special HL variables for processing rtn
"RTN","HLTP3",86,0)
 S HLQUIT=0,HLNODE="",HLNEXT="D HLNEXT^HLCSUTL"
"RTN","HLTP3",87,0)
 ;
"RTN","HLTP3",88,0)
 ; message is an acknowledgement, HLMSA=ack code^id^text
"RTN","HLTP3",89,0)
 I ($G(HLMSA)]"") D  Q
"RTN","HLTP3",90,0)
 . ;X=1 if ack ok, 0=reject of error
"RTN","HLTP3",91,0)
 . S X=$E(HLMSA,2)="A"
"RTN","HLTP3",92,0)
 . ;Update status of original message and remove it from the queue
"RTN","HLTP3",93,0)
 . D STATUS^HLTF0(HL("MTIENS"),$S(X:3,1:4),"",$S(X:"",1:$P(HLMSA,HL("FS"),3)),1)
"RTN","HLTP3",94,0)
 . D DEQUE^HLCSREP($P($G(^HLMA(HL("MTIENS"),0)),"^",7),"O",HL("MTIENS"))
"RTN","HLTP3",95,0)
 . D
"RTN","HLTP3",96,0)
 .. N HLTCP ;variable to update status in file #772.
"RTN","HLTP3",97,0)
 ..;
"RTN","HLTP3",98,0)
 ..;**108**
"RTN","HLTP3",99,0)
 .. N TEMP
"RTN","HLTP3",100,0)
 .. S TEMP=HLMTIENS
"RTN","HLTP3",101,0)
 .. N HLMTIENS
"RTN","HLTP3",102,0)
 .. S HLMTIENS=TEMP
"RTN","HLTP3",103,0)
 ..;**END 108**
"RTN","HLTP3",104,0)
 ..;
"RTN","HLTP3",105,0)
 .. D PROCACK^HLTP2(HLMTIEN,HL("EID"),.HLRESLT,.HL)
"RTN","HLTP3",106,0)
 . ;update status of incoming & unlock
"RTN","HLTP3",107,0)
 . D STATUS^HLTF0(HLMTIENS,$S($G(HLRESLT):4,1:3),$S($G(HLRESLT):+$G(HLRESLT),1:""),$S($G(HLRESLT):$P(HLRESLT,U,2),1:""),1),EXIT
"RTN","HLTP3",108,0)
 ;
"RTN","HLTP3",109,0)
 ;get entry action, exit action and processing routine
"RTN","HLTP3",110,0)
 K HLHDR,HLLD0,HLLD1,HLMSA
"RTN","HLTP3",111,0)
 I HL("EIDS")="",$G(HLEIDS)]"" S HL("EIDS")=HLEIDS ;**CIRN**
"RTN","HLTP3",112,0)
 D EVENT^HLUTIL1(HL("EIDS"),"15,20,771",.HLN)
"RTN","HLTP3",113,0)
 S HLENROU=$G(HLN(20)),HLEXROU=$G(HLN(15)),HLPROU=$G(HLN(771))
"RTN","HLTP3",114,0)
 ;quit if no processing routine,update status and quit
"RTN","HLTP3",115,0)
 I HLPROU']"" S HLRESLT="10^"_$G(^HL(771.7,10,0)) D STATUS^HLTF0(HLMTIENS,3,,,1),EXIT Q
"RTN","HLTP3",116,0)
 ;HLORNOD=subscriber protocol for Fileman auditing, ien;global ref
"RTN","HLTP3",117,0)
 N HLORNODD S HLORNOD=HL("EIDS")_";ORD(101,"
"RTN","HLTP3",118,0)
 ;Execute entry action of client protocol
"RTN","HLTP3",119,0)
 X:HLENROU]"" HLENROU K HLENROU,HLDONE1
"RTN","HLTP3",120,0)
 ;
"RTN","HLTP3",121,0)
 ;Execute processing routine
"RTN","HLTP3",122,0)
 X HLPROU S HLRESLT=0 S:($D(HLERR)) HLRESLT="9^"_HLERR
"RTN","HLTP3",123,0)
 ;update status of incoming to complete & unlock
"RTN","HLTP3",124,0)
 D STATUS^HLTF0(HLMTIENS,$S(HLRESLT:4,1:3),$S(HLRESLT:+HLRESLT,1:""),$S(HLRESLT:$P(HLRESLT,U,2),1:""),1,$S($G(HLERR("SKIP_EVENT"))=1:1,1:0)),EXIT
"RTN","HLTP3",125,0)
 ;HLTCPO=link open, HLTCP=ien of ack msg. from GENACK
"RTN","HLTP3",126,0)
ACK I $G(HLTCPO),$G(HLTCP) D  Q
"RTN","HLTP3",127,0)
 . D LLCNT^HLCSTCP(HLDP,3)
"RTN","HLTP3",128,0)
 . ;write ack back over open tcp link
"RTN","HLTP3",129,0)
 . S X=$$WRITE^HLCSTCP2(HLTCP)
"RTN","HLTP3",130,0)
 . ;update status of ack to complete
"RTN","HLTP3",131,0)
 . D:'$G(HLASTRSP) STATUS^HLTF0(HLTCP,3,,,1)
"RTN","HLTP3",132,0)
 . D LLCNT^HLCSTCP(HLDP,4)
"RTN","HLTP3",133,0)
 Q
"RTN","HLTP3",134,0)
 ;
"RTN","HLTP3",135,0)
DEFACK(HLDP,X) ;process the deferred application ack, called from HLCSIN
"RTN","HLTP3",136,0)
 ;HLDP=logical link, X=ien in file 773
"RTN","HLTP3",137,0)
 ;
"RTN","HLTP3",138,0)
 ; patch HL*1.6*120 start
"RTN","HLTP3",139,0)
 ; clean non-Kernel variables
"RTN","HLTP3",140,0)
 D
"RTN","HLTP3",141,0)
 . ; protect variables defined in STARTIN^HLCSIN
"RTN","HLTP3",142,0)
 . N HLFLG,HLEXIT,HLPTRFLR
"RTN","HLTP3",143,0)
 . ; protect variables defined in DEFACK^HLCSIN
"RTN","HLTP3",144,0)
 . N HLXX,HLD0,HLPCT
"RTN","HLTP3",145,0)
 . ; protect input parameters of this sub-routine
"RTN","HLTP3",146,0)
 . N HLDP,X
"RTN","HLTP3",147,0)
 . D KILL^XUSCLEAN
"RTN","HLTP3",148,0)
 ; patch HL*1.6*120 end
"RTN","HLTP3",149,0)
 ;
"RTN","HLTP3",150,0)
 ;set error trap
"RTN","HLTP3",151,0)
 N $ETRAP,$ESTACK S $ETRAP="D ERROR^HLTP3"
"RTN","HLTP3",152,0)
 N HLERR     ;patch HL*1.6*109
"RTN","HLTP3",153,0)
 Q:'$G(HLDP)!'$G(X)  Q:'$G(^HLMA(X,0))
"RTN","HLTP3",154,0)
 Q:'$D(^HLMA("AC","I",HLDP,X))
"RTN","HLTP3",155,0)
 ;
"RTN","HLTP3",156,0)
 N HL,HLA,HLD0,HLEID,HLEIDS,HLHDR,HLHDRO,HLMTIEN,HLMTIENS,HLJ,HLMSA,HLN,HLQUIT,HLNODE,HLNEXT,HLRESLT,HLRESLTA,HLTCP,HLXX,Z,HLDONE1
"RTN","HLTP3",157,0)
 S HLMTIENS=X,X=^HLMA(HLMTIENS,0),HLMTIEN=+$P(X,U),HL("MID")=$P(X,U,2),HL("MTIENS")=$P(X,U,10),HL("LL")=$P(X,U,7),HLTCP="",HL("Q")=""""""
"RTN","HLTP3",158,0)
 S HL("EIDS")=$P(X,U,8),HL("SAP")=$P(X,U,11),HL("RAP")=$P(X,U,12),HL("MTP")=$P(X,U,13),HL("ETP")=$P(X,U,14)
"RTN","HLTP3",159,0)
 S:$P(X,U,15) HL("MTP_ETP")=$P(X,U,15)
"RTN","HLTP3",160,0)
 S:HL("SAP") HL("SAN")=$P($G(^HL(771,HL("SAP"),0)),U) S:HL("RAP") HL("RAN")=$P($G(^HL(771,HL("RAP"),0)),U)
"RTN","HLTP3",161,0)
 S:HL("MTP") HL("MTN")=$P($G(^HL(771.2,HL("MTP"),0)),U) S:HL("ETP") HL("ETN")=$P($G(^HL(779.001,HL("ETP"),0)),U)
"RTN","HLTP3",162,0)
 S:$G(HL("MTP_ETP")) HL("MTN_ETN")=$P($G(^HL(779.005,HL("MTP_ETP"),0)),U)
"RTN","HLTP3",163,0)
 S HL("EID")=$P($G(^HL(772,HLMTIEN,0)),U,10)
"RTN","HLTP3",164,0)
 M HLHDRO=^HLMA(HLMTIENS,"MSH")
"RTN","HLTP3",165,0)
 ; if no header quit
"RTN","HLTP3",166,0)
 Q:'$O(HLHDRO(0))
"RTN","HLTP3",167,0)
 ;
"RTN","HLTP3",168,0)
 S HL("FS")=$E(HLHDRO(1,0),4),HL("ECH")=$$P^HLTPCK2(.HLHDRO,2),HL("SFN")=$$P^HLTPCK2(.HLHDRO,4),HL("RFN")=$$P^HLTPCK2(.HLHDRO,6),HL("DTM")=$$P^HLTPCK2(.HLHDRO,7)
"RTN","HLTP3",169,0)
 ;
"RTN","HLTP3",170,0)
 ; quit if ien of #772 is not defined
"RTN","HLTP3",171,0)
 Q:'HLMTIEN
"RTN","HLTP3",172,0)
 ; quit if field separator is not defined
"RTN","HLTP3",173,0)
 Q:HL("FS")=""
"RTN","HLTP3",174,0)
 ;
"RTN","HLTP3",175,0)
 S X=$$P^HLTPCK2(.HLHDRO,1)
"RTN","HLTP3",176,0)
 ;
"RTN","HLTP3",177,0)
 ; patch HL*1.6*120 start
"RTN","HLTP3",178,0)
 I X="MSH" D
"RTN","HLTP3",179,0)
 . S HL("PID")=$$P^HLTPCK2(.HLHDRO,11),HL("VER")=$$P^HLTPCK2(.HLHDRO,12),HL("APAT")=$$P^HLTPCK2(.HLHDRO,16),HL("CC")=$$P^HLTPCK2(.HLHDRO,17)
"RTN","HLTP3",180,0)
 . ;
"RTN","HLTP3",181,0)
 . ; 2nd component is Processing mode
"RTN","HLTP3",182,0)
 . S HL("PMOD")=$P(HL("PID"),$E(HL("ECH"),1),2)
"RTN","HLTP3",183,0)
 . ; first component is Processing id
"RTN","HLTP3",184,0)
 . S HL("PID")=$P(HL("PID"),$E(HL("ECH"),1))
"RTN","HLTP3",185,0)
 ;
"RTN","HLTP3",186,0)
 I X'="MSH" D
"RTN","HLTP3",187,0)
 . S X=$$P^HLTPCK2(.HLHDRO,9),Z=$E(HL("ECH")),HL("PID")=$P(X,Z,2),HL("VER")=$P(X,Z,4)
"RTN","HLTP3",188,0)
 . ;
"RTN","HLTP3",189,0)
 . ; original code incorrectly treats repetition separator as
"RTN","HLTP3",190,0)
 . ; subcomponent separator
"RTN","HLTP3",191,0)
 . I $E(HL("ECH"),2)]"",X[$E(HL("ECH"),2) D
"RTN","HLTP3",192,0)
 .. S HL("SUB-COMPONENT")=$E(HL("ECH"),2)
"RTN","HLTP3",193,0)
 . ; if subcomponent separator is correctly applied
"RTN","HLTP3",194,0)
 . I $E(HL("ECH"),4)]"",X[$E(HL("ECH"),4) D
"RTN","HLTP3",195,0)
 .. S HL("SUB-COMPONENT")=$E(HL("ECH"),4)
"RTN","HLTP3",196,0)
 . ;
"RTN","HLTP3",197,0)
 . I $D(HL("SUB-COMPONENT")),HL("PID")[HL("SUB-COMPONENT") D
"RTN","HLTP3",198,0)
 .. ; 2nd sub-component is Processing mode
"RTN","HLTP3",199,0)
 .. S HL("PMOD")=$P(HL("PID"),HL("SUB-COMPONENT"),2)
"RTN","HLTP3",200,0)
 .. ; first sub-component is Processing id
"RTN","HLTP3",201,0)
 .. S HL("PID")=$P(HL("PID"),HL("SUB-COMPONENT"))
"RTN","HLTP3",202,0)
 . ; patch HL*1.6*120 end
"RTN","HLTP3",203,0)
 . ;
"RTN","HLTP3",204,0)
 . Q:$$P^HLTPCK2(.HLHDRO,10)=""
"RTN","HLTP3",205,0)
 . ;HLMSA=ack code^id^text
"RTN","HLTP3",206,0)
 . S HLMSA=$P($$P^HLTPCK2(.HLHDRO,10),$E(HL("ECH")),1),$P(HLMSA,HL("FS"),2)=$$P^HLTPCK2(.HLHDRO,12),$P(HLMSA,HL("FS"),3)=$P($$P^HLTPCK2(.HLHDRO,10),$E(HL("ECH")),2),HL("MSAID")=$P(HLMSA,HL("FS"),2)
"RTN","HLTP3",207,0)
 ;
"RTN","HLTP3",208,0)
 ; quit if this is a commit ack
"RTN","HLTP3",209,0)
 I $P($G(^HL(772,HLMTIEN,"IN",1,0)),HL("FS"),1)="MSA",$E($P($G(^HL(772,HLMTIEN,"IN",1,0)),HL("FS"),2))="C" Q
"RTN","HLTP3",210,0)
 ;
"RTN","HLTP3",211,0)
 ;**  HL*1.6*117 **
"RTN","HLTP3",212,0)
 K HLL("SET FOR APP ACK"),HLL("LINKS")
"RTN","HLTP3",213,0)
 ;
"RTN","HLTP3",214,0)
 D CONT
"RTN","HLTP3",215,0)
 Q
"RTN","HLTP3",216,0)
 ;
"RTN","HLTP3",217,0)
MSA(Y) ;Y=ien in 772, returns MSA segment
"RTN","HLTP3",218,0)
 ;ack code^msg being ack id^text
"RTN","HLTP3",219,0)
 ; patch HL*1.6*122
"RTN","HLTP3",220,0)
 ; for HL7 v2.5 and beyond with MSA as 3rd segment
"RTN","HLTP3",221,0)
 N X,SUBIEN,DATA,DONE
"RTN","HLTP3",222,0)
 S X=$G(^HL(772,Y,"IN",1,0)),X=$S($E(X,1,3)="MSA":$E(X,5,999),1:"")
"RTN","HLTP3",223,0)
 Q:X]"" X
"RTN","HLTP3",224,0)
 ;
"RTN","HLTP3",225,0)
 S DONE=0
"RTN","HLTP3",226,0)
 S SUBIEN=1
"RTN","HLTP3",227,0)
 F  S SUBIEN=$O(^HL(772,Y,"IN",SUBIEN)) Q:'SUBIEN  D  Q:DONE
"RTN","HLTP3",228,0)
 . S DATA=$G(^HL(772,Y,"IN",SUBIEN,0)) I DATA="" D
"RTN","HLTP3",229,0)
 .. S DONE=1
"RTN","HLTP3",230,0)
 .. S SUBIEN=$O(^HL(772,Y,"IN",SUBIEN)) Q:'SUBIEN
"RTN","HLTP3",231,0)
 .. S X=$G(^HL(772,Y,"IN",SUBIEN,0)),X=$S($E(X,1,3)="MSA":$E(X,5,999),1:"")
"RTN","HLTP3",232,0)
 ; patch HL*1.6*122 end
"RTN","HLTP3",233,0)
 ;
"RTN","HLTP3",234,0)
 Q X
"RTN","HLTP3",235,0)
 ;
"RTN","HLTP3",236,0)
ERROR ;error trap
"RTN","HLTP3",237,0)
 D ^%ZTER
"RTN","HLTP3",238,0)
 I $G(HLMTIENS),$D(^HLMA(HLMTIENS,0)) D STATUS^HLTF0(HLMTIENS,4,,,1),EXIT
"RTN","HLTP3",239,0)
 ; release locks created by inbound filer
"RTN","HLTP3",240,0)
 ; patch HL*1.6*140
"RTN","HLTP3",241,0)
 ; L -^HLMA("AC","I",+$G(HLXX))
"RTN","HLTP3",242,0)
 L -^HLMA("IN-FILER","AC","I",+$G(HLXX))
"RTN","HLTP3",243,0)
 G UNWIND^%ZTER
"RTN","HLTP3",244,0)
 ;
"RTN","HLTP3",245,0)
 ;
"RTN","HLTP3",246,0)
EXIT ;unlock
"RTN","HLTP3",247,0)
 I $G(HLMTIENS) L -^HLMA(HLMTIENS)
"RTN","HLTP3",248,0)
 Q
"RTN","HLTP3",249,0)
 ;
"RTN","HLTP3",250,0)
ONAC(IEN773) ;
"RTN","HLTP3",251,0)
 ;Returns 1 if the message is on the "AC","I" xref
"RTN","HLTP3",252,0)
 ;Returns 0 otherwise
"RTN","HLTP3",253,0)
 ;
"RTN","HLTP3",254,0)
 N LINK
"RTN","HLTP3",255,0)
 S LINK=$P($G(^HLMA(IEN773,0)),"^",17)
"RTN","HLTP3",256,0)
 Q:'LINK 0
"RTN","HLTP3",257,0)
 Q $D(^HLMA("AC","I",LINK,IEN773))
"VER")
8.0^22.0
"^DD",870,870,400.09,0)
TCP/IP OPENFAIL TIMEOUT^NJ2,0^^400;9^K:+X'=X!(X>60)!(X<1)!(X?.E1"."1N.N) X
"^DD",870,870,400.09,3)
Type a Number between 1 and 60, 0 Decimal Digits
"^DD",870,870,400.09,21,0)
^^2^2^3080416^
"^DD",870,870,400.09,21,1,0)
Enter the number of seconds for the TCP/IP Openfail Timeout. The default
"^DD",870,870,400.09,21,2,0)
is 30 seconds if this field is left blank.
"^DD",870,870,400.09,"DT")
3080416
"BLD",1074,6)
^112
**END**
**END**
