Released HL*1.6*147 SEQ #120
Extracted from mail message
**KIDS**:HL*1.6*147^

**INSTALL NAME**
HL*1.6*147
"BLD",1298,0)
HL*1.6*147^HEALTH LEVEL SEVEN^0^3100823^y
"BLD",1298,1,0)
^^2^2^3100112^
"BLD",1298,1,1,0)
Please see the National Patch Module on Forum for a complete description.
"BLD",1298,1,2,0)

"BLD",1298,4,0)
^9.64PA^779.3^4
"BLD",1298,4,779.1,0)
779.1
"BLD",1298,4,779.1,222)
y^n^f^^^^n
"BLD",1298,4,779.11,0)
779.11
"BLD",1298,4,779.11,222)
y^y^f^^^^n
"BLD",1298,4,779.3,0)
779.3
"BLD",1298,4,779.3,222)
y^n^f^^^^n
"BLD",1298,4,779.9,0)
779.9
"BLD",1298,4,779.9,222)
y^n^f^^^^n
"BLD",1298,4,"B",779.1,779.1)

"BLD",1298,4,"B",779.11,779.11)

"BLD",1298,4,"B",779.3,779.3)

"BLD",1298,4,"B",779.9,779.9)

"BLD",1298,6.3)
15
"BLD",1298,"ABPKG")
n
"BLD",1298,"INI")
PRE^HLOP147
"BLD",1298,"INID")
^^y
"BLD",1298,"KRN",0)
^9.67PA^9002226^21
"BLD",1298,"KRN",.4,0)
.4
"BLD",1298,"KRN",.401,0)
.401
"BLD",1298,"KRN",.402,0)
.402
"BLD",1298,"KRN",.402,"NM",0)
^9.68A^2^2
"BLD",1298,"KRN",.402,"NM",1,0)
HLO EDIT ERROR SCREEN    FILE #779.11^779.11^0
"BLD",1298,"KRN",.402,"NM",2,0)
HLO EDIT SYSTEM PARAMETERS    FILE #779.1^779.1^0
"BLD",1298,"KRN",.402,"NM","B","HLO EDIT ERROR SCREEN    FILE #779.11",1)

"BLD",1298,"KRN",.402,"NM","B","HLO EDIT SYSTEM PARAMETERS    FILE #779.1",2)

"BLD",1298,"KRN",.403,0)
.403
"BLD",1298,"KRN",.5,0)
.5
"BLD",1298,"KRN",.84,0)
.84
"BLD",1298,"KRN",3.6,0)
3.6
"BLD",1298,"KRN",3.8,0)
3.8
"BLD",1298,"KRN",9.2,0)
9.2
"BLD",1298,"KRN",9.8,0)
9.8
"BLD",1298,"KRN",9.8,"NM",0)
^9.68A^24^22
"BLD",1298,"KRN",9.8,"NM",1,0)
HLOUSR6^^0^B27362137
"BLD",1298,"KRN",9.8,"NM",2,0)
HLOUSR2^^0^B85470396
"BLD",1298,"KRN",9.8,"NM",3,0)
HLOQUE^^0^B148335504
"BLD",1298,"KRN",9.8,"NM",5,0)
HLOAPI5^^1^
"BLD",1298,"KRN",9.8,"NM",6,0)
HLOCLNT^^0^B80403155
"BLD",1298,"KRN",9.8,"NM",7,0)
HLOPING^^0^B23547701
"BLD",1298,"KRN",9.8,"NM",8,0)
HLOUSR7^^0^B22703242
"BLD",1298,"KRN",9.8,"NM",9,0)
HLOQUE1^^1^
"BLD",1298,"KRN",9.8,"NM",11,0)
HLOQUE2^^1^
"BLD",1298,"KRN",9.8,"NM",12,0)
HLOUSR3^^0^B69258883
"BLD",1298,"KRN",9.8,"NM",13,0)
HLOUSR4^^0^B15343784
"BLD",1298,"KRN",9.8,"NM",14,0)
HLOUSR^^0^B121177713
"BLD",1298,"KRN",9.8,"NM",15,0)
HLOASUB1^^0^B91573157
"BLD",1298,"KRN",9.8,"NM",16,0)
HLOSTRAC^^0^B43533858
"BLD",1298,"KRN",9.8,"NM",17,0)
HLOSRVR3^^0^B1081356
"BLD",1298,"KRN",9.8,"NM",18,0)
HLOSRVR^^0^B84093197
"BLD",1298,"KRN",9.8,"NM",19,0)
HLOUSR1^^0^B106982040
"BLD",1298,"KRN",9.8,"NM",20,0)
HLOSITE^^0^B8246314
"BLD",1298,"KRN",9.8,"NM",21,0)
HLOPROC^^0^B28480069
"BLD",1298,"KRN",9.8,"NM",22,0)
HLOPROC1^^0^B102064543
"BLD",1298,"KRN",9.8,"NM",23,0)
HLOSRVR1^^0^B86348500
"BLD",1298,"KRN",9.8,"NM",24,0)
HLOTRACE^^0^B65409615
"BLD",1298,"KRN",9.8,"NM","B","HLOAPI5",5)

"BLD",1298,"KRN",9.8,"NM","B","HLOASUB1",15)

"BLD",1298,"KRN",9.8,"NM","B","HLOCLNT",6)

"BLD",1298,"KRN",9.8,"NM","B","HLOPING",7)

"BLD",1298,"KRN",9.8,"NM","B","HLOPROC",21)

"BLD",1298,"KRN",9.8,"NM","B","HLOPROC1",22)

"BLD",1298,"KRN",9.8,"NM","B","HLOQUE",3)

"BLD",1298,"KRN",9.8,"NM","B","HLOQUE1",9)

"BLD",1298,"KRN",9.8,"NM","B","HLOQUE2",11)

"BLD",1298,"KRN",9.8,"NM","B","HLOSITE",20)

"BLD",1298,"KRN",9.8,"NM","B","HLOSRVR",18)

"BLD",1298,"KRN",9.8,"NM","B","HLOSRVR1",23)

"BLD",1298,"KRN",9.8,"NM","B","HLOSRVR3",17)

"BLD",1298,"KRN",9.8,"NM","B","HLOSTRAC",16)

"BLD",1298,"KRN",9.8,"NM","B","HLOTRACE",24)

"BLD",1298,"KRN",9.8,"NM","B","HLOUSR",14)

"BLD",1298,"KRN",9.8,"NM","B","HLOUSR1",19)

"BLD",1298,"KRN",9.8,"NM","B","HLOUSR2",2)

"BLD",1298,"KRN",9.8,"NM","B","HLOUSR3",12)

"BLD",1298,"KRN",9.8,"NM","B","HLOUSR4",13)

"BLD",1298,"KRN",9.8,"NM","B","HLOUSR6",1)

"BLD",1298,"KRN",9.8,"NM","B","HLOUSR7",8)

"BLD",1298,"KRN",19,0)
19
"BLD",1298,"KRN",19,"NM",0)
^9.68A^13^11
"BLD",1298,"KRN",19,"NM",1,0)
HLO EDIT ERROR SCREENS^^0
"BLD",1298,"KRN",19,"NM",3,0)
HLO MAIN MENU^^3
"BLD",1298,"KRN",19,"NM",4,0)
HLO DEVELOPER MENU^^3
"BLD",1298,"KRN",19,"NM",5,0)
HLO PING^^0
"BLD",1298,"KRN",19,"NM",6,0)
HLO SERVER TRACE^^0
"BLD",1298,"KRN",19,"NM",7,0)
HLO CLIENT TRACE^^0
"BLD",1298,"KRN",19,"NM",8,0)
HLO TROUBLESHOOTING MENU^^0
"BLD",1298,"KRN",19,"NM",10,0)
HL PING^^0
"BLD",1298,"KRN",19,"NM",11,0)
HLO SET QUEUE PRIORITY^^0
"BLD",1298,"KRN",19,"NM",12,0)
HLO LOG READ/WRITE ERRORS^^0
"BLD",1298,"KRN",19,"NM",13,0)
HLO RECOUNT MESSAGE QUEUES^^0
"BLD",1298,"KRN",19,"NM","B","HL PING",10)

"BLD",1298,"KRN",19,"NM","B","HLO CLIENT TRACE",7)

"BLD",1298,"KRN",19,"NM","B","HLO DEVELOPER MENU",4)

"BLD",1298,"KRN",19,"NM","B","HLO EDIT ERROR SCREENS",1)

"BLD",1298,"KRN",19,"NM","B","HLO LOG READ/WRITE ERRORS",12)

"BLD",1298,"KRN",19,"NM","B","HLO MAIN MENU",3)

"BLD",1298,"KRN",19,"NM","B","HLO PING",5)

"BLD",1298,"KRN",19,"NM","B","HLO RECOUNT MESSAGE QUEUES",13)

"BLD",1298,"KRN",19,"NM","B","HLO SERVER TRACE",6)

"BLD",1298,"KRN",19,"NM","B","HLO SET QUEUE PRIORITY",11)

"BLD",1298,"KRN",19,"NM","B","HLO TROUBLESHOOTING MENU",8)

"BLD",1298,"KRN",19.1,0)
19.1
"BLD",1298,"KRN",19.1,"NM",0)
^9.68A^^
"BLD",1298,"KRN",101,0)
101
"BLD",1298,"KRN",101,"NM",0)
^9.68A^2^2
"BLD",1298,"KRN",101,"NM",1,0)
HLO OUTBOUND DELETE^^0
"BLD",1298,"KRN",101,"NM",2,0)
HLO SEQUENCE DELETE^^0
"BLD",1298,"KRN",101,"NM","B","HLO OUTBOUND DELETE",1)

"BLD",1298,"KRN",101,"NM","B","HLO SEQUENCE DELETE",2)

"BLD",1298,"KRN",409.61,0)
409.61
"BLD",1298,"KRN",771,0)
771
"BLD",1298,"KRN",779.2,0)
779.2
"BLD",1298,"KRN",870,0)
870
"BLD",1298,"KRN",8989.51,0)
8989.51
"BLD",1298,"KRN",8989.52,0)
8989.52
"BLD",1298,"KRN",8994,0)
8994
"BLD",1298,"KRN",9002226,0)
9002226
"BLD",1298,"KRN","B",.4,.4)

"BLD",1298,"KRN","B",.401,.401)

"BLD",1298,"KRN","B",.402,.402)

"BLD",1298,"KRN","B",.403,.403)

"BLD",1298,"KRN","B",.5,.5)

"BLD",1298,"KRN","B",.84,.84)

"BLD",1298,"KRN","B",3.6,3.6)

"BLD",1298,"KRN","B",3.8,3.8)

"BLD",1298,"KRN","B",9.2,9.2)

"BLD",1298,"KRN","B",9.8,9.8)

"BLD",1298,"KRN","B",19,19)

"BLD",1298,"KRN","B",19.1,19.1)

"BLD",1298,"KRN","B",101,101)

"BLD",1298,"KRN","B",409.61,409.61)

"BLD",1298,"KRN","B",771,771)

"BLD",1298,"KRN","B",779.2,779.2)

"BLD",1298,"KRN","B",870,870)

"BLD",1298,"KRN","B",8989.51,8989.51)

"BLD",1298,"KRN","B",8989.52,8989.52)

"BLD",1298,"KRN","B",8994,8994)

"BLD",1298,"KRN","B",9002226,9002226)

"BLD",1298,"QUES",0)
^9.62^^
"BLD",1298,"REQB",0)
^9.611^1^1
"BLD",1298,"REQB",1,0)
HL*1.6*146^2
"BLD",1298,"REQB","B","HL*1.6*146",1)

"FIA",779.1)
HLO SYSTEM PARAMETERS
"FIA",779.1,0)
^HLD(779.1,
"FIA",779.1,0,0)
779.1
"FIA",779.1,0,1)
y^n^f^^^^n
"FIA",779.1,0,10)

"FIA",779.1,0,11)

"FIA",779.1,0,"RLRO")

"FIA",779.1,0,"VR")
1.6^HL
"FIA",779.1,779.1)
0
"FIA",779.11)
HLO ERROR SCREENS
"FIA",779.11,0)
^HLD(779.11,
"FIA",779.11,0,0)
779.11
"FIA",779.11,0,1)
y^y^f^^^^n
"FIA",779.11,0,10)

"FIA",779.11,0,11)

"FIA",779.11,0,"RLRO")

"FIA",779.11,0,"VR")
1.6^HL
"FIA",779.11,779.11)
0
"FIA",779.11,779.111)
0
"FIA",779.11,779.115)
0
"FIA",779.3)
HLO PROCESS REGISTRY
"FIA",779.3,0)
^HLD(779.3,
"FIA",779.3,0,0)
779.3
"FIA",779.3,0,1)
y^n^f^^^^n
"FIA",779.3,0,10)

"FIA",779.3,0,11)

"FIA",779.3,0,"RLRO")

"FIA",779.3,0,"VR")
1.6^HL
"FIA",779.3,779.3)
0
"FIA",779.9)
HLO PRIORITY QUEUES
"FIA",779.9,0)
^HLD(779.9,
"FIA",779.9,0,0)
779.9I
"FIA",779.9,0,1)
y^n^f^^^^n
"FIA",779.9,0,10)

"FIA",779.9,0,11)

"FIA",779.9,0,"RLRO")

"FIA",779.9,0,"VR")
1.6^HL
"FIA",779.9,779.9)
0
"FIA",779.9,779.91)
0
"INI")
PRE^HLOP147
"IX",779.3,779.3,"D",0)
779.3^D^Uniqueness Index for Key 'A' of File #779.3^R^^F^IR^I^779.3^^^^^LS
"IX",779.3,779.3,"D",1)
S ^HLD(779.3,"D",X,DA)=""
"IX",779.3,779.3,"D",2)
K ^HLD(779.3,"D",X,DA)
"IX",779.3,779.3,"D",2.5)
K ^HLD(779.3,"D")
"IX",779.3,779.3,"D",11.1,0)
^.114IA^1^1
"IX",779.3,779.3,"D",11.1,1,0)
1^F^779.3^.01^^1
"IX",779.9,779.9,"E",0)
779.9^E^Used to find the queue priority.^MU^^R^IR^I^779.9^^^^^LS
"IX",779.9,779.9,"E",1)
S ^HLD(779.9,"E",X2(2),X2(3))=$G(X2(4))
"IX",779.9,779.9,"E",1.4)
S X=X2(1)
"IX",779.9,779.9,"E",2)
K:($L(X1(2))&$L(X1(3))) ^HLD(779.9,"E",X1(2),X1(3)),^HLD(779.9,"F",X1(2),X1(3)) D RESETF^HLOQUE(DA)
"IX",779.9,779.9,"E",2.5)
K ^HLD(779.9,"E")
"IX",779.9,779.9,"E",11.1,0)
^.114IA^4^4
"IX",779.9,779.9,"E",11.1,1,0)
1^F^779.9^.03^^^F
"IX",779.9,779.9,"E",11.1,2,0)
2^F^779.9^.01^20^^F
"IX",779.9,779.9,"E",11.1,3,0)
3^F^779.9^.02^3^^F
"IX",779.9,779.9,"E",11.1,4,0)
4^F^779.9^.04^3^^F
"IX",779.9,779.9,"F",0)
779.9^F^Used to lookup queue priority specific to a particular link.^MU^^R^IR^W^779.91^^^^^LS
"IX",779.9,779.9,"F",.1,0)
^^1^1^3091104^
"IX",779.9,779.9,"F",.1,1,0)

"IX",779.9,779.9,"F",1)
S:($L(X2(1))&$L(X2(2))&$L(X2(4))) ^HLD(779.9,"F",X2(1),X2(2),X2(4))=$S(X2(5):X2(5),X2(3):X2(3),1:50)
"IX",779.9,779.9,"F",2)
K:($L(X1(1))&$L(X1(2))&$L(X1(4))) ^HLD(779.9,"F",X1(1),X1(2),X1(4))
"IX",779.9,779.9,"F",2.5)
K ^HLD(779.9,"F")
"IX",779.9,779.9,"F",11.1,0)
^.114IA^5^5
"IX",779.9,779.9,"F",11.1,1,0)
1^C^^^20^1^F
"IX",779.9,779.9,"F",11.1,1,1.5)
S X=$P(^HLD(779.9,DA(1),0),"^")
"IX",779.9,779.9,"F",11.1,2,0)
2^C^^^3^2
"IX",779.9,779.9,"F",11.1,2,1.5)
S X=$P(^HLD(779.9,DA(1),0),"^",2)
"IX",779.9,779.9,"F",11.1,3,0)
3^C^^^3^
"IX",779.9,779.9,"F",11.1,3,1.5)
S X=$P(^HLD(779.9,DA(1),0),"^",4)
"IX",779.9,779.9,"F",11.1,4,0)
4^F^779.91^.01^10^3^F
"IX",779.9,779.9,"F",11.1,4,1)

"IX",779.9,779.9,"F",11.1,4,2)
S X=$P(^HLCS(870,X,0),"^")
"IX",779.9,779.9,"F",11.1,5,0)
5^F^779.91^.02^3^^F
"KEY",779.3,779.3,"A",0)
779.3^A^P^83
"KEY",779.3,779.3,"A",2,0)
^.312IA^1^1
"KEY",779.3,779.3,"A",2,1,0)
.01^779.3^1
"KEYPTR",779.3,779.3,"A")
779.3^D
"KRN",.402,104,-1)
0^2
"KRN",.402,104,0)
HLO EDIT SYSTEM PARAMETERS^3100324.1817^@^779.1^^@^3100324
"KRN",.402,104,"DR",1,779.1)
.01;.02;.03;.04;.05;.06;.07;.08;.12;.1;.13;
"KRN",.402,111,-1)
0^1
"KRN",.402,111,0)
HLO EDIT ERROR SCREEN^3100727.1714^@^779.11^^@^3100727
"KRN",.402,111,"DR",1,779.11)
.01;1;4;5;
"KRN",.402,111,"DR",2,779.115)
.01;.02;
"KRN",19,764,-1)
0^10
"KRN",19,764,0)
HL PING^Ping (TCP Only)^^A^^^^^^^^HEALTH LEVEL SEVEN^y^1
"KRN",19,764,1,0)
^19.06^2^2^3100112^^^^
"KRN",19,764,1,1,0)
Use this option to test TCP connectivity with a remote systems.
"KRN",19,764,1,2,0)

"KRN",19,764,20)
D:($$VERSION^%ZOSV(1)'["Cache") PING^HLMA D:($$VERSION^%ZOSV(1)["Cache") PING^HLOPING
"KRN",19,764,25)

"KRN",19,764,"U")
PING (TCP ONLY)
"KRN",19,1047,-1)
3^3
"KRN",19,1047,0)
HLO MAIN MENU^HL7 (Optimized) MAIN MENU^^M^^HLOMAIN^^^^^y^HEALTH LEVEL SEVEN
"KRN",19,1047,1,0)
^19.06^1^1^3091109^^^^
"KRN",19,1047,1,1,0)
This menu contains all the options developed for HLO.
"KRN",19,1047,10,0)
^19.01IP^12^8
"KRN",19,1047,10,10,0)
1414^DM^10
"KRN",19,1047,10,10,"^")
HLO DEVELOPER MENU
"KRN",19,1047,10,11,0)
1415^SE^5
"KRN",19,1047,10,11,"^")
HLO EDIT ERROR SCREENS
"KRN",19,1047,10,12,0)
1416^TS^8
"KRN",19,1047,10,12,"^")
HLO TROUBLESHOOTING MENU
"KRN",19,1047,10.1)
HLO MAIN MENU
"KRN",19,1047,99)
61737,34894
"KRN",19,1047,99.1)
61961,3301
"KRN",19,1047,"U")
HL7 (OPTIMIZED) MAIN MENU
"KRN",19,1414,-1)
3^4
"KRN",19,1414,0)
HLO DEVELOPER MENU^HLO DEVELOPER MENU^^M^^^^^^^^HEALTH LEVEL SEVEN
"KRN",19,1414,1,0)
^19.06^2^2^3091109^^^^
"KRN",19,1414,1,1,0)
Contains options that are geared towards developing messaging applications.
"KRN",19,1414,1,2,0)

"KRN",19,1414,10,0)
^19.01IP^4^4
"KRN",19,1414,10,4,0)
1419^EP^4
"KRN",19,1414,10,4,"^")
HLO SET QUEUE PRIORITY
"KRN",19,1414,10.1)
DEVELOPER MENU
"KRN",19,1414,99)
61746,26370
"KRN",19,1414,"U")
HLO DEVELOPER MENU
"KRN",19,1415,-1)
0^1
"KRN",19,1415,0)
HLO EDIT ERROR SCREENS^HLO EDIT ERROR SCREENS^^E^^^^^^^y^HEALTH LEVEL SEVEN
"KRN",19,1415,1,0)
^19.06^4^4^3090825^^
"KRN",19,1415,1,1,0)
This option allows the user to edit/add HLO error message screens to the HLO
"KRN",19,1415,1,2,0)
ERROR SCREENS file (#779.11).
"KRN",19,1415,1,3,0)

"KRN",19,1415,1,4,0)

"KRN",19,1415,10.1)
HLO EDIT ERR SCREEN
"KRN",19,1415,30)
HLD(779.11,
"KRN",19,1415,31)
AEMQL
"KRN",19,1415,50)
HLD(779.11,
"KRN",19,1415,51)
[HLO EDIT ERROR SCREEN]
"KRN",19,1415,"U")
HLO EDIT ERROR SCREENS
"KRN",19,1416,-1)
0^8
"KRN",19,1416,0)
HLO TROUBLESHOOTING MENU^TROUBLESHOOTING MENU^^M^^^^^^^y^HEALTH LEVEL SEVEN
"KRN",19,1416,1,0)
^19.06^4^4^3100318^^^^
"KRN",19,1416,1,1,0)
This option contains a menu of toolS used to troubleshoot
"KRN",19,1416,1,2,0)
HLO.
"KRN",19,1416,1,3,0)

"KRN",19,1416,1,4,0)

"KRN",19,1416,10,0)
^19.01IP^4^4
"KRN",19,1416,10,1,0)
1417^CS^1
"KRN",19,1416,10,1,"^")
HLO CLIENT TRACE
"KRN",19,1416,10,2,0)
1418^ST^2
"KRN",19,1416,10,2,"^")
HLO SERVER TRACE
"KRN",19,1416,10,3,0)
1420^PING
"KRN",19,1416,10,3,"^")
HLO PING
"KRN",19,1416,10,4,0)
1431^LOG
"KRN",19,1416,10,4,"^")
HLO LOG READ/WRITE ERRORS
"KRN",19,1416,10.1)
TROUBLESHOOTING MENU
"KRN",19,1416,99)
61810,36579
"KRN",19,1416,"U")
TROUBLESHOOTING MENU
"KRN",19,1417,-1)
0^7
"KRN",19,1417,0)
HLO CLIENT TRACE^CLIENT TRACE^^R^^^^^^^y^HEALTH LEVEL SEVEN
"KRN",19,1417,1,0)
^19.06^6^6^3100111^^
"KRN",19,1417,1,1,0)
The client trace tool is used to run the HLO
"KRN",19,1417,1,2,0)
client in the foreground and to trace its
"KRN",19,1417,1,3,0)
execution.  The purpose of the tool is to
"KRN",19,1417,1,4,0)
determine failure points within the client
"KRN",19,1417,1,5,0)
process.
"KRN",19,1417,1,6,0)

"KRN",19,1417,10.1)
Client trace tool
"KRN",19,1417,25)
HLOTRACE
"KRN",19,1417,"U")
CLIENT TRACE
"KRN",19,1418,-1)
0^6
"KRN",19,1418,0)
HLO SERVER TRACE^SERVER TRACE^^R^^^^^^^y^HEALTH LEVEL SEVEN
"KRN",19,1418,1,0)
^19.06^5^5^3091124^^
"KRN",19,1418,1,1,0)
The server trace tool is used to trace the 
"KRN",19,1418,1,2,0)
execution of the HLO server.  The purpose
"KRN",19,1418,1,3,0)
of the tools is to troubleshoot the server
"KRN",19,1418,1,4,0)
functionality and find failure points.
"KRN",19,1418,1,5,0)

"KRN",19,1418,10.1)
SERVER TRACE TOOL
"KRN",19,1418,25)
HLOSTRAC
"KRN",19,1418,"U")
SERVER TRACE
"KRN",19,1419,-1)
0^11
"KRN",19,1419,0)
HLO SET QUEUE PRIORITY^SET OUTGOING QUEUE PRIORITY^^R^^^^^^^y^HEALTH LEVEL SEVEN
"KRN",19,1419,1,0)
^19.06^7^7^3100120^^^^
"KRN",19,1419,1,1,0)
This option allows users to add/edit entries in the HLO PRIORITY QUEUES
"KRN",19,1419,1,2,0)
file (#779.9). Creating a Priority Queue allows the operations staff
"KRN",19,1419,1,3,0)
to increase or decrease the throughput of particular queues. The default
"KRN",19,1419,1,4,0)
priority of a queue is 50.  For queues that tend to backup, their priority
"KRN",19,1419,1,5,0)
should be set to higher than 50.
"KRN",19,1419,1,6,0)

"KRN",19,1419,1,7,0)

"KRN",19,1419,10.1)
SET OUTGOING QUEUE PRIORITY
"KRN",19,1419,25)
SETPRTY^HLOQUE
"KRN",19,1419,"U")
SET OUTGOING QUEUE PRIORITY
"KRN",19,1420,-1)
0^5
"KRN",19,1420,0)
HLO PING^PING REMOTE SYSTEM^^A^^^^^^^y^HEALTH LEVEL SEVEN^^1
"KRN",19,1420,1,0)
^^6^6^3091124^
"KRN",19,1420,1,1,0)
This option asks the user to select an TCP HL Logical Link.  It then asks
"KRN",19,1420,1,2,0)
the user to choose between the HLO port and the HL7 1.6 port.  It then
"KRN",19,1420,1,3,0)
sends an HL7 message to that other system.  If a commit ack is returned then
"KRN",19,1420,1,4,0)
that demonstrates that there is remote connectivity AND the remote HL7 server
"KRN",19,1420,1,5,0)
is in operation. 
"KRN",19,1420,1,6,0)

"KRN",19,1420,10.1)
PING OTHER SYSTEM
"KRN",19,1420,20)
D PING^HLOPING
"KRN",19,1420,"U")
PING REMOTE SYSTEM
"KRN",19,1431,-1)
0^12
"KRN",19,1431,0)
HLO LOG READ/WRITE ERRORS^LOG READ/WRITE ERRORS^^A^^^^^^^y^HEALTH LEVEL SEVEN^^1^
"KRN",19,1431,1,0)
^19.06^10^10^3100325^^^
"KRN",19,1431,1,1,0)
This is a troubleshooting option. Logging all errors should be turned on for
"KRN",19,1431,1,2,0)
only short periods while troubleshooting a communication problem, and will
"KRN",19,1431,1,3,0)
cause TCP/IP errors to be entered to the Kernel Error Trap.
"KRN",19,1431,1,4,0)

"KRN",19,1431,1,5,0)
Normally, the HLO software (HL7 optimized) will NOT log common errors that
"KRN",19,1431,1,6,0)
occur durring TCP/IP communication, such as READ and WRITE errors, though other
"KRN",19,1431,1,7,0)
types of errors ARE always entered to the Kerel Error Trap. Turning
"KRN",19,1431,1,8,0)
logging on will cause READ and WRITE errors to be logged to the Kernel Error
"KRN",19,1431,1,9,0)
Trap.
"KRN",19,1431,1,10,0)

"KRN",19,1431,15)

"KRN",19,1431,20)
D LOGALL^HLOUSR
"KRN",19,1431,"U")
LOG READ/WRITE ERRORS
"KRN",19,1432,-1)
0^13
"KRN",19,1432,0)
HLO RECOUNT MESSAGE QUEUES^HLO RECOUNT MESSAGE QUEUES^^A^^^^^^^n^HEALTH LEVEL SEVEN^^1
"KRN",19,1432,1,0)
^^8^8^3100415^
"KRN",19,1432,1,1,0)
Every once in a while the count of messages pending on a queue will become
"KRN",19,1432,1,2,0)
off by a message or two.  This option will recount all the messages pending
"KRN",19,1432,1,3,0)
on all the queues to insure that the counts never get too far off. 
"KRN",19,1432,1,4,0)

"KRN",19,1432,1,5,0)
This option first stops all HLO processes, because otherwise the messages
"KRN",19,1432,1,6,0)
could not be counted accurately.  It should NOT be run during peak hours.
"KRN",19,1432,1,7,0)
The recommended use is to schedule it to be run onces daily.
"KRN",19,1432,1,8,0)

"KRN",19,1432,20)
D QCOUNT^HLOPROC1
"KRN",19,1432,"U")
HLO RECOUNT MESSAGE QUEUES
"KRN",101,513,-1)
0^2
"KRN",101,513,0)
HLO SEQUENCE DELETE^SEQUENCE QUEUE DELETE^^A^^^^^^^^HEALTH LEVEL SEVEN
"KRN",101,513,.1)
DELETE
"KRN",101,513,1,0)
^101.06^2^2^3100104^^
"KRN",101,513,1,1,0)
This action deletes a specified sequence queue.
"KRN",101,513,1,2,0)

"KRN",101,513,2,0)
^101.02A^^0
"KRN",101,513,15)

"KRN",101,513,20)
D SPURGE^HLOUSR7
"KRN",101,513,99)
61206,27044
"KRN",101,514,-1)
0^1
"KRN",101,514,0)
HLO OUTBOUND DELETE^DEL QUE^^A^^^^^^^^HEALTH LEVEL SEVEN
"KRN",101,514,.1)
DELETE
"KRN",101,514,1,0)
^101.06^2^2^3100104^^^^
"KRN",101,514,1,1,0)
This action deletes messages from a specified queue.
"KRN",101,514,1,2,0)

"KRN",101,514,2,0)
^101.02A^2^1
"KRN",101,514,2,2,0)
DQ
"KRN",101,514,2,"B","DQ",2)

"KRN",101,514,15)

"KRN",101,514,20)
D OPURGE^HLOUSR7
"KRN",101,514,99)
61206,27044
"MBREQ")
0
"ORD",0,9.8)
9.8;;1;RTNF^XPDTA;RTNE^XPDTA
"ORD",0,9.8,0)
ROUTINE
"ORD",7,.402)
.402;7;;;EDEOUT^DIFROMSO(.402,DA,"",XPDA);FPRE^DIFROMSI(.402,"",XPDA);EPRE^DIFROMSI(.402,DA,$E("N",$G(XPDNEW)),XPDA,"",OLDA);;EPOST^DIFROMSI(.402,DA,"",XPDA);DEL^DIFROMSK(.402,"",%)
"ORD",7,.402,0)
INPUT TEMPLATE
"ORD",15,101)
101;15;;;PRO^XPDTA;PROF1^XPDIA;PROE1^XPDIA;PROF2^XPDIA;;PRODEL^XPDIA
"ORD",15,101,0)
PROTOCOL
"ORD",18,19)
19;18;;;OPT^XPDTA;OPTF1^XPDIA;OPTE1^XPDIA;OPTF2^XPDIA;;OPTDEL^XPDIA
"ORD",18,19,0)
OPTION
"PKG",9,-1)
1^1
"PKG",9,0)
HEALTH LEVEL SEVEN^HL^DHCP IMPLEMENTATION OF HEALTH LEVEL SEVEN^
"PKG",9,20,0)
^9.402P^^
"PKG",9,22,0)
^9.49I^1^1
"PKG",9,22,1,0)
1.6^2980130^2980130^6
"PKG",9,22,1,"PAH",1,0)
147^3100823
"PKG",9,22,1,"PAH",1,1,0)
^^2^2^3100823
"PKG",9,22,1,"PAH",1,1,1,0)
Please see the National Patch Module on Forum for a complete description.
"PKG",9,22,1,"PAH",1,1,2,0)

"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
NO
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
NO
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
NO
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
23
"RTN","HLOAPI5")
1^5^^B90305828
"RTN","HLOASUB1")
0^15^B91573157^B91447015
"RTN","HLOASUB1",1,0)
HLOASUB1 ;IRMFO-ALB/CJM/RBN - Subscription Registry (continued) ;04/08/2010
"RTN","HLOASUB1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,134,138,146,147**;Oct 13, 1995;Build 15
"RTN","HLOASUB1",3,0)
 ;Per VHA Directive 10-93-142, this routine should not be modified.
"RTN","HLOASUB1",4,0)
 ;
"RTN","HLOASUB1",5,0)
INDEX(IEN,PARMARY) ;
"RTN","HLOASUB1",6,0)
 ;Allows an application to optionally index its subscriptions.
"RTN","HLOASUB1",7,0)
 ;so that it can find find them without storing the ien.
"RTN","HLOASUB1",8,0)
 ;
"RTN","HLOASUB1",9,0)
 ;Input:
"RTN","HLOASUB1",10,0)
 ;  IEN - ien of the entry
"RTN","HLOASUB1",11,0)
 ;  PARMARY (pass by reference) An array of up to 6 lookup values with
"RTN","HLOASUB1",12,0)
 ;which to build the index.  The format is: PARMARY(1)=<first parameter>,
"RTN","HLOASUB1",13,0)
 ; up to PARMARY(6)
"RTN","HLOASUB1",14,0)
 ;Output:
"RTN","HLOASUB1",15,0)
 ;  function returns 1 on success, 0 otherwise
"RTN","HLOASUB1",16,0)
 ;  PARMARY - left undefined
"RTN","HLOASUB1",17,0)
 ;
"RTN","HLOASUB1",18,0)
 N OWNER,I,NODE
"RTN","HLOASUB1",19,0)
 Q:'$G(IEN) 0
"RTN","HLOASUB1",20,0)
 S OWNER=$P($G(^HLD(779.4,IEN,0)),"^",2)
"RTN","HLOASUB1",21,0)
 Q:'$L(OWNER) 0
"RTN","HLOASUB1",22,0)
 D KILLAH(IEN)
"RTN","HLOASUB1",23,0)
 F I=1:1:6 S:'$L($G(PARMARY(I))) PARMARY(I)=" "
"RTN","HLOASUB1",24,0)
 D SETAH(IEN,OWNER,.PARMARY)
"RTN","HLOASUB1",25,0)
 S NODE=""
"RTN","HLOASUB1",26,0)
 F I=1:1:6 S NODE=NODE_$G(PARMARY(I))_"^"
"RTN","HLOASUB1",27,0)
 S ^HLD(779.4,IEN,3)=NODE
"RTN","HLOASUB1",28,0)
 K PARMARY
"RTN","HLOASUB1",29,0)
 Q 1
"RTN","HLOASUB1",30,0)
 ;
"RTN","HLOASUB1",31,0)
SETAH(IEN,OWNER,PARMS) ;
"RTN","HLOASUB1",32,0)
 Q:'$G(IEN)
"RTN","HLOASUB1",33,0)
 Q:'$L($G(OWNER))
"RTN","HLOASUB1",34,0)
 N INDEX
"RTN","HLOASUB1",35,0)
 S INDEX="^HLD(779.4,""AH"",OWNER,"
"RTN","HLOASUB1",36,0)
 F I=1:1:6 D
"RTN","HLOASUB1",37,0)
 .S:'$L($G(PARMS(I))) PARMS(I)=" "
"RTN","HLOASUB1",38,0)
 .S INDEX=INDEX_""""_PARMS(I)_""","
"RTN","HLOASUB1",39,0)
 S INDEX=$E(INDEX,1,$L(INDEX)-1)_")"
"RTN","HLOASUB1",40,0)
 S @INDEX=IEN
"RTN","HLOASUB1",41,0)
 Q
"RTN","HLOASUB1",42,0)
 ;
"RTN","HLOASUB1",43,0)
SETAH1(DA,OWNER,X1,X2,X3,X4,X5,X6) ;
"RTN","HLOASUB1",44,0)
 Q:'$G(DA)
"RTN","HLOASUB1",45,0)
 Q:'$L($G(OWNER))
"RTN","HLOASUB1",46,0)
 N PARMS,I
"RTN","HLOASUB1",47,0)
 F I=1:1:6 I $L($G(@("X"_I))) S PARMS(I)=@("X"_I)
"RTN","HLOASUB1",48,0)
 D SETAH(DA,OWNER,.PARMS)
"RTN","HLOASUB1",49,0)
 Q
"RTN","HLOASUB1",50,0)
 ;
"RTN","HLOASUB1",51,0)
KILLAH1(OWNER,LOOKUP1,LOOKUP2,LOOKUP3,LOOKUP4,LOOKUP5,LOOKUP6) ;
"RTN","HLOASUB1",52,0)
 Q:'$L(OWNER)
"RTN","HLOASUB1",53,0)
 N I,INDEX
"RTN","HLOASUB1",54,0)
 S INDEX="^HLD(779.4,""AH"",OWNER"
"RTN","HLOASUB1",55,0)
 F I=1:1:6 D
"RTN","HLOASUB1",56,0)
 .S:'$L($G(@("LOOKUP"_I))) @("LOOKUP"_I)=" "
"RTN","HLOASUB1",57,0)
 .S INDEX=INDEX_","_""""_@("LOOKUP"_I)_""""
"RTN","HLOASUB1",58,0)
 S INDEX=INDEX_")"
"RTN","HLOASUB1",59,0)
 K @INDEX
"RTN","HLOASUB1",60,0)
 Q
"RTN","HLOASUB1",61,0)
 ;
"RTN","HLOASUB1",62,0)
KILLAH(IEN) ;kills the AH x~ref on file 779.4 for a particular subscription registry entry=ien
"RTN","HLOASUB1",63,0)
 Q:'$G(IEN)
"RTN","HLOASUB1",64,0)
 N OWNER,X1,X2,X3,X4,X5,X6,I,NODE
"RTN","HLOASUB1",65,0)
 S OWNER=$P($G(^HLD(779.4,IEN,0)),"^",2)
"RTN","HLOASUB1",66,0)
 Q:'$L(OWNER)
"RTN","HLOASUB1",67,0)
 S NODE=$G(^HLD(779.4,IEN,3))
"RTN","HLOASUB1",68,0)
 F I=1:1:6 I $L($P(NODE,"^",I)) S @("X"_I)=$P(NODE,"^",I)
"RTN","HLOASUB1",69,0)
 D KILLAH1(OWNER,.X1,.X2,.X3,.X4,.X5,.X6)
"RTN","HLOASUB1",70,0)
 Q
"RTN","HLOASUB1",71,0)
 ;
"RTN","HLOASUB1",72,0)
FIND(OWNER,PARMARY) ;
"RTN","HLOASUB1",73,0)
 ;Allows an application to find a subscription
"RTN","HLOASUB1",74,0)
 ;list.  The application must maintain a private index in order to
"RTN","HLOASUB1",75,0)
 ;utilize this function, via $$INDEX^HLOASUB()
"RTN","HLOASUB1",76,0)
 ;
"RTN","HLOASUB1",77,0)
 ;Input:
"RTN","HLOASUB1",78,0)
 ;  OWNER - owning application name
"RTN","HLOASUB1",79,0)
 ;  PARMARY  **pass by reference** an array of up to 6 lookup value with which the index was built.  The format is: PARMARY(1)=<first parameter>, PARMARY(2)=<second parameter>  If PARMARY(i)=null, the parameter will be ignored
"RTN","HLOASUB1",80,0)
 ;Output:
"RTN","HLOASUB1",81,0)
 ;  function returns the ien of the subscription list if found, 0 otherwise
"RTN","HLOASUB1",82,0)
 ; PARMARY - left undefined
"RTN","HLOASUB1",83,0)
 ;
"RTN","HLOASUB1",84,0)
 N OK S OK=0
"RTN","HLOASUB1",85,0)
 ;
"RTN","HLOASUB1",86,0)
 D
"RTN","HLOASUB1",87,0)
 .Q:'$D(PARMARY)
"RTN","HLOASUB1",88,0)
 .Q:'$L($G(OWNER))
"RTN","HLOASUB1",89,0)
 .N INDEX,I
"RTN","HLOASUB1",90,0)
 .S INDEX="^HLD(779.4,""AH"",OWNER"
"RTN","HLOASUB1",91,0)
 .F I=1:1:6 D
"RTN","HLOASUB1",92,0)
 ..S:'$L($G(PARMARY(I))) PARMARY(I)=" "
"RTN","HLOASUB1",93,0)
 ..S INDEX=INDEX_","_""""_PARMARY(I)_""""
"RTN","HLOASUB1",94,0)
 .S INDEX=INDEX_")"
"RTN","HLOASUB1",95,0)
 .S OK=+$G(@INDEX)
"RTN","HLOASUB1",96,0)
 K PARMARY
"RTN","HLOASUB1",97,0)
 Q OK
"RTN","HLOASUB1",98,0)
 ;
"RTN","HLOASUB1",99,0)
UPD(FILE,DA,DATA,ERROR) ;File data into an existing record.
"RTN","HLOASUB1",100,0)
 ; Input:
"RTN","HLOASUB1",101,0)
 ;   FILE - File or sub-file number
"RTN","HLOASUB1",102,0)
 ;   DA - Traditional DA array, with same meaning.
"RTN","HLOASUB1",103,0)
 ;            Pass by reference.
"RTN","HLOASUB1",104,0)
 ;   DATA - Data array to file (pass by reference)
"RTN","HLOASUB1",105,0)
 ;          Format: DATA(<field #>)=<value>
"RTN","HLOASUB1",106,0)
 ;
"RTN","HLOASUB1",107,0)
 ; Output:
"RTN","HLOASUB1",108,0)
 ;  Function Value -     0=error and 1=no error
"RTN","HLOASUB1",109,0)
 ;  ERROR - optional error message - if needed, pass by reference
"RTN","HLOASUB1",110,0)
 ;
"RTN","HLOASUB1",111,0)
 ; Example: To update a record in subfile 2.0361 in record with ien=353,
"RTN","HLOASUB1",112,0)
 ;          subrecord ien=68, with the field .01 value = 21:
"RTN","HLOASUB1",113,0)
 ;    S DATA(.01)=21,DA=68,DA(1)=353 I $$UPD(2.0361,.DA,.DATA,.ERROR) W !,"DONE"
"RTN","HLOASUB1",114,0)
 ;
"RTN","HLOASUB1",115,0)
 N FDA,FIELD,IENS,ERRORS
"RTN","HLOASUB1",116,0)
 ;
"RTN","HLOASUB1",117,0)
 ;IENS - Internal Entry Number String defined by FM
"RTN","HLOASUB1",118,0)
 ;FDA - the FDA array as defined by FM
"RTN","HLOASUB1",119,0)
 ;
"RTN","HLOASUB1",120,0)
 I '$G(DA) S ERROR="IEN OF RECORD TO BE UPDATED NOT SPECIFIED" Q 0
"RTN","HLOASUB1",121,0)
 S IENS=$$IENS^DILF(.DA)
"RTN","HLOASUB1",122,0)
 S FIELD=0
"RTN","HLOASUB1",123,0)
 F  S FIELD=$O(DATA(FIELD)) Q:'FIELD  D
"RTN","HLOASUB1",124,0)
 .S FDA(FILE,IENS,FIELD)=$G(DATA(FIELD))
"RTN","HLOASUB1",125,0)
 D FILE^DIE("","FDA","ERRORS(1)")
"RTN","HLOASUB1",126,0)
 I +$G(DIERR) D
"RTN","HLOASUB1",127,0)
 .S ERROR=$G(ERRORS(1,"DIERR",1,"TEXT",1))
"RTN","HLOASUB1",128,0)
 E  D
"RTN","HLOASUB1",129,0)
 .S ERROR=""
"RTN","HLOASUB1",130,0)
 ;
"RTN","HLOASUB1",131,0)
 D CLEAN^DILF
"RTN","HLOASUB1",132,0)
 Q $S(+$G(DIERR):0,1:1)
"RTN","HLOASUB1",133,0)
 ;
"RTN","HLOASUB1",134,0)
ADD(FILE,DA,DATA,ERROR,IEN) ;
"RTN","HLOASUB1",135,0)
 ;Description: Creates a new record and files the data.
"RTN","HLOASUB1",136,0)
 ; Input:
"RTN","HLOASUB1",137,0)
 ;   FILE - File or sub-file number
"RTN","HLOASUB1",138,0)
 ;   DA - Traditional FileMan DA array with same
"RTN","HLOASUB1",139,0)
 ;            meaning. Pass by reference.  Only needed if adding to a
"RTN","HLOASUB1",140,0)
 ;            subfile.
"RTN","HLOASUB1",141,0)
 ;   DATA - Data array to file, pass by reference
"RTN","HLOASUB1",142,0)
 ;          Format: DATA(<field #>)=<value>
"RTN","HLOASUB1",143,0)
 ;   IEN - internal entry number to use (optional)
"RTN","HLOASUB1",144,0)
 ;
"RTN","HLOASUB1",145,0)
 ; Output:
"RTN","HLOASUB1",146,0)
 ;   Function Value - If no error then it returns the ien of the created record, else returns NULL.
"RTN","HLOASUB1",147,0)
 ;  DA - returns the ien of the new record, NULL if none created.  If needed, pass by reference.
"RTN","HLOASUB1",148,0)
 ;  ERROR - optional error message - if needed, pass by reference
"RTN","HLOASUB1",149,0)
 ;
"RTN","HLOASUB1",150,0)
 ; Example: To add a record in subfile 2.0361 in the record with ien=353
"RTN","HLOASUB1",151,0)
 ;          with the field .01 value = 21:
"RTN","HLOASUB1",152,0)
 ;  S DATA(.01)=21,DA(1)=353 I $$ADD(2.0361,.DA,.DATA) W !,"DONE"
"RTN","HLOASUB1",153,0)
 ;
"RTN","HLOASUB1",154,0)
 ; Example: If creating a record not in a subfile, would look like this:
"RTN","HLOASUB1",155,0)
 ;          S DATA(.01)=21 I $$ADD(867,,.DATA) W !,"DONE"
"RTN","HLOASUB1",156,0)
 ;
"RTN","HLOASUB1",157,0)
 N FDA,FIELD,IENA,IENS,ERRORS
"RTN","HLOASUB1",158,0)
 ;
"RTN","HLOASUB1",159,0)
 ;IENS - Internal Entry Number String defined by FM
"RTN","HLOASUB1",160,0)
 ;IENA - the Internal Entry Number Array defined by FM
"RTN","HLOASUB1",161,0)
 ;FDA - the FDA array defined by FM
"RTN","HLOASUB1",162,0)
 ;IEN - the ien of the new record
"RTN","HLOASUB1",163,0)
 ;
"RTN","HLOASUB1",164,0)
 S DA="+1"
"RTN","HLOASUB1",165,0)
 S IENS=$$IENS^DILF(.DA)
"RTN","HLOASUB1",166,0)
 S FIELD=0
"RTN","HLOASUB1",167,0)
 F  S FIELD=$O(DATA(FIELD)) Q:'FIELD  D
"RTN","HLOASUB1",168,0)
 .S FDA(FILE,IENS,FIELD)=$G(DATA(FIELD))
"RTN","HLOASUB1",169,0)
 I $G(IEN) S IENA(1)=IEN
"RTN","HLOASUB1",170,0)
 D UPDATE^DIE("","FDA","IENA","ERRORS(1)")
"RTN","HLOASUB1",171,0)
 I +$G(DIERR) D
"RTN","HLOASUB1",172,0)
 .S ERROR=$G(ERRORS(1,"DIERR",1,"TEXT",1))
"RTN","HLOASUB1",173,0)
 .S IEN=""
"RTN","HLOASUB1",174,0)
 E  D
"RTN","HLOASUB1",175,0)
 .S IEN=IENA(1)
"RTN","HLOASUB1",176,0)
 .S ERROR=""
"RTN","HLOASUB1",177,0)
 D CLEAN^DILF
"RTN","HLOASUB1",178,0)
 S DA=IEN
"RTN","HLOASUB1",179,0)
 Q IEN
"RTN","HLOASUB1",180,0)
 ;
"RTN","HLOASUB1",181,0)
DELETE(FILE,DA,ERROR)   ;Delete an existing record.
"RTN","HLOASUB1",182,0)
 N DATA
"RTN","HLOASUB1",183,0)
 S DATA(.01)="@"
"RTN","HLOASUB1",184,0)
 Q $$UPD(FILE,.DA,.DATA,.ERROR)
"RTN","HLOASUB1",185,0)
 Q
"RTN","HLOASUB1",186,0)
 ;
"RTN","HLOASUB1",187,0)
STATNUM(IEN) ;
"RTN","HLOASUB1",188,0)
 ;Description:  Given an ien to the Institution file, returns as the function value the station number. If IEN is NOT passed in, it assumes the local site.  Returns "" on failure.
"RTN","HLOASUB1",189,0)
 ;
"RTN","HLOASUB1",190,0)
 N STATION,RETURN
"RTN","HLOASUB1",191,0)
 S RETURN=""
"RTN","HLOASUB1",192,0)
 I $G(IEN) D
"RTN","HLOASUB1",193,0)
 .Q:'$D(^DIC(4,IEN,0))
"RTN","HLOASUB1",194,0)
 .S STATION=$P($$NNT^XUAF4(IEN),"^",2)
"RTN","HLOASUB1",195,0)
 .S RETURN=$S(+STATION:STATION,1:"")
"RTN","HLOASUB1",196,0)
 E  D
"RTN","HLOASUB1",197,0)
 .S RETURN=$P($$SITE^VASITE(),"^",3)
"RTN","HLOASUB1",198,0)
 Q RETURN
"RTN","HLOASUB1",199,0)
 ;
"RTN","HLOASUB1",200,0)
CHECKWHO(WHO,PARMS,ERROR) ;
"RTN","HLOASUB1",201,0)
 ;Checks the parameters provided in WHO() (see $$ADD).  They must resolve
"RTN","HLOASUB1",202,0)
 ;the link, receiving app and receiving facility.
"RTN","HLOASUB1",203,0)
 ;INPUT:
"RTN","HLOASUB1",204,0)
 ;  WHO - (required, pass by reference) - see $$ADD.
"RTN","HLOASUB1",205,0)
 ;
"RTN","HLOASUB1",206,0)
 ;  WHO("PORT") - if this is valued, it will be used as the remote port
"RTN","HLOASUB1",207,0)
 ;    to connect with rather than the port associated with the link
"RTN","HLOASUB1",208,0)
 ;Output:
"RTN","HLOASUB1",209,0)
 ;  Function returns 1 if the input is resolved successfully, 0 otherwise
"RTN","HLOASUB1",210,0)
 ;    PARMS - (pass by reference)  These subscripts are returned:
"RTN","HLOASUB1",211,0)
 ;     "LINK IEN" - ien of the link overwhich to transmit (could be middleware)
"RTN","HLOASUB1",212,0)
 ;     "LINK NAME" - name of the link
"RTN","HLOASUB1",213,0)
 ;     "RECEIVING APPLICATION"  - name of the receiving app
"RTN","HLOASUB1",214,0)
 ;     "RECEIVING FACILITY",1)  - component 1
"RTN","HLOASUB1",215,0)
 ;     "RECEIVING FACILITY",2) - component 2
"RTN","HLOASUB1",216,0)
 ;     "RECEIVING FACILITY",3) - component 3
"RTN","HLOASUB1",217,0)
 ;     "RECEIVING FACILITY","LINK IEN") - ien of facility
"RTN","HLOASUB1",218,0)
 ;   ERROR - (pass by reference) - if unsuccessful, an error message is returned.
"RTN","HLOASUB1",219,0)
 ;
"RTN","HLOASUB1",220,0)
 N OK
"RTN","HLOASUB1",221,0)
 K ERROR
"RTN","HLOASUB1",222,0)
 S OK=1
"RTN","HLOASUB1",223,0)
 S PARMS("LINK IEN")="",PARMS("LINK NAME")=""
"RTN","HLOASUB1",224,0)
 ;must identify the receiving app
"RTN","HLOASUB1",225,0)
 ;
"RTN","HLOASUB1",226,0)
 D
"RTN","HLOASUB1",227,0)
 .N LEN
"RTN","HLOASUB1",228,0)
 .S LEN=$L($G(WHO("RECEIVING APPLICATION")))
"RTN","HLOASUB1",229,0)
 .I 'LEN S OK=0
"RTN","HLOASUB1",230,0)
 .E  I LEN>60 S OK=0
"RTN","HLOASUB1",231,0)
 .S:'OK ERROR="RECEIVING APPLICATION NOT VALID"
"RTN","HLOASUB1",232,0)
 .S PARMS("RECEIVING APPLICATION")=$G(WHO("RECEIVING APPLICATION"))
"RTN","HLOASUB1",233,0)
 ;
"RTN","HLOASUB1",234,0)
 ;find the station # if Institution ien known
"RTN","HLOASUB1",235,0)
 S:$G(WHO("INSTITUTION IEN")) WHO("STATION NUMBER")=$$STATNUM^HLOASUB1(WHO("INSTITUTION IEN"))
"RTN","HLOASUB1",236,0)
 ;
"RTN","HLOASUB1",237,0)
 ;if destination link specified by name, get its ien
"RTN","HLOASUB1",238,0)
 I '$G(WHO("FACILITY LINK IEN")),$L($G(WHO("FACILITY LINK NAME"))) S WHO("FACILITY LINK IEN")=$O(^HLCS(870,"B",WHO("FACILITY LINK NAME"),0))
"RTN","HLOASUB1",239,0)
 ;
"RTN","HLOASUB1",240,0)
 ;if destination link not specified, find it based on station #
"RTN","HLOASUB1",241,0)
 I $L($G(WHO("STATION NUMBER"))),'$G(WHO("FACILITY LINK IEN")) S WHO("FACILITY LINK IEN")=$$FINDLINK^HLOTLNK(WHO("STATION NUMBER"))
"RTN","HLOASUB1",242,0)
 ;
"RTN","HLOASUB1",243,0)
 ;if station # not known, find it based on destination link
"RTN","HLOASUB1",244,0)
 I '$L($G(WHO("STATION NUMBER"))),$G(WHO("FACILITY LINK IEN")) S WHO("STATION NUMBER")=$$STATNUM^HLOTLNK(WHO("FACILITY LINK IEN"))
"RTN","HLOASUB1",245,0)
 ;
"RTN","HLOASUB1",246,0)
 S PARMS("RECEIVING FACILITY",1)=$G(WHO("STATION NUMBER"))
"RTN","HLOASUB1",247,0)
 ;
"RTN","HLOASUB1",248,0)
 ;if the destination link is known, get the domain
"RTN","HLOASUB1",249,0)
 S PARMS("RECEIVING FACILITY",2)=$S($G(WHO("FACILITY LINK IEN")):$$DOMAIN^HLOTLNK(WHO("FACILITY LINK IEN")),1:"")
"RTN","HLOASUB1",250,0)
 ;
"RTN","HLOASUB1",251,0)
 ;**P146 START CJM
"RTN","HLOASUB1",252,0)
 S PARMS("RECEIVING FACILITY","LINK IEN")=$G(WHO("FACILITY LINK IEN"))
"RTN","HLOASUB1",253,0)
 ;**P146 END CJM
"RTN","HLOASUB1",254,0)
 ;
"RTN","HLOASUB1",255,0)
 S PARMS("RECEIVING FACILITY",3)="DNS"
"RTN","HLOASUB1",256,0)
 ;
"RTN","HLOASUB1",257,0)
 ;find the link to send over - need name & ien
"RTN","HLOASUB1",258,0)
 I $G(WHO("MIDDLEWARE LINK IEN")) S WHO("IE LINK IEN")=WHO("MIDDLEWARE LINK IEN")
"RTN","HLOASUB1",259,0)
 I $L($G(WHO("MIDDLEWARE LINK NAME"))) S WHO("IE LINK NAME")=WHO("MIDDLEWARE LINK NAME")
"RTN","HLOASUB1",260,0)
 I $G(WHO("IE LINK IEN")) D
"RTN","HLOASUB1",261,0)
 .S PARMS("LINK IEN")=WHO("IE LINK IEN")
"RTN","HLOASUB1",262,0)
 .S PARMS("LINK NAME")=$P($G(^HLCS(870,PARMS("LINK IEN"),0)),"^")
"RTN","HLOASUB1",263,0)
 .I OK,'$L(PARMS("LINK NAME")) S OK=0,ERROR="MIDDLEWARE LOGICAL LINK PROVIDED BUT NOT FOUND"
"RTN","HLOASUB1",264,0)
 E  I $L($G(WHO("IE LINK NAME"))) D
"RTN","HLOASUB1",265,0)
 .S PARMS("LINK NAME")=WHO("IE LINK NAME")
"RTN","HLOASUB1",266,0)
 .S PARMS("LINK IEN")=$O(^HLCS(870,"B",WHO("IE LINK NAME"),0))
"RTN","HLOASUB1",267,0)
 .I OK,'PARMS("LINK IEN") S OK=0,ERROR="MIDDLEWARE LOGICAL LINK PROVIDED BUT NOT FOUND"
"RTN","HLOASUB1",268,0)
 E  I $G(WHO("FACILITY LINK IEN")) D
"RTN","HLOASUB1",269,0)
 .S PARMS("LINK IEN")=WHO("FACILITY LINK IEN")
"RTN","HLOASUB1",270,0)
 .S PARMS("LINK NAME")=$P($G(^HLCS(870,PARMS("LINK IEN"),0)),"^")
"RTN","HLOASUB1",271,0)
 .I OK,'$L(PARMS("LINK NAME")) S OK=0,ERROR="RECEIVING FACILITY LOGICAL LINK NOT FOUND"
"RTN","HLOASUB1",272,0)
 E  I $L($G(WHO("FACILITY LINK NAME"))) D
"RTN","HLOASUB1",273,0)
 .S PARMS("LINK NAME")=WHO("FACILITY LINK NAME")
"RTN","HLOASUB1",274,0)
 .S PARMS("LINK IEN")=$O(^HLCS(870,"B",WHO("FACILITY LINK NAME"),0))
"RTN","HLOASUB1",275,0)
 .;; ** Start HL*1.6*138 - RBN **
"RTN","HLOASUB1",276,0)
 .;I OK,'PARMS("LINK IEN") S OK=0,ERROR="RECEIVING FACILITY LOGICAL LINK NOT FOUND"
"RTN","HLOASUB1",277,0)
 .I OK,'PARMS("LINK IEN") S OK=0,ERROR="NEITHER THE RECEIVING FACILITY STATION # NOR THE DOMAIN IS SPECIFIED. AT LEAST ONE OR THE OTHER MUST BE SPECIFIED."
"RTN","HLOASUB1",278,0)
 .;; ** Start HL*1.6*138 - RBN **
"RTN","HLOASUB1",279,0)
 I OK,(('PARMS("LINK IEN"))!(PARMS("LINK NAME")="")) S OK=0,ERROR="LOGICAL LINK TO TRANSMIT OVER NOT SPECIFIED"
"RTN","HLOASUB1",280,0)
 ;
"RTN","HLOASUB1",281,0)
 ;need the station # or domain for msg header
"RTN","HLOASUB1",282,0)
ZB25 I OK,'$L(PARMS("RECEIVING FACILITY",2)),'PARMS("RECEIVING FACILITY",1) S OK=0,ERROR="NEITHER THE RECEIVING FACILITY STATION # NOR THE DOMAIN IS SPECIFIED. AT LEAST ONE OR THE OTHER MUST BE SPECIFIED."
"RTN","HLOASUB1",283,0)
 ;
"RTN","HLOASUB1",284,0)
 ;append the port#
"RTN","HLOASUB1",285,0)
 I '$G(WHO("PORT")) S PARMS("RECEIVING FACILITY",2)=PARMS("RECEIVING FACILITY",2)_":"_$$PORT^HLOTLNK($G(WHO("FACILITY LINK IEN")))
"RTN","HLOASUB1",286,0)
 E  S PARMS("RECEIVING FACILITY",2)=PARMS("RECEIVING FACILITY",2)_":"_WHO("PORT")
"RTN","HLOASUB1",287,0)
 ;
"RTN","HLOASUB1",288,0)
 Q OK
"RTN","HLOASUB1",289,0)
 ;
"RTN","HLOASUB1",290,0)
 ;**P146 START CJM
"RTN","HLOASUB1",291,0)
ONLIST(IEN,WHO) ;
"RTN","HLOASUB1",292,0)
 ;Description:
"RTN","HLOASUB1",293,0)
 ;  Determines if a recipient is already on the subscriber list
"RTN","HLOASUB1",294,0)
 ;
"RTN","HLOASUB1",295,0)
 ;Input:
"RTN","HLOASUB1",296,0)
 ;  IEN - ien of subscription
"RTN","HLOASUB1",297,0)
 ;  WHO (pass by reference) Identifies the recipient. The allows
"RTN","HLOASUB1",298,0)
 ;      subscripts are the same as in ADD^HLOASUB.
"RTN","HLOASUB1",299,0)
 ;
"RTN","HLOASUB1",300,0)
 ;Output:
"RTN","HLOASUB1",301,0)
 ;   Function returns 0 if not on the subscription list, otherwise
"RTN","HLOASUB1",302,0)
 ;      returns the ien of the subscriber on the subscription list.
"RTN","HLOASUB1",303,0)
 ;
"RTN","HLOASUB1",304,0)
 N PARMS,SUBIEN,TLINK
"RTN","HLOASUB1",305,0)
 S SUBIEN=0
"RTN","HLOASUB1",306,0)
 ;
"RTN","HLOASUB1",307,0)
 ;resolve input parameters
"RTN","HLOASUB1",308,0)
 I '$$CHECKWHO(.WHO,.PARMS) Q 0
"RTN","HLOASUB1",309,0)
 ;
"RTN","HLOASUB1",310,0)
 ;check the "AE" xref
"RTN","HLOASUB1",311,0)
ZB S SUBIEN=$O(^HLD(779.4,IEN,2,"AE",PARMS("RECEIVING APPLICATION"),+$G(PARMS("RECEIVING FACILITY","LINK IEN")),+$G(PARMS("LINK IEN")),0))
"RTN","HLOASUB1",312,0)
 I SUBIEN Q SUBIEN
"RTN","HLOASUB1",313,0)
 I PARMS("RECEIVING FACILITY","LINK IEN")=PARMS("LINK IEN") S SUBIEN=$O(^HLD(779.4,IEN,2,"AE",PARMS("RECEIVING APPLICATION"),+$G(PARMS("RECEIVING FACILITY","LINK IEN")),0,0))
"RTN","HLOASUB1",314,0)
 I SUBIEN Q SUBIEN
"RTN","HLOASUB1",315,0)
 ;
"RTN","HLOASUB1",316,0)
 ;check the "AD" xref
"RTN","HLOASUB1",317,0)
 I PARMS("LINK IEN"),PARMS("LINK IEN")'=PARMS("RECEIVING FACILITY","LINK IEN") D
"RTN","HLOASUB1",318,0)
 .S TLINK=PARMS("LINK IEN")
"RTN","HLOASUB1",319,0)
 E  S TLINK=PARMS("RECEIVING FACILITY","LINK IEN")
"RTN","HLOASUB1",320,0)
 ;
"RTN","HLOASUB1",321,0)
 Q +$O(^HLD(779.4,IEN,2,"AD",PARMS("RECEIVING APPLICATION"),+TLINK,PARMS("RECEIVING FACILITY",1)_PARMS("RECEIVING FACILITY",2)_PARMS("RECEIVING FACILITY",3),0))
"RTN","HLOASUB1",322,0)
 ;
"RTN","HLOASUB1",323,0)
 ;**P146 END CJM
"RTN","HLOCLNT")
0^6^B80403155^B86058650
"RTN","HLOCLNT",1,0)
HLOCLNT ;ALB/CJM- Client for sending messages - 10/4/94 1pm ;08/17/2010
"RTN","HLOCLNT",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,130,131,134,137,139,143,147**;Oct 13, 1995;Build 15
"RTN","HLOCLNT",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOCLNT",4,0)
 ;
"RTN","HLOCLNT",5,0)
 ;GET WORK function for the process running under the Process Manager
"RTN","HLOCLNT",6,0)
GETWORK(QUE) ;
"RTN","HLOCLNT",7,0)
 ;Input:
"RTN","HLOCLNT",8,0)
 ;  QUE - (pass by reference) These subscripts are used:
"RTN","HLOCLNT",9,0)
 ;    ("LINK")  - <link name>_":"_<port> last obtained
"RTN","HLOCLNT",10,0)
 ;    ("QUEUE") - name of the queue last obtained
"RTN","HLOCLNT",11,0)
 ;Output:
"RTN","HLOCLNT",12,0)
 ;  Function returns 1 if success, 0 if no more work
"RTN","HLOCLNT",13,0)
 ;  QUE -  updated to identify next queue of messages to process.
"RTN","HLOCLNT",14,0)
 ;    ("LINK") - <link name>_":"_<port>
"RTN","HLOCLNT",15,0)
 ;    ("QUEUE") - the named queue on the link
"RTN","HLOCLNT",16,0)
 ;    ("DOWN") - =1 means that the last OPEN attempt failed
"RTN","HLOCLNT",17,0)
 ;
"RTN","HLOCLNT",18,0)
 N LINK,QUEUE
"RTN","HLOCLNT",19,0)
 S LINK=$G(QUE("LINK")),QUEUE=$G(QUE("QUEUE"))
"RTN","HLOCLNT",20,0)
TRY I (LINK]""),(QUEUE]"") D
"RTN","HLOCLNT",21,0)
 .L -^HLB("QUEUE","OUT",LINK,QUEUE)
"RTN","HLOCLNT",22,0)
 .I $$IFSHUT^HLOTLNK($P(LINK,":")) S QUEUE="" Q
"RTN","HLOCLNT",23,0)
 .I '$$CNNCTD(LINK),$$FAILING(.LINK) S QUEUE="" Q
"RTN","HLOCLNT",24,0)
 .F  S QUEUE=$O(^HLB("QUEUE","OUT",LINK,QUEUE)) Q:(QUEUE="")  I '$$STOPPED^HLOQUE("OUT",QUEUE) L +^HLB("QUEUE","OUT",LINK,QUEUE):0  Q:$T
"RTN","HLOCLNT",25,0)
 I (LINK]""),(QUEUE="") D
"RTN","HLOCLNT",26,0)
 .F  S LINK=$O(^HLB("QUEUE","OUT",LINK)) Q:LINK=""  D  Q:$L(QUEUE)
"RTN","HLOCLNT",27,0)
 ..Q:$$IFSHUT^HLOTLNK($P(LINK,":"))
"RTN","HLOCLNT",28,0)
 ..I '$$CNNCTD(LINK),$$FAILING(.LINK) Q
"RTN","HLOCLNT",29,0)
 ..S QUEUE="" F  S QUEUE=$O(^HLB("QUEUE","OUT",LINK,QUEUE)) Q:(QUEUE="")  I '$$STOPPED^HLOQUE("OUT",QUEUE) L +^HLB("QUEUE","OUT",LINK,QUEUE):0 Q:$T
"RTN","HLOCLNT",30,0)
 I LINK="" D
"RTN","HLOCLNT",31,0)
 .F  S LINK=$O(^HLB("QUEUE","OUT",LINK)) Q:LINK=""  D  Q:$L(QUEUE)
"RTN","HLOCLNT",32,0)
 ..Q:$$IFSHUT^HLOTLNK($P(LINK,":"))
"RTN","HLOCLNT",33,0)
 ..I '$$CNNCTD(LINK),$$FAILING(.LINK) Q
"RTN","HLOCLNT",34,0)
 ..S QUEUE="" F  S QUEUE=$O(^HLB("QUEUE","OUT",LINK,QUEUE)) Q:(QUEUE="")  I '$$STOPPED^HLOQUE("OUT",QUEUE) L +^HLB("QUEUE","OUT",LINK,QUEUE):0 Q:$T
"RTN","HLOCLNT",35,0)
 S QUE("LINK")=LINK,QUE("QUEUE")=QUEUE,QUE("DOWN")=$G(LINK("DOWN"))
"RTN","HLOCLNT",36,0)
 ;
"RTN","HLOCLNT",37,0)
 ;** P147 START CJM
"RTN","HLOCLNT",38,0)
 I $L(QUEUE),($R(100)>$$GETPRTY^HLOQUE(QUE("QUEUE"),QUE("LINK"))) G TRY
"RTN","HLOCLNT",39,0)
 ;** P148 END CJM
"RTN","HLOCLNT",40,0)
 ;
"RTN","HLOCLNT",41,0)
 Q:$L(QUEUE) 1
"RTN","HLOCLNT",42,0)
 D:$G(HLCSTATE("CONNECTED")) CLOSE^HLOT(.HLCSTATE)
"RTN","HLOCLNT",43,0)
 Q 0
"RTN","HLOCLNT",44,0)
 ;
"RTN","HLOCLNT",45,0)
FAILING(LINK) ;
"RTN","HLOCLNT",46,0)
 ;Returns 1 if the link has failed in the last 30 seconds, 0 otherwise
"RTN","HLOCLNT",47,0)
 ;Also returns LINK("DOWN")=1 if the link was failing > 30 seconds ago, not yet known if its up
"RTN","HLOCLNT",48,0)
 ;
"RTN","HLOCLNT",49,0)
 N LASTTIME,SET
"RTN","HLOCLNT",50,0)
 S LINK("DOWN")=0
"RTN","HLOCLNT",51,0)
 S LASTTIME=$G(^HLB("QUEUE","OUT",LINK))
"RTN","HLOCLNT",52,0)
 S SET=$S(LASTTIME]"":1,1:0)
"RTN","HLOCLNT",53,0)
 I SET D
"RTN","HLOCLNT",54,0)
 .I $$HDIFF^XLFDT($H,LASTTIME,2)>30 S ^HLB("QUEUE","OUT",LINK)="",SET=0,LINK("DOWN")=1
"RTN","HLOCLNT",55,0)
 I $D(^HLTMP("FAILING LINKS",LINK)) S LINK("DOWN")=1
"RTN","HLOCLNT",56,0)
 Q SET
"RTN","HLOCLNT",57,0)
 ;
"RTN","HLOCLNT",58,0)
LINKDOWN(HLCSTATE) ;
"RTN","HLOCLNT",59,0)
 N TO
"RTN","HLOCLNT",60,0)
 D:$G(HLCSTATE("CONNECTED")) CLOSE^HLOT(.HLCSTATE)
"RTN","HLOCLNT",61,0)
 I $D(HLCSTATE("LINK","NAME")),$D(HLCSTATE("LINK","PORT")) D
"RTN","HLOCLNT",62,0)
 .S TO=HLCSTATE("LINK","NAME")_":"_HLCSTATE("LINK","PORT")
"RTN","HLOCLNT",63,0)
 .S ^HLB("QUEUE","OUT",TO)=$H
"RTN","HLOCLNT",64,0)
 .S:'$D(^HLTMP("FAILING LINKS",TO)) ^HLTMP("FAILING LINKS",TO)=$H
"RTN","HLOCLNT",65,0)
 Q
"RTN","HLOCLNT",66,0)
 ;
"RTN","HLOCLNT",67,0)
ERROR ;error trap
"RTN","HLOCLNT",68,0)
ZB3 ;
"RTN","HLOCLNT",69,0)
 ;
"RTN","HLOCLNT",70,0)
 S $ETRAP="Q:$QUIT """" Q"
"RTN","HLOCLNT",71,0)
 ;
"RTN","HLOCLNT",72,0)
 D END
"RTN","HLOCLNT",73,0)
 D LINKDOWN(.HLCSTATE)
"RTN","HLOCLNT",74,0)
 ;
"RTN","HLOCLNT",75,0)
 ;return to the Process Manager error trap
"RTN","HLOCLNT",76,0)
 D UNWIND^%ZTER
"RTN","HLOCLNT",77,0)
 Q:$QUIT "" Q
"RTN","HLOCLNT",78,0)
 ;
"RTN","HLOCLNT",79,0)
DOWORK(QUEUE) ;sends the messages on the queue
"RTN","HLOCLNT",80,0)
ZB0 ;
"RTN","HLOCLNT",81,0)
 N $ETRAP,$ESTACK S $ETRAP="G ERROR^HLOCLNT"
"RTN","HLOCLNT",82,0)
 N MSGIEN,DEQUE,SUCCESS,MSGCOUNT,MAXIMUM
"RTN","HLOCLNT",83,0)
 S DEQUE=0
"RTN","HLOCLNT",84,0)
 S SUCCESS=1
"RTN","HLOCLNT",85,0)
 ;
"RTN","HLOCLNT",86,0)
 I '$$CNNCTD(QUEUE("LINK")),'$$CONNECT^HLOCLNT1($P(QUEUE("LINK"),":"),$P(QUEUE("LINK"),":",2),30,.HLCSTATE) Q
"RTN","HLOCLNT",87,0)
 S (MSGCOUNT,MSGIEN)=0
"RTN","HLOCLNT",88,0)
 S MAXIMUM=$$GETPRTY^HLOQUE(QUEUE("QUEUE"),QUEUE("LINK"))*2
"RTN","HLOCLNT",89,0)
 F  S MSGIEN=$O(^HLB("QUEUE","OUT",QUEUE("LINK"),QUEUE("QUEUE"),MSGIEN)) D  Q:'SUCCESS  Q:MSGCOUNT>MAXIMUM  Q:$$STOPPED^HLOQUE("OUT",QUEUE("QUEUE"))  Q:$$IFSHUT^HLOTLNK($P(QUEUE("LINK"),":"))
"RTN","HLOCLNT",90,0)
 .S:'MSGIEN SUCCESS=0
"RTN","HLOCLNT",91,0)
ZB4 .;
"RTN","HLOCLNT",92,0)
 .Q:'SUCCESS
"RTN","HLOCLNT",93,0)
 .N UPDATE
"RTN","HLOCLNT",94,0)
 .S ^HLB(MSGIEN,"TRIES")=$G(^HLB(MSGIEN,"TRIES"))+1
"RTN","HLOCLNT",95,0)
 .S SUCCESS=0
"RTN","HLOCLNT",96,0)
 .S:$$TRANSMIT(.HLCSTATE,MSGIEN,.UPDATE) SUCCESS=1
"RTN","HLOCLNT",97,0)
 .Q:('SUCCESS)!('$D(UPDATE))
"RTN","HLOCLNT",98,0)
 .D DEQUE(.UPDATE)
"RTN","HLOCLNT",99,0)
 .S MSGCOUNT=MSGCOUNT+1
"RTN","HLOCLNT",100,0)
 .D:HLCSTATE("COUNTS")>4 SAVECNTS^HLOSTAT(.HLCSTATE)
"RTN","HLOCLNT",101,0)
 .;
"RTN","HLOCLNT",102,0)
 .;if the queue was on the down list, and not since shutdown, mark it as up, since a message has been successfully transmitted across it
"RTN","HLOCLNT",103,0)
 .I $G(QUEUE("DOWN"))!$$FAILING(QUEUE("LINK")),'$$IFSHUT^HLOTLNK(QUEUE("LINK")) S QUEUE("DOWN")=0,^HLB("QUEUE","OUT",QUEUE("LINK"))="" K ^HLTMP("FAILING LINKS",QUEUE("LINK"))
"RTN","HLOCLNT",104,0)
 ;
"RTN","HLOCLNT",105,0)
ZB5 ;
"RTN","HLOCLNT",106,0)
END D DEQUE()
"RTN","HLOCLNT",107,0)
 D SAVECNTS^HLOSTAT(.HLCSTATE)
"RTN","HLOCLNT",108,0)
 Q
"RTN","HLOCLNT",109,0)
CNNCTD(LINK) ;
"RTN","HLOCLNT",110,0)
 ;Connected to LINK?  HLCSTATE must be defined, LINK=<link name>:<port>
"RTN","HLOCLNT",111,0)
 ;
"RTN","HLOCLNT",112,0)
 I ($G(HLCSTATE("LINK","NAME"))=$P(LINK,":")),($G(HLCSTATE("LINK","PORT"))=$P(LINK,":",2)),$G(HLCSTATE("CONNECTED")) Q 1
"RTN","HLOCLNT",113,0)
 Q 0
"RTN","HLOCLNT",114,0)
 ;
"RTN","HLOCLNT",115,0)
DEQUE(UPDATE) ;
"RTN","HLOCLNT",116,0)
 ;**P143 START CJM
"RTN","HLOCLNT",117,0)
ZB25 ;
"RTN","HLOCLNT",118,0)
 ;**P143 END CJM
"RTN","HLOCLNT",119,0)
 I $D(UPDATE) S DEQUE=DEQUE+1,DEQUE(+UPDATE)=$P(UPDATE,"^",2,99) S:$G(UPDATE("MSA"))]"" DEQUE(+UPDATE,"MSA")=UPDATE("MSA") S:$G(UPDATE("ACTION"))]"" DEQUE(+UPDATE,"ACTION")=UPDATE("ACTION")
"RTN","HLOCLNT",120,0)
 I '$D(UPDATE)!(DEQUE>15) D
"RTN","HLOCLNT",121,0)
 .N MSGIEN S MSGIEN=0
"RTN","HLOCLNT",122,0)
 .F  S MSGIEN=$O(DEQUE(MSGIEN)) Q:'MSGIEN  D
"RTN","HLOCLNT",123,0)
 ..N NODE,TIME
"RTN","HLOCLNT",124,0)
 ..D DEQUE^HLOQUE(QUEUE("LINK"),QUEUE("QUEUE"),"OUT",MSGIEN)
"RTN","HLOCLNT",125,0)
 ..S TIME=$P(DEQUE(MSGIEN),"^")
"RTN","HLOCLNT",126,0)
 ..Q:'TIME
"RTN","HLOCLNT",127,0)
 ..S NODE=QUEUE("LINK")_"^"_QUEUE("QUEUE")_"^"_$P(DEQUE(MSGIEN),"^",2,99)
"RTN","HLOCLNT",128,0)
 ..S ^HLTMP("CLIENT UPDATES",$J,TIME,MSGIEN)=NODE
"RTN","HLOCLNT",129,0)
 ..S:$G(DEQUE(MSGIEN,"MSA"))]"" ^HLTMP("CLIENT UPDATES",$J,TIME,MSGIEN,"MSA")=DEQUE(MSGIEN,"MSA")
"RTN","HLOCLNT",130,0)
 ..S:$G(DEQUE(MSGIEN,"ACTION"))]"" ^HLTMP("CLIENT UPDATES",$J,TIME,MSGIEN,"ACTION")=DEQUE(MSGIEN,"ACTION")
"RTN","HLOCLNT",131,0)
 .K DEQUE S DEQUE=0
"RTN","HLOCLNT",132,0)
 Q
"RTN","HLOCLNT",133,0)
 ;
"RTN","HLOCLNT",134,0)
TRANSMIT(HLCSTATE,MSGIEN,UPDATE) ;
"RTN","HLOCLNT",135,0)
 ;Transmits a single message and if a commit ack was requested reads it.  Updates file 778 with the result.  Queues for the infiler the application accept action if one was requested.
"RTN","HLOCLNT",136,0)
 ;Input:
"RTN","HLOCLNT",137,0)
 ;   HLCSTATE (pass by reference)
"RTN","HLOCLNT",138,0)
 ;   MSGIEN - ien, file 778, of message to be transmitted
"RTN","HLOCLNT",139,0)
 ;Output:
"RTN","HLOCLNT",140,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOCLNT",141,0)
 ;  UPDATE - (pass by reference) to contain updates needed for message
"RTN","HLOCLNT",142,0)
 ;
"RTN","HLOCLNT",143,0)
 N HLMSTATE,MSA,HDR,SUCCESS
"RTN","HLOCLNT",144,0)
 ;
"RTN","HLOCLNT",145,0)
 S SUCCESS=0
"RTN","HLOCLNT",146,0)
 S HLCSTATE("ATTEMPT")=0
"RTN","HLOCLNT",147,0)
 ;
"RTN","HLOCLNT",148,0)
 ;start saving updates needed after the message is transmitted
"RTN","HLOCLNT",149,0)
 S UPDATE=MSGIEN
"RTN","HLOCLNT",150,0)
 Q:'$$GETMSG^HLOCLNT2(MSGIEN,.HLMSTATE) 1  ;returns 1 so the message will be removed from the queue
"RTN","HLOCLNT",151,0)
 I HLMSTATE("DT/TM"),HLMSTATE("STATUS","ACCEPTED")!(HLMSTATE("HDR","ACCEPT ACK TYPE")="NE") D  Q 1  ;the message was already transmitted
"RTN","HLOCLNT",152,0)
ZB20 .;**P143 START CJM
"RTN","HLOCLNT",153,0)
 .;**P143 END CJM
"RTN","HLOCLNT",154,0)
 ;
"RTN","HLOCLNT",155,0)
 ;**P143 START CJM
"RTN","HLOCLNT",156,0)
 I HLMSTATE("ACK BY")]"",HLMSTATE("STATUS")]"",$G(^HLB(MSGIEN,"TRIES"))>1 Q 1  ;The app ack was already returned, so don't keep transmitting
"RTN","HLOCLNT",157,0)
 ;**P143 END CJM
"RTN","HLOCLNT",158,0)
 ;
"RTN","HLOCLNT",159,0)
 S UPDATE=UPDATE_"^"_$$NOW^XLFDT
"RTN","HLOCLNT",160,0)
RETRY D
"RTN","HLOCLNT",161,0)
 .S HLCSTATE("ATTEMPT")=HLCSTATE("ATTEMPT")+1
"RTN","HLOCLNT",162,0)
 .I 'HLCSTATE("CONNECTED") D OPEN^HLOT(.HLCSTATE) Q:'HLCSTATE("CONNECTED")
"RTN","HLOCLNT",163,0)
 .;
"RTN","HLOCLNT",164,0)
 .;try to send the message
"RTN","HLOCLNT",165,0)
 .;
"RTN","HLOCLNT",166,0)
 .;
"RTN","HLOCLNT",167,0)
 .Q:'$$WRITEMSG^HLOCLNT1(.HLCSTATE,.HLMSTATE)
"RTN","HLOCLNT",168,0)
 .;does the message need an accept ack?
"RTN","HLOCLNT",169,0)
 .I HLMSTATE("HDR","ACCEPT ACK TYPE")="AL" D
"RTN","HLOCLNT",170,0)
 ..N FS
"RTN","HLOCLNT",171,0)
 ..Q:'$$READACK^HLOCLNT1(.HLCSTATE,.HDR,.MSA)
"RTN","HLOCLNT",172,0)
 ..;does the MSA refer to the correct control id?
"RTN","HLOCLNT",173,0)
 ..S FS=$E(HDR(1),4)
"RTN","HLOCLNT",174,0)
 ..I $P(MSA,FS,3)'=HLMSTATE("ID") D  Q
"RTN","HLOCLNT",175,0)
ZB21 ...;**P143 START CJM
"RTN","HLOCLNT",176,0)
 ...;**P43 END CJM
"RTN","HLOCLNT",177,0)
 ..N ACKID,ACKCODE
"RTN","HLOCLNT",178,0)
 ..S ACKCODE=$P(MSA,FS,2)
"RTN","HLOCLNT",179,0)
 ..S ACKID=$S($E(HDR(1),1,3)="MSH":$P(HDR(2),FS,5),1:$P(HDR(2),FS,6))
"RTN","HLOCLNT",180,0)
 ..S $P(UPDATE,"^",5)=1
"RTN","HLOCLNT",181,0)
 ..S UPDATE("MSA")=ACKID_"^"_MSA
"RTN","HLOCLNT",182,0)
 ..I '(ACKCODE="CA") D
"RTN","HLOCLNT",183,0)
 ...S $P(UPDATE,"^",3)="ER",$P(UPDATE,"^",4)=2
"RTN","HLOCLNT",184,0)
ZB22 ...;**P143 START CJM
"RTN","HLOCLNT",185,0)
 ...;**P143 END CJM
"RTN","HLOCLNT",186,0)
 ..I ACKCODE="CA",HLMSTATE("HDR","APP ACK TYPE")="NE" S $P(UPDATE,"^",3)="SU",$P(UPDATE,"^",4)=$S(HLMSTATE("BATCH"):"2",1:1)
"RTN","HLOCLNT",187,0)
 ..I ($P(UPDATE,"^",3)="ER") S $P(UPDATE,"^",6)=$P(HLMSTATE("HDR",1),FS,5) ;errors need the application for xref
"RTN","HLOCLNT",188,0)
 ..;
"RTN","HLOCLNT",189,0)
 ..;if it's from a sequence queue, timestamp the queue
"RTN","HLOCLNT",190,0)
 ..I $L($G(HLMSTATE("STATUS","SEQUENCE QUEUE"))) D
"RTN","HLOCLNT",191,0)
 ...L +^HLB("QUEUE","SEQUENCE",HLMSTATE("STATUS","SEQUENCE QUEUE")):200
"RTN","HLOCLNT",192,0)
 ...I $P($G(^HLB("QUEUE","SEQUENCE",HLMSTATE("STATUS","SEQUENCE QUEUE"))),"^")'=MSGIEN L -^HLB("QUEUE","SEQUENCE",HLMSTATE("STATUS","SEQUENCE QUEUE")) Q
"RTN","HLOCLNT",193,0)
 ...I ACKCODE="CA" D
"RTN","HLOCLNT",194,0)
 ....S $P(^HLB("QUEUE","SEQUENCE",HLMSTATE("STATUS","SEQUENCE QUEUE")),"^",2)=$$FMADD^XLFDT($P(UPDATE,"^",2),,,$$TIMEOUT^HLOAPP($$GETSAP^HLOCLNT2(MSGIEN))) L -^HLB("QUEUE","SEQUENCE",HLMSTATE("STATUS","SEQUENCE QUEUE"))
"RTN","HLOCLNT",195,0)
ZB23 ....;**P143 START CJM
"RTN","HLOCLNT",196,0)
 ....;**P143 END CJM
"RTN","HLOCLNT",197,0)
 ...;if the message wasn't accepted, need to notify without waiting
"RTN","HLOCLNT",198,0)
 ...S $P(^HLB("QUEUE","SEQUENCE",HLMSTATE("STATUS","SEQUENCE QUEUE")),"^",2)=$P(UPDATE,"^",2)
"RTN","HLOCLNT",199,0)
 ...L -^HLB("QUEUE","SEQUENCE",HLMSTATE("STATUS","SEQUENCE QUEUE"))
"RTN","HLOCLNT",200,0)
 ..;
"RTN","HLOCLNT",201,0)
 ..;does the app need notification of accept ack?
"RTN","HLOCLNT",202,0)
 ..S UPDATE("ACTION")=HLMSTATE("ACCEPT ACK RESPONSE")
"RTN","HLOCLNT",203,0)
 ..;
"RTN","HLOCLNT",204,0)
 ..S SUCCESS=1
"RTN","HLOCLNT",205,0)
 .E  D  ;accept ack wasn't requested
"RTN","HLOCLNT",206,0)
 ..S SUCCESS=1
"RTN","HLOCLNT",207,0)
 ..I HLMSTATE("HDR","APP ACK TYPE")="NE" S $P(UPDATE,"^",3)="SU",$P(UPDATE,"^",4)=$S(HLMSTATE("BATCH"):2,1:1)
"RTN","HLOCLNT",208,0)
 ;
"RTN","HLOCLNT",209,0)
 I 'SUCCESS,'HLCSTATE("CONNECTED"),(HLCSTATE("ATTEMPT")<2) G RETRY
"RTN","HLOCLNT",210,0)
 I SUCCESS D
"RTN","HLOCLNT",211,0)
 .D COUNT^HLOSTAT(.HLCSTATE,HLMSTATE("HDR","RECEIVING APPLICATION"),HLMSTATE("HDR","SENDING APPLICATION"),$S(HLMSTATE("BATCH"):"BATCH",1:HLMSTATE("HDR","MESSAGE TYPE")_"~"_HLMSTATE("HDR","EVENT")))
"RTN","HLOCLNT",212,0)
 .;if this is an ack to a message need to purge the original message, so store its ien with the purge date
"RTN","HLOCLNT",213,0)
 .S:$G(HLMSTATE("ACK TO IEN")) $P(UPDATE,"^",4)=$P(UPDATE,"^",4)_"-"_HLMSTATE("ACK TO IEN")
"RTN","HLOCLNT",214,0)
 I ('HLCSTATE("CONNECTED"))!('SUCCESS) D LINKDOWN(.HLCSTATE)
"RTN","HLOCLNT",215,0)
 Q SUCCESS
"RTN","HLOP147")
0^^B890981^n/a
"RTN","HLOP147",1,0)
HLOP147 ;ALB/CJM-Pre & Post install ;01/12/2010
"RTN","HLOP147",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**147**;Oct 13, 1995;Build 15
"RTN","HLOP147",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOP147",4,0)
 ;
"RTN","HLOP147",5,0)
PRE ;
"RTN","HLOP147",6,0)
 ;
"RTN","HLOP147",7,0)
 N WORK
"RTN","HLOP147",8,0)
 L +^HLTMP("PROCESS MANAGER"):0
"RTN","HLOP147",9,0)
 I '$T D ABORT Q
"RTN","HLOP147",10,0)
 D CHKDEAD^HLOPROC1(.WORK)
"RTN","HLOP147",11,0)
 I $O(^HLTMP("HL7 RUNNING PROCESSES",""))'="" D ABORT
"RTN","HLOP147",12,0)
 L -^HLTMP("PROCESS MANAGER")
"RTN","HLOP147",13,0)
 Q
"RTN","HLOP147",14,0)
ABORT ;
"RTN","HLOP147",15,0)
 S XPDABORT=1
"RTN","HLOP147",16,0)
 D BMES^XPDUTL("HLO processes are still running and prevent this installation from completing")
"RTN","HLOP147",17,0)
 Q
"RTN","HLOPING")
0^7^B23547701^n/a
"RTN","HLOPING",1,0)
HLOPING ;alb/cjm HLO PING UTILITY - 10/4/94 1pm ;01/27/2010
"RTN","HLOPING",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**147**;Oct 13, 1995;Build 15
"RTN","HLOPING",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOPING",4,0)
 ;
"RTN","HLOPING",5,0)
 ;
"RTN","HLOPING",6,0)
PING ;
"RTN","HLOPING",7,0)
 I '$G(DUZ) W !,"Your DUZ must be set!" Q
"RTN","HLOPING",8,0)
 N LINK,CONF,HLCSTATE,PORT,LINK,HLODONE
"RTN","HLOPING",9,0)
 S HLODONE=0
"RTN","HLOPING",10,0)
 I $P($$VERSION^%ZOSV(1),"/",1)'["Cache" D  Q
"RTN","HLOPING",11,0)
 .W !!,"   Sorry, this tool can only be used under Cache",!!
"RTN","HLOPING",12,0)
 W !,"What HL Logical Link do you want to test?"
"RTN","HLOPING",13,0)
 S LINK=$$ASKLINK^HLOUSR
"RTN","HLOPING",14,0)
 Q:LINK=""
"RTN","HLOPING",15,0)
 S PORT=$$ASKPORT(LINK)
"RTN","HLOPING",16,0)
 Q:'PORT
"RTN","HLOPING",17,0)
 L +^HLB("QUEUE","OUT",LINK_":"_PORT,"HLOPING"_$J):1
"RTN","HLOPING",18,0)
 D STOPQUE^HLOQUE("OUT","HLOPING"_$J)
"RTN","HLOPING",19,0)
 D BREAKS
"RTN","HLOPING",20,0)
 D CHECKAPP
"RTN","HLOPING",21,0)
 I $$ADDMSG(LINK) D
"RTN","HLOPING",22,0)
 .ZB /INTERRUPT:NORMAL ;disable CTRL-C breaks
"RTN","HLOPING",23,0)
 .S WORK("QUEUE")="HLOPING"_$J,WORK("LINK")=LINK_":"_PORT
"RTN","HLOPING",24,0)
 .D DOWORK^HLOCLNT(.WORK)
"RTN","HLOPING",25,0)
 .D:$G(HLCSTATE("CONNECTED")) CLOSE^HLOT(.HLCSTATE)
"RTN","HLOPING",26,0)
 .;
"RTN","HLOPING",27,0)
 .U $PRINCIPAL
"RTN","HLOPING",28,0)
 D PURGE(LINK_":"_PORT)
"RTN","HLOPING",29,0)
 ZB /CLEAR
"RTN","HLOPING",30,0)
 L -^HLB("QUEUE","OUT",LINK_":"_PORT,"HLOPING"_$J)
"RTN","HLOPING",31,0)
 D STARTQUE^HLOQUE("OUT","HLOPING"_$J)
"RTN","HLOPING",32,0)
 Q
"RTN","HLOPING",33,0)
 ;
"RTN","HLOPING",34,0)
ASKPORT(LINK) ;
"RTN","HLOPING",35,0)
 N IEN,NODE,HLOPORT,HL7PORT,DIR,X,Y
"RTN","HLOPING",36,0)
 S IEN=$O(^HLCS(870,"B",LINK,0))
"RTN","HLOPING",37,0)
 Q:'IEN ""
"RTN","HLOPING",38,0)
 S NODE=$G(^HLCS(870,IEN,400))
"RTN","HLOPING",39,0)
 S HLOPORT=$P(NODE,"^",8)
"RTN","HLOPING",40,0)
 S:'HLOPORT HLOPORT=$S($P($G(^HLD(779.1,1,0)),"^",3)="P":5001,1:5026)
"RTN","HLOPING",41,0)
 S HL7PORT=$P(NODE,"^",2)
"RTN","HLOPING",42,0)
 S:'HL7PORT HL7PORT=$S($P($G(^HLD(779.1,1,0)),"^",3)="P":5000,1:5025)
"RTN","HLOPING",43,0)
 W !,"Do you want to PING the port used by HLO or the one used by HL7 1.6?"
"RTN","HLOPING",44,0)
 S DIR(0)="S^1:HLO     --> Port #"_HLOPORT_";2:HL7 1.6 --> Port #"_HL7PORT
"RTN","HLOPING",45,0)
 S DIR("B")=1
"RTN","HLOPING",46,0)
 D ^DIR
"RTN","HLOPING",47,0)
 Q:'X ""
"RTN","HLOPING",48,0)
 Q:$D(DUOUT) ""
"RTN","HLOPING",49,0)
 Q:X=1 HLOPORT
"RTN","HLOPING",50,0)
 Q:X=2 HL7PORT
"RTN","HLOPING",51,0)
 Q ""
"RTN","HLOPING",52,0)
ADDMSG(LINK) ;
"RTN","HLOPING",53,0)
 N PARMS,MSG,SEG,ERROR
"RTN","HLOPING",54,0)
 S PARMS("MESSAGE TYPE")="ZZZ"
"RTN","HLOPING",55,0)
 S PARMS("EVENT")="ZZZ"
"RTN","HLOPING",56,0)
 I '$$NEWMSG^HLOAPI(.PARMS,.MSG,.ERROR) W !,"ERROR",ERROR Q 0
"RTN","HLOPING",57,0)
 D SET^HLOAPI(.SEG,"NTE",0)
"RTN","HLOPING",58,0)
 D SET^HLOAPI(.SEG,"This is a PING message to test connectivity.",1)
"RTN","HLOPING",59,0)
 I '$$ADDSEG^HLOAPI(.MSG,.SEG,.ERROR) W !,"ERROR",ERROR Q 0
"RTN","HLOPING",60,0)
 S PARMS("SENDING APPLICATION")="HLO PING CLIENT",WHOTO("RECEIVING APPLICATION")="HLO PING SERVER",WHOTO("FACILITY LINK NAME")=LINK
"RTN","HLOPING",61,0)
 S PARMS("ACCEPT ACK TYPE")="AL"
"RTN","HLOPING",62,0)
 S PARMS("APP ACK TYPE")="NE"
"RTN","HLOPING",63,0)
 S PARMS("QUEUE")="HLOPING"_$J
"RTN","HLOPING",64,0)
 I '$$SENDONE^HLOAPI1(.MSG,.PARMS,.WHOTO,.ERROR) W !,"There is a problem in the setup!",!,ERROR Q 0
"RTN","HLOPING",65,0)
 Q 1
"RTN","HLOPING",66,0)
 ;
"RTN","HLOPING",67,0)
PURGE(LINK) ;
"RTN","HLOPING",68,0)
 N IEN
"RTN","HLOPING",69,0)
 S IEN=0
"RTN","HLOPING",70,0)
 F  S IEN=$O(^HLB("QUEUE","OUT",LINK,"HLOPING"_$J,IEN)) Q:'IEN  D DEQUE^HLOQUE(LINK,"HLOPING"_$J,"OUT",IEN),SETPURGE^HLOAPI3(IEN)
"RTN","HLOPING",71,0)
 Q
"RTN","HLOPING",72,0)
 ;
"RTN","HLOPING",73,0)
BREAKS ;
"RTN","HLOPING",74,0)
 ZB /CLEAR
"RTN","HLOPING",75,0)
 ;
"RTN","HLOPING",76,0)
 ZB SEND^HLOAPI1:"N":1:"S HLMSTATE(""STATUS"",""PORT"")="_PORT
"RTN","HLOPING",77,0)
 ZB CHECKWHO^HLOASUB1:"N":1:"S WHO(""PORT"")="_PORT
"RTN","HLOPING",78,0)
 ZB ZB25^HLOASUB1:"N":1:"D ZB25^HLOPING"
"RTN","HLOPING",79,0)
 ;set break in $$STOPPED^HLOQUE to circumvent shutdown of the queue
"RTN","HLOPING",80,0)
 ZB ZB0^HLOQUE:"N":1:"S RET=0"
"RTN","HLOPING",81,0)
 ;set break in $$IFSHUT^HLOTLNK to circumvent shutdown of the link
"RTN","HLOPING",82,0)
 ZB ZB0^HLOTLNK:"N":1:"S RET=0"
"RTN","HLOPING",83,0)
 ;set break at ZB1 in client ($$CONNECT)
"RTN","HLOPING",84,0)
 ZB ZB1^HLOCLNT1:"N":1:"D WRITE^HLOPING(""Trying to connect..."")"
"RTN","HLOPING",85,0)
 ;set break at ZB2 in client (end of $$CONNECT)
"RTN","HLOPING",86,0)
 ZB ZB2^HLOCLNT1:"N":1:"D ZB2^HLOPING"
"RTN","HLOPING",87,0)
 ;
"RTN","HLOPING",88,0)
 ;set break at ZB6 in client (start of $$TRANSMIT^HLOCLNT1)
"RTN","HLOPING",89,0)
 ZB ZB6^HLOCLNT1:"N":1:"D WRITE^HLOPING(""Sending PING ..."")"
"RTN","HLOPING",90,0)
 ;set break at ZB7 in client (end of $$TRANSMIT^HLOCLNT1)
"RTN","HLOPING",91,0)
 ZB ZB7^HLOCLNT1:"N":1:"D WRITE^HLOPING(""PING sent!"")"
"RTN","HLOPING",92,0)
 ;set break at ZB8 in client (start of $$READACK^HLOCLNT1)
"RTN","HLOPING",93,0)
 ZB ZB8^HLOCLNT1:"N":1:"D WRITE^HLOPING(""Reading acknowledgment...."")"
"RTN","HLOPING",94,0)
 ;set break at ZB9 in client (end of $$READACK^HLOCLNT1)
"RTN","HLOPING",95,0)
 ZB ZB9^HLOCLNT1:"N":1:"D ZB9^HLOPING"
"RTN","HLOPING",96,0)
 ;
"RTN","HLOPING",97,0)
 ;set break at ZB4 in client (FOR loop on the outgoing queue)
"RTN","HLOPING",98,0)
 ZB ZB4^HLOCLNT:"N":1:"S SUCCESS=0 I 'HLODONE S (SUCCESS,HLODONE)=1"
"RTN","HLOPING",99,0)
 ;
"RTN","HLOPING",100,0)
 ;set status to SU so that the PING doesn't appear on the error report
"RTN","HLOPING",101,0)
 ZB ZB22^HLOCLNT:"N":1:"S $P(UPDATE,""^"",3)=""SU"",$P(UPDATE,""^"",4)=1"
"RTN","HLOPING",102,0)
 ;
"RTN","HLOPING",103,0)
 ZB ZB24^HLOCLNT1:"N":1:"D ZB24^HLOPING"
"RTN","HLOPING",104,0)
 ;set break at ZB3 in client (ERROR TRAP)
"RTN","HLOPING",105,0)
 ZB ZB3^HLOCLNT:"N":1:"D ZB3^HLOPING"
"RTN","HLOPING",106,0)
 Q
"RTN","HLOPING",107,0)
 ;
"RTN","HLOPING",108,0)
CHECKAPP ;
"RTN","HLOPING",109,0)
 I '$O(^HLD(779.2,"C","HLO PING CLIENT",0)) D
"RTN","HLOPING",110,0)
 .N DATA,ERROR
"RTN","HLOPING",111,0)
 .S DATA(.01)="HLO PING CLIENT"
"RTN","HLOPING",112,0)
 .D ADD^HLOASUB1(779.2,,.DATA)
"RTN","HLOPING",113,0)
 Q
"RTN","HLOPING",114,0)
WRITE(MSG) ;
"RTN","HLOPING",115,0)
 N OLD
"RTN","HLOPING",116,0)
 S OLD=$IO
"RTN","HLOPING",117,0)
 U $PRINCIPAL
"RTN","HLOPING",118,0)
 W !,MSG
"RTN","HLOPING",119,0)
 U OLD
"RTN","HLOPING",120,0)
 Q
"RTN","HLOPING",121,0)
ZB2 ;
"RTN","HLOPING",122,0)
 D WRITE($S('HLCSTATE("CONNECTED"):"Unable to Connect!",1:"Connected!"))
"RTN","HLOPING",123,0)
 Q
"RTN","HLOPING",124,0)
ZB3 ;
"RTN","HLOPING",125,0)
 N CON,MSG
"RTN","HLOPING",126,0)
 S CON=($ZA\8192#2)
"RTN","HLOPING",127,0)
 S MSG="Error encountered, $ECODE="_$ECODE
"RTN","HLOPING",128,0)
 D WRITE(MSG)
"RTN","HLOPING",129,0)
 S MSG=$S(CON:"           TCP connection still active",1:"          TCP connection was dropped")
"RTN","HLOPING",130,0)
 D WRITE(MSG)
"RTN","HLOPING",131,0)
 D ^%ZTER
"RTN","HLOPING",132,0)
 Q
"RTN","HLOPING",133,0)
ZB9 ;
"RTN","HLOPING",134,0)
 I $G(SUCCESS) D
"RTN","HLOPING",135,0)
 .D WRITE("Acknowledgment received!")
"RTN","HLOPING",136,0)
 E  D
"RTN","HLOPING",137,0)
 .D WRITE("Acknowledgment NOT returned!")
"RTN","HLOPING",138,0)
 Q
"RTN","HLOPING",139,0)
ZB24 ;
"RTN","HLOPING",140,0)
 S HLCSTATE("LINK","SHUTDOWN")=0
"RTN","HLOPING",141,0)
 Q
"RTN","HLOPING",142,0)
ZB25 ;
"RTN","HLOPING",143,0)
 I '$L(PARMS("RECEIVING FACILITY",2)),'PARMS("RECEIVING FACILITY",1) S PARMS("RECEIVING FACILITY",2)="REMOTE FACILITY TO PING"
"RTN","HLOPING",144,0)
 Q
"RTN","HLOPROC")
0^21^B28480069^B26547261
"RTN","HLOPROC",1,0)
HLOPROC ;ALB/CJM- Generic HL7 Process - 10/4/94 1pm ;08/23/2010
"RTN","HLOPROC",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,134,146,147**;Oct 13, 1995;Build 15
"RTN","HLOPROC",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOPROC",4,0)
 ;
"RTN","HLOPROC",5,0)
PROCESS ;queued entry point
"RTN","HLOPROC",6,0)
 ;
"RTN","HLOPROC",7,0)
 ;insure just one process manager
"RTN","HLOPROC",8,0)
 I PROCNAME="PROCESS MANAGER" N RUNNING L +^HLTMP(PROCNAME):1 S RUNNING='$T D  Q:RUNNING
"RTN","HLOPROC",9,0)
 .I 'RUNNING D
"RTN","HLOPROC",10,0)
 ..D SETNM^%ZOSV($E("HLOmgr:"_$J,1,17))
"RTN","HLOPROC",11,0)
 .E  D
"RTN","HLOPROC",12,0)
 ..L +HL7("COUNTING PROCESSES"):20
"RTN","HLOPROC",13,0)
 ..K:$D(ZTSK) ^HLTMP("HL7 QUEUED PROCESSES",ZTSK)
"RTN","HLOPROC",14,0)
 ..S ^HLC("HL7 PROCESS COUNTS","RUNNING","PROCESS MANAGER")=1
"RTN","HLOPROC",15,0)
 ..S ^HLC("HL7 PROCESS COUNTS","QUEUED","PROCESS MANAGER")=0
"RTN","HLOPROC",16,0)
 ..L -HL7("COUNTING PROCESSES")
"RTN","HLOPROC",17,0)
 ..S ZTREQ="@"
"RTN","HLOPROC",18,0)
 ;
"RTN","HLOPROC",19,0)
 ;invoke the framework process
"RTN","HLOPROC",20,0)
 D HL7PROC(PROCNAME)
"RTN","HLOPROC",21,0)
 ;
"RTN","HLOPROC",22,0)
 I PROCNAME="PROCESS MANAGER" L -^HLTMP(PROCNAME)
"RTN","HLOPROC",23,0)
 S ZTREQ="@"
"RTN","HLOPROC",24,0)
 Q
"RTN","HLOPROC",25,0)
 ;
"RTN","HLOPROC",26,0)
HL7PROC(PROCNAME) ;
"RTN","HLOPROC",27,0)
 ;This is the generic HL7 process used by all processes started under the HL7 Process Manager
"RTN","HLOPROC",28,0)
 ;Input:
"RTN","HLOPROC",29,0)
 ;  PROCNAME - the name of a process found in the HL7 Process Registry
"RTN","HLOPROC",30,0)
 ;  OUTPUT - none
"RTN","HLOPROC",31,0)
 ;
"RTN","HLOPROC",32,0)
 N PROCESS,HL7STOP,WORK
"RTN","HLOPROC",33,0)
 ;
"RTN","HLOPROC",34,0)
 S ^HL7TMP("HL7 PROCESS NAME",$J)=PROCNAME
"RTN","HLOPROC",35,0)
 ;
"RTN","HLOPROC",36,0)
 L +HL7("COUNTING PROCESSES"):20
"RTN","HLOPROC",37,0)
 I $D(ZTQUEUED) D
"RTN","HLOPROC",38,0)
 .K:$D(ZTSK) ^HLTMP("HL7 QUEUED PROCESSES",ZTSK)
"RTN","HLOPROC",39,0)
 .I $$INC^HLOSITE($NA(^HLC("HL7 PROCESS COUNTS","QUEUED",PROCNAME)),-1)<0,$$INC^HLOSITE($NA(^HLC("HL7 PROCESS COUNTS","QUEUED",PROCNAME)))
"RTN","HLOPROC",40,0)
 L +^HLTMP("HL7 RUNNING PROCESSES",$J):0
"RTN","HLOPROC",41,0)
 I $$INC^HLOSITE($NA(^HLC("HL7 PROCESS COUNTS","RUNNING",PROCNAME)))
"RTN","HLOPROC",42,0)
 S ^HLTMP("HL7 RUNNING PROCESSES",$J)=$H_"^"_$G(ZTSK)_"^"_PROCNAME
"RTN","HLOPROC",43,0)
 L -HL7("COUNTING PROCESSES")
"RTN","HLOPROC",44,0)
 ;
"RTN","HLOPROC",45,0)
 ;
"RTN","HLOPROC",46,0)
 I $$GETPROC(PROCNAME,.PROCESS),'$$CHK4STOP(.PROCESS) D
"RTN","HLOPROC",47,0)
 .S $P(^HLD(779.3,PROCESS("IEN"),0),"^",6)=$$NOW^XLFDT
"RTN","HLOPROC",48,0)
 .;
"RTN","HLOPROC",49,0)
 .;should this task be made persistent?
"RTN","HLOPROC",50,0)
 .I PROCESS("PERSISTENT"),$G(ZTQUEUED),$$PSET^%ZTLOAD(ZTQUEUED)
"RTN","HLOPROC",51,0)
 .;
"RTN","HLOPROC",52,0)
 .S HL7STOP=0
"RTN","HLOPROC",53,0)
 .F  D  Q:HL7STOP
"RTN","HLOPROC",54,0)
 ..N $ETRAP,$ESTACK S $ETRAP="G ERROR^HLOPROC"
"RTN","HLOPROC",55,0)
 ..N HL7TRIES,GOTWORK
"RTN","HLOPROC",56,0)
 ..F HL7TRIES=1:1 D  Q:GOTWORK  Q:$G(HL7STOP)
"RTN","HLOPROC",57,0)
 ...S GOTWORK=$$GETWORK(.PROCESS,.WORK)
"RTN","HLOPROC",58,0)
 ...Q:GOTWORK
"RTN","HLOPROC",59,0)
 ...;since there is no work, don't want another process starting
"RTN","HLOPROC",60,0)
 ...S $P(^HLD(779.3,PROCESS("IEN"),0),"^",6)=$$NOW^XLFDT
"RTN","HLOPROC",61,0)
 ...H PROCESS("HANG")
"RTN","HLOPROC",62,0)
 ...S HL7STOP=$$CHK4STOP(.PROCESS,HL7TRIES)
"RTN","HLOPROC",63,0)
 ..Q:$G(HL7STOP)
"RTN","HLOPROC",64,0)
 ..I GOTWORK D DOWORK(.PROCESS,.WORK) S HL7TRIES=0
"RTN","HLOPROC",65,0)
 ..S:'$G(HL7STOP) HL7STOP=$$CHK4STOP(.PROCESS,.HL7TRIES)
"RTN","HLOPROC",66,0)
 ;
"RTN","HLOPROC",67,0)
 S $P(^HLD(779.3,PROCESS("IEN"),0),"^",6)=$$NOW^XLFDT
"RTN","HLOPROC",68,0)
 ;
"RTN","HLOPROC",69,0)
END ;
"RTN","HLOPROC",70,0)
 S HL7STOP=1
"RTN","HLOPROC",71,0)
 K ^HL7TMP("HL7 PROCESS NAME",$J)
"RTN","HLOPROC",72,0)
 L +HL7("COUNTING PROCESSES"):20
"RTN","HLOPROC",73,0)
 K ^HLTMP("HL7 RUNNING PROCESSES",$J)
"RTN","HLOPROC",74,0)
 I $$INC^HLOSITE($NA(^HLC("HL7 PROCESS COUNTS","RUNNING",PROCNAME)),-1)<0,$$INC^HLOSITE($NA(^HLC("HL7 PROCESS COUNTS","RUNNING",PROCNAME)),1)
"RTN","HLOPROC",75,0)
 L -^HLTMP("HL7 RUNNING PROCESSES",$J)
"RTN","HLOPROC",76,0)
 L -HL7("COUNTING PROCESSES")
"RTN","HLOPROC",77,0)
 K ^TMP("HL7 ERRORS",$J)
"RTN","HLOPROC",78,0)
 ;
"RTN","HLOPROC",79,0)
 Q
"RTN","HLOPROC",80,0)
 ;
"RTN","HLOPROC",81,0)
ERROR ;error trap
"RTN","HLOPROC",82,0)
 ;
"RTN","HLOPROC",83,0)
 S $ETRAP="Q:$QUIT """" Q"
"RTN","HLOPROC",84,0)
 ;
"RTN","HLOPROC",85,0)
 ;quit back to the Taskman error trap on these errors
"RTN","HLOPROC",86,0)
 I ($ECODE["TOOMANYFILES")!($ECODE["EDITED") D  Q:$QUIT "" Q
"RTN","HLOPROC",87,0)
 .S:'$D(PROCNAME) PROCNAME=$G(^HL7TMP("HL7 PROCESS NAME",$J))
"RTN","HLOPROC",88,0)
 .D END
"RTN","HLOPROC",89,0)
 .G UNWIND^%ZTER
"RTN","HLOPROC",90,0)
 ;
"RTN","HLOPROC",91,0)
 ;don't log READ/WRITE errors unless logging is turned on, but do resume
"RTN","HLOPROC",92,0)
 ;execution
"RTN","HLOPROC",93,0)
 I '$G(^HLTMP("LOG ALL ERRORS")),($ECODE["READ")!($ECODE["NOTOPEN")!($ECODE["DEVNOTOPN")!($ECODE["WRITE")!($ECODE["OPENERR") D  Q:$QUIT "" Q
"RTN","HLOPROC",94,0)
 .S $ECODE=""
"RTN","HLOPROC",95,0)
 ;
"RTN","HLOPROC",96,0)
 ;add to the process's count for the type of error
"RTN","HLOPROC",97,0)
 N HOUR
"RTN","HLOPROC",98,0)
 S HOUR=$E($$NOW^XLFDT,1,10)
"RTN","HLOPROC",99,0)
 S ^TMP("HL7 ERRORS",$J,HOUR,$P($ECODE,",",2))=$G(^TMP("HL7 ERRORS",$J,HOUR,$P($ECODE,",",2)))+1
"RTN","HLOPROC",100,0)
 ;
"RTN","HLOPROC",101,0)
 ;a lot of errors of the same type may indicate an endless loop, so quit
"RTN","HLOPROC",102,0)
 ;to Taskman error trap to be on the safe side.
"RTN","HLOPROC",103,0)
 I $G(^TMP("HL7 ERRORS",$J,HOUR,$P($ECODE,",",2)))>30 D  Q:$QUIT "" Q
"RTN","HLOPROC",104,0)
 .S:'$D(PROCNAME) PROCNAME=$G(^HL7TMP("HL7 PROCESS NAME",$J))
"RTN","HLOPROC",105,0)
 .D END
"RTN","HLOPROC",106,0)
 .G UNWIND^%ZTER
"RTN","HLOPROC",107,0)
 ;
"RTN","HLOPROC",108,0)
 ;can log error and continue processing
"RTN","HLOPROC",109,0)
 D ^%ZTER
"RTN","HLOPROC",110,0)
 S $ECODE=""
"RTN","HLOPROC",111,0)
 Q:$QUIT "" Q
"RTN","HLOPROC",112,0)
 ;
"RTN","HLOPROC",113,0)
GETPROC(PROCNAME,PROCESS) ;
"RTN","HLOPROC",114,0)
 ;using PROCNAME to find the entry in the HL7 Process Registry, returns the entry as a subscripted array in .PROCESS
"RTN","HLOPROC",115,0)
 ;
"RTN","HLOPROC",116,0)
 ;Output: Function returns 0 on failure, 1 on success
"RTN","HLOPROC",117,0)
 ;
"RTN","HLOPROC",118,0)
 N IEN,NODE
"RTN","HLOPROC",119,0)
 S IEN=$O(^HLD(779.3,"B",PROCNAME,0))
"RTN","HLOPROC",120,0)
 Q:'IEN 0
"RTN","HLOPROC",121,0)
 S PROCESS("NAME")=PROCNAME
"RTN","HLOPROC",122,0)
 S PROCESS("IEN")=IEN
"RTN","HLOPROC",123,0)
 S NODE=$G(^HLD(779.3,IEN,0))
"RTN","HLOPROC",124,0)
 S PROCESS("MINIMUM")=+$P(NODE,"^",3)
"RTN","HLOPROC",125,0)
 S PROCESS("MAXIMUM")=+$P(NODE,"^",4)
"RTN","HLOPROC",126,0)
 S PROCESS("HANG")=+$P(NODE,"^",7)
"RTN","HLOPROC",127,0)
 I 'PROCESS("HANG") S PROCESS("HANG")=1
"RTN","HLOPROC",128,0)
 S PROCESS("GET WORK")=$P(NODE,"^",8,9)
"RTN","HLOPROC",129,0)
 S PROCESS("DO WORK")=$P(NODE,"^",10,11)
"RTN","HLOPROC",130,0)
 S PROCESS("MAX TRIES")=$P(NODE,"^",12)
"RTN","HLOPROC",131,0)
 I 'PROCESS("MAX TRIES") S PROCESS("MAX TRIES")=999
"RTN","HLOPROC",132,0)
 S PROCESS("PERSISTENT")=+$P(NODE,"^",13)
"RTN","HLOPROC",133,0)
 S PROCESS("LINK")=$P(NODE,"^",14)
"RTN","HLOPROC",134,0)
 Q 1
"RTN","HLOPROC",135,0)
 ;
"RTN","HLOPROC",136,0)
GETWORK(PROCESS,WORK) ;
"RTN","HLOPROC",137,0)
 N RETURN,XECUTE
"RTN","HLOPROC",138,0)
 I PROCESS("LINK")]"" S WORK("LINK")=PROCESS("LINK")
"RTN","HLOPROC",139,0)
 S XECUTE="S RETURN=$$"_PROCESS("GET WORK")_"(.WORK)"
"RTN","HLOPROC",140,0)
 D
"RTN","HLOPROC",141,0)
 .N PROCESS
"RTN","HLOPROC",142,0)
 .X XECUTE
"RTN","HLOPROC",143,0)
 Q RETURN
"RTN","HLOPROC",144,0)
 ;
"RTN","HLOPROC",145,0)
DOWORK(PROCESS,WORK) ;
"RTN","HLOPROC",146,0)
 N XECUTE
"RTN","HLOPROC",147,0)
 M PARMS=WORK
"RTN","HLOPROC",148,0)
 S XECUTE="D "_PROCESS("DO WORK")_"(.WORK)"
"RTN","HLOPROC",149,0)
 D
"RTN","HLOPROC",150,0)
 .N PROCESS,HL7TRIES,PARMS,PROCNAME
"RTN","HLOPROC",151,0)
 .X XECUTE
"RTN","HLOPROC",152,0)
 M WORK=PARMS
"RTN","HLOPROC",153,0)
 Q
"RTN","HLOPROC",154,0)
 ;
"RTN","HLOPROC",155,0)
CHK4STOP(PROCESS,HL7TRIES) ;
"RTN","HLOPROC",156,0)
 ;Determines if the process should stop, returns 1 if yes, 0 if no
"RTN","HLOPROC",157,0)
 ;
"RTN","HLOPROC",158,0)
 Q:$$CHKSTOP 1
"RTN","HLOPROC",159,0)
 Q:'$P($G(^HLD(779.3,PROCESS("IEN"),0)),"^",2) 1
"RTN","HLOPROC",160,0)
 I $G(HL7TRIES)>(PROCESS("MAX TRIES")-1),PROCESS("MINIMUM")<$G(^HLC("HL7 PROCESS COUNTS","RUNNING",PROCESS("NAME"))) Q 1
"RTN","HLOPROC",161,0)
 Q:$G(^HLC("HL7 PROCESS COUNTS","RUNNING",PROCESS("NAME")))>PROCESS("MAXIMUM") 1
"RTN","HLOPROC",162,0)
 Q 0
"RTN","HLOPROC",163,0)
 ;
"RTN","HLOPROC",164,0)
CHKSTOP() ;has HL7 been requested to stop?
"RTN","HLOPROC",165,0)
 N RET
"RTN","HLOPROC",166,0)
 ;** P146 START CJM
"RTN","HLOPROC",167,0)
 ;Q '$P($G(^HLD(779.1,1,0)),"^",9)
"RTN","HLOPROC",168,0)
 S RET='$P($G(^HLD(779.1,1,0)),"^",9)
"RTN","HLOPROC",169,0)
ZB25 ;
"RTN","HLOPROC",170,0)
 Q RET
"RTN","HLOPROC",171,0)
 ;**P146 END CJM
"RTN","HLOPROC1")
0^22^B102064543^B91809391
"RTN","HLOPROC1",1,0)
HLOPROC1 ;ALB/CJM/OAK/PIJ- Process Manager - 10/4/94 1pm ;06/09/2010
"RTN","HLOPROC1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,138,139,147**;Oct 13, 1995;Build 15
"RTN","HLOPROC1",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOPROC1",4,0)
 ;
"RTN","HLOPROC1",5,0)
 ;
"RTN","HLOPROC1",6,0)
GETWORK(PROCESS) ;
"RTN","HLOPROC1",7,0)
 ;This is the GETWORK function for the process manager
"RTN","HLOPROC1",8,0)
 ;Finds a process that needs to be started
"RTN","HLOPROC1",9,0)
 ;
"RTN","HLOPROC1",10,0)
 N NAME,IEN,GOTWORK
"RTN","HLOPROC1",11,0)
 ;this is how  HL7 can be stopped via Taskman
"RTN","HLOPROC1",12,0)
 I $$S^%ZTLOAD D STOPHL7 Q 0
"RTN","HLOPROC1",13,0)
 S GOTWORK=0
"RTN","HLOPROC1",14,0)
 S IEN=+$G(PROCESS("IEN"))
"RTN","HLOPROC1",15,0)
 F  S IEN=$O(^HLD(779.3,"C",1,IEN)) Q:IEN=$G(PROCESS("IEN"))  I IEN D  Q:GOTWORK
"RTN","HLOPROC1",16,0)
 .N PROC,COUNT,QUEUED,RUNNING
"RTN","HLOPROC1",17,0)
 .Q:'$$GETPROC(IEN,.PROC)
"RTN","HLOPROC1",18,0)
 .Q:PROC("VMS SERVICE")
"RTN","HLOPROC1",19,0)
 .Q:PROC("NAME")="PROCESS MANAGER"
"RTN","HLOPROC1",20,0)
 .Q:'PROC("ACTIVE")
"RTN","HLOPROC1",21,0)
 .S PROCESS("COUNT")=1
"RTN","HLOPROC1",22,0)
 .S QUEUED=+$G(^HLC("HL7 PROCESS COUNTS","QUEUED",PROC("NAME")))
"RTN","HLOPROC1",23,0)
 .S:QUEUED<0 QUEUED=0
"RTN","HLOPROC1",24,0)
 .S RUNNING=+$G(^HLC("HL7 PROCESS COUNTS","RUNNING",PROC("NAME")))
"RTN","HLOPROC1",25,0)
 .S:RUNNING<0 RUNNING=0
"RTN","HLOPROC1",26,0)
 .S COUNT=QUEUED+RUNNING
"RTN","HLOPROC1",27,0)
 .I COUNT<PROC("MINIMUM") S GOTWORK=1,PROCESS("IEN")=IEN,PROCESS("NAME")=PROC("NAME"),PROCESS("COUNT")=(PROC("MINIMUM")-COUNT),PROCESS("NODE")=PROC("NODE") Q
"RTN","HLOPROC1",28,0)
 .I COUNT<PROC("MAXIMUM"),$$FMDIFF^XLFDT($$NOW^XLFDT,PROC("LAST DT/TM"),2)>PROC("WAIT SECONDS"),'QUEUED S GOTWORK=1,PROCESS("IEN")=IEN,PROCESS("NAME")=PROC("NAME"),PROCESS("COUNT")=1,PROCESS("NODE")=PROC("NODE") Q
"RTN","HLOPROC1",29,0)
 I 'GOTWORK K PROCESS
"RTN","HLOPROC1",30,0)
 Q GOTWORK
"RTN","HLOPROC1",31,0)
 ;
"RTN","HLOPROC1",32,0)
DOWORK(PROCESS) ;
"RTN","HLOPROC1",33,0)
 ;starts a process
"RTN","HLOPROC1",34,0)
 ;
"RTN","HLOPROC1",35,0)
 ;don't start a new task if stopped
"RTN","HLOPROC1",36,0)
 Q:$$CHKSTOP^HLOPROC
"RTN","HLOPROC1",37,0)
 ;
"RTN","HLOPROC1",38,0)
 N ZTRTN,ZTDESC,ZTSAVE,ZTIO,ZTSK,I,ZTDTH,ZTCPU
"RTN","HLOPROC1",39,0)
 S:'$G(PROCESS("COUNT")) PROCESS("COUNT")=1
"RTN","HLOPROC1",40,0)
 F I=1:1:PROCESS("COUNT") D
"RTN","HLOPROC1",41,0)
 .S ZTRTN="PROCESS^HLOPROC"
"RTN","HLOPROC1",42,0)
 .S ZTDESC="HL7 - "_PROCESS("NAME")
"RTN","HLOPROC1",43,0)
 .S ZTIO=""
"RTN","HLOPROC1",44,0)
 .S ZTSAVE("PROCNAME")=PROCESS("NAME")
"RTN","HLOPROC1",45,0)
 .S ZTDTH=$H
"RTN","HLOPROC1",46,0)
 .I $L(PROCESS("NODE")) S ZTCPU=PROCESS("NODE")
"RTN","HLOPROC1",47,0)
 .D ^%ZTLOAD
"RTN","HLOPROC1",48,0)
 .I $D(ZTSK) D
"RTN","HLOPROC1",49,0)
 ..;lock before changing counts
"RTN","HLOPROC1",50,0)
 ..L +HL7("COUNTING PROCESSES"):20
"RTN","HLOPROC1",51,0)
 ..I $$INC^HLOSITE($NA(^HLC("HL7 PROCESS COUNTS","QUEUED",PROCESS("NAME"))))
"RTN","HLOPROC1",52,0)
 ..S $P(^HLD(779.3,PROCESS("IEN"),0),"^",6)=$$NOW^XLFDT,^HLTMP("HL7 QUEUED PROCESSES",ZTSK)=$H_"^"_PROCESS("NAME")
"RTN","HLOPROC1",53,0)
 ..L -HL7("COUNTING PROCESSES")
"RTN","HLOPROC1",54,0)
 Q
"RTN","HLOPROC1",55,0)
 ;
"RTN","HLOPROC1",56,0)
GETPROC(IEN,PROCESS) ;
"RTN","HLOPROC1",57,0)
 ;given the ien of the HL7 Process Registry entry, returns the entry as a subscripted array in .PROCESS
"RTN","HLOPROC1",58,0)
 ;
"RTN","HLOPROC1",59,0)
 ;Output: Function returns 0 on failure, 1 on success
"RTN","HLOPROC1",60,0)
 ;
"RTN","HLOPROC1",61,0)
 N NODE
"RTN","HLOPROC1",62,0)
 S NODE=$G(^HLD(779.3,IEN,0))
"RTN","HLOPROC1",63,0)
 Q:NODE="" 0
"RTN","HLOPROC1",64,0)
 S PROCESS("NAME")=$P(NODE,"^")
"RTN","HLOPROC1",65,0)
 S PROCESS("IEN")=IEN
"RTN","HLOPROC1",66,0)
 S PROCESS("ACTIVE")=$P(NODE,"^",2)
"RTN","HLOPROC1",67,0)
 S PROCESS("MINIMUM")=+$P(NODE,"^",3)
"RTN","HLOPROC1",68,0)
 S PROCESS("MAXIMUM")=+$P(NODE,"^",4)
"RTN","HLOPROC1",69,0)
 S PROCESS("WAIT SECONDS")=+($P(NODE,"^",5))*60
"RTN","HLOPROC1",70,0)
 I 'PROCESS("WAIT SECONDS") S PROCESS("WAIT SECONDS")=1000
"RTN","HLOPROC1",71,0)
 S PROCESS("LAST DT/TM")=$P(NODE,"^",6)
"RTN","HLOPROC1",72,0)
 S PROCESS("VMS SERVICE")=$P(NODE,"^",15)
"RTN","HLOPROC1",73,0)
 S PROCESS("NODE")=$P(NODE,"^",16)
"RTN","HLOPROC1",74,0)
 I PROCESS("NODE") D
"RTN","HLOPROC1",75,0)
 .S PROCESS("NODE")=$P($G(^%ZIS(14.7,PROCESS("NODE"),0)),"^")
"RTN","HLOPROC1",76,0)
 E  S PROCESS("NODE")=""
"RTN","HLOPROC1",77,0)
 I '$L(PROCESS("NODE")) S PROCESS("NODE")=$$GETNODE^HLOSITE
"RTN","HLOPROC1",78,0)
 Q 1
"RTN","HLOPROC1",79,0)
 ;
"RTN","HLOPROC1",80,0)
STOPHL7 ;shut down HLO HL7
"RTN","HLOPROC1",81,0)
 N ZTSK,DOLLARJ
"RTN","HLOPROC1",82,0)
 ;let other processes know that starting/stopping is underway
"RTN","HLOPROC1",83,0)
 S $P(^HLD(779.1,1,0),"^",9)=0
"RTN","HLOPROC1",84,0)
 S ZTSK=""
"RTN","HLOPROC1",85,0)
 F  S ZTSK=$O(^HLTMP("HL7 QUEUED PROCESSES",ZTSK)) Q:ZTSK=""  D DQ^%ZTLOAD
"RTN","HLOPROC1",86,0)
 S DOLLARJ=""
"RTN","HLOPROC1",87,0)
 F  S DOLLARJ=$O(^HLTMP("HL7 RUNNING PROCESSES",DOLLARJ)) Q:DOLLARJ=""  S ZTSK=$P($G(^HLTMP("HL7 RUNNING PROCESSES",DOLLARJ)),"^",2) I ZTSK]"" D PCLEAR^%ZTLOAD(ZTSK) I $$ASKSTOP^%ZTLOAD(ZTSK)
"RTN","HLOPROC1",88,0)
 D CHKQUED
"RTN","HLOPROC1",89,0)
 Q
"RTN","HLOPROC1",90,0)
 ;
"RTN","HLOPROC1",91,0)
STARTHL7 ;
"RTN","HLOPROC1",92,0)
 ;start HL7 system
"RTN","HLOPROC1",93,0)
 ;
"RTN","HLOPROC1",94,0)
 N PROCESS
"RTN","HLOPROC1",95,0)
 S $P(^HLD(779.1,1,0),"^",9)=1
"RTN","HLOPROC1",96,0)
 D RECOUNT()
"RTN","HLOPROC1",97,0)
 D RESET
"RTN","HLOPROC1",98,0)
 ;
"RTN","HLOPROC1",99,0)
 L +^HLTMP("PROCESS MANAGER"):20
"RTN","HLOPROC1",100,0)
 ;if the lock was obtained then the Process Manager isn't running
"RTN","HLOPROC1",101,0)
 I $T D
"RTN","HLOPROC1",102,0)
 .L -^HLTMP("PROCESS MANAGER")
"RTN","HLOPROC1",103,0)
 .S PROCESS("IEN")=$O(^HLD(779.3,"B","PROCESS MANAGER",0))
"RTN","HLOPROC1",104,0)
 .D GETPROC(PROCESS("IEN"),.PROCESS)
"RTN","HLOPROC1",105,0)
 .D DOWORK(.PROCESS)
"RTN","HLOPROC1",106,0)
 Q
"RTN","HLOPROC1",107,0)
 ;
"RTN","HLOPROC1",108,0)
QUIT1(COUNT) ;just returns 1 as function value first time around,then 0, insuring that the DO WORK function is called just once
"RTN","HLOPROC1",109,0)
 I '$G(COUNT) S COUNT=1 Q 1
"RTN","HLOPROC1",110,0)
 Q 0
"RTN","HLOPROC1",111,0)
 ;
"RTN","HLOPROC1",112,0)
CHKDEAD(WORK) ;
"RTN","HLOPROC1",113,0)
 ;did any process terminate without erasing itself?
"RTN","HLOPROC1",114,0)
 ;WORK (pass by reference, not required) by the Process Manager that is not used and not required
"RTN","HLOPROC1",115,0)
 N DOLLARJ S DOLLARJ=""
"RTN","HLOPROC1",116,0)
 L +HL7("COUNTING PROCESSES"):20
"RTN","HLOPROC1",117,0)
 Q:'$T
"RTN","HLOPROC1",118,0)
 F  S DOLLARJ=$O(^HLTMP("HL7 RUNNING PROCESSES",DOLLARJ)) Q:DOLLARJ=""  I DOLLARJ'=$J L +^HLTMP("HL7 RUNNING PROCESSES",DOLLARJ):1 D:$T
"RTN","HLOPROC1",119,0)
 .L -^HLTMP("HL7 RUNNING PROCESSES",DOLLARJ)
"RTN","HLOPROC1",120,0)
 .N PROC
"RTN","HLOPROC1",121,0)
 .S PROC=$P($G(^HLTMP("HL7 RUNNING PROCESSES",DOLLARJ)),"^",3)
"RTN","HLOPROC1",122,0)
 .K ^HLTMP("HL7 RUNNING PROCESSES",DOLLARJ)
"RTN","HLOPROC1",123,0)
 .Q:PROC=""
"RTN","HLOPROC1",124,0)
 .I $$INC^HLOSITE($NA(^HLC("HL7 PROCESS COUNTS","RUNNING",PROC)),-1)<0,$$INC^HLOSITE($NA(^HLC("HL7 PROCESS COUNTS","RUNNING",PROC)),1)
"RTN","HLOPROC1",125,0)
 L -HL7("COUNTING PROCESSES")
"RTN","HLOPROC1",126,0)
 Q
"RTN","HLOPROC1",127,0)
CHKQUED ;did any queued task get dequeued without being erased?
"RTN","HLOPROC1",128,0)
 N PROC,JOB
"RTN","HLOPROC1",129,0)
 L +HL7("COUNTING PROCESSES"):20
"RTN","HLOPROC1",130,0)
 Q:'$T
"RTN","HLOPROC1",131,0)
 S JOB=""
"RTN","HLOPROC1",132,0)
 F  S JOB=$O(^HLTMP("HL7 QUEUED PROCESSES",JOB)) Q:JOB=""  I '$$QUEUED(JOB) D
"RTN","HLOPROC1",133,0)
 .N PROC
"RTN","HLOPROC1",134,0)
 .S PROC=$P($G(^HLTMP("HL7 QUEUED PROCESSES",JOB)),"^",2)
"RTN","HLOPROC1",135,0)
 .I PROC]"",$$INC^HLOSITE($NA(^HLC("HL7 PROCESS COUNTS","QUEUED",PROC)),-1)<0,$$INC^HLOSITE($NA(^HLC("HL7 PROCESS COUNTS","QUEUED",PROC)),1)
"RTN","HLOPROC1",136,0)
 .K ^HLTMP("HL7 QUEUED PROCESSES",JOB)
"RTN","HLOPROC1",137,0)
 L -HL7("COUNTING PROCESSES")
"RTN","HLOPROC1",138,0)
 Q
"RTN","HLOPROC1",139,0)
 ;
"RTN","HLOPROC1",140,0)
QUEUED(TASK) ;
"RTN","HLOPROC1",141,0)
 ;function returns 0 if ZTSK is not queued to run, 1 if it is
"RTN","HLOPROC1",142,0)
 N ZTSK
"RTN","HLOPROC1",143,0)
 S ZTSK=TASK
"RTN","HLOPROC1",144,0)
 D ISQED^%ZTLOAD
"RTN","HLOPROC1",145,0)
 Q:ZTSK(0) 1
"RTN","HLOPROC1",146,0)
 Q 0
"RTN","HLOPROC1",147,0)
 ;
"RTN","HLOPROC1",148,0)
CNTLIVE ;count the running processes
"RTN","HLOPROC1",149,0)
 N JOB,COUNTS,PROC
"RTN","HLOPROC1",150,0)
 L +HL7("COUNTING PROCESSES"):20
"RTN","HLOPROC1",151,0)
 Q:'$T
"RTN","HLOPROC1",152,0)
 S JOB=""
"RTN","HLOPROC1",153,0)
 F  S JOB=$O(^HLTMP("HL7 RUNNING PROCESSES",JOB)) Q:JOB=""  S PROC=$P($G(^HLTMP("HL7 RUNNING PROCESSES",JOB)),"^",3) I PROC]"" S COUNTS(PROC)=$G(COUNTS(PROC))+1
"RTN","HLOPROC1",154,0)
 S PROC="" F  S PROC=$O(COUNTS(PROC)) Q:PROC=""  S ^HLC("HL7 PROCESS COUNTS","RUNNING",PROC)=COUNTS(PROC)
"RTN","HLOPROC1",155,0)
 S PROC="" F  S PROC=$O(^HLC("HL7 PROCESS COUNTS","RUNNING",PROC)) Q:PROC=""  S ^HLC("HL7 PROCESS COUNTS","RUNNING",PROC)=+$G(COUNTS(PROC))
"RTN","HLOPROC1",156,0)
 L -HL7("COUNTING PROCESSES")
"RTN","HLOPROC1",157,0)
 Q
"RTN","HLOPROC1",158,0)
 ;
"RTN","HLOPROC1",159,0)
CNTQUED ;count the queued tasks
"RTN","HLOPROC1",160,0)
 N JOB,COUNTS,PROC
"RTN","HLOPROC1",161,0)
 L +HL7("COUNTING PROCESSES"):20
"RTN","HLOPROC1",162,0)
 Q:'$T
"RTN","HLOPROC1",163,0)
 S JOB=""
"RTN","HLOPROC1",164,0)
 F  S JOB=$O(^HLTMP("HL7 QUEUED PROCESSES",JOB)) Q:JOB=""  S PROC=$P($G(^HLTMP("HL7 QUEUED PROCESSES",JOB)),"^",2) I PROC]"" S COUNTS(PROC)=$G(COUNTS(PROC))+1
"RTN","HLOPROC1",165,0)
 S PROC="" F  S PROC=$O(COUNTS(PROC)) Q:PROC=""  S ^HLC("HL7 PROCESS COUNTS","QUEUED",PROC)=COUNTS(PROC)
"RTN","HLOPROC1",166,0)
 S PROC="" F  S PROC=$O(^HLC("HL7 PROCESS COUNTS","QUEUED",PROC)) Q:PROC=""  S ^HLC("HL7 PROCESS COUNTS","QUEUED",PROC)=+$G(COUNTS(PROC))
"RTN","HLOPROC1",167,0)
 L -HL7("COUNTING PROCESSES")
"RTN","HLOPROC1",168,0)
 Q
"RTN","HLOPROC1",169,0)
 ;
"RTN","HLOPROC1",170,0)
RECOUNT(RECOUNT) ;check that the processes that are supposed to be running actually are, same for the queued processes
"RTN","HLOPROC1",171,0)
 ;Input:
"RTN","HLOPROC1",172,0)
 ;  RECOUNT (pass by reference, optional) not used, but passed in by the process manager
"RTN","HLOPROC1",173,0)
 ;
"RTN","HLOPROC1",174,0)
 ;
"RTN","HLOPROC1",175,0)
 ;check for processes that are supposed to be running or queued but aren't
"RTN","HLOPROC1",176,0)
 D CHKDEAD(),CHKQUED
"RTN","HLOPROC1",177,0)
 ;
"RTN","HLOPROC1",178,0)
 ;recount the processes
"RTN","HLOPROC1",179,0)
 D CNTLIVE,CNTQUED
"RTN","HLOPROC1",180,0)
 Q
"RTN","HLOPROC1",181,0)
 ;
"RTN","HLOPROC1",182,0)
RESET ;
"RTN","HLOPROC1",183,0)
 N CTR,DT,LINK,QUEUE,MSGIEN
"RTN","HLOPROC1",184,0)
 K ^HLTMP("FAILING LINKS")
"RTN","HLOPROC1",185,0)
 S LINK=""
"RTN","HLOPROC1",186,0)
 F  S LINK=$O(^HLB("QUEUE","OUT",LINK)) Q:LINK=""  D
"RTN","HLOPROC1",187,0)
 . S DT=$G(^HLB("QUEUE","OUT",LINK))
"RTN","HLOPROC1",188,0)
 . I DT'="" S ^HLTMP("FAILING LINKS",LINK)=DT ;; down link (has a DT/TM)
"RTN","HLOPROC1",189,0)
 Q
"RTN","HLOPROC1",190,0)
 ;
"RTN","HLOPROC1",191,0)
ERROR ;
"RTN","HLOPROC1",192,0)
 ;cleanup if the error occurred during queue recount
"RTN","HLOPROC1",193,0)
 L -^HLTMP("PROCESS MANAGER")
"RTN","HLOPROC1",194,0)
 D:$G(HLON) STARTHL7
"RTN","HLOPROC1",195,0)
 D RCNT^HLOSITE("U")
"RTN","HLOPROC1",196,0)
 I $L($G(LOCK)) L -@LOCK
"RTN","HLOPROC1",197,0)
 D ^%ZTER
"RTN","HLOPROC1",198,0)
 D UNWIND^%ZTER
"RTN","HLOPROC1",199,0)
 Q
"RTN","HLOPROC1",200,0)
 ;*****End HL*1.6*138
"RTN","HLOPROC1",201,0)
QCOUNT ;count messages pending on all the queues
"RTN","HLOPROC1",202,0)
 ;
"RTN","HLOPROC1",203,0)
 N STOPPED,HLON
"RTN","HLOPROC1",204,0)
 S HLON=$P(^HLD(779.1,1,0),"^",9)
"RTN","HLOPROC1",205,0)
 D STOPHL7^HLOPROC1
"RTN","HLOPROC1",206,0)
 L +^HLTMP("PROCESS MANAGER"):600
"RTN","HLOPROC1",207,0)
 S STOPPED=$T
"RTN","HLOPROC1",208,0)
 D RECOUNT() ;checks list of processes, both running and queued
"RTN","HLOPROC1",209,0)
 I STOPPED D
"RTN","HLOPROC1",210,0)
 .N ALLDEAD
"RTN","HLOPROC1",211,0)
 .;wait a little while to see if all the processes stop 
"RTN","HLOPROC1",212,0)
 .F I=1:1:4 S ALLDEAD=$S(($O(^HLTMP("HL7 RUNNING PROCESSES",""))=""):1,1:0) Q:ALLDEAD  H 10
"RTN","HLOPROC1",213,0)
 .Q:'ALLDEAD  ;giveup on recounting queues - processes aren't stopping
"RTN","HLOPROC1",214,0)
 .;
"RTN","HLOPROC1",215,0)
 .D QCNT
"RTN","HLOPROC1",216,0)
 ;restart HLO
"RTN","HLOPROC1",217,0)
 L -^HLTMP("PROCESS MANAGER")
"RTN","HLOPROC1",218,0)
 D:$G(HLON) STARTHL7
"RTN","HLOPROC1",219,0)
 Q
"RTN","HLOPROC1",220,0)
QCNT ; count messages pending on queues
"RTN","HLOPROC1",221,0)
 ;HLO processes should be stopped
"RTN","HLOPROC1",222,0)
 N LOCK,FROM
"RTN","HLOPROC1",223,0)
 N $ETRAP,$ESTACK S $ETRAP="G ERROR^HLOPROC1"
"RTN","HLOPROC1",224,0)
 D RCNT^HLOSITE("S") ;; SET RECOUNT FLAG on
"RTN","HLOPROC1",225,0)
 ;
"RTN","HLOPROC1",226,0)
 ; recount each OUT queue
"RTN","HLOPROC1",227,0)
 ;first delete counters for non-existent queues
"RTN","HLOPROC1",228,0)
 S LINK=""
"RTN","HLOPROC1",229,0)
 F  S LINK=$O(^HLC("QUEUECOUNT","OUT",LINK)) Q:LINK=""  D
"RTN","HLOPROC1",230,0)
 . S QUEUE=""
"RTN","HLOPROC1",231,0)
 . F  S QUEUE=$O(^HLC("QUEUECOUNT","OUT",LINK,QUEUE)) Q:QUEUE=""  I '$O(^HLB("QUEUE","OUT",LINK,QUEUE,0)) D
"RTN","HLOPROC1",232,0)
 . . S LOCK=$NA(RECOUNT("OUT",LINK,QUEUE))
"RTN","HLOPROC1",233,0)
 . . L +@LOCK:1 Q:'$T  ;should not fail, but if it does skip recount for this queue
"RTN","HLOPROC1",234,0)
 . .I '$O(^HLB("QUEUE","OUT",LINK,QUEUE,0)) S ^HLC("QUEUECOUNT","OUT",LINK,QUEUE)=0
"RTN","HLOPROC1",235,0)
 . . L -@LOCK
"RTN","HLOPROC1",236,0)
 ;
"RTN","HLOPROC1",237,0)
 ;now count the queues
"RTN","HLOPROC1",238,0)
 S LINK=""
"RTN","HLOPROC1",239,0)
 F  S LINK=$O(^HLB("QUEUE","OUT",LINK)) Q:LINK=""  D
"RTN","HLOPROC1",240,0)
 . S QUEUE=""
"RTN","HLOPROC1",241,0)
 . F  S QUEUE=$O(^HLB("QUEUE","OUT",LINK,QUEUE)) Q:QUEUE=""  D
"RTN","HLOPROC1",242,0)
 . . S LOCK=$NA(RECOUNT("OUT",LINK,QUEUE))
"RTN","HLOPROC1",243,0)
 . . L +@LOCK:1 Q:'$T  ;should not fail, but if it does skip recount for this queue
"RTN","HLOPROC1",244,0)
 . . S (MSGIEN,CTR)=0
"RTN","HLOPROC1",245,0)
 . . F  S MSGIEN=$O(^HLB("QUEUE","OUT",LINK,QUEUE,MSGIEN)) Q:MSGIEN=""  S CTR=CTR+1
"RTN","HLOPROC1",246,0)
 . . S ^HLC("QUEUECOUNT","OUT",LINK,QUEUE)=CTR
"RTN","HLOPROC1",247,0)
 . . L -@LOCK
"RTN","HLOPROC1",248,0)
 ;
"RTN","HLOPROC1",249,0)
 ; recount each sequence queue
"RTN","HLOPROC1",250,0)
 ;first delete counts for non-existent queues
"RTN","HLOPROC1",251,0)
 S QUEUE=""
"RTN","HLOPROC1",252,0)
 F  S QUEUE=$O(^HLC("QUEUECOUNT","SEQUENCE",QUEUE)) Q:QUEUE=""  D
"RTN","HLOPROC1",253,0)
 . Q:$G(^HLB("QUEUE","SEQUENCE",QUEUE))!$O(^HLB("QUEUE","SEQUENCE",QUEUE,0))
"RTN","HLOPROC1",254,0)
 . S LOCK=$NA(RECOUNT("SEQUENCE",QUEUE))
"RTN","HLOPROC1",255,0)
 . L +@LOCK:1 Q:'$T
"RTN","HLOPROC1",256,0)
 . I '$G(^HLB("QUEUE","SEQUENCE",QUEUE)),'$O(^HLB("QUEUE","SEQUENCE",QUEUE,0)) S ^HLC("QUEUECOUNT","SEQUENCE",QUEUE)=0
"RTN","HLOPROC1",257,0)
 . L -@LOCK
"RTN","HLOPROC1",258,0)
 ;
"RTN","HLOPROC1",259,0)
 ;now count the queues
"RTN","HLOPROC1",260,0)
 S QUEUE=""
"RTN","HLOPROC1",261,0)
 F  S QUEUE=$O(^HLB("QUEUE","SEQUENCE",QUEUE)) Q:QUEUE=""  D
"RTN","HLOPROC1",262,0)
 .S LOCK=$NA(RECOUNT("SEQUENCE",QUEUE))
"RTN","HLOPROC1",263,0)
 . L +@LOCK:1 Q:'$T  ;should not fail, but if it does, skip the recount  of this queue
"RTN","HLOPROC1",264,0)
 .;
"RTN","HLOPROC1",265,0)
 .S (MSGIEN,CTR)=0
"RTN","HLOPROC1",266,0)
 .;count msg even if not on the queue if the queue is waiting on it
"RTN","HLOPROC1",267,0)
 . I +$G(^HLB("QUEUE","SEQUENCE",QUEUE)) S CTR=1
"RTN","HLOPROC1",268,0)
 .;
"RTN","HLOPROC1",269,0)
 . F  S MSGIEN=$O(^HLB("QUEUE","SEQUENCE",QUEUE,MSGIEN)) Q:MSGIEN=""  S CTR=CTR+1
"RTN","HLOPROC1",270,0)
 . S ^HLC("QUEUECOUNT","SEQUENCE",QUEUE)=CTR
"RTN","HLOPROC1",271,0)
 . L -@LOCK
"RTN","HLOPROC1",272,0)
 ;
"RTN","HLOPROC1",273,0)
 ;recount flag not needed anymore
"RTN","HLOPROC1",274,0)
 D RCNT^HLOSITE("U")
"RTN","HLOPROC1",275,0)
 ;
"RTN","HLOPROC1",276,0)
 ; now caculate the all-inclusive counter
"RTN","HLOPROC1",277,0)
 S QUEUE=""
"RTN","HLOPROC1",278,0)
 S CTR=0
"RTN","HLOPROC1",279,0)
 F  S QUEUE=$O(^HLC("QUEUECOUNT","SEQUENCE",QUEUE)) Q:QUEUE=""  S CTR=CTR+$G(^HLC("QUEUECOUNT","SEQUENCE",QUEUE))
"RTN","HLOPROC1",280,0)
 S ^HLC("QUEUECOUNT","SEQUENCE")=CTR
"RTN","HLOPROC1",281,0)
 ;
"RTN","HLOPROC1",282,0)
 ;
"RTN","HLOPROC1",283,0)
 ; recount IN queues
"RTN","HLOPROC1",284,0)
 ;the infilers and server should currently be stopped, so there is no contention for these data structures
"RTN","HLOPROC1",285,0)
 ;
"RTN","HLOPROC1",286,0)
 ;first delete counts for non-existent queues
"RTN","HLOPROC1",287,0)
 S FROM=""
"RTN","HLOPROC1",288,0)
 F  S FROM=$O(^HLC("QUEUECOUNT","IN",FROM)) Q:FROM=""  D
"RTN","HLOPROC1",289,0)
 . S QUEUE=""
"RTN","HLOPROC1",290,0)
 . F  S QUEUE=$O(^HLC("QUEUECOUNT","IN",FROM,QUEUE)) Q:QUEUE=""  I '$O(^HLB("QUEUE","IN",FROM,QUEUE,0)) S ^HLC("QUEUECOUNT","IN",FROM,QUEUE)=0
"RTN","HLOPROC1",291,0)
 ;
"RTN","HLOPROC1",292,0)
 ;now count the queues
"RTN","HLOPROC1",293,0)
 S FROM=""
"RTN","HLOPROC1",294,0)
 F  S FROM=$O(^HLB("QUEUE","IN",FROM)) Q:FROM=""  D
"RTN","HLOPROC1",295,0)
 . S QUEUE=""
"RTN","HLOPROC1",296,0)
 . F  S QUEUE=$O(^HLB("QUEUE","IN",FROM,QUEUE)) Q:QUEUE=""  D
"RTN","HLOPROC1",297,0)
 . . S (MSGIEN,CTR)=0
"RTN","HLOPROC1",298,0)
 . . F  S MSGIEN=$O(^HLB("QUEUE","IN",FROM,QUEUE,MSGIEN)) Q:MSGIEN=""  D
"RTN","HLOPROC1",299,0)
 . . . S CTR=CTR+1
"RTN","HLOPROC1",300,0)
 . . S ^HLC("QUEUECOUNT","IN",FROM,QUEUE)=CTR
"RTN","HLOPROC1",301,0)
 ;
"RTN","HLOPROC1",302,0)
 Q
"RTN","HLOQUE")
0^3^B148335504^B97643227
"RTN","HLOQUE",1,0)
HLOQUE ;ALB/CJM/OAK/PIJ/RBN- HL7 QUEUE MANAGEMENT - 10/4/94 1pm ;08/23/2010
"RTN","HLOQUE",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,132,134,137,138,143,147**;Oct 13, 1995;Build 15
"RTN","HLOQUE",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOQUE",4,0)
 ;
"RTN","HLOQUE",5,0)
INQUE(FROM,QNAME,IEN778,ACTION,PURGE) ;
"RTN","HLOQUE",6,0)
 ;Will place the message=IEN778 on the IN queue, incoming
"RTN","HLOQUE",7,0)
 ;Input:
"RTN","HLOQUE",8,0)
 ;  FROM - sending facility from message header.
"RTN","HLOQUE",9,0)
 ;         For actions other than incoming messages, its the specified link.
"RTN","HLOQUE",10,0)
 ;  QNAME - queue named by the application
"RTN","HLOQUE",11,0)
 ;  IEN778 = ien of the message in file 778
"RTN","HLOQUE",12,0)
 ;  ACTION - <tag^routine> that should be executed for the application
"RTN","HLOQUE",13,0)
 ;  PURGE (optional) - PURGE=1 indicates that the purge dt/tm needs to be set by the infiler
"RTN","HLOQUE",14,0)
 ;     If PURGE("ACKTOIEN") is set, it indicates that the purge dt/tm of
"RTN","HLOQUE",15,0)
 ;     the original message to this application ack also needs to be set.
"RTN","HLOQUE",16,0)
 ;Output: none
"RTN","HLOQUE",17,0)
 ;
"RTN","HLOQUE",18,0)
ZB36 I $G(FROM)="" S FROM="UNKNOWN"
"RTN","HLOQUE",19,0)
 I '$L($G(QNAME)) S QNAME="DEFAULT"
"RTN","HLOQUE",20,0)
 S ^HLB("QUEUE","IN",FROM,QNAME,IEN778)=ACTION_"^"_$G(PURGE)_"^"_$G(PURGE("ACKTOIEN"))
"RTN","HLOQUE",21,0)
 I $$INC^HLOSITE($NA(^HLC("QUEUECOUNT","IN",FROM,QNAME)))
"RTN","HLOQUE",22,0)
 Q
"RTN","HLOQUE",23,0)
 ;
"RTN","HLOQUE",24,0)
OUTQUE(LINKNAME,PORT,QNAME,IEN778) ;
"RTN","HLOQUE",25,0)
 ;Will place the message=IEN778 on the out-going queue
"RTN","HLOQUE",26,0)
 ;Input:
"RTN","HLOQUE",27,0)
 ;  LINKNAME = name of (.01) the logical link
"RTN","HLOQUE",28,0)
 ;  PORT (optional) the port to connect to
"RTN","HLOQUE",29,0)
 ;  QNAME - queue named by the application
"RTN","HLOQUE",30,0)
 ;  IEN778 = ien of the message in file 778
"RTN","HLOQUE",31,0)
 ;Output: none
"RTN","HLOQUE",32,0)
 ;
"RTN","HLOQUE",33,0)
 ;
"RTN","HLOQUE",34,0)
 N SUB,FLG
"RTN","HLOQUE",35,0)
 S FLG=0
"RTN","HLOQUE",36,0)
 S SUB=LINKNAME
"RTN","HLOQUE",37,0)
 I PORT S SUB=SUB_":"_PORT
"RTN","HLOQUE",38,0)
 I '$L($G(QNAME)) S QNAME="DEFAULT"
"RTN","HLOQUE",39,0)
 ;***Start HL*1.6*138 PIJ
"RTN","HLOQUE",40,0)
 ;if recount in progress, give it up to 20 seconds to finish - if it takes longer than that the recount won't be exact, but a longer delay is unreasonable
"RTN","HLOQUE",41,0)
 I $$RCNT^HLOSITE L +RECOUNT("OUT",SUB,QNAME):20 S:$T FLG=1
"RTN","HLOQUE",42,0)
 ;***End HL*1.6*138 PIJ"
"RTN","HLOQUE",43,0)
 S ^HLB("QUEUE","OUT",SUB,QNAME,IEN778)=""
"RTN","HLOQUE",44,0)
 I $$INC^HLOSITE($NA(^HLC("QUEUECOUNT","OUT",SUB,QNAME)))
"RTN","HLOQUE",45,0)
 L:FLG -RECOUNT("OUT",SUB,QNAME)
"RTN","HLOQUE",46,0)
 Q
"RTN","HLOQUE",47,0)
 ;
"RTN","HLOQUE",48,0)
DEQUE(FROMORTO,QNAME,DIR,IEN778) ;
"RTN","HLOQUE",49,0)
 ;This routine will remove the message=IEN778 from its queue
"RTN","HLOQUE",50,0)
 ;Input:
"RTN","HLOQUE",51,0)
 ;  DIR = "IN" or "OUT", denoting the direction that the message is going in
"RTN","HLOQUE",52,0)
 ;  FROMORTO = for outgoing: the .01 field of the logical link
"RTN","HLOQUE",53,0)
 ;         for incoming: sending facility
"RTN","HLOQUE",54,0)
 ;  IEN778 = ien of the message in file 778
"RTN","HLOQUE",55,0)
 ;Output: none
"RTN","HLOQUE",56,0)
 ;
"RTN","HLOQUE",57,0)
 Q:(FROMORTO="")
"RTN","HLOQUE",58,0)
 I ($G(QNAME)="") S QNAME="DEFAULT"
"RTN","HLOQUE",59,0)
 D
"RTN","HLOQUE",60,0)
 .I $E(DIR)="I" S DIR="IN" Q
"RTN","HLOQUE",61,0)
 .I $E(DIR)="O" S DIR="OUT" Q
"RTN","HLOQUE",62,0)
 I DIR'="IN",DIR'="OUT" Q
"RTN","HLOQUE",63,0)
 Q:'$G(IEN778)
"RTN","HLOQUE",64,0)
 D:$D(^HLB("QUEUE",DIR,FROMORTO,QNAME,IEN778))
"RTN","HLOQUE",65,0)
 .K ^HLB("QUEUE",DIR,FROMORTO,QNAME,IEN778)
"RTN","HLOQUE",66,0)
 .;don't let the count become negative
"RTN","HLOQUE",67,0)
 .I $$INC^HLOSITE($NA(^HLC("QUEUECOUNT",DIR,FROMORTO,QNAME)),-1)<0,$$INC^HLOSITE($NA(^HLC("QUEUECOUNT",DIR,FROMORTO,QNAME)))
"RTN","HLOQUE",68,0)
 Q
"RTN","HLOQUE",69,0)
 ;
"RTN","HLOQUE",70,0)
STOPQUE(DIR,QUEUE) ;
"RTN","HLOQUE",71,0)
 ;This API is used to set a stop flag on a named queue.
"RTN","HLOQUE",72,0)
 ;DIR=<"IN" or "OUT">
"RTN","HLOQUE",73,0)
 ;QUEUE - the name of the queue to be stopped
"RTN","HLOQUE",74,0)
 ;
"RTN","HLOQUE",75,0)
 Q:$G(DIR)=""
"RTN","HLOQUE",76,0)
 Q:$G(QUEUE)=""
"RTN","HLOQUE",77,0)
 S ^HLTMP("STOPPED QUEUES",DIR,QUEUE)=1
"RTN","HLOQUE",78,0)
 Q
"RTN","HLOQUE",79,0)
STARTQUE(DIR,QUEUE) ;
"RTN","HLOQUE",80,0)
 ;This API is used to REMOVE the stop flag on a named queue.
"RTN","HLOQUE",81,0)
 ;DIR=<"IN" or "OUT">
"RTN","HLOQUE",82,0)
 ;QUEUE - the name of the queue to be stopped
"RTN","HLOQUE",83,0)
 ;
"RTN","HLOQUE",84,0)
 Q:$G(DIR)=""
"RTN","HLOQUE",85,0)
 Q:$G(QUEUE)=""
"RTN","HLOQUE",86,0)
 K ^HLTMP("STOPPED QUEUES",DIR,QUEUE)
"RTN","HLOQUE",87,0)
 Q
"RTN","HLOQUE",88,0)
STOPPED(DIR,QUEUE) ;
"RTN","HLOQUE",89,0)
 ;This API is used to DETERMINE if the stop flag on a named queue is set.
"RTN","HLOQUE",90,0)
 ;Input:
"RTN","HLOQUE",91,0)
 ;  DIR=<"IN" or "OUT">
"RTN","HLOQUE",92,0)
 ;  QUEUE - the name of the queue to be checked
"RTN","HLOQUE",93,0)
 ;Output:
"RTN","HLOQUE",94,0)
 ;  Function returns 1 if the queue is stopped, 0 otherwise
"RTN","HLOQUE",95,0)
 N RET
"RTN","HLOQUE",96,0)
 S RET=0
"RTN","HLOQUE",97,0)
 Q:$G(DIR)="" 0
"RTN","HLOQUE",98,0)
 Q:$G(QUEUE)="" 0
"RTN","HLOQUE",99,0)
 S:$G(^HLTMP("STOPPED QUEUES",DIR,QUEUE)) RET=1
"RTN","HLOQUE",100,0)
ZB0 Q RET
"RTN","HLOQUE",101,0)
 ;
"RTN","HLOQUE",102,0)
SQUE(SQUE,LINKNAME,PORT,QNAME,IEN778) ;
"RTN","HLOQUE",103,0)
 ;Will place the message=IEN778 on the sequencing queue. This is always done in the context of the application calling an HLO API to send a message.
"RTN","HLOQUE",104,0)
 ;Input:
"RTN","HLOQUE",105,0)
 ;  SQUE - name of the sequencing queue
"RTN","HLOQUE",106,0)
 ;  LINKNAME = name of (.01) the logical link
"RTN","HLOQUE",107,0)
 ;  PORT (optional) the port to connect to
"RTN","HLOQUE",108,0)
 ;  QNAME (optional) outgoing queue
"RTN","HLOQUE",109,0)
 ;  IEN778 = ien of the message in file 778
"RTN","HLOQUE",110,0)
 ;Output: 1 if placed on the outgoing queue, 0 if placed on the sequence queue
"RTN","HLOQUE",111,0)
 ;
"RTN","HLOQUE",112,0)
 N NEXT,MOVED,FLG
"RTN","HLOQUE",113,0)
 S (FLG,MOVED)=0
"RTN","HLOQUE",114,0)
 ;
"RTN","HLOQUE",115,0)
 ;keep a count of messages pending on sequence queues for the HLO System Monitor
"RTN","HLOQUE",116,0)
 ;
"RTN","HLOQUE",117,0)
 ;***Start HL*1.6*138 PIJ
"RTN","HLOQUE",118,0)
 ;if recount in progress, pause up to 20 seconds to finish - if it takes longer than that the recount won't be exact, but a longer delay is unreasonable
"RTN","HLOQUE",119,0)
 I $$RCNT^HLOSITE L +RECOUNT("SEQUENCE",SQUE):20 S:$T FLG=1
"RTN","HLOQUE",120,0)
 ;***End HL*1.6*138 PIJ
"RTN","HLOQUE",121,0)
 ;
"RTN","HLOQUE",122,0)
 ;** START 143 CJM
"RTN","HLOQUE",123,0)
 L +^HLB("QUEUE","SEQUENCE",SQUE):200
"RTN","HLOQUE",124,0)
 ;** END 143 CJM
"RTN","HLOQUE",125,0)
 ;
"RTN","HLOQUE",126,0)
 S NEXT=+$G(^HLB("QUEUE","SEQUENCE",SQUE))
"RTN","HLOQUE",127,0)
 I NEXT=IEN778 L -^HLB("QUEUE","SEQUENCE",SQUE) Q 0  ;already queued!
"RTN","HLOQUE",128,0)
 ;
"RTN","HLOQUE",129,0)
 ;increment the counter for all sequence queues
"RTN","HLOQUE",130,0)
 I $$INC^HLOSITE($NA(^HLC("QUEUECOUNT","SEQUENCE")))
"RTN","HLOQUE",131,0)
 ;
"RTN","HLOQUE",132,0)
 ;*** Start HL*1.6*138 CJM
"RTN","HLOQUE",133,0)
 ;also keep counter for the individual queue
"RTN","HLOQUE",134,0)
 I $$INC^HLOSITE($NA(^HLC("QUEUECOUNT","SEQUENCE",SQUE)))
"RTN","HLOQUE",135,0)
 ;*** End HL*1.6*138 CJM
"RTN","HLOQUE",136,0)
 ;
"RTN","HLOQUE",137,0)
 ;** START 143 CJM
"RTN","HLOQUE",138,0)
 ;L +^HLB("QUEUE","SEQUENCE",SQUE):200
"RTN","HLOQUE",139,0)
 ;** END 143 CJM
"RTN","HLOQUE",140,0)
 ;
"RTN","HLOQUE",141,0)
 ;if the sequence queue is empty and not waiting on a message, then the message can be put directly on the outgoing queue, bypassing the sequence queue
"RTN","HLOQUE",142,0)
 I '$O(^HLB("QUEUE","SEQUENCE",SQUE,0)),'NEXT D
"RTN","HLOQUE",143,0)
 .S ^HLB("QUEUE","SEQUENCE",SQUE)=IEN778 ;to mean something moved to outgoing but not yet transmitted
"RTN","HLOQUE",144,0)
 .D OUTQUE(.LINKNAME,.PORT,.QNAME,IEN778)
"RTN","HLOQUE",145,0)
 .S MOVED=1
"RTN","HLOQUE",146,0)
 E  D
"RTN","HLOQUE",147,0)
 .;Put the message on the sequence queue.
"RTN","HLOQUE",148,0)
 .S ^HLB("QUEUE","SEQUENCE",SQUE,IEN778)=""
"RTN","HLOQUE",149,0)
 .;
"RTN","HLOQUE",150,0)
 .;**P143 START CJM
"RTN","HLOQUE",151,0)
 .I 'NEXT,$$ADVANCE(SQUE,"")
"RTN","HLOQUE",152,0)
 .;**P143 END CJM
"RTN","HLOQUE",153,0)
 .;
"RTN","HLOQUE",154,0)
 .;**P147 START CJM
"RTN","HLOQUE",155,0)
 .I NEXT,$L($P($G(^HLB(NEXT,0)),"^",7)) D ADVANCE(SQUE,NEXT)
"RTN","HLOQUE",156,0)
 .;**P147 END CJM
"RTN","HLOQUE",157,0)
 .;
"RTN","HLOQUE",158,0)
 L -^HLB("QUEUE","SEQUENCE",SQUE)
"RTN","HLOQUE",159,0)
 L:FLG -RECOUNT("SEQUENCE",SQUE)
"RTN","HLOQUE",160,0)
 Q MOVED
"RTN","HLOQUE",161,0)
 ;
"RTN","HLOQUE",162,0)
ADVANCE(SQUE,MSGIEN) ;
"RTN","HLOQUE",163,0)
 ;Will move the specified sequencing queue to the next message. 
"RTN","HLOQUE",164,0)
 ;Input:
"RTN","HLOQUE",165,0)
 ;  SQUE - name of the sequencing queue
"RTN","HLOQUE",166,0)
 ;  MSGIEN - the ien of the message upon which the sequence queue was waiting.  If it is NOT the correct ien, then the sequence queue will NOT be advance.
"RTN","HLOQUE",167,0)
 ;Output:
"RTN","HLOQUE",168,0)
 ;  Function - 1 if advanced, 0 if not
"RTN","HLOQUE",169,0)
 ;
"RTN","HLOQUE",170,0)
 N NODE,IEN778,LINKNAME,PORT,QNAME
"RTN","HLOQUE",171,0)
 Q:'$L($G(SQUE)) 0
"RTN","HLOQUE",172,0)
 ;
"RTN","HLOQUE",173,0)
 ;**P143 START CJM
"RTN","HLOQUE",174,0)
 ;Q:'$G(MSGIEN) 0
"RTN","HLOQUE",175,0)
 Q:'$D(MSGIEN) 0
"RTN","HLOQUE",176,0)
 ;**P143 END CJM
"RTN","HLOQUE",177,0)
 ;
"RTN","HLOQUE",178,0)
 L +^HLB("QUEUE","SEQUENCE",SQUE):200
"RTN","HLOQUE",179,0)
 ;
"RTN","HLOQUE",180,0)
 ;do not advance if the queue wasn't pending the message=MSGIEN
"RTN","HLOQUE",181,0)
 ;**P143 START CJM
"RTN","HLOQUE",182,0)
 ;I (MSGIEN'=$P($G(^HLB("QUEUE","SEQUENCE",SQUE)),"^")) L -^HLB("QUEUE","SEQUENCE",SQUE) Q 0
"RTN","HLOQUE",183,0)
 I ($G(MSGIEN)'=$P($G(^HLB("QUEUE","SEQUENCE",SQUE)),"^")) L -^HLB("QUEUE","SEQUENCE",SQUE) Q 0
"RTN","HLOQUE",184,0)
 ;**P143 END CJM
"RTN","HLOQUE",185,0)
 ;
"RTN","HLOQUE",186,0)
 ;decrement the count of messages pending on all sequence queues
"RTN","HLOQUE",187,0)
 I $$INC^HLOSITE($NA(^HLC("QUEUECOUNT","SEQUENCE")),-1)<0,$$INC^HLOSITE($NA(^HLC("QUEUECOUNT","SEQUENCE")))
"RTN","HLOQUE",188,0)
 ;
"RTN","HLOQUE",189,0)
 ;**Start HL*1.6*138 CJM
"RTN","HLOQUE",190,0)
 ;decrement the count of messages pending on this individual queue
"RTN","HLOQUE",191,0)
 I $$INC^HLOSITE($NA(^HLC("QUEUECOUNT","SEQUENCE",SQUE)),-1)<0,$$INC^HLOSITE($NA(^HLC("QUEUECOUNT","SEQUENCE",SQUE)))
"RTN","HLOQUE",192,0)
 ;**End HL*1.6*138 CJM
"RTN","HLOQUE",193,0)
 ;
"RTN","HLOQUE",194,0)
 S IEN778=0
"RTN","HLOQUE",195,0)
 ;look for the first message on the sequence que.  Make sure its valid, if not remove the invalid entry and keep looking.
"RTN","HLOQUE",196,0)
 F  S IEN778=$O(^HLB("QUEUE","SEQUENCE",SQUE,0)) Q:'IEN778  S NODE=$G(^HLB(IEN778,0)) Q:$L(NODE)  D
"RTN","HLOQUE",197,0)
 .;message does not exist! Remove from queue and try again.
"RTN","HLOQUE",198,0)
 .K ^HLB("QUEUE","SEQUENCE",SQUE,IEN778)
"RTN","HLOQUE",199,0)
 .I $$INC^HLOSITE($NA(^HLC("QUEUECOUNT","SEQUENCE")),-1)<0,$$INC^HLOSITE($NA(^HLC("QUEUECOUNT","SEQUENCE"))) ;decrement the count of messages pending sequence queues
"RTN","HLOQUE",200,0)
 .;**Start HL*1.6*138 CJM
"RTN","HLOQUE",201,0)
 .; also decrement the count of messages pending on this individual queue
"RTN","HLOQUE",202,0)
 .I $$INC^HLOSITE($NA(^HLC("QUEUECOUNT","SEQUENCE",SQUE)),-1)<0,$$INC^HLOSITE($NA(^HLC("QUEUECOUNT","SEQUENCE",SQUE)))
"RTN","HLOQUE",203,0)
 .;**End HL*1.6*138 CJM
"RTN","HLOQUE",204,0)
 ;
"RTN","HLOQUE",205,0)
 ;IEN778 is the next pending msg on this sequence queue
"RTN","HLOQUE",206,0)
 I IEN778 D
"RTN","HLOQUE",207,0)
 .;
"RTN","HLOQUE",208,0)
 .;parse out info needed to move to outgoing queue
"RTN","HLOQUE",209,0)
 .S LINKNAME=$P(NODE,"^",5),PORT=$P(NODE,"^",8),QNAME=$P(NODE,"^",6)
"RTN","HLOQUE",210,0)
 .;
"RTN","HLOQUE",211,0)
 .S ^HLB("QUEUE","SEQUENCE",SQUE)=IEN778 ;indicates this sequence queue is now waiting for msg=IEN778 before advancing.  The second pieces is the timer, but will not be set until the message=IEN778 is actually transmitted.
"RTN","HLOQUE",212,0)
 .K ^HLB("QUEUE","SEQUENCE",SQUE,IEN778) ;remove from sequence queue
"RTN","HLOQUE",213,0)
 .L -^HLB("QUEUE","SEQUENCE",SQUE)
"RTN","HLOQUE",214,0)
 .S $P(^HLB(IEN778,5),"^",2)=1
"RTN","HLOQUE",215,0)
 .D OUTQUE(.LINKNAME,$G(PORT),$G(QNAME),IEN778) ;move to outgoing queue
"RTN","HLOQUE",216,0)
 E  D
"RTN","HLOQUE",217,0)
 .K ^HLB("QUEUE","SEQUENCE",SQUE) ;this sequence queue is currently empty and not needed
"RTN","HLOQUE",218,0)
 .L -^HLB("QUEUE","SEQUENCE",SQUE)
"RTN","HLOQUE",219,0)
 Q 1
"RTN","HLOQUE",220,0)
 ;
"RTN","HLOQUE",221,0)
SEQCHK(WORK) ;functions under the HLO Process Manager
"RTN","HLOQUE",222,0)
 ;check sequence queues for timeout
"RTN","HLOQUE",223,0)
 N QUE,NOW
"RTN","HLOQUE",224,0)
 S NOW=$$NOW^XLFDT
"RTN","HLOQUE",225,0)
 S QUE=""
"RTN","HLOQUE",226,0)
 F  S QUE=$O(^HLB("QUEUE","SEQUENCE",QUE)) Q:QUE=""  D
"RTN","HLOQUE",227,0)
 .N NODE,MSGIEN,ACTION,NODE
"RTN","HLOQUE",228,0)
 .S NODE=$G(^HLB("QUEUE","SEQUENCE",QUE))
"RTN","HLOQUE",229,0)
 .Q:'$P(NODE,"^",2)
"RTN","HLOQUE",230,0)
 .Q:$P(NODE,"^",2)>NOW
"RTN","HLOQUE",231,0)
 .Q:$P(NODE,"^",3)
"RTN","HLOQUE",232,0)
 .L +^HLB("QUEUE","SEQUENCE",QUE):2
"RTN","HLOQUE",233,0)
 .;don't report if a lock wasn't obtained
"RTN","HLOQUE",234,0)
 .Q:'$T
"RTN","HLOQUE",235,0)
 .S NODE=$G(^HLB("QUEUE","SEQUENCE",QUE))
"RTN","HLOQUE",236,0)
 .I '$P(NODE,"^",2) L -^HLB("QUEUE","SEQUENCE",QUE) Q
"RTN","HLOQUE",237,0)
 .I ($P(NODE,"^",2)>NOW) L -^HLB("QUEUE","SEQUENCE",QUE) Q
"RTN","HLOQUE",238,0)
 .I $P(NODE,"^",3) L -^HLB("QUEUE","SEQUENCE",QUE) Q  ;exception already raised
"RTN","HLOQUE",239,0)
 .S MSGIEN=$P(NODE,"^")
"RTN","HLOQUE",240,0)
 .I 'MSGIEN L -^HLB("QUEUE","SEQUENCE",QUE) Q
"RTN","HLOQUE",241,0)
 .S ACTION=$$EXCEPT^HLOAPP($$GETSAP^HLOCLNT2(MSGIEN))
"RTN","HLOQUE",242,0)
 .S $P(^HLB(MSGIEN,5),"^",3)=1
"RTN","HLOQUE",243,0)
 .S $P(^HLB("QUEUE","SEQUENCE",QUE),"^",3)=1 ;indicates exception raised
"RTN","HLOQUE",244,0)
 .L -^HLB("QUEUE","SEQUENCE",QUE)
"RTN","HLOQUE",245,0)
 .D  ;call the application to take action
"RTN","HLOQUE",246,0)
 ..N HLMSGIEN,MCODE,DUZ,QUE,NOW
"RTN","HLOQUE",247,0)
 ..N $ETRAP,$ESTACK S $ETRAP="G ERROR^HLOQUE"
"RTN","HLOQUE",248,0)
 ..S HLMSGIEN=MSGIEN
"RTN","HLOQUE",249,0)
 ..S MCODE="D "_ACTION
"RTN","HLOQUE",250,0)
 ..N MSGIEN,X
"RTN","HLOQUE",251,0)
 ..D DUZ^XUP(.5)
"RTN","HLOQUE",252,0)
 ..X MCODE
"RTN","HLOQUE",253,0)
 ..;kill the apps variables
"RTN","HLOQUE",254,0)
 ..D
"RTN","HLOQUE",255,0)
 ...N ZTSK
"RTN","HLOQUE",256,0)
 ...D KILL^XUSCLEAN
"RTN","HLOQUE",257,0)
 Q
"RTN","HLOQUE",258,0)
ERROR ;error trap for application context
"RTN","HLOQUE",259,0)
 S $ETRAP="D UNWIND^%ZTER"
"RTN","HLOQUE",260,0)
 D ^%ZTER
"RTN","HLOQUE",261,0)
 S $ECODE=",UAPPLICATION ERROR,"
"RTN","HLOQUE",262,0)
 ;
"RTN","HLOQUE",263,0)
 ;kill the apps variables
"RTN","HLOQUE",264,0)
 D
"RTN","HLOQUE",265,0)
 .N ZTSK,MSGIEN,QUEUE
"RTN","HLOQUE",266,0)
 .D KILL^XUSCLEAN
"RTN","HLOQUE",267,0)
 ;
"RTN","HLOQUE",268,0)
 ;release all the locks the app may have set, except Taskman lock
"RTN","HLOQUE",269,0)
 L:$D(ZTSK) ^%ZTSCH("TASK",ZTSK):1
"RTN","HLOQUE",270,0)
 L:'$D(ZTSK)
"RTN","HLOQUE",271,0)
 ;reset HLO's lock
"RTN","HLOQUE",272,0)
 L +^HLTMP("HL7 RUNNING PROCESSES",$J):0
"RTN","HLOQUE",273,0)
 ;return to processing the next message on the queue
"RTN","HLOQUE",274,0)
 D UNWIND^%ZTER
"RTN","HLOQUE",275,0)
 Q
"RTN","HLOQUE",276,0)
 ;
"RTN","HLOQUE",277,0)
 ; *** start HL*1.6*143 -  RBN ***
"RTN","HLOQUE",278,0)
 ;
"RTN","HLOQUE",279,0)
 ; IMPLEMENTATION OF HL0 QUEUE COUNT SUMMARY
"RTN","HLOQUE",280,0)
 ;
"RTN","HLOQUE",281,0)
QUECNT(QUEARRAY) ;
"RTN","HLOQUE",282,0)
 ; 
"RTN","HLOQUE",283,0)
 ; DESC  : Functions eturns the total number of messages on all the queues and an the QUEARRAY
"RTN","HLOQUE",284,0)
 ;        
"RTN","HLOQUE",285,0)
 ; INPUT : QUEARRAY - the array, passed by reference, to contain the queue counts. 
"RTN","HLOQUE",286,0)
 ;               
"RTN","HLOQUE",287,0)
 ; OUTPUT : Filled array
"RTN","HLOQUE",288,0)
 ;               
"RTN","HLOQUE",289,0)
 ;               Format:
"RTN","HLOQUE",290,0)
 ;             
"RTN","HLOQUE",291,0)
 ;               QUE("TOTAL") = Total number of messages on all queues.
"RTN","HLOQUE",292,0)
 ;               QUE("OUT")   = Total number of outgoing messages.
"RTN","HLOQUE",293,0)
 ;               QUE("IN")    = Total number of incoming messages.
"RTN","HLOQUE",294,0)
 ;               QUE("SEQ")   = Total number of messages on sequence queues.
"RTN","HLOQUE",295,0)
 ;               QUE("IN",link_name,queue_name) = Number of messages on given link and queue.
"RTN","HLOQUE",296,0)
 ;               QUE("OUT",link_name,queue_name) = Number of messages on given link and queue.
"RTN","HLOQUE",297,0)
 ;               QUE("SEQ",queue_name) = Number of messages on given sequence queue.
"RTN","HLOQUE",298,0)
 ; 
"RTN","HLOQUE",299,0)
 ; There are four possible calls ("entry points") to this API:
"RTN","HLOQUE",300,0)
 ;   1. QUECNT - returns the referenced array with all of the above data.
"RTN","HLOQUE",301,0)
 ;   2. IN     - returns only the data related to the IN queues.
"RTN","HLOQUE",302,0)
 ;   3. OUT    - returns only the data related to the OUT queues.
"RTN","HLOQUE",303,0)
 ;   4. SEQ    - returns only the data related to the SEQUENCE queues.
"RTN","HLOQUE",304,0)
 ;   
"RTN","HLOQUE",305,0)
 N TOTAL,INCNT,OUTCNT,SEQCNT,LINK,QUE,FLG
"RTN","HLOQUE",306,0)
 S FLG=1
"RTN","HLOQUE",307,0)
 ; Get incomming counts
"RTN","HLOQUE",308,0)
 D IN(.QUEARRAY)
"RTN","HLOQUE",309,0)
 ; Get outgoing counts
"RTN","HLOQUE",310,0)
 D OUT(.QUEARRAY)
"RTN","HLOQUE",311,0)
 ; Get sequence counts
"RTN","HLOQUE",312,0)
 D SEQ(.QUEARRAY)
"RTN","HLOQUE",313,0)
 ;
"RTN","HLOQUE",314,0)
 ; Total messages on all queues
"RTN","HLOQUE",315,0)
 ; 
"RTN","HLOQUE",316,0)
 S QUEARRAY("TOTAL")=INCNT+OUTCNT+SEQCNT
"RTN","HLOQUE",317,0)
 Q QUEARRAY("TOTAL")
"RTN","HLOQUE",318,0)
 ;
"RTN","HLOQUE",319,0)
IN(QUEARRAY) ;
"RTN","HLOQUE",320,0)
 ; Count messages on incoming queues
"RTN","HLOQUE",321,0)
 ;
"RTN","HLOQUE",322,0)
 I '$G(FLG) N TOTAL,INCNT,OUTCNT,SEQCNT,LINK,QUE,FLG
"RTN","HLOQUE",323,0)
 S (LINK,QUE)=""
"RTN","HLOQUE",324,0)
 S INCNT=0
"RTN","HLOQUE",325,0)
 F  S LINK=$O(^HLC("QUEUECOUNT","IN",LINK)) Q:LINK=""  D
"RTN","HLOQUE",326,0)
 .  F  S QUE=$O(^HLC("QUEUECOUNT","IN",LINK,QUE)) Q:QUE=""  D
"RTN","HLOQUE",327,0)
 .  .  S INCNT=INCNT+^HLC("QUEUECOUNT","IN",LINK,QUE)
"RTN","HLOQUE",328,0)
 .  .  S QUEARRAY("IN",LINK,QUE)=^HLC("QUEUECOUNT","IN",LINK,QUE)
"RTN","HLOQUE",329,0)
 S QUEARRAY("IN")=INCNT
"RTN","HLOQUE",330,0)
 I '$G(FLG) Q INCNT
"RTN","HLOQUE",331,0)
 Q
"RTN","HLOQUE",332,0)
 ;
"RTN","HLOQUE",333,0)
OUT(QUEARRAY) ;
"RTN","HLOQUE",334,0)
 ; Count messages on outgoing queues
"RTN","HLOQUE",335,0)
 ;
"RTN","HLOQUE",336,0)
 I '$G(FLG) N TOTAL,INCNT,OUTCNT,SEQCNT,LINK,QUE,FLG
"RTN","HLOQUE",337,0)
 S (LINK,QUE)=""
"RTN","HLOQUE",338,0)
 S OUTCNT=0
"RTN","HLOQUE",339,0)
 F  S LINK=$O(^HLC("QUEUECOUNT","OUT",LINK)) Q:LINK=""  D
"RTN","HLOQUE",340,0)
 .  F  S QUE=$O(^HLC("QUEUECOUNT","OUT",LINK,QUE)) Q:QUE=""  D
"RTN","HLOQUE",341,0)
 .  .  S OUTCNT=OUTCNT+^HLC("QUEUECOUNT","OUT",LINK,QUE)
"RTN","HLOQUE",342,0)
 .  .  S QUEARRAY("OUT",LINK,QUE)=^HLC("QUEUECOUNT","OUT",LINK,QUE)
"RTN","HLOQUE",343,0)
 S QUEARRAY("OUT")=OUTCNT
"RTN","HLOQUE",344,0)
 I '$G(FLG) Q OUTCNT
"RTN","HLOQUE",345,0)
 Q
"RTN","HLOQUE",346,0)
 ;
"RTN","HLOQUE",347,0)
SEQ(QUEARRAY) ;
"RTN","HLOQUE",348,0)
 ; Count messages on sequence queues
"RTN","HLOQUE",349,0)
 ;
"RTN","HLOQUE",350,0)
 I '$G(FLG) N TOTAL,INCNT,OUTCNT,SEQCNT,LINK,QUE,FLG
"RTN","HLOQUE",351,0)
 S QUE=""
"RTN","HLOQUE",352,0)
 S SEQCNT=0
"RTN","HLOQUE",353,0)
 F  S QUE=$O(^HLC("QUEUECOUNT","SEQUENCE",QUE)) Q:QUE=""  D
"RTN","HLOQUE",354,0)
 .  S SEQCNT=SEQCNT+^HLC("QUEUECOUNT","SEQUENCE",QUE)
"RTN","HLOQUE",355,0)
 .  S QUEARRAY("SEQ",QUE)=^HLC("QUEUECOUNT","SEQUENCE",QUE)
"RTN","HLOQUE",356,0)
 S QUEARRAY("SEQ")=^HLC("QUEUECOUNT","SEQUENCE")
"RTN","HLOQUE",357,0)
 I '$G(FLG) Q QUEARRAY("SEQ")
"RTN","HLOQUE",358,0)
 Q
"RTN","HLOQUE",359,0)
 ;
"RTN","HLOQUE",360,0)
 ; *** End HL*1.6*143 -  RBN ***
"RTN","HLOQUE",361,0)
 ;
"RTN","HLOQUE",362,0)
 ;** P147 START CJM
"RTN","HLOQUE",363,0)
RESETF(IEN) ;
"RTN","HLOQUE",364,0)
 ;resets the "F" index on the HLO Priority Queues file (#779.9) for
"RTN","HLOQUE",365,0)
 ;for record IEN
"RTN","HLOQUE",366,0)
 ;
"RTN","HLOQUE",367,0)
 N DA
"RTN","HLOQUE",368,0)
 S DA(1)=IEN
"RTN","HLOQUE",369,0)
 S DA=0
"RTN","HLOQUE",370,0)
 F  S DA=$O(^HLD(779.9,DA(1),1,DA)) Q:'DA  D
"RTN","HLOQUE",371,0)
 .N DATA
"RTN","HLOQUE",372,0)
 .S DATA(.01)=$P($G(^HLD(779.9,DA(1),1,DA,0)),"^")
"RTN","HLOQUE",373,0)
 .Q:DATA(.01)=""
"RTN","HLOQUE",374,0)
 .D UPD^HLOASUB1(779.91,.DA,.DATA)
"RTN","HLOQUE",375,0)
 Q
"RTN","HLOQUE",376,0)
 ;
"RTN","HLOQUE",377,0)
GETPRTY(QUEUE,LINK) ;
"RTN","HLOQUE",378,0)
 ;Inputs:
"RTN","HLOQUE",379,0)
 ;    QUEUE (required)
"RTN","HLOQUE",380,0)
 ;    LINK (required) the name of hte link, possibly with the port # appeded
"RTN","HLOQUE",381,0)
 ;
"RTN","HLOQUE",382,0)
 ;
"RTN","HLOQUE",383,0)
 N PRTY,LNK
"RTN","HLOQUE",384,0)
 S PRTY=0
"RTN","HLOQUE",385,0)
 S LNK=$P(LINK,":")
"RTN","HLOQUE",386,0)
 I $L(LNK) S PRTY=$G(^HLD(779.9,"F",QUEUE,"OUT",LNK))
"RTN","HLOQUE",387,0)
 I PRTY Q PRTY
"RTN","HLOQUE",388,0)
 S PRTY=$G(^HLD(779.9,"E",QUEUE,"OUT"))
"RTN","HLOQUE",389,0)
 Q:'PRTY 50
"RTN","HLOQUE",390,0)
 Q PRTY
"RTN","HLOQUE",391,0)
 ; 
"RTN","HLOQUE",392,0)
SETPRTY ;  User interface to set queue priority
"RTN","HLOQUE",393,0)
 ; 
"RTN","HLOQUE",394,0)
 N DIC,DA,DR,Y,DIE,QUEUE
"RTN","HLOQUE",395,0)
 S DIC="^HLD(779.9,"
"RTN","HLOQUE",396,0)
 S DIC(0)="QEAL"
"RTN","HLOQUE",397,0)
 S DIC("A")="Enter the name of an outgoing queue: "
"RTN","HLOQUE",398,0)
 S DIC("DR")=".01"
"RTN","HLOQUE",399,0)
 D ^DIC
"RTN","HLOQUE",400,0)
 I $G(DTOUT)!($G(DUOUT))!(Y=-1) D  Q
"RTN","HLOQUE",401,0)
 . K DIC,DA,DR,Y,DIE
"RTN","HLOQUE",402,0)
 S DA=+Y,QUEUE=$P(Y,"^",2)
"RTN","HLOQUE",403,0)
 I $$ASKYESNO^HLOUSR2("Do you want to set "_QUEUE_"'s priority for just one specific logical link","YES") D
"RTN","HLOQUE",404,0)
 .N DATA
"RTN","HLOQUE",405,0)
 .S DATA(.02)="OUT"
"RTN","HLOQUE",406,0)
 .D UPD^HLOASUB1(779.9,DA,.DATA)
"RTN","HLOQUE",407,0)
 .S DIC="^HLD(779.9,"_DA_",1,"
"RTN","HLOQUE",408,0)
 .S DA(1)=DA,DA=""
"RTN","HLOQUE",409,0)
 .S DIC("DR")=.02
"RTN","HLOQUE",410,0)
 .S DIC(0)="QEAL"
"RTN","HLOQUE",411,0)
 .S DIC("A")="Select the specific link: "
"RTN","HLOQUE",412,0)
 .D ^DIC
"RTN","HLOQUE",413,0)
 E  D
"RTN","HLOQUE",414,0)
 .N DATA
"RTN","HLOQUE",415,0)
 .S DATA(.02)="OUT"
"RTN","HLOQUE",416,0)
 .S DATA(.03)=1
"RTN","HLOQUE",417,0)
 .D UPD^HLOASUB1(779.9,DA,.DATA)
"RTN","HLOQUE",418,0)
 .S DIE="^HLD(779.9,"
"RTN","HLOQUE",419,0)
 .S DR=.04
"RTN","HLOQUE",420,0)
 .D ^DIE
"RTN","HLOQUE",421,0)
 Q
"RTN","HLOQUE",422,0)
SETP(QUEUE,PRIORITY,LINK) ;
"RTN","HLOQUE",423,0)
 ;Description: API for setting an outgoing queue's priority
"RTN","HLOQUE",424,0)
 ;Input:
"RTN","HLOQUE",425,0)
 ;   QUEUE (required) the name of the queue
"RTN","HLOQUE",426,0)
 ;   PRIORITY (required) the priority, 20-100
"RTN","HLOQUE",427,0)
 ;   LINK (optional) name or IEN of an HL Logical Link. If specified, 
"RTN","HLOQUE",428,0)
 ;                   the priority will be applied only to the specific
"RTN","HLOQUE",429,0)
 ;                   link, otherwise the priority will be applied to all
"RTN","HLOQUE",430,0)
 ;                   queues named QUEUE
"RTN","HLOQUE",431,0)
 ;Output:
"RTN","HLOQUE",432,0)
 ;     function returns 1 on success, 0 on failure
"RTN","HLOQUE",433,0)
 ;
"RTN","HLOQUE",434,0)
 N LINKIEN,DA,DATA
"RTN","HLOQUE",435,0)
 S LINKIEN=0
"RTN","HLOQUE",436,0)
 S PRIORITY=+$G(PRIORITY)
"RTN","HLOQUE",437,0)
 I $G(PRIORITY)<20 Q 0
"RTN","HLOQUE",438,0)
 I PRIORITY>100 Q 0
"RTN","HLOQUE",439,0)
 I '$L($G(QUEUE)) Q 0
"RTN","HLOQUE",440,0)
 I $L(QUEUE)>20 Q 0
"RTN","HLOQUE",441,0)
 I $L($G(LINK)) D  Q:'LINKIEN 0
"RTN","HLOQUE",442,0)
 .S LINKIEN=0
"RTN","HLOQUE",443,0)
 .I LINK,$D(^HLCS(870,LINK,0)) S LINKIEN=LINK Q
"RTN","HLOQUE",444,0)
 .S LINKIEN=$O(^HLCS(870,"B",LINK,0))
"RTN","HLOQUE",445,0)
 S DA=$O(^HLD(779.9,"B",QUEUE,0))
"RTN","HLOQUE",446,0)
 I 'DA D
"RTN","HLOQUE",447,0)
 .S DATA(.02)="OUT"
"RTN","HLOQUE",448,0)
 .S DATA(.01)=QUEUE
"RTN","HLOQUE",449,0)
 .I 'LINKIEN S DATA(.03)=1,DATA(.04)=PRIORITY
"RTN","HLOQUE",450,0)
 .S DA=$$ADD^HLOASUB1(779.9,,.DATA)
"RTN","HLOQUE",451,0)
 E  I 'LINKIEN D  Q $$UPD^HLOASUB1(779.9,DA,.DATA)
"RTN","HLOQUE",452,0)
 .S DATA(.02)="OUT"
"RTN","HLOQUE",453,0)
 .S DATA(.03)=1
"RTN","HLOQUE",454,0)
 .S DATA(.04)=PRIORITY
"RTN","HLOQUE",455,0)
 Q:'DA 0
"RTN","HLOQUE",456,0)
 Q:'LINKIEN 1
"RTN","HLOQUE",457,0)
 S DA(1)=DA
"RTN","HLOQUE",458,0)
 S DA=$O(^HLD(779.9,DA(1),1,"B",LINKIEN,0))
"RTN","HLOQUE",459,0)
 K DATA
"RTN","HLOQUE",460,0)
 S DATA(.01)=LINKIEN
"RTN","HLOQUE",461,0)
 S DATA(.02)=PRIORITY
"RTN","HLOQUE",462,0)
 I DA Q $$UPD^HLOASUB1(779.91,.DA,.DATA)
"RTN","HLOQUE",463,0)
 I $$ADD^HLOASUB1(779.91,.DA,.DATA,.ERROR) Q 1
"RTN","HLOQUE",464,0)
 Q 0
"RTN","HLOQUE",465,0)
 ;**P147 END CJM
"RTN","HLOQUE1")
1^9^^B78441748
"RTN","HLOQUE2")
1^11^^n/a
"RTN","HLOSITE")
0^20^B8246314^B6862294
"RTN","HLOSITE",1,0)
HLOSITE ;ALB/CJM/OAK/PIJ-HL7 - API for getting site parameters ;08/12/2010
"RTN","HLOSITE",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,138,147**;Oct 13, 1995;Build 15
"RTN","HLOSITE",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOSITE",4,0)
 ;
"RTN","HLOSITE",5,0)
SYSPARMS(SYSTEM) ;Gets system parameters from file 779.1
"RTN","HLOSITE",6,0)
 ;Input: none
"RTN","HLOSITE",7,0)
 ;Output:
"RTN","HLOSITE",8,0)
 ;
"RTN","HLOSITE",9,0)
 N NODE,LINK
"RTN","HLOSITE",10,0)
 S NODE=$G(^HLD(779.1,1,0))
"RTN","HLOSITE",11,0)
 S SYSTEM("DOMAIN")=$P(NODE,"^")
"RTN","HLOSITE",12,0)
 S SYSTEM("STATION")=$P(NODE,"^",2)
"RTN","HLOSITE",13,0)
 S SYSTEM("PROCESSING ID")=$P(NODE,"^",3)
"RTN","HLOSITE",14,0)
 S SYSTEM("MAXSTRING")=$P(NODE,"^",4)
"RTN","HLOSITE",15,0)
 I ('SYSTEM("MAXSTRING"))!(SYSTEM("MAXSTRING")<256) D
"RTN","HLOSITE",16,0)
 .N OS S OS=^%ZOSF("OS")
"RTN","HLOSITE",17,0)
 .S SYSTEM("MAXSTRING")=$S(OS["OpenM":512,OS["DSM":512,1:256)
"RTN","HLOSITE",18,0)
 S SYSTEM("HL7 BUFFER")=$P(NODE,"^",5)
"RTN","HLOSITE",19,0)
 S:'SYSTEM("HL7 BUFFER") SYSTEM("HL7 BUFFER")=15000
"RTN","HLOSITE",20,0)
 S SYSTEM("USER BUFFER")=$P(NODE,"^",6)
"RTN","HLOSITE",21,0)
 S:'SYSTEM("USER BUFFER") SYSTEM("USER BUFFER")=5000
"RTN","HLOSITE",22,0)
 S SYSTEM("NORMAL PURGE")=$P(NODE,"^",7)
"RTN","HLOSITE",23,0)
 I 'SYSTEM("NORMAL PURGE") S SYSTEM("NORMAL PURGE")=36
"RTN","HLOSITE",24,0)
 S SYSTEM("ERROR PURGE")=$P(NODE,"^",8)
"RTN","HLOSITE",25,0)
 I 'SYSTEM("ERROR PURGE") S SYSTEM("ERROR PURGE")=7
"RTN","HLOSITE",26,0)
 S LINK=$P(NODE,"^",10)
"RTN","HLOSITE",27,0)
 S:LINK SYSTEM("PORT")=$$PORT^HLOTLNK(LINK)
"RTN","HLOSITE",28,0)
 S:'$G(SYSTEM("PORT")) SYSTEM("PORT")=$S(SYSTEM("PROCESSING ID")="P":5001,1:5026)
"RTN","HLOSITE",29,0)
 S SYSTEM("NODE")=$P(NODE,"^",13)
"RTN","HLOSITE",30,0)
 I SYSTEM("NODE") S SYSTEM("NODE")=$P($G(^%ZIS(14.7,SYSTEM("NODE"),0)),"^")
"RTN","HLOSITE",31,0)
 Q
"RTN","HLOSITE",32,0)
 ;
"RTN","HLOSITE",33,0)
GETNODE() ;
"RTN","HLOSITE",34,0)
 N NODE
"RTN","HLOSITE",35,0)
 S NODE=$P($G(^HLD(779.1,1,0)),"^",13)
"RTN","HLOSITE",36,0)
 Q:NODE $P($G(^%ZIS(14.7,NODE,0)),"^")
"RTN","HLOSITE",37,0)
 Q ""
"RTN","HLOSITE",38,0)
 ;
"RTN","HLOSITE",39,0)
INC(VARIABLE,AMOUNT) ;
"RTN","HLOSITE",40,0)
 ;Increments VARIABLE by AMOUNT, using $I if available, otherwise by locking.
"RTN","HLOSITE",41,0)
 ;
"RTN","HLOSITE",42,0)
 N OS
"RTN","HLOSITE",43,0)
 ;if HLCSTATE has been defined, then we have already checked the OS, so use it.
"RTN","HLOSITE",44,0)
 I $D(HLCSTATE("SYSTEM","OS")) D
"RTN","HLOSITE",45,0)
 .S OS=HLCSTATE("SYSTEM","OS")
"RTN","HLOSITE",46,0)
 E  D
"RTN","HLOSITE",47,0)
 .S OS=^%ZOSF("OS")
"RTN","HLOSITE",48,0)
 I '$G(AMOUNT) S AMOUNT=1
"RTN","HLOSITE",49,0)
 I (OS["OpenM")!(OS["DSM")!(OS["CACHE") Q $I(@VARIABLE,AMOUNT)
"RTN","HLOSITE",50,0)
 L +VARIABLE:100
"RTN","HLOSITE",51,0)
 S @VARIABLE=@VARIABLE+AMOUNT
"RTN","HLOSITE",52,0)
 L -VARIABLE
"RTN","HLOSITE",53,0)
 Q @VARIABLE
"RTN","HLOSITE",54,0)
 ;
"RTN","HLOSITE",55,0)
COUNT778() ;
"RTN","HLOSITE",56,0)
 ;This function returns the # of records in file 778.
"RTN","HLOSITE",57,0)
 N COUNT,IEN
"RTN","HLOSITE",58,0)
 S (COUNT,IEN)=0
"RTN","HLOSITE",59,0)
 F  S IEN=$O(^HLB(IEN)) Q:'IEN  S COUNT=COUNT+1
"RTN","HLOSITE",60,0)
 Q COUNT
"RTN","HLOSITE",61,0)
COUNT777() ;
"RTN","HLOSITE",62,0)
 ;This function returns the # of records in file 777.
"RTN","HLOSITE",63,0)
 N COUNT,IEN
"RTN","HLOSITE",64,0)
 S (COUNT,IEN)=0
"RTN","HLOSITE",65,0)
 F  S IEN=$O(^HLA(IEN)) Q:'IEN  S COUNT=COUNT+1
"RTN","HLOSITE",66,0)
 Q COUNT
"RTN","HLOSITE",67,0)
 ;
"RTN","HLOSITE",68,0)
UPDCNTS ;update the record counts for file 777,778
"RTN","HLOSITE",69,0)
 N COUNT
"RTN","HLOSITE",70,0)
 S COUNT=$$COUNT777^HLOSITE
"RTN","HLOSITE",71,0)
 S $P(^HLA(0),"^",4)=COUNT
"RTN","HLOSITE",72,0)
 S ^HLTMP("FILE 777 RECORD COUNT")=COUNT_"^"_$$NOW^XLFDT
"RTN","HLOSITE",73,0)
 S COUNT=$$COUNT778^HLOSITE
"RTN","HLOSITE",74,0)
 S $P(^HLB(0),"^",4)=COUNT
"RTN","HLOSITE",75,0)
 S ^HLTMP("FILE 778 RECORD COUNT")=COUNT_"^"_$$NOW^XLFDT
"RTN","HLOSITE",76,0)
 Q
"RTN","HLOSITE",77,0)
 ;;HL*1.6*138 start PIJ 10/26/2007
"RTN","HLOSITE",78,0)
RCNT(ST) ;This section sets or reads the recount flag.
"RTN","HLOSITE",79,0)
 ;; When ST="S" Flag is set
"RTN","HLOSITE",80,0)
 ;; When ST="U" Flag is unset
"RTN","HLOSITE",81,0)
 I $G(ST)="S" S $P(^HLD(779.1,1,0),"^",11)=1
"RTN","HLOSITE",82,0)
 I $G(ST)="U" S $P(^HLD(779.1,1,0),"^",11)=0
"RTN","HLOSITE",83,0)
 Q $P($G(^HLD(779.1,1,0)),"^",11)
"RTN","HLOSITE",84,0)
 ;;HL*1.6*138 end
"RTN","HLOSITE",85,0)
OLDPURGE() ;returns the retention time in days for unsent messages
"RTN","HLOSITE",86,0)
 N TIME
"RTN","HLOSITE",87,0)
 S TIME=$P($G(^HLD(779.1,1,0)),"^",12)
"RTN","HLOSITE",88,0)
 Q $S(TIME:TIME,1:45)
"RTN","HLOSRVR")
0^18^B84093197^B84549527
"RTN","HLOSRVR",1,0)
HLOSRVR ;ALB/CJM/OAK/PIJ- Server for receiving messages - 10/4/94 1pm ;04/08/2010
"RTN","HLOSRVR",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,130,131,134,137,138,139,143,147**;Oct 13, 1995;Build 15
"RTN","HLOSRVR",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOSRVR",4,0)
 ;
"RTN","HLOSRVR",5,0)
GETWORK(WORK) ;
"RTN","HLOSRVR",6,0)
 ;GET WORK function for a single server or a Taskman multi-server
"RTN","HLOSRVR",7,0)
 N LINK
"RTN","HLOSRVR",8,0)
 I '$$CHKSTOP^HLOPROC,$G(WORK("LINK"))]"",$$GETLINK^HLOTLNK(WORK("LINK"),.LINK),+LINK("SERVER") S WORK("PORT")=LINK("PORT") Q 1
"RTN","HLOSRVR",9,0)
 Q 0
"RTN","HLOSRVR",10,0)
 ;
"RTN","HLOSRVR",11,0)
DOWORKS(WORK) ;
"RTN","HLOSRVR",12,0)
 ;DO WORK rtn for a single server (non-concurrent)
"RTN","HLOSRVR",13,0)
 N $ETRAP,$ESTACK
"RTN","HLOSRVR",14,0)
 S $ETRAP="G ERROR^HLOSRVR3"
"RTN","HLOSRVR",15,0)
 D SERVER(WORK("LINK"))
"RTN","HLOSRVR",16,0)
 Q
"RTN","HLOSRVR",17,0)
DOWORKM(WORK) ;
"RTN","HLOSRVR",18,0)
 ;DO WORK rtn for a Taskman multi-server (Cache systems only)
"RTN","HLOSRVR",19,0)
 D LISTEN^%ZISTCPS(WORK("PORT"),"SERVER^HLOSRVR("""_WORK("LINK")_""")")
"RTN","HLOSRVR",20,0)
 Q
"RTN","HLOSRVR",21,0)
 ;
"RTN","HLOSRVR",22,0)
VMS2(LINKNAME) ;called from a VMS TCP Service once a connection request has been received.  This entry point should be used only if an additional VMS TCPIP Services are being created for HLO.
"RTN","HLOSRVR",23,0)
 ;Input:
"RTN","HLOSRVR",24,0)
 ;   LINKNAME - only pass it in if an additional service is being created on a different port
"RTN","HLOSRVR",25,0)
 Q:'$L(LINKNAME)
"RTN","HLOSRVR",26,0)
 D VMS
"RTN","HLOSRVR",27,0)
 Q
"RTN","HLOSRVR",28,0)
 ;
"RTN","HLOSRVR",29,0)
VMS ;Called from VMS TCP Service once a connection request has been received. This entry point should be used only by the standard HLO service that runs on the standard HLO port.
"RTN","HLOSRVR",30,0)
 Q:$$CHKSTOP^HLOPROC
"RTN","HLOSRVR",31,0)
 D
"RTN","HLOSRVR",32,0)
 .Q:$L($G(LINKNAME))
"RTN","HLOSRVR",33,0)
 .;
"RTN","HLOSRVR",34,0)
 .N PROC,NODE
"RTN","HLOSRVR",35,0)
 .S PROC=$O(^HLD(779.3,"B","VMS TCP LISTENER",0))
"RTN","HLOSRVR",36,0)
 .I PROC S LINKNAME=$P($G(^HLD(779.3,PROC,0)),"^",14) Q:$L(LINKNAME)
"RTN","HLOSRVR",37,0)
 .S NODE=$G(^HLD(779.1,1,0)) I $P(NODE,"^",10) S LINKNAME=$P($G(^HLCS(870,$P(NODE,"^",10),0)),"^") Q:$L(LINKNAME) 
"RTN","HLOSRVR",38,0)
 .S LINKNAME="HLO DEFAULT LISTENER"
"RTN","HLOSRVR",39,0)
 ;
"RTN","HLOSRVR",40,0)
 D SERVER(LINKNAME,"SYS$NET")
"RTN","HLOSRVR",41,0)
 Q
"RTN","HLOSRVR",42,0)
 ;
"RTN","HLOSRVR",43,0)
SERVER(LINKNAME,LOGICAL) ; LINKNAME identifies the logical link, which describes the communication channel to be used
"RTN","HLOSRVR",44,0)
 ;;Start HL*1.6*138 PIJ
"RTN","HLOSRVR",45,0)
 ;;N $ETRAP,$ESTACK S $ETRAP="G ERROR^HLOSRVR1"
"RTN","HLOSRVR",46,0)
 N $ETRAP,$ESTACK S $ETRAP="G ERROR^HLOSRVR3"
"RTN","HLOSRVR",47,0)
 ;;End HL*1.6*138 PIJ
"RTN","HLOSRVR",48,0)
 N HLCSTATE,INQUE
"RTN","HLOSRVR",49,0)
 S INQUE=0
"RTN","HLOSRVR",50,0)
 ;
"RTN","HLOSRVR",51,0)
ZB1 ;
"RTN","HLOSRVR",52,0)
 ;
"RTN","HLOSRVR",53,0)
 Q:'$$CONNECT(.HLCSTATE,LINKNAME,.LOGICAL)
"RTN","HLOSRVR",54,0)
 ;
"RTN","HLOSRVR",55,0)
 K LINKNAME
"RTN","HLOSRVR",56,0)
 F  Q:'HLCSTATE("CONNECTED")  D  Q:$$CHKSTOP^HLOPROC
"RTN","HLOSRVR",57,0)
 .N HLMSTATE,SENT
"RTN","HLOSRVR",58,0)
 .;read msg and parse the hdr
"RTN","HLOSRVR",59,0)
 .;HLMSTATE("MSA",1) is set with type of ack to return
"RTN","HLOSRVR",60,0)
 .;
"RTN","HLOSRVR",61,0)
 .I $$READMSG^HLOSRVR1(.HLCSTATE,.HLMSTATE) D
"RTN","HLOSRVR",62,0)
 ..I (HLMSTATE("MSA",1)]"") S SENT=$$WRITEACK(.HLCSTATE,.HLMSTATE) D:HLMSTATE("IEN") SAVEACK(.HLMSTATE,SENT)
"RTN","HLOSRVR",63,0)
 ..;
"RTN","HLOSRVR",64,0)
 ..;** P143 START CJM **
"RTN","HLOSRVR",65,0)
 ..I HLMSTATE("ID")'="" L -HLO("MSGID",HLMSTATE("ID"))
"RTN","HLOSRVR",66,0)
 ..;** P143 END CJM **
"RTN","HLOSRVR",67,0)
 ..;
"RTN","HLOSRVR",68,0)
 ..D:HLMSTATE("IEN") UPDATE(.HLMSTATE,.HLCSTATE)
"RTN","HLOSRVR",69,0)
 ..D:HLCSTATE("COUNTS")>4 SAVECNTS^HLOSTAT(.HLCSTATE)
"RTN","HLOSRVR",70,0)
 ..I $G(HLMSTATE("ACK TO","IEN")),$L($G(HLMSTATE("ACK TO","SEQUENCE QUEUE"))) D ADVANCE^HLOQUE(HLMSTATE("ACK TO","SEQUENCE QUEUE"),+HLMSTATE("ACK TO","IEN"))
"RTN","HLOSRVR",71,0)
 .E  D
"RTN","HLOSRVR",72,0)
 ..;** P143 START CJM **
"RTN","HLOSRVR",73,0)
 ..I $G(HLMSTATE("ID"))'="" L -HLO("MSGID",HLMSTATE("ID"))
"RTN","HLOSRVR",74,0)
 ..;** P143 END CJM **
"RTN","HLOSRVR",75,0)
 ..D INQUE() H:HLCSTATE("CONNECTED") 1
"RTN","HLOSRVR",76,0)
 ;
"RTN","HLOSRVR",77,0)
END D CLOSE^HLOT(.HLCSTATE)
"RTN","HLOSRVR",78,0)
 D INQUE()
"RTN","HLOSRVR",79,0)
 D SAVECNTS^HLOSTAT(.HLCSTATE)
"RTN","HLOSRVR",80,0)
 Q
"RTN","HLOSRVR",81,0)
 ;
"RTN","HLOSRVR",82,0)
CONNECT(HLCSTATE,LINKNAME,LOGICAL) ;
"RTN","HLOSRVR",83,0)
 ;sets up HLCSTATE() and opens a server connection
"RTN","HLOSRVR",84,0)
 ;
"RTN","HLOSRVR",85,0)
 N LINK,NODE
"RTN","HLOSRVR",86,0)
 S HLCSTATE("CONNECTED")=0
"RTN","HLOSRVR",87,0)
 Q:'$$GETLINK^HLOTLNK(LINKNAME,.LINK) 0
"RTN","HLOSRVR",88,0)
ZB999 ; 
"RTN","HLOSRVR",89,0)
 Q:+LINK("SERVER")'=1 0
"RTN","HLOSRVR",90,0)
 S HLCSTATE("SERVER")=LINK("SERVER")
"RTN","HLOSRVR",91,0)
 M HLCSTATE("LINK")=LINK
"RTN","HLOSRVR",92,0)
 S HLCSTATE("READ TIMEOUT")=20
"RTN","HLOSRVR",93,0)
 S HLCSTATE("OPEN TIMEOUT")=30
"RTN","HLOSRVR",94,0)
 S HLCSTATE("READ")="" ;buffer for reads
"RTN","HLOSRVR",95,0)
 ;
"RTN","HLOSRVR",96,0)
 ;HLCSTATE("BUFFER",<seg>,<line>)  write buffer
"RTN","HLOSRVR",97,0)
 S HLCSTATE("BUFFER","BYTE COUNT")=0 ;count of bytes in buffer
"RTN","HLOSRVR",98,0)
 S HLCSTATE("BUFFER","SEGMENT COUNT")=0 ;count of segments in buffer
"RTN","HLOSRVR",99,0)
 ;
"RTN","HLOSRVR",100,0)
 S HLCSTATE("COUNTS")=0
"RTN","HLOSRVR",101,0)
 S HLCSTATE("MESSAGE STARTED")=0 ;start of message flag
"RTN","HLOSRVR",102,0)
 S HLCSTATE("MESSAGE ENDED")=0 ;end of message flag
"RTN","HLOSRVR",103,0)
 S NODE=^%ZOSF("OS")
"RTN","HLOSRVR",104,0)
 S HLCSTATE("SYSTEM","OS")=$S(NODE["DSM":"DSM",NODE["OpenM":"CACHE",NODE["G.TM":"G.TM",1:"")
"RTN","HLOSRVR",105,0)
 Q:HLCSTATE("SYSTEM","OS")="" 0
"RTN","HLOSRVR",106,0)
 D  ;get necessary system parameters
"RTN","HLOSRVR",107,0)
 .N SYS,SUB
"RTN","HLOSRVR",108,0)
 .D SYSPARMS^HLOSITE(.SYS)
"RTN","HLOSRVR",109,0)
 .F SUB="MAXSTRING","DOMAIN","STATION","PROCESSING ID","NORMAL PURGE","ERROR PURGE" S HLCSTATE("SYSTEM",SUB)=SYS(SUB)
"RTN","HLOSRVR",110,0)
 .S HLCSTATE("SYSTEM","BUFFER")=SYS("HL7 BUFFER")
"RTN","HLOSRVR",111,0)
 I HLCSTATE("LINK","LLP")="TCP" D
"RTN","HLOSRVR",112,0)
 .D OPEN^HLOTCP(.HLCSTATE,.LOGICAL)
"RTN","HLOSRVR",113,0)
 E  ;no other LLP implemented
"RTN","HLOSRVR",114,0)
 ;
"RTN","HLOSRVR",115,0)
 Q HLCSTATE("CONNECTED")
"RTN","HLOSRVR",116,0)
 ;
"RTN","HLOSRVR",117,0)
INQUE(MSGIEN,PARMS) ;
"RTN","HLOSRVR",118,0)
 ;
"RTN","HLOSRVR",119,0)
 ;** do not implement the Pass Immediate parameter **
"RTN","HLOSRVR",120,0)
 ;INQUE(MSGIEN,PARMS,IMMEDIATE);
"RTN","HLOSRVR",121,0)
 ;
"RTN","HLOSRVR",122,0)
 ;puts received messages on the incoming queue and sets the B x-ref
"RTN","HLOSRVR",123,0)
 I $G(MSGIEN) S INQUE=INQUE+1 M INQUE(MSGIEN)=PARMS
"RTN","HLOSRVR",124,0)
 ;
"RTN","HLOSRVR",125,0)
 ;** do not implement the Pass Immediate parameter **
"RTN","HLOSRVR",126,0)
 ;I ('$G(MSGIEN))!(INQUE>20)!($G(IMMEDIATE)) S MSGIEN=0 D
"RTN","HLOSRVR",127,0)
 ;
"RTN","HLOSRVR",128,0)
 I ('$G(MSGIEN))!(INQUE>20) S MSGIEN=0 D
"RTN","HLOSRVR",129,0)
 .F  S MSGIEN=$O(INQUE(MSGIEN)) Q:'MSGIEN  D
"RTN","HLOSRVR",130,0)
 ..S ^HLB("B",INQUE(MSGIEN,"MSGID"),MSGIEN)=""
"RTN","HLOSRVR",131,0)
 ..S ^HLA("B",INQUE(MSGIEN,"DT/TM"),INQUE(MSGIEN,"BODY"))=""
"RTN","HLOSRVR",132,0)
 ..D:INQUE(MSGIEN,"PASS")
"RTN","HLOSRVR",133,0)
 ...N PURGE
"RTN","HLOSRVR",134,0)
 ...S PURGE=+$G(INQUE(MSGIEN,"PURGE"))
"RTN","HLOSRVR",135,0)
 ...S PURGE("ACKTOIEN")=$G(INQUE(MSGIEN,"ACKTOIEN"))
"RTN","HLOSRVR",136,0)
 ...D INQUE^HLOQUE(INQUE(MSGIEN,"FROM"),INQUE(MSGIEN,"QUEUE"),MSGIEN,INQUE(MSGIEN,"ACTION"),.PURGE)
"RTN","HLOSRVR",137,0)
 .K INQUE S INQUE=0
"RTN","HLOSRVR",138,0)
 Q
"RTN","HLOSRVR",139,0)
 ;
"RTN","HLOSRVR",140,0)
SAVEACK(HLMSTATE,SENT) ;
"RTN","HLOSRVR",141,0)
 ;Input:
"RTN","HLOSRVR",142,0)
 ;  SENT - flag = 1 if transmission of ack succeeded, 0 otherwise
"RTN","HLOSRVR",143,0)
 ;
"RTN","HLOSRVR",144,0)
 N NODE,I,XX
"RTN","HLOSRVR",145,0)
 S $P(NODE,"^")=HLMSTATE("MSA","DT/TM OF MESSAGE")
"RTN","HLOSRVR",146,0)
 S $P(NODE,"^",2)=HLMSTATE("MSA","MESSAGE CONTROL ID")
"RTN","HLOSRVR",147,0)
 S $P(NODE,"^",3)="MSA"
"RTN","HLOSRVR",148,0)
 F I=1:1:3 S NODE=NODE_"|"_$G(HLMSTATE("MSA",I))
"RTN","HLOSRVR",149,0)
 S ^HLB(HLMSTATE("IEN"),4)=NODE
"RTN","HLOSRVR",150,0)
 S:SENT $P(^HLB(HLMSTATE("IEN"),0),"^",$S($E(HLMSTATE("MSA",1))="A":18,1:17))=1
"RTN","HLOSRVR",151,0)
 Q
"RTN","HLOSRVR",152,0)
 ;
"RTN","HLOSRVR",153,0)
UPDATE(HLMSTATE,HLCSTATE) ;
"RTN","HLOSRVR",154,0)
 ;Updates status and purge date when appropriate
"RTN","HLOSRVR",155,0)
 ;Also, sets the "B" xrefs, files 777,778, and places message on the incoming queue
"RTN","HLOSRVR",156,0)
 ;
"RTN","HLOSRVR",157,0)
 N PARMS,PURGE,WAIT
"RTN","HLOSRVR",158,0)
 S PARMS("PASS")=0
"RTN","HLOSRVR",159,0)
 I HLMSTATE("STATUS","ACTION")]"",HLMSTATE("STATUS")'="ER" D
"RTN","HLOSRVR",160,0)
 .N IEN
"RTN","HLOSRVR",161,0)
 .S IEN=HLMSTATE("IEN")
"RTN","HLOSRVR",162,0)
 .S PARMS("PASS")=1,$P(^HLB(IEN,0),"^",6)=HLMSTATE("STATUS","QUEUE"),$P(^HLB(IEN,0),"^",10)=$P(HLMSTATE("STATUS","ACTION"),"^"),$P(^HLB(IEN,0),"^",11)=$P(HLMSTATE("STATUS","ACTION"),"^",2)
"RTN","HLOSRVR",163,0)
 D:'PARMS("PASS")  ;if not passing to the app, set the purge date
"RTN","HLOSRVR",164,0)
 .I HLMSTATE("STATUS")="" S HLMSTATE("STATUS")="SU"
"RTN","HLOSRVR",165,0)
 .S:HLMSTATE("BATCH") WAIT=HLCSTATE("SYSTEM","ERROR PURGE")
"RTN","HLOSRVR",166,0)
 .S:'HLMSTATE("BATCH") WAIT=$S(($G(HLMSTATE("ACK TO","STATUS"))="ER"):24*HLCSTATE("SYSTEM","ERROR PURGE"),HLMSTATE("STATUS")="ER":24*HLCSTATE("SYSTEM","ERROR PURGE"),1:HLCSTATE("SYSTEM","NORMAL PURGE"))
"RTN","HLOSRVR",167,0)
 .S PURGE=$$FMADD^XLFDT($$NOW^XLFDT,,WAIT)
"RTN","HLOSRVR",168,0)
 .S $P(^HLB(HLMSTATE("IEN"),0),"^",9)=PURGE
"RTN","HLOSRVR",169,0)
 .S ^HLB("AD","IN",PURGE,HLMSTATE("IEN"))=""
"RTN","HLOSRVR",170,0)
 .;if this is an app ack, purge the original message at the same time
"RTN","HLOSRVR",171,0)
 .I $G(HLMSTATE("ACK TO","IEN")),'HLMSTATE("BATCH") D
"RTN","HLOSRVR",172,0)
 ..S $P(^HLB(+HLMSTATE("ACK TO","IEN"),0),"^",9)=PURGE
"RTN","HLOSRVR",173,0)
 ..S ^HLB("AD","IN",PURGE,+HLMSTATE("ACK TO","IEN"))=""
"RTN","HLOSRVR",174,0)
 ;
"RTN","HLOSRVR",175,0)
 ;if not waiting for an application ack, set the status now even if passing to the app - but don't set the purge until the infiler passes the message
"RTN","HLOSRVR",176,0)
 I HLMSTATE("STATUS")="",($G(HLMSTATE("ACK TO","IEN"))!HLMSTATE("HDR","APP ACK TYPE")'="AL") S HLMSTATE("STATUS")="SU"
"RTN","HLOSRVR",177,0)
 I HLMSTATE("STATUS")'="" S $P(^HLB(HLMSTATE("IEN"),0),"^",20)=HLMSTATE("STATUS") S:$G(HLMSTATE("MSA",3))]"" $P(^HLB(HLMSTATE("IEN"),0),"^",21)=HLMSTATE("MSA",3) D:HLMSTATE("STATUS")'="SU"
"RTN","HLOSRVR",178,0)
 .N APP
"RTN","HLOSRVR",179,0)
 .S APP=HLMSTATE("HDR","RECEIVING APPLICATION") S:APP="" APP="UNKNOWN" S ^HLB("ERRORS",APP,HLMSTATE("DT/TM"),HLMSTATE("IEN"))=""
"RTN","HLOSRVR",180,0)
 .D COUNT^HLOESTAT("IN",$G(HLMSTATE("HDR","RECEIVING APPLICATION")),$G(HLMSTATE("HDR","SENDING APPLICATION")),$S(HLMSTATE("BATCH"):"BATCH",1:$G(HLMSTATE("HDR","MESSAGE TYPE"))),$G(HLMSTATE("HDR","EVENT")))
"RTN","HLOSRVR",181,0)
 ;
"RTN","HLOSRVR",182,0)
 ;set the necessary parms for passing the msg to the app via the infiler
"RTN","HLOSRVR",183,0)
 D:PARMS("PASS")
"RTN","HLOSRVR",184,0)
 .N I,FROM
"RTN","HLOSRVR",185,0)
 .S FROM=HLMSTATE("HDR","SENDING FACILITY",1)
"RTN","HLOSRVR",186,0)
 .I HLMSTATE("HDR","SENDING FACILITY",2)]"" S FROM=FROM_"~"_HLMSTATE("HDR","SENDING FACILITY",2)_"~"_HLMSTATE("HDR","SENDING FACILITY",3)
"RTN","HLOSRVR",187,0)
 .I FROM="" S FROM="UNKNOWN SENDING FACILITY"
"RTN","HLOSRVR",188,0)
 .S PARMS("FROM")=FROM,PARMS("QUEUE")=HLMSTATE("STATUS","QUEUE"),PARMS("ACTION")=HLMSTATE("STATUS","ACTION")
"RTN","HLOSRVR",189,0)
 .I HLMSTATE("STATUS")'="" S PARMS("PURGE")=$S(HLMSTATE("STATUS")="ER":2,$G(HLMSTATE("ACK TO","STATUS"))="ER":2,1:1)
"RTN","HLOSRVR",190,0)
 .S:$G(HLMSTATE("ACK TO","IEN")) PARMS("ACKTOIEN")=HLMSTATE("ACK TO","IEN") ;to insure that the infiler will know to set the purge date at the same time as the initial message
"RTN","HLOSRVR",191,0)
 ;
"RTN","HLOSRVR",192,0)
 S PARMS("BODY")=HLMSTATE("BODY")
"RTN","HLOSRVR",193,0)
 S PARMS("DT/TM")=HLMSTATE("DT/TM")
"RTN","HLOSRVR",194,0)
 S PARMS("MSGID")=HLMSTATE("ID")
"RTN","HLOSRVR",195,0)
 ;
"RTN","HLOSRVR",196,0)
 ;** do not implement the Pass Immediate parameter **
"RTN","HLOSRVR",197,0)
 ;D INQUE(HLMSTATE("IEN"),.PARMS,$G(HLMSTATE("STATUS","PASS IMMEDIATE")))
"RTN","HLOSRVR",198,0)
 ;
"RTN","HLOSRVR",199,0)
 D INQUE(HLMSTATE("IEN"),.PARMS)
"RTN","HLOSRVR",200,0)
 Q
"RTN","HLOSRVR",201,0)
 ;
"RTN","HLOSRVR",202,0)
WRITEACK(HLCSTATE,HLMSTATE) ;
"RTN","HLOSRVR",203,0)
 ;Sends an accept ack
"RTN","HLOSRVR",204,0)
 ;
"RTN","HLOSRVR",205,0)
 ;Input:
"RTN","HLOSRVR",206,0)
 ;  HLCSTATE (pass by reference) defines the communication channel
"RTN","HLOSRVR",207,0)
 ;  HLMSTATE (pass by reference) the message being acked
"RTN","HLOSRVR",208,0)
 ;     ("MSA",1) - value for MSA-1
"RTN","HLOSRVR",209,0)
 ;     ("MSA",2) - value for MSA-2
"RTN","HLOSRVR",210,0)
 ;     ("MSA",3) - value for MSA-3
"RTN","HLOSRVR",211,0)
 ;     ("HDR") - parsed values for the message being ack'd
"RTN","HLOSRVR",212,0)
 ;Output:
"RTN","HLOSRVR",213,0)
 ;  Function returns 1 if successful, 0 otherwise
"RTN","HLOSRVR",214,0)
 ;  HLMSTATE("MSA","MESSAGE CONTROL ID") - the msg id of the ack
"RTN","HLOSRVR",215,0)
 ;  HLMSTATE(,"MSA","DT/TM OF MESSAGE") - from the ack header
"RTN","HLOSRVR",216,0)
 ; 
"RTN","HLOSRVR",217,0)
 N HDR,SUB,FS,CS,MSA,ACKID,TIME
"RTN","HLOSRVR",218,0)
 ;Hard-code the delimiters, the standard requires that the receiving system accept the delimiters listed in the header
"RTN","HLOSRVR",219,0)
 S FS="|"
"RTN","HLOSRVR",220,0)
 S CS="^"
"RTN","HLOSRVR",221,0)
 S TIME=$$NOW^XLFDT
"RTN","HLOSRVR",222,0)
 S HLMSTATE("MSA","DT/TM OF MESSAGE")=TIME
"RTN","HLOSRVR",223,0)
 S ACKID=HLCSTATE("SYSTEM","STATION")_" "_$$NEWIEN^HLOF778A("OUT")
"RTN","HLOSRVR",224,0)
 S HLMSTATE("MSA","MESSAGE CONTROL ID")=ACKID
"RTN","HLOSRVR",225,0)
 ;
"RTN","HLOSRVR",226,0)
 S HDR(1)="MSH"_FS_"^~\&"_FS_HLMSTATE("HDR","RECEIVING APPLICATION")_FS_HLCSTATE("SYSTEM","STATION")_CS_HLCSTATE("SYSTEM","DOMAIN")_CS_"DNS"_FS
"RTN","HLOSRVR",227,0)
 S HDR(1)=HDR(1)_HLMSTATE("HDR","SENDING APPLICATION")_FS_HLMSTATE("HDR","SENDING FACILITY",1)_CS_HLMSTATE("HDR","SENDING FACILITY",2)_CS_HLMSTATE("HDR","SENDING FACILITY",3)
"RTN","HLOSRVR",228,0)
 ;
"RTN","HLOSRVR",229,0)
 S HDR(2)=FS_$$HLDATE^HLFNC(TIME,"TS")_FS_FS_"ACK"_FS_ACKID_FS_HLMSTATE("HDR","PROCESSING ID")_FS_"2.4"_FS_FS_FS_"NE"_FS_"NE"
"RTN","HLOSRVR",230,0)
 ;
"RTN","HLOSRVR",231,0)
 S MSA(1)="MSA"_FS
"RTN","HLOSRVR",232,0)
 F SUB=1:1:3 S MSA(1)=MSA(1)_HLMSTATE("MSA",SUB)_FS
"RTN","HLOSRVR",233,0)
 I $$WRITEHDR^HLOT(.HLCSTATE,.HDR),$$WRITESEG^HLOT(.HLCSTATE,.MSA),$$ENDMSG^HLOT(.HLCSTATE) S HLCSTATE("COUNTS","ACKS")=$G(HLCSTATE("COUNTS","ACKS"))+1 Q 1
"RTN","HLOSRVR",234,0)
 S HLMSTATE("MSA","DT/TM OF MESSAGE")=""
"RTN","HLOSRVR",235,0)
 Q 0
"RTN","HLOSRVR1")
0^23^B86348500^B86429474
"RTN","HLOSRVR1",1,0)
HLOSRVR1 ;IRMFO-ALB/CJM/OAK/PIJ - Reading messages, sending acks;03/24/2004  14:43 ;07/28/2009
"RTN","HLOSRVR1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,130,131,133,134,137,138,139,143,146,147**;Oct 13, 1995;Build 15
"RTN","HLOSRVR1",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOSRVR1",4,0)
 ;
"RTN","HLOSRVR1",5,0)
READMSG(HLCSTATE,HLMSTATE) ;
"RTN","HLOSRVR1",6,0)
 ;Reads a message.  The header is parsed. Does these checks:
"RTN","HLOSRVR1",7,0)
 ; 1) Duplicate?
"RTN","HLOSRVR1",8,0)
 ; 2) Wrong Receiving Facility?
"RTN","HLOSRVR1",9,0)
 ; 3) Can the Receiving App accept this message, based message type & event?
"RTN","HLOSRVR1",10,0)
 ; 4) Processing ID must match the receiving system
"RTN","HLOSRVR1",11,0)
 ; 5) Must have an ID
"RTN","HLOSRVR1",12,0)
 ; 6) Header must be BHS or MSH
"RTN","HLOSRVR1",13,0)
 ;
"RTN","HLOSRVR1",14,0)
 ;Output:
"RTN","HLOSRVR1",15,0)
 ;  Function returns 1 if the message was read fully, 0 otherwise
"RTN","HLOSRVR1",16,0)
 ;  HLMSTATE (pass by reference) the message.  It will include the fields for the return ack in HLMSTATE("MSA")
"RTN","HLOSRVR1",17,0)
 ;
"RTN","HLOSRVR1",18,0)
 N ACK,SEG,STORE,I
"RTN","HLOSRVR1",19,0)
 ;
"RTN","HLOSRVR1",20,0)
 S STORE=1
"RTN","HLOSRVR1",21,0)
 Q:'$$READHDR^HLOT(.HLCSTATE,.SEG) 0
"RTN","HLOSRVR1",22,0)
 D SPLITHDR(.SEG)
"RTN","HLOSRVR1",23,0)
 ;
"RTN","HLOSRVR1",24,0)
 ;parse the header, stop if unsuccessful because the server cannot know what to do next
"RTN","HLOSRVR1",25,0)
 I '$$PARSEHDR^HLOPRS(.SEG) D  Q 0
"RTN","HLOSRVR1",26,0)
ZB29 .S HLCSTATE("MESSAGE ENDED")=0
"RTN","HLOSRVR1",27,0)
 .D CLOSE^HLOT(.HLCSTATE)
"RTN","HLOSRVR1",28,0)
 ;
"RTN","HLOSRVR1",29,0)
 ;** P143 START CJM**
"RTN","HLOSRVR1",30,0)
 S I=$S(SEG("SEGMENT TYPE")="MSH":$G(SEG("MESSAGE CONTROL ID")),1:$G(SEG("BATCH CONTROL ID")))
"RTN","HLOSRVR1",31,0)
 I I'="" L +HLO("MSGID",I):5 I '$T D  Q 0
"RTN","HLOSRVR1",32,0)
 .S HLCSTATE("MESSAGE ENDED")=0
"RTN","HLOSRVR1",33,0)
 .D CLOSE^HLOT(.HLCSTATE)
"RTN","HLOSRVR1",34,0)
 ;** P143 END CJM
"RTN","HLOSRVR1",35,0)
 ;
"RTN","HLOSRVR1",36,0)
 D NEWMSG^HLOSRVR2(.HLCSTATE,.HLMSTATE,.SEG)
"RTN","HLOSRVR1",37,0)
 I HLMSTATE("ID")="" D
"RTN","HLOSRVR1",38,0)
 .S STORE=0
"RTN","HLOSRVR1",39,0)
 .I HLMSTATE("HDR","ACCEPT ACK TYPE")="AL" S HLMSTATE("MSA",1)="CE",HLMSTATE("MSA",3)="CONTROL ID MISSING"
"RTN","HLOSRVR1",40,0)
 I STORE,$$DUP(.HLMSTATE) D
"RTN","HLOSRVR1",41,0)
ZB30 .S STORE=0
"RTN","HLOSRVR1",42,0)
 ;
"RTN","HLOSRVR1",43,0)
 ;if the message is not to be stored, just read it and discard the segments
"RTN","HLOSRVR1",44,0)
 I 'STORE D
"RTN","HLOSRVR1",45,0)
 .F  Q:'$$READSEG^HLOT(.HLCSTATE,.SEG)
"RTN","HLOSRVR1",46,0)
 ;
"RTN","HLOSRVR1",47,0)
 E  D
"RTN","HLOSRVR1",48,0)
 .N FS,NEWMSGID
"RTN","HLOSRVR1",49,0)
 .S NEWMSGID=""
"RTN","HLOSRVR1",50,0)
 .S FS=HLMSTATE("HDR","FIELD SEPARATOR")
"RTN","HLOSRVR1",51,0)
 .F  Q:'$$READSEG^HLOT(.HLCSTATE,.SEG)  D
"RTN","HLOSRVR1",52,0)
 ..N MSA,SEGTYPE,OLDMSGID,CODE,IEN,TEXT
"RTN","HLOSRVR1",53,0)
 ..S SEGTYPE=$E($E(SEG(1),1,3)_$E($G(SEG(2)),1,2),1,3)
"RTN","HLOSRVR1",54,0)
 ..I SEGTYPE="MSA" D
"RTN","HLOSRVR1",55,0)
 ...S MSA=SEG(1)_$G(SEG(2))_$G(SEG(3))
"RTN","HLOSRVR1",56,0)
 ...;; ** Start HL*1.6*138 PIJ **
"RTN","HLOSRVR1",57,0)
 ...;;S OLDMSGID=$P(MSA,FS,3),CODE=$P(MSA,FS,2),TEXT=$E($P(MSA,FS,4),1,30)
"RTN","HLOSRVR1",58,0)
 ...S OLDMSGID=$P(MSA,FS,3),CODE=$P(MSA,FS,2)
"RTN","HLOSRVR1",59,0)
 ...S TEXT=$$ESCAPE^HLOPBLD(.HLMSTATE,$P(MSA,FS,4))
"RTN","HLOSRVR1",60,0)
 ...;; ** End HL*1.6*138 **
"RTN","HLOSRVR1",61,0)
 ...I $E(CODE,1)'="A" S SEGTYPE="" Q
"RTN","HLOSRVR1",62,0)
 ...;** P143 START CJM
"RTN","HLOSRVR1",63,0)
 ...;S:$P(OLDMSGID,"-")]"" IEN=$O(^HLB("B",$P(OLDMSGID,"-"),0))
"RTN","HLOSRVR1",64,0)
 ...;S:$G(IEN) IEN=IEN_"^"_$P(OLDMSGID,"-",2)
"RTN","HLOSRVR1",65,0)
 ...S IEN=$$ACKTOIEN^HLOMSG1("",OLDMSGID)
"RTN","HLOSRVR1",66,0)
 ...;** P143 END CJM
"RTN","HLOSRVR1",67,0)
 ..I 'HLMSTATE("BATCH") D
"RTN","HLOSRVR1",68,0)
 ...D:SEGTYPE="MSA"
"RTN","HLOSRVR1",69,0)
 ....S HLMSTATE("ACK TO")=OLDMSGID
"RTN","HLOSRVR1",70,0)
 ....S HLMSTATE("ACK TO","ACK BY")=HLMSTATE("ID")
"RTN","HLOSRVR1",71,0)
 ....S HLMSTATE("ACK TO","STATUS")=$S(CODE="AA":"SU",1:"ER")
"RTN","HLOSRVR1",72,0)
 ....I $G(IEN) D
"RTN","HLOSRVR1",73,0)
 .....S HLMSTATE("ACK TO","IEN")=IEN
"RTN","HLOSRVR1",74,0)
 .....S HLMSTATE("ACK TO","SEQUENCE QUEUE")=$P($G(^HLB(+IEN,5)),"^")
"RTN","HLOSRVR1",75,0)
 ....S HLMSTATE("ACK TO","ERROR TEXT")=TEXT
"RTN","HLOSRVR1",76,0)
 ...D ADDSEG^HLOMSG(.HLMSTATE,.SEG)
"RTN","HLOSRVR1",77,0)
 ..E  D  ;batch
"RTN","HLOSRVR1",78,0)
 ...I SEGTYPE="MSH" D
"RTN","HLOSRVR1",79,0)
 ....D SPLITHDR(.SEG)
"RTN","HLOSRVR1",80,0)
 ....S NEWMSGID=$P(SEG(2),FS,5)
"RTN","HLOSRVR1",81,0)
 ....D ADDMSG2^HLOMSG(.HLMSTATE,.SEG)
"RTN","HLOSRVR1",82,0)
 ...E  D  ;not MSH
"RTN","HLOSRVR1",83,0)
 ....D:SEGTYPE="MSA"
"RTN","HLOSRVR1",84,0)
 .....N SUBIEN S SUBIEN=HLMSTATE("BATCH","CURRENT MESSAGE")
"RTN","HLOSRVR1",85,0)
 .....S HLMSTATE("BATCH","ACK TO",SUBIEN)=OLDMSGID
"RTN","HLOSRVR1",86,0)
 .....S HLMSTATE("BATCH","ACK TO",SUBIEN,"ACK BY")=NEWMSGID
"RTN","HLOSRVR1",87,0)
 .....S HLMSTATE("BATCH","ACK TO",SUBIEN,"STATUS")=$S(CODE="AA":"SU",1:"ER")
"RTN","HLOSRVR1",88,0)
 .....S:$D(IEN) HLMSTATE("BATCH","ACK TO",SUBIEN,"IEN")=IEN
"RTN","HLOSRVR1",89,0)
 ....D ADDSEG^HLOMSG(.HLMSTATE,.SEG)
"RTN","HLOSRVR1",90,0)
 .I HLMSTATE("UNSTORED LINES"),HLCSTATE("MESSAGE ENDED"),$$SAVEMSG^HLOF778(.HLMSTATE)
"RTN","HLOSRVR1",91,0)
 ;
"RTN","HLOSRVR1",92,0)
 I STORE,'HLCSTATE("MESSAGE ENDED") D
"RTN","HLOSRVR1",93,0)
 .;reading failed, don't store
"RTN","HLOSRVR1",94,0)
 .D:HLMSTATE("IEN") DEL778(HLMSTATE("IEN")) D:HLMSTATE("BODY") DEL777(HLMSTATE("BODY"))
"RTN","HLOSRVR1",95,0)
 .S HLMSTATE("IEN")="",HLMSTATE("BODY")=""
"RTN","HLOSRVR1",96,0)
 E  D:STORE
"RTN","HLOSRVR1",97,0)
 .D CHECKMSG(.HLMSTATE)
"RTN","HLOSRVR1",98,0)
 .D ADDAC(.HLMSTATE) ;so future duplicates are detected
"RTN","HLOSRVR1",99,0)
 .D COUNT^HLOSTAT(.HLCSTATE,HLMSTATE("HDR","RECEIVING APPLICATION"),HLMSTATE("HDR","SENDING APPLICATION"),$S(HLMSTATE("BATCH"):"BATCH",1:HLMSTATE("HDR","MESSAGE TYPE")_"~"_HLMSTATE("HDR","EVENT")))
"RTN","HLOSRVR1",100,0)
 ;
"RTN","HLOSRVR1",101,0)
 D:'HLCSTATE("MESSAGE ENDED") CLOSE^HLOT(.HLCSTATE)
"RTN","HLOSRVR1",102,0)
 Q HLCSTATE("MESSAGE ENDED")
"RTN","HLOSRVR1",103,0)
 ;
"RTN","HLOSRVR1",104,0)
ADDAC(HLMSTATE) ;adds the AC xref for duplicates detection
"RTN","HLOSRVR1",105,0)
 ;
"RTN","HLOSRVR1",106,0)
 N FROM
"RTN","HLOSRVR1",107,0)
 S FROM=$S(HLMSTATE("HDR","SENDING FACILITY",2)]"":HLMSTATE("HDR","SENDING FACILITY",2),1:HLMSTATE("HDR","SENDING FACILITY",1))
"RTN","HLOSRVR1",108,0)
 S ^HLB("AC",FROM_HLMSTATE("HDR","SENDING APPLICATION")_HLMSTATE("ID"),HLMSTATE("IEN"))=""
"RTN","HLOSRVR1",109,0)
 Q
"RTN","HLOSRVR1",110,0)
 ;
"RTN","HLOSRVR1",111,0)
DUP(HLMSTATE) ;
"RTN","HLOSRVR1",112,0)
 ;Returns 1 if the message is a duplicate and its ack (if requested) is found, 0 otherwise
"RTN","HLOSRVR1",113,0)
 ;Input:
"RTN","HLOSRVR1",114,0)
 ; HLMSTATE (pass by reference) the message being read
"RTN","HLOSRVR1",115,0)
 ;Output:
"RTN","HLOSRVR1",116,0)
 ;  Function returns 1 if the message is a duplicate, 0 otherwise
"RTN","HLOSRVR1",117,0)
 ;  HLMSTATE (pass by reference) IF the message is a duplicate:
"RTN","HLOSRVR1",118,0)
 ;     returns the prior MSA segment in HLMSTATE("MSA")
"RTN","HLOSRVR1",119,0)
 ;
"RTN","HLOSRVR1",120,0)
 N IEN,FROM,DUP
"RTN","HLOSRVR1",121,0)
 S (IEN,DUP)=0
"RTN","HLOSRVR1",122,0)
 ;
"RTN","HLOSRVR1",123,0)
 ;no way to determine!  Bad header will be rejected
"RTN","HLOSRVR1",124,0)
 Q:(HLMSTATE("ID")="") 0
"RTN","HLOSRVR1",125,0)
 ;
"RTN","HLOSRVR1",126,0)
 S FROM=$S(HLMSTATE("HDR","SENDING FACILITY",2)]"":HLMSTATE("HDR","SENDING FACILITY",2),1:HLMSTATE("HDR","SENDING FACILITY",1))
"RTN","HLOSRVR1",127,0)
 F  S IEN=$O(^HLB("AC",FROM_HLMSTATE("HDR","SENDING APPLICATION")_HLMSTATE("ID"),IEN)) Q:'IEN  D  Q:DUP
"RTN","HLOSRVR1",128,0)
 .I HLMSTATE("HDR","ACCEPT ACK TYPE")="NE" S DUP=1 Q
"RTN","HLOSRVR1",129,0)
 .;need the MSA to return
"RTN","HLOSRVR1",130,0)
 .D  Q
"RTN","HLOSRVR1",131,0)
 ..N NODE
"RTN","HLOSRVR1",132,0)
 ..S NODE=$P($G(^HLB(IEN,4)),"^",3,10)
"RTN","HLOSRVR1",133,0)
 ..S HLMSTATE("MSA",1)=$P(NODE,"|",2)
"RTN","HLOSRVR1",134,0)
 ..Q:$L(HLMSTATE("MSA",1))'=2
"RTN","HLOSRVR1",135,0)
 ..S HLMSTATE("MSA",2)=$P(NODE,"|",3)
"RTN","HLOSRVR1",136,0)
 ..S HLMSTATE("MSA",3)=$P(NODE,"|",4,10)
"RTN","HLOSRVR1",137,0)
 ..S DUP=1
"RTN","HLOSRVR1",138,0)
 ;
"RTN","HLOSRVR1",139,0)
 Q DUP
"RTN","HLOSRVR1",140,0)
 ;
"RTN","HLOSRVR1",141,0)
CHECKMSG(HLMSTATE) ;
"RTN","HLOSRVR1",142,0)
 ;Checks the header & MSA segment, sets HLMSTATE("STATUS","ACTION") if the message needs to be passed, determines if completion status should be set
"RTN","HLOSRVR1",143,0)
 ;Input:
"RTN","HLOSRVR1",144,0)
 ;  HLMSTATE("HDR") - the parsed header segment
"RTN","HLOSRVR1",145,0)
 ;Output:
"RTN","HLOSRVR1",146,0)
 ;  HLMSTATE("STATUS")="ER" if an error is detected
"RTN","HLOSRVR1",147,0)
 ;  HLMSTATE("STATUS","QUEUE") queue to put the message on
"RTN","HLOSRVR1",148,0)
 ;  HLMSTATE("STATUS","ACTION")  <tag^rtn> that is the processing routine for the receiving application
"RTN","HLOSRVR1",149,0)
 ;  HLMSTATE("MSA") - MSA(1)=accept code to be returned, MSA(3)= error txt
"RTN","HLOSRVR1",150,0)
 ;
"RTN","HLOSRVR1",151,0)
 N WANTACK,PASS,ACTION,QUEUE,ERROR
"RTN","HLOSRVR1",152,0)
 M HDR=HLMSTATE("HDR")
"RTN","HLOSRVR1",153,0)
 S ERROR=0
"RTN","HLOSRVR1",154,0)
 I HDR("ACCEPT ACK TYPE")="NE",'HLMSTATE("ORIGINAL MODE") D
"RTN","HLOSRVR1",155,0)
 .S WANTACK=0
"RTN","HLOSRVR1",156,0)
 E  D
"RTN","HLOSRVR1",157,0)
 .S WANTACK=1
"RTN","HLOSRVR1",158,0)
 I HLMSTATE("ORIGINAL MODE") S HLMSTATE("MSA",1)="AE",HLMSTATE("MSA",3)="THIS INTERFACE DOES NOT IMPLEMENT ORIGINAL MODE APPLICATION ACKOWLEDGMENTS",HLMSTATE("STATUS")="ER" Q
"RTN","HLOSRVR1",159,0)
 I $G(HLMSTATE("ACK TO"))="" D  Q:ERROR
"RTN","HLOSRVR1",160,0)
 .;
"RTN","HLOSRVR1",161,0)
 .;** do not immplement the Pass Immediate parameter **
"RTN","HLOSRVR1",162,0)
 .;N IMMEDIATE
"RTN","HLOSRVR1",163,0)
 .;I '$$ACTION^HLOAPP(.HDR,.ACTION,.QUEUE,.IMMEDIATE) S ERROR=1 S:WANTACK HLMSTATE("MSA",1)="CR" S HLMSTATE("MSA",3)="RECEIVING APPLICATION NOT DEFINED",HLMSTATE("STATUS")="ER" Q
"RTN","HLOSRVR1",164,0)
 .;S HLMSTATE("STATUS","ACTION")=$G(ACTION),HLMSTATE("STATUS","QUEUE")=$G(QUEUE),HLMSTATE("STATUS","PASS IMMEDIATE")=$G(IMMEDIATE)
"RTN","HLOSRVR1",165,0)
 .;
"RTN","HLOSRVR1",166,0)
 .I '$$ACTION^HLOAPP(.HDR,.ACTION,.QUEUE) S ERROR=1 S:WANTACK HLMSTATE("MSA",1)="CR" S HLMSTATE("MSA",3)="RECEIVING APPLICATION NOT DEFINED",HLMSTATE("STATUS")="ER" Q
"RTN","HLOSRVR1",167,0)
 .S HLMSTATE("STATUS","ACTION")=$G(ACTION),HLMSTATE("STATUS","QUEUE")=$G(QUEUE)
"RTN","HLOSRVR1",168,0)
 E  D  Q:ERROR  ;this is an app ack
"RTN","HLOSRVR1",169,0)
 .;does the original message exist?
"RTN","HLOSRVR1",170,0)
 .;
"RTN","HLOSRVR1",171,0)
 .;** do not immplement the Pass Immediate parameter **
"RTN","HLOSRVR1",172,0)
 .;N NODE,IMMEDIATE
"RTN","HLOSRVR1",173,0)
 .;
"RTN","HLOSRVR1",174,0)
 .N NODE
"RTN","HLOSRVR1",175,0)
 .S:+$G(HLMSTATE("ACK TO","IEN")) NODE=$G(^HLB(+HLMSTATE("ACK TO","IEN"),0))
"RTN","HLOSRVR1",176,0)
 .I $G(NODE)="" S ERROR=1,HLMSTATE("STATUS")="ER",HLMSTATE("ACK TO","IEN")="" S:WANTACK HLMSTATE("MSA",1)="CE" S HLMSTATE("MSA",3)="INITIAL MESSAGE TO APPLICATION ACKNOWLEDGMENT NOT FOUND" Q
"RTN","HLOSRVR1",177,0)
 .I $P(NODE,"^",7)'="",$P(NODE,"^",7)'=HLMSTATE("ID") S ERROR=1,HLMSTATE("STATUS")="ER",HLMSTATE("ACK TO","IEN")="" S:WANTACK HLMSTATE("MSA",1)="CE" S HLMSTATE("MSA",3)="INITIAL MESSAGE WAS ALREADY ACKED" Q
"RTN","HLOSRVR1",178,0)
 .I ($P(NODE,"^",11)]"") S HLMSTATE("STATUS","ACTION")=$P(NODE,"^",10,11),HLMSTATE("STATUS","QUEUE")=$S($P(NODE,"^",6)]"":$P(NODE,"^",6),1:"DEFAULT")  Q
"RTN","HLOSRVR1",179,0)
 .;processing routine for the app ack wasn't found with the original message, look in the HLO Application Registry
"RTN","HLOSRVR1",180,0)
 .I HLMSTATE("HDR","MESSAGE TYPE")="ACK",HLMSTATE("HDR","EVENT")="" S HDR("EVENT")=$$GETEVENT^HLOCLNT2(+HLMSTATE("ACK TO","IEN"))
"RTN","HLOSRVR1",181,0)
 .;
"RTN","HLOSRVR1",182,0)
 .;** do not immplement the Pass Immediate parameter **
"RTN","HLOSRVR1",183,0)
 .;I $$ACTION^HLOAPP(.HDR,.ACTION,.QUEUE,.IMMEDIATE) S HLMSTATE("STATUS","ACTION")=$G(ACTION),HLMSTATE("STATUS","QUEUE")=$G(QUEUE),HLMSTATE("STATUS","PASS IMMEDIATE")=$G(IMMEDIATE)
"RTN","HLOSRVR1",184,0)
 .;
"RTN","HLOSRVR1",185,0)
 .I $$ACTION^HLOAPP(.HDR,.ACTION,.QUEUE) S HLMSTATE("STATUS","ACTION")=$G(ACTION),HLMSTATE("STATUS","QUEUE")=$G(QUEUE)
"RTN","HLOSRVR1",186,0)
 ;
"RTN","HLOSRVR1",187,0)
 I HDR("PROCESSING ID")'=HLCSTATE("SYSTEM","PROCESSING ID") S:WANTACK HLMSTATE("MSA",1)="CR" S HLMSTATE("STATUS")="ER",HLMSTATE("MSA",3)="SYSTEM PROCESSING ID="_HLCSTATE("SYSTEM","PROCESSING ID") Q
"RTN","HLOSRVR1",188,0)
 ;
"RTN","HLOSRVR1",189,0)
 ;wrong receiving facility?  This is hard to check if the sender is not VistA, because the HL7 standard permits different coding systems to be used. This check is only for DNS or station number.
"RTN","HLOSRVR1",190,0)
 S PASS=0
"RTN","HLOSRVR1",191,0)
 D
"RTN","HLOSRVR1",192,0)
 .;if its an ack to an existing message, don't check the receiving facility
"RTN","HLOSRVR1",193,0)
 .I $G(HLMSTATE("ACK TO"))]"" S PASS=1 Q
"RTN","HLOSRVR1",194,0)
 .I HDR("RECEIVING FACILITY",1)=HLCSTATE("SYSTEM","STATION") S PASS=1 Q
"RTN","HLOSRVR1",195,0)
 .I HDR("RECEIVING FACILITY",3)'="DNS" S PASS=1 Q
"RTN","HLOSRVR1",196,0)
 .I HDR("RECEIVING FACILITY",2)="" S PASS=1 Q
"RTN","HLOSRVR1",197,0)
 .I $P(HDR("RECEIVING FACILITY",2),":")[HLCSTATE("SYSTEM","DOMAIN") S PASS=1 Q
"RTN","HLOSRVR1",198,0)
 .I HLCSTATE("SYSTEM","DOMAIN")[$P(HDR("RECEIVING FACILITY",2),":") S PASS=1 Q
"RTN","HLOSRVR1",199,0)
 I 'PASS S HLMSTATE("STATUS")="ER",HLMSTATE("MSA",3)="RECEIVING FACILITY IS "_HLCSTATE("SYSTEM","DOMAIN") S:WANTACK HLMSTATE("MSA",1)="CE"
"RTN","HLOSRVR1",200,0)
 I PASS,WANTACK S HLMSTATE("MSA",1)="CA"
"RTN","HLOSRVR1",201,0)
 Q
"RTN","HLOSRVR1",202,0)
 ;
"RTN","HLOSRVR1",203,0)
DEL777(IEN777) ;delete a record from file 777 where the read did not complete
"RTN","HLOSRVR1",204,0)
 ;
"RTN","HLOSRVR1",205,0)
 K ^HLA(IEN777,0)
"RTN","HLOSRVR1",206,0)
 Q
"RTN","HLOSRVR1",207,0)
DEL778(IEN778) ;delete a record from file 778 where the read did not complete
"RTN","HLOSRVR1",208,0)
 ;
"RTN","HLOSRVR1",209,0)
 K ^HLB(IEN778,0)
"RTN","HLOSRVR1",210,0)
 Q
"RTN","HLOSRVR1",211,0)
 ;
"RTN","HLOSRVR1",212,0)
SPLITHDR(HDR) ;
"RTN","HLOSRVR1",213,0)
 ;splits hdr segment into two lines, first being just components 1-6
"RTN","HLOSRVR1",214,0)
 ;
"RTN","HLOSRVR1",215,0)
 N TEMP,FS
"RTN","HLOSRVR1",216,0)
 D SQUISH(.HDR)
"RTN","HLOSRVR1",217,0)
 S FS=$E($G(HDR(1)),4)
"RTN","HLOSRVR1",218,0)
 S TEMP(1)=$P($G(HDR(1)),FS,1,6)
"RTN","HLOSRVR1",219,0)
 S TEMP(2)=""
"RTN","HLOSRVR1",220,0)
 I $L(TEMP(1))<$L($G(HDR(1))) S TEMP(2)=FS_$P($G(HDR(1)),FS,7,20)
"RTN","HLOSRVR1",221,0)
 S HDR(2)=TEMP(2)_$G(HDR(2))
"RTN","HLOSRVR1",222,0)
 S HDR(1)=TEMP(1)
"RTN","HLOSRVR1",223,0)
 Q
"RTN","HLOSRVR1",224,0)
 ;
"RTN","HLOSRVR1",225,0)
SQUISH(SEG) ;
"RTN","HLOSRVR1",226,0)
 ;reformat the segment array into full lines
"RTN","HLOSRVR1",227,0)
 ;
"RTN","HLOSRVR1",228,0)
 ;nothing to do if less than 2 lines
"RTN","HLOSRVR1",229,0)
 Q:'$O(SEG(1))
"RTN","HLOSRVR1",230,0)
 ;
"RTN","HLOSRVR1",231,0)
 N A,I,J,K,MAX,COUNT,LEN
"RTN","HLOSRVR1",232,0)
 S MAX=$S($G(HLCSTATE("SYSTEM","MAXSTRING"))>256:HLCSTATE("SYSTEM","MAXSTRING"),1:256)
"RTN","HLOSRVR1",233,0)
 S (COUNT,I)=0,J=1
"RTN","HLOSRVR1",234,0)
 F  S I=$O(SEG(I)) Q:'I  D
"RTN","HLOSRVR1",235,0)
 .S LEN=$L(SEG(I))
"RTN","HLOSRVR1",236,0)
 .F K=1:1:LEN D
"RTN","HLOSRVR1",237,0)
 ..S A(J)=$G(A(J))_$E(SEG(I),K)
"RTN","HLOSRVR1",238,0)
 ..S COUNT=COUNT+1
"RTN","HLOSRVR1",239,0)
 ..I (COUNT>(MAX-1)) S COUNT=0,J=J+1
"RTN","HLOSRVR1",240,0)
 K SEG
"RTN","HLOSRVR1",241,0)
 M SEG=A
"RTN","HLOSRVR1",242,0)
 Q
"RTN","HLOSRVR3")
0^17^B1081356^B2176219
"RTN","HLOSRVR3",1,0)
HLOSRVR3 ;IRMFO/OAK/CJM - Reading messages, sending acks;03/24/2004  14:43 ;04/08/2010
"RTN","HLOSRVR3",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**138,147**;Oct 13, 1995;Build 15
"RTN","HLOSRVR3",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOSRVR3",4,0)
 ;
"RTN","HLOSRVR3",5,0)
ERROR ;error trap
"RTN","HLOSRVR3",6,0)
 ;
"RTN","HLOSRVR3",7,0)
 S $ETRAP="Q:$QUIT """" Q"
"RTN","HLOSRVR3",8,0)
 D END^HLOSRVR
"RTN","HLOSRVR3",9,0)
 ;
"RTN","HLOSRVR3",10,0)
 I ($ECODE["TOOMANYFILES")!($ECODE["EDITED") Q:$QUIT "" Q
"RTN","HLOSRVR3",11,0)
 ;
"RTN","HLOSRVR3",12,0)
 ;multi-listener should stop execution, only a single server may continue
"RTN","HLOSRVR3",13,0)
 I $P($G(HLCSTATE("LINK","SERVER")),"^",2)'="S" D  Q:$QUIT "" Q
"RTN","HLOSRVR3",14,0)
 .;don't log these errors unless logging is turned on
"RTN","HLOSRVR3",15,0)
 .I $G(^HLTMP("LOG ALL ERRORS")) D ^%ZTER Q
"RTN","HLOSRVR3",16,0)
 .I ($ECODE["READ")!($ECODE["NOTOPEN")!($ECODE["DEVNOTOPN")!($ECODE["WRITE")!($ECODE["OPENERR") Q
"RTN","HLOSRVR3",17,0)
 .D ^%ZTER
"RTN","HLOSRVR3",18,0)
 .Q
"RTN","HLOSRVR3",19,0)
 ;
"RTN","HLOSRVR3",20,0)
 ;single listener should return to the process manager
"RTN","HLOSRVR3",21,0)
 Q:$Q "" Q
"RTN","HLOSTRAC")
0^16^B43533858^B33783349
"RTN","HLOSTRAC",1,0)
HLOSTRAC ;;OIFO-OAK/RBN/CJM ;03/23/2010
"RTN","HLOSTRAC",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**146,147**;Oct 13, 1995;Build 15
"RTN","HLOSTRAC",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOSTRAC",4,0)
 ;;
"RTN","HLOSTRAC",5,0)
 ;; HLO SERVER TRACE Tool
"RTN","HLOSTRAC",6,0)
 ;; *** For troubleshooting HLO server issues ***
"RTN","HLOSTRAC",7,0)
 ;;     The HLO server runs in the foreground and writes trace
"RTN","HLOSTRAC",8,0)
 ;;     statements to the screen.
"RTN","HLOSTRAC",9,0)
 ;; 
"RTN","HLOSTRAC",10,0)
TRACE    ;
"RTN","HLOSTRAC",11,0)
 N CONF,HLOTRACE
"RTN","HLOSTRAC",12,0)
 S HLOTRACE("COUNT")=0
"RTN","HLOSTRAC",13,0)
 S HLOTRACE("ERRORS")=0
"RTN","HLOSTRAC",14,0)
 I '$G(DUZ) W !,"Your DUZ must be set!" Q
"RTN","HLOSTRAC",15,0)
 D OWNSKEY^XUSRB(.CONF,"XUPROG",DUZ)
"RTN","HLOSTRAC",16,0)
 I 'CONF(0) D  Q
"RTN","HLOSTRAC",17,0)
 . W !!,"   Sorry, you are not authorized to use this tool.",!!
"RTN","HLOSTRAC",18,0)
 I $P($$VERSION^%ZOSV(1),"/",1)'["Cache" D  Q
"RTN","HLOSTRAC",19,0)
 . W !!,"   Sorry, this tool can only be used under Cache",!!
"RTN","HLOSTRAC",20,0)
 N IEN,LINK,PORT
"RTN","HLOSTRAC",21,0)
 S IEN=+$O(^HLD(779.1,0))
"RTN","HLOSTRAC",22,0)
 D:IEN
"RTN","HLOSTRAC",23,0)
 .S LINK=$P($G(^HLD(779.1,IEN,0)),"^",10)
"RTN","HLOSTRAC",24,0)
 .S LINK=$P($G(^HLCS(870,LINK,0)),"^")
"RTN","HLOSTRAC",25,0)
 S:'$L($G(LINK)) LINK="HLO DEFAULT LISTENER"
"RTN","HLOSTRAC",26,0)
 W !,"What port do you want to listen on while in server trace mode?"
"RTN","HLOSTRAC",27,0)
 W !,"The port must be free. If a server already has it opened then the"
"RTN","HLOSTRAC",28,0)
 W !,"server needs to be stopped before starting in server trace mode."
"RTN","HLOSTRAC",29,0)
 S PORT=$$ASKPORT^HLOUSRA(LINK)
"RTN","HLOSTRAC",30,0)
 Q:'PORT
"RTN","HLOSTRAC",31,0)
 D SETBREAKS
"RTN","HLOSTRAC",32,0)
 ;
"RTN","HLOSTRAC",33,0)
 ZB ZB999^HLOSRVR:"N":1:"S LINK(""PORT"")=PORT,LINK(""SERVER"")=""1^S"",LINK(""LLP"")=""TCP"""
"RTN","HLOSTRAC",34,0)
 ;
"RTN","HLOSTRAC",35,0)
 W !!,"Starting the server, hit the CTRL-C key to stop the server...",!!
"RTN","HLOSTRAC",36,0)
READ D
"RTN","HLOSTRAC",37,0)
 .N $ETRAP,$ESTACK
"RTN","HLOSTRAC",38,0)
 .S $ETRAP="G ERROR^HLOSTRAC"
"RTN","HLOSTRAC",39,0)
 .D SERVER^HLOSRVR(LINK)
"RTN","HLOSTRAC",40,0)
 .U $PRINCIPAL
"RTN","HLOSTRAC",41,0)
 .W !,"DONE!"
"RTN","HLOSTRAC",42,0)
 ZB /CLEAR
"RTN","HLOSTRAC",43,0)
 Q
"RTN","HLOSTRAC",44,0)
 ;
"RTN","HLOSTRAC",45,0)
SETBREAKS ;
"RTN","HLOSTRAC",46,0)
 ZB /CLEAR
"RTN","HLOSTRAC",47,0)
 ZB /INTERRUPT:NORMAL
"RTN","HLOSTRAC",48,0)
 ;
"RTN","HLOSTRAC",49,0)
 ;report errors
"RTN","HLOSTRAC",50,0)
 ZB ZB1^HLOSRVR:"N":1:"S $ETRAP=""G ZB3^HLOSTRAC"""
"RTN","HLOSTRAC",51,0)
 ;
"RTN","HLOSTRAC",52,0)
 ;allow Server Trace tool to run even if HLO is shut down
"RTN","HLOSTRAC",53,0)
 ZB ZB25^HLOPROC:"N":1:"S RET=0"
"RTN","HLOSTRAC",54,0)
 ZB READMSG^HLOSRVR1:"N":1:"D READMSG^HLOSTRAC"
"RTN","HLOSTRAC",55,0)
 ZB PARSEHDR^HLOPRS:"N":1:"D PARSEHDR^HLOSTRAC"
"RTN","HLOSTRAC",56,0)
 ZB DUP^HLOSRVR1:"N":1:"D DUP^HLOSTRAC"
"RTN","HLOSTRAC",57,0)
 ZB CLOSE^HLOT:"N":1:"D CLOSE^HLOSTRAC"
"RTN","HLOSTRAC",58,0)
 ;set break ZB10 in the client(start of $$READHDR^HLOT)
"RTN","HLOSTRAC",59,0)
 ZB ZB10^HLOT:"N":1:"D ZB10^HLOSTRAC"
"RTN","HLOSTRAC",60,0)
 ;set break ZB11 in the client(end of $$READHDR^HLOT)
"RTN","HLOSTRAC",61,0)
 ZB ZB11^HLOT:"N":1:"D ZB11^HLOSTRAC"
"RTN","HLOSTRAC",62,0)
 ;set break ZB12 in the client(start of $$READSEG^HLOT)
"RTN","HLOSTRAC",63,0)
 ZB ZB12^HLOT:"N":1:"D ZB12^HLOSTRAC"
"RTN","HLOSTRAC",64,0)
 ;set break ZB13 in the client(end of $$READSEG^HLOT)
"RTN","HLOSTRAC",65,0)
 ZB ZB13^HLOT:"N":1:"D ZB13^HLOSTRAC"
"RTN","HLOSTRAC",66,0)
 ;set break ZB14 in the client(start of $$WRITESEG^HLOT)
"RTN","HLOSTRAC",67,0)
 ZB ZB14^HLOT:"N":1:"D ZB14^HLOSTRAC"
"RTN","HLOSTRAC",68,0)
 ;set break ZB15 in the client(end of $$WRITESEG^HLOT)
"RTN","HLOSTRAC",69,0)
 ZB ZB15^HLOT:"N":1:"D ZB15^HLOSTRAC"
"RTN","HLOSTRAC",70,0)
 ;set break ZB16 in the client(start of $$WRITEHDR^HLOT)
"RTN","HLOSTRAC",71,0)
 ZB ZB16^HLOT:"N":1:"D ZB16^HLOSTRAC"
"RTN","HLOSTRAC",72,0)
 ;set break ZB17 in the client(end of $$WRITEHDR^HLOT)
"RTN","HLOSTRAC",73,0)
 ZB ZB17^HLOT:"N":1:"D ZB17^HLOSTRAC"
"RTN","HLOSTRAC",74,0)
 ;set break ZB18 in the client(start of $$ENDMSG^HLOT)
"RTN","HLOSTRAC",75,0)
 ZB ZB18^HLOT:"N":1:"D ZB18^HLOSTRAC"
"RTN","HLOSTRAC",76,0)
 ;set break ZB19 in the server(end of $$ENDMSG^HLOT)
"RTN","HLOSTRAC",77,0)
 ZB ZB19^HLOT:"N":1:"D ZB19^HLOSTRAC"
"RTN","HLOSTRAC",78,0)
 ZB ZB25^HLOTCP:"N":1:"D ZB25^HLOSTRAC"
"RTN","HLOSTRAC",79,0)
 ZB ZB26^HLOTCP:"N":1:"D ZB26^HLOSTRAC"
"RTN","HLOSTRAC",80,0)
 ZB ZB27^HLOTCP:"N":1:"D ZB27^HLOSTRAC"
"RTN","HLOSTRAC",81,0)
 ZB ZB28^HLOTCP:"N":1:"D ZB28^HLOSTRAC"
"RTN","HLOSTRAC",82,0)
 ;set break ZB29 in the server(after parsing the message header)
"RTN","HLOSTRAC",83,0)
 ZB ZB29^HLOSRVR1:"N":1:"D ZB29^HLOSTRAC"
"RTN","HLOSTRAC",84,0)
 ;set break ZB30 in the server(afterchecking if duplicate)
"RTN","HLOSTRAC",85,0)
 ZB ZB30^HLOSRVR1:"N":1:"D ZB30^HLOSTRAC"
"RTN","HLOSTRAC",86,0)
 Q
"RTN","HLOSTRAC",87,0)
 ;
"RTN","HLOSTRAC",88,0)
WRITE(MSG) ;
"RTN","HLOSTRAC",89,0)
 N OLD
"RTN","HLOSTRAC",90,0)
 S OLD=$IO
"RTN","HLOSTRAC",91,0)
 U $PRINCIPAL
"RTN","HLOSTRAC",92,0)
 W !,?5,"Time: ",$$NOW^XLFDT,"   ",MSG
"RTN","HLOSTRAC",93,0)
 U OLD
"RTN","HLOSTRAC",94,0)
 Q
"RTN","HLOSTRAC",95,0)
WRITE2(MSG,VALUE) ;
"RTN","HLOSTRAC",96,0)
 N OLD,I
"RTN","HLOSTRAC",97,0)
 S OLD=$IO
"RTN","HLOSTRAC",98,0)
 U $PRINCIPAL
"RTN","HLOSTRAC",99,0)
 W !,?5,"Time: ",$$NOW^XLFDT,"   ",MSG
"RTN","HLOSTRAC",100,0)
 S I=0
"RTN","HLOSTRAC",101,0)
 W:$O(VALUE(0)) !
"RTN","HLOSTRAC",102,0)
 F  S I=$O(VALUE(I)) Q:'I  W VALUE(I)
"RTN","HLOSTRAC",103,0)
 U OLD
"RTN","HLOSTRAC",104,0)
 Q
"RTN","HLOSTRAC",105,0)
WRITE3(MSG) ;
"RTN","HLOSTRAC",106,0)
 N OLD
"RTN","HLOSTRAC",107,0)
 S OLD=$IO
"RTN","HLOSTRAC",108,0)
 U $PRINCIPAL
"RTN","HLOSTRAC",109,0)
 W !,MSG
"RTN","HLOSTRAC",110,0)
 U OLD
"RTN","HLOSTRAC",111,0)
 Q
"RTN","HLOSTRAC",112,0)
READMSG ;
"RTN","HLOSTRAC",113,0)
 ;
"RTN","HLOSTRAC",114,0)
 S HLOTRACE("COUNT")=HLOTRACE("COUNT")+1
"RTN","HLOSTRAC",115,0)
 S HLOTRACE("ERRORS")=0
"RTN","HLOSTRAC",116,0)
 I HLOTRACE("COUNT")>10 D
"RTN","HLOSTRAC",117,0)
 .N OLD,SEND
"RTN","HLOSTRAC",118,0)
 .S OLD=$IO
"RTN","HLOSTRAC",119,0)
 .U $PRINCIPAL
"RTN","HLOSTRAC",120,0)
 .W !
"RTN","HLOSTRAC",121,0)
 .S SEND=$$ASKYESNO^HLOUSR2("Do you want to trace more message transmissions","NO")
"RTN","HLOSTRAC",122,0)
 .I 'SEND S $ECODE=",UHLOSTOP,"
"RTN","HLOSTRAC",123,0)
 .U OLD
"RTN","HLOSTRAC",124,0)
 W !
"RTN","HLOSTRAC",125,0)
 D WRITE3^HLOSTRAC("Beginning to read next message...")
"RTN","HLOSTRAC",126,0)
 Q
"RTN","HLOSTRAC",127,0)
PARSEHDR ;
"RTN","HLOSTRAC",128,0)
 D WRITE^HLOSTRAC("Parsing the message header...")
"RTN","HLOSTRAC",129,0)
 Q
"RTN","HLOSTRAC",130,0)
DUP ;
"RTN","HLOSTRAC",131,0)
 D WRITE^HLOSTRAC("Checking if duplicate message...")
"RTN","HLOSTRAC",132,0)
 Q
"RTN","HLOSTRAC",133,0)
CLOSE ;
"RTN","HLOSTRAC",134,0)
 D WRITE^HLOSTRAC("Closing the port...")
"RTN","HLOSTRAC",135,0)
 Q
"RTN","HLOSTRAC",136,0)
 ;
"RTN","HLOSTRAC",137,0)
ERROR ;
"RTN","HLOSTRAC",138,0)
 I ($ECODE["EDITED") Q:$QUIT "" Q
"RTN","HLOSTRAC",139,0)
 S HLOTRACE("ERRORS")=HLOTRACE("ERRORS")+1
"RTN","HLOSTRAC",140,0)
 I HLOTRACE("ERRORS")>5 Q:$QUIT "" Q
"RTN","HLOSTRAC",141,0)
 S $ECODE=""
"RTN","HLOSTRAC",142,0)
 G READ^HLOSTRAC
"RTN","HLOSTRAC",143,0)
 Q:$QUIT "" Q
"RTN","HLOSTRAC",144,0)
 Q
"RTN","HLOSTRAC",145,0)
ZB10 ;
"RTN","HLOSTRAC",146,0)
 D WRITE^HLOSTRAC("Reading message header...")
"RTN","HLOSTRAC",147,0)
 Q
"RTN","HLOSTRAC",148,0)
ZB11 I $D(HDR) D WRITE2^HLOSTRAC("",.HDR)
"RTN","HLOSTRAC",149,0)
 D WRITE^HLOSTRAC($S(SUCCESS:"Completed!",1:"**** FAILED TO COMPLETE *****"))
"RTN","HLOSTRAC",150,0)
 Q
"RTN","HLOSTRAC",151,0)
ZB12 ;
"RTN","HLOSTRAC",152,0)
 D WRITE^HLOSTRAC("Reading next segment...")
"RTN","HLOSTRAC",153,0)
 Q
"RTN","HLOSTRAC",154,0)
ZB13 I $D(SEG) D WRITE2^HLOSTRAC("",.SEG)
"RTN","HLOSTRAC",155,0)
 D WRITE^HLOSTRAC($S(RETURN:"Completed!",$G(HLCSTATE("MESSAGE ENDED")):"No more segments!",1:"**** FAILED TO COMPLETE *****"))
"RTN","HLOSTRAC",156,0)
 Q
"RTN","HLOSTRAC",157,0)
ZB14 ;
"RTN","HLOSTRAC",158,0)
 D WRITE2^HLOSTRAC("Writing next segment...",.SEG)
"RTN","HLOSTRAC",159,0)
 Q
"RTN","HLOSTRAC",160,0)
ZB15 D WRITE^HLOSTRAC($S(RETURN:"Completed!",1:"**** FAILED TO COMPLETE *****"))
"RTN","HLOSTRAC",161,0)
 Q
"RTN","HLOSTRAC",162,0)
ZB16 ;
"RTN","HLOSTRAC",163,0)
 D WRITE3^HLOSTRAC("Beginning to write the commit acknowledgment...")
"RTN","HLOSTRAC",164,0)
 D WRITE2^HLOSTRAC("Writing header segment...",.HDR)
"RTN","HLOSTRAC",165,0)
 Q
"RTN","HLOSTRAC",166,0)
ZB17 D WRITE^HLOSTRAC($S(SUCCESS:"Completed!",1:"**** FAILED TO COMPLETE *****"))
"RTN","HLOSTRAC",167,0)
 Q
"RTN","HLOSTRAC",168,0)
ZB18 ;
"RTN","HLOSTRAC",169,0)
 D WRITE^HLOSTRAC("Writing message terminators and flushing buffer...")
"RTN","HLOSTRAC",170,0)
 Q
"RTN","HLOSTRAC",171,0)
ZB19 D WRITE^HLOSTRAC($S(RETURN:"Completed!",1:"**** FAILED TO COMPLETE *****"))
"RTN","HLOSTRAC",172,0)
 Q
"RTN","HLOSTRAC",173,0)
ZB25 D WRITE^HLOSTRAC("Opening the port...")
"RTN","HLOSTRAC",174,0)
 Q
"RTN","HLOSTRAC",175,0)
ZB26 D WRITE^HLOSTRAC("Waiting for remote client to connect...")
"RTN","HLOSTRAC",176,0)
 Q
"RTN","HLOSTRAC",177,0)
ZB27 D WRITE^HLOSTRAC("Remote client connected...")
"RTN","HLOSTRAC",178,0)
 Q
"RTN","HLOSTRAC",179,0)
ZB28 D WRITE^HLOSTRAC("**** UNABLE TO OPEN PORT *****")
"RTN","HLOSTRAC",180,0)
 Q
"RTN","HLOSTRAC",181,0)
ZB29 D WRITE3^HLOSTRAC("*** THE MESSAGE HEADER COULD NOT BE PARSED   ***")
"RTN","HLOSTRAC",182,0)
 Q
"RTN","HLOSTRAC",183,0)
ZB30 D WRITE3^HLOSTRAC("*** THE MESSAGE IS A DUPLICATE AND WILL BE DISCARDED   ***")
"RTN","HLOSTRAC",184,0)
 D WRITE3^HLOSTRAC("*** THE ORIGINAL COMMIT ACKNOWLEDMENT WILL BE RETURNED ***")
"RTN","HLOSTRAC",185,0)
 Q
"RTN","HLOSTRAC",186,0)
 ;
"RTN","HLOSTRAC",187,0)
ZB3 ;
"RTN","HLOSTRAC",188,0)
 S $ETRAP="Q:$QUIT """" Q"
"RTN","HLOSTRAC",189,0)
 D END^HLOSRVR
"RTN","HLOSTRAC",190,0)
 N CON,MSG
"RTN","HLOSTRAC",191,0)
 S CON=($ZA\8192#2)
"RTN","HLOSTRAC",192,0)
 S MSG="Error encountered, $ECODE="_$ECODE
"RTN","HLOSTRAC",193,0)
 D WRITE^HLOTRACE(MSG)
"RTN","HLOSTRAC",194,0)
 S MSG=$S(CON:"           TCP connection still active",1:"          TCP connection was dropped")
"RTN","HLOSTRAC",195,0)
 D WRITE3^HLOTRACE(MSG)
"RTN","HLOSTRAC",196,0)
 I ($ECODE["EDITED") Q:$QUIT "" Q
"RTN","HLOSTRAC",197,0)
 I ($ECODE["READ")!($ECODE["NOTOPEN")!($ECODE["DEVNOTOPN")!($ECODE["WRITE")!($ECODE["OPENERR") D
"RTN","HLOSTRAC",198,0)
 .;
"RTN","HLOSTRAC",199,0)
 E  D
"RTN","HLOSTRAC",200,0)
 .D ^%ZTER
"RTN","HLOSTRAC",201,0)
 Q
"RTN","HLOTRACE")
0^24^B65409615^B65294426
"RTN","HLOTRACE",1,0)
HLOTRACE ;;OIFO-OAK/PIJ/CJM ;08/23/2010
"RTN","HLOTRACE",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**146,147** ;Oct 13, 1995;Build 15
"RTN","HLOTRACE",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOTRACE",4,0)
 ;;
"RTN","HLOTRACE",5,0)
 ;; HLO CLIENT TRACE Tool
"RTN","HLOTRACE",6,0)
 ;; *** For troubleshooting HLO client issues ***
"RTN","HLOTRACE",7,0)
 ;;     Client runs in the foreground and writes trace statements
"RTN","HLOTRACE",8,0)
 ;;     to the screen.
"RTN","HLOTRACE",9,0)
 ;; 
"RTN","HLOTRACE",10,0)
START ;
"RTN","HLOTRACE",11,0)
 N CONF
"RTN","HLOTRACE",12,0)
 I '$G(DUZ) W !,"Your DUZ must be set!" Q
"RTN","HLOTRACE",13,0)
 D OWNSKEY^XUSRB(.CONF,"XUPROG",DUZ)
"RTN","HLOTRACE",14,0)
 I 'CONF(0) D  Q
"RTN","HLOTRACE",15,0)
 . W !!,"   Sorry, you are not authorized to use this tool.",!!
"RTN","HLOTRACE",16,0)
 ;I $P($$VERSION^%ZOSV(1),"/",1)'="Cache for OpenVMS" D  Q
"RTN","HLOTRACE",17,0)
 I $P($$VERSION^%ZOSV(1),"/",1)'["Cache" D  Q
"RTN","HLOTRACE",18,0)
 . W !!,"   Sorry, this tool can only be used under Cache",!!
"RTN","HLOTRACE",19,0)
 N LINK,PORT,QUE,SUB,WORK,HLMSTATE,HLCSTATE,OLD,MAXTRACE,TRACECNT
"RTN","HLOTRACE",20,0)
 S LINK=$$ASKLINK^HLOUSR
"RTN","HLOTRACE",21,0)
 Q:LINK=""
"RTN","HLOTRACE",22,0)
 S PORT=$$ASKPORT(LINK)
"RTN","HLOTRACE",23,0)
 Q:'PORT
"RTN","HLOTRACE",24,0)
 S SUB=LINK_":"_PORT
"RTN","HLOTRACE",25,0)
 S QUE=$$ASKQUE(SUB)
"RTN","HLOTRACE",26,0)
 Q:QUE=""
"RTN","HLOTRACE",27,0)
 ZB /INTERRUPT:NORMAL ;disable CTRL-C breaks
"RTN","HLOTRACE",28,0)
 L +^HLB("QUEUE","OUT",SUB,QUE):20
"RTN","HLOTRACE",29,0)
 ;
"RTN","HLOTRACE",30,0)
 I '$T W !,"That queue is currently being processed. You need to either stop that link,",!,"stop that queue, or totally stop HLO so that this tool can be used." Q
"RTN","HLOTRACE",31,0)
 I '$O(^HLB("QUEUE","OUT",SUB,QUE,0)) W !,"There are no messages pending on that queue!" Q
"RTN","HLOTRACE",32,0)
 S TRACECNT=0
"RTN","HLOTRACE",33,0)
 S MAXTRACE=$$ASKCOUNT
"RTN","HLOTRACE",34,0)
 Q:(MAXTRACE<1)
"RTN","HLOTRACE",35,0)
 S WORK("QUEUE")=QUE,WORK("LINK")=SUB
"RTN","HLOTRACE",36,0)
 D SETBREAKS
"RTN","HLOTRACE",37,0)
 D DOWORK^HLOCLNT(.WORK)
"RTN","HLOTRACE",38,0)
 D:$G(HLCSTATE("CONNECTED")) CLOSE^HLOT(.HLCSTATE)
"RTN","HLOTRACE",39,0)
 ;
"RTN","HLOTRACE",40,0)
 U $PRINCIPAL
"RTN","HLOTRACE",41,0)
 L -^HLB("QUEUE","OUT",SUB,QUE)
"RTN","HLOTRACE",42,0)
 ZB /CLEAR
"RTN","HLOTRACE",43,0)
 W !,"DONE!"
"RTN","HLOTRACE",44,0)
 ;
"RTN","HLOTRACE",45,0)
 Q
"RTN","HLOTRACE",46,0)
SETBREAKS ;
"RTN","HLOTRACE",47,0)
 ZB /CLEAR
"RTN","HLOTRACE",48,0)
 ;
"RTN","HLOTRACE",49,0)
 ;set break in $$STOPPED^HLOQUE to circumvent shutdown of the queue
"RTN","HLOTRACE",50,0)
 ZB ZB0^HLOQUE:"N":1:"S RET=0"
"RTN","HLOTRACE",51,0)
 ;set break in $$IFSHUT^HLOTLNK to circumvent shutdown of the link
"RTN","HLOTRACE",52,0)
 ZB ZB0^HLOTLNK:"N":1:"S RET=0"
"RTN","HLOTRACE",53,0)
 ;set break at ZB0 in client (start of DOWORK)
"RTN","HLOTRACE",54,0)
 ZB ZB0^HLOCLNT:"N":1:"D WRITE^HLOTRACE(""Launching the client process..."")"
"RTN","HLOTRACE",55,0)
 ;set break at ZB1 in client ($$CONNECT)
"RTN","HLOTRACE",56,0)
 ZB ZB1^HLOCLNT1:"N":1:"D WRITE^HLOTRACE(""Trying to connect..."")"
"RTN","HLOTRACE",57,0)
 ;set break at ZB2 in client (end of $$CONNECT)
"RTN","HLOTRACE",58,0)
 ZB ZB2^HLOCLNT1:"N":1:"D ZB2^HLOTRACE"
"RTN","HLOTRACE",59,0)
 ;set break at ZB3 in client (ERROR TRAP)
"RTN","HLOTRACE",60,0)
 ZB ZB3^HLOCLNT:"N":1:"D ZB3^HLOTRACE"
"RTN","HLOTRACE",61,0)
 ;set break at ZB4 in client (FOR loop on the outgoing queue)
"RTN","HLOTRACE",62,0)
 ZB ZB4^HLOCLNT:"N":1:"D ZB4^HLOTRACE"
"RTN","HLOTRACE",63,0)
 ;set break at ZB5 in client (end of DOWORK, with just cleanup left)
"RTN","HLOTRACE",64,0)
 ZB ZB5^HLOCLNT:"N":1:"D WRITE3^HLOTRACE(""Cleaning up...."")"
"RTN","HLOTRACE",65,0)
 ;set break at ZB6 in client (start of $$TRANSMIT^HLOCLNT1)
"RTN","HLOTRACE",66,0)
 ZB ZB6^HLOCLNT1:"N":1:"D WRITE^HLOTRACE(""Beginning to transmit message...."")"
"RTN","HLOTRACE",67,0)
 ;set break at ZB7 in client (end of $$TRANSMIT^HLOCLNT1)
"RTN","HLOTRACE",68,0)
 ZB ZB7^HLOCLNT1:"N":1:"D WRITE^HLOTRACE(""Message transmitted!"")"
"RTN","HLOTRACE",69,0)
 ;set break at ZB8 in client (start of $$READACK^HLOCLNT1)
"RTN","HLOTRACE",70,0)
 ZB ZB8^HLOCLNT1:"N":1:"D WRITE^HLOTRACE(""Beginning to read commit acknowledgment...."")"
"RTN","HLOTRACE",71,0)
 ;set break at ZB9 in client (end of $$READACK^HLOCLNT1)
"RTN","HLOTRACE",72,0)
 ;ZB ZB9^HLOCLNT1:"N":1:"D WRITE^HLOTRACE(""Commit acknowledgment received!"")"
"RTN","HLOTRACE",73,0)
 ZB ZB9^HLOCLNT1:"N":1:"D ZB9^HLOTRACE"
"RTN","HLOTRACE",74,0)
 ;set break ZB10 in the client(start of $$READHDR^HLOT)
"RTN","HLOTRACE",75,0)
 ZB ZB10^HLOT:"N":1:"D ZB10^HLOTRACE"
"RTN","HLOTRACE",76,0)
 ;set break ZB11 in the client(end of $$READHDR^HLOT)
"RTN","HLOTRACE",77,0)
 ZB ZB11^HLOT:"N":1:"D ZB11^HLOTRACE"
"RTN","HLOTRACE",78,0)
 ;set break ZB12 in the client(start of $$READSEG^HLOT)
"RTN","HLOTRACE",79,0)
 ZB ZB12^HLOT:"N":1:"D ZB12^HLOTRACE"
"RTN","HLOTRACE",80,0)
 ;set break ZB13 in the client(end of $$READSEG^HLOT)
"RTN","HLOTRACE",81,0)
 ZB ZB13^HLOT:"N":1:"D ZB13^HLOTRACE"
"RTN","HLOTRACE",82,0)
 ;set break ZB14 in the client(start of $$WRITESEG^HLOT)
"RTN","HLOTRACE",83,0)
 ZB ZB14^HLOT:"N":1:"D ZB14^HLOTRACE"
"RTN","HLOTRACE",84,0)
 ;set break ZB15 in the client(end of $$WRITESEG^HLOT)
"RTN","HLOTRACE",85,0)
 ZB ZB15^HLOT:"N":1:"D ZB15^HLOTRACE"
"RTN","HLOTRACE",86,0)
 ;set break ZB16 in the client(start of $$WRITEHDR^HLOT)
"RTN","HLOTRACE",87,0)
 ZB ZB16^HLOT:"N":1:"D ZB16^HLOTRACE"
"RTN","HLOTRACE",88,0)
 ;set break ZB17 in the client(end of $$WRITEHDR^HLOT)
"RTN","HLOTRACE",89,0)
 ZB ZB17^HLOT:"N":1:"D ZB17^HLOTRACE"
"RTN","HLOTRACE",90,0)
 ;set break ZB18 in the client(start of $$ENDMSG^HLOT)
"RTN","HLOTRACE",91,0)
 ZB ZB18^HLOT:"N":1:"D ZB18^HLOTRACE"
"RTN","HLOTRACE",92,0)
 ;set break ZB19 in the client(end of $$ENDMSG^HLOT)
"RTN","HLOTRACE",93,0)
 ZB ZB19^HLOT:"N":1:"D ZB19^HLOTRACE"
"RTN","HLOTRACE",94,0)
 ZB ZB20^HLOCLNT:"N":1:"D ZB20^HLOTRACE"
"RTN","HLOTRACE",95,0)
 ZB ZB21^HLOCLNT:"N":1:"D ZB21^HLOTRACE"
"RTN","HLOTRACE",96,0)
 ZB ZB22^HLOCLNT:"N":1:"D ZB22^HLOTRACE"
"RTN","HLOTRACE",97,0)
 ZB ZB23^HLOCLNT:"N":1:"D ZB23^HLOTRACE"
"RTN","HLOTRACE",98,0)
 ZB ZB24^HLOCLNT1:"N":1:"D ZB24^HLOTRACE"
"RTN","HLOTRACE",99,0)
 ZB ZB25^HLOCLNT:"N":1:"D WRITE^HLOTRACE(""Calling DEQUE..."")"
"RTN","HLOTRACE",100,0)
 Q
"RTN","HLOTRACE",101,0)
WRITE(MSG) ;
"RTN","HLOTRACE",102,0)
 N OLD
"RTN","HLOTRACE",103,0)
 S OLD=$IO
"RTN","HLOTRACE",104,0)
 U $PRINCIPAL
"RTN","HLOTRACE",105,0)
 W !,?5,"Time: ",$$NOW^XLFDT,"   ",MSG
"RTN","HLOTRACE",106,0)
 U OLD
"RTN","HLOTRACE",107,0)
 Q
"RTN","HLOTRACE",108,0)
WRITE2(MSG,VALUE) ;
"RTN","HLOTRACE",109,0)
 N OLD,I
"RTN","HLOTRACE",110,0)
 S OLD=$IO
"RTN","HLOTRACE",111,0)
 U $PRINCIPAL
"RTN","HLOTRACE",112,0)
 W !,?5,"Time: ",$$NOW^XLFDT,"   ",MSG
"RTN","HLOTRACE",113,0)
 S I=0
"RTN","HLOTRACE",114,0)
 W:$O(VALUE(0)) !
"RTN","HLOTRACE",115,0)
 F  S I=$O(VALUE(I)) Q:'I  W VALUE(I)
"RTN","HLOTRACE",116,0)
 U OLD
"RTN","HLOTRACE",117,0)
 Q
"RTN","HLOTRACE",118,0)
WRITE3(MSG) ;
"RTN","HLOTRACE",119,0)
 N OLD
"RTN","HLOTRACE",120,0)
 S OLD=$IO
"RTN","HLOTRACE",121,0)
 U $PRINCIPAL
"RTN","HLOTRACE",122,0)
 W !,MSG
"RTN","HLOTRACE",123,0)
 U OLD
"RTN","HLOTRACE",124,0)
 Q
"RTN","HLOTRACE",125,0)
 ;
"RTN","HLOTRACE",126,0)
ZB3 ;
"RTN","HLOTRACE",127,0)
 N CON,MSG
"RTN","HLOTRACE",128,0)
 S CON=($ZA\8192#2)
"RTN","HLOTRACE",129,0)
 S MSG="Error encountered, $ECODE="_$ECODE
"RTN","HLOTRACE",130,0)
 D WRITE^HLOTRACE(MSG)
"RTN","HLOTRACE",131,0)
 S MSG=$S(CON:"           TCP connection still active",1:"          TCP connection was dropped")
"RTN","HLOTRACE",132,0)
 D WRITE3^HLOTRACE(MSG)
"RTN","HLOTRACE",133,0)
 D ^%ZTER
"RTN","HLOTRACE",134,0)
 Q
"RTN","HLOTRACE",135,0)
ZB4 ;
"RTN","HLOTRACE",136,0)
 N OLD
"RTN","HLOTRACE",137,0)
 S OLD=$IO
"RTN","HLOTRACE",138,0)
 U $PRINCIPAL
"RTN","HLOTRACE",139,0)
 W !!,"Looking for the next message to transmit..."
"RTN","HLOTRACE",140,0)
 I 'MSGIEN W !!,"No more messages pending on that queue!" S SUCCESS=0 Q
"RTN","HLOTRACE",141,0)
 S TRACECNT=$G(TRACECNT)+1
"RTN","HLOTRACE",142,0)
 I MAXTRACE>1 D
"RTN","HLOTRACE",143,0)
 .W !!,"Message IEN=",MSGIEN," next on queue"
"RTN","HLOTRACE",144,0)
 .I TRACECNT>MAXTRACE D
"RTN","HLOTRACE",145,0)
 ..I $$ASKYESNO^HLOUSR2("Do you want to trace another group of message transmissions","YES") S SUCCESS=1,TRACECNT=1
"RTN","HLOTRACE",146,0)
 ..E  S SUCCESS=0
"RTN","HLOTRACE",147,0)
 .E  S SUCCESS=1
"RTN","HLOTRACE",148,0)
 E  D
"RTN","HLOTRACE",149,0)
 .I '$$ASKYESNO^HLOUSR2("Message IEN="_MSGIEN_" next on queue, do you want to trace its transmission","YES") S SUCCESS=0
"RTN","HLOTRACE",150,0)
 U OLD
"RTN","HLOTRACE",151,0)
 Q
"RTN","HLOTRACE",152,0)
 ;
"RTN","HLOTRACE",153,0)
ZB2 ;
"RTN","HLOTRACE",154,0)
 W !,$S('HLCSTATE("CONNECTED"):"Connection Failed!",1:"Connected!")
"RTN","HLOTRACE",155,0)
 Q
"RTN","HLOTRACE",156,0)
ZB9 ;
"RTN","HLOTRACE",157,0)
 I $G(SUCCESS) D
"RTN","HLOTRACE",158,0)
 .D WRITE^HLOTRACE("Commit acknowledgment received!")
"RTN","HLOTRACE",159,0)
 E  D
"RTN","HLOTRACE",160,0)
 .D WRITE^HLOTRACE("Read of commit acknowledgment FAILED!")
"RTN","HLOTRACE",161,0)
 Q
"RTN","HLOTRACE",162,0)
ZB10 ;
"RTN","HLOTRACE",163,0)
 D WRITE^HLOTRACE("Reading header...")
"RTN","HLOTRACE",164,0)
 Q
"RTN","HLOTRACE",165,0)
ZB11 I $D(HDR) D WRITE2^HLOTRACE("",.HDR)
"RTN","HLOTRACE",166,0)
 D WRITE^HLOTRACE($S(SUCCESS:"Completed!",1:"**** FAILED TO COMPLETE *****"))
"RTN","HLOTRACE",167,0)
 Q
"RTN","HLOTRACE",168,0)
ZB12 ;
"RTN","HLOTRACE",169,0)
 D WRITE^HLOTRACE("Reading next segment...")
"RTN","HLOTRACE",170,0)
 Q
"RTN","HLOTRACE",171,0)
ZB13 I $D(SEG) D WRITE2^HLOTRACE("",.SEG)
"RTN","HLOTRACE",172,0)
 D WRITE^HLOTRACE($S(RETURN:"Completed!",$G(HLCSTATE("MESSAGE ENDED")):"No more segments!",1:"**** FAILED TO COMPLETE *****"))
"RTN","HLOTRACE",173,0)
 Q
"RTN","HLOTRACE",174,0)
ZB14 ;
"RTN","HLOTRACE",175,0)
 D WRITE2^HLOTRACE("Writing next segment...",.SEG)
"RTN","HLOTRACE",176,0)
 Q
"RTN","HLOTRACE",177,0)
ZB15 D WRITE^HLOTRACE($S(RETURN:"Completed!",1:"**** FAILED TO COMPLETE *****"))
"RTN","HLOTRACE",178,0)
 Q
"RTN","HLOTRACE",179,0)
ZB16 ;
"RTN","HLOTRACE",180,0)
 D WRITE2^HLOTRACE("Writing header segment...",.HDR)
"RTN","HLOTRACE",181,0)
 Q
"RTN","HLOTRACE",182,0)
ZB17 D WRITE^HLOTRACE($S(SUCCESS:"Completed!",1:"**** FAILED TO COMPLETE *****"))
"RTN","HLOTRACE",183,0)
 Q
"RTN","HLOTRACE",184,0)
ZB18 ;
"RTN","HLOTRACE",185,0)
 D WRITE^HLOTRACE("Writing message terminators and flushing buffer...")
"RTN","HLOTRACE",186,0)
 Q
"RTN","HLOTRACE",187,0)
ZB19 D WRITE^HLOTRACE($S(RETURN:"Completed!",1:"**** FAILED TO COMPLETE *****"))
"RTN","HLOTRACE",188,0)
 Q
"RTN","HLOTRACE",189,0)
ZB20 ;
"RTN","HLOTRACE",190,0)
 D WRITE^HLOTRACE("Message on queue was already transmitted, will be deleted from queue...")
"RTN","HLOTRACE",191,0)
 Q
"RTN","HLOTRACE",192,0)
ZB21 ;
"RTN","HLOTRACE",193,0)
 D WRITE^HLOTRACE("MSA segment shows this is not a commmit ack to the message transmitted...")
"RTN","HLOTRACE",194,0)
 Q
"RTN","HLOTRACE",195,0)
ZB22 ;
"RTN","HLOTRACE",196,0)
 D WRITE^HLOTRACE("Commit ack not CA, message status set to error...")
"RTN","HLOTRACE",197,0)
 Q
"RTN","HLOTRACE",198,0)
ZB23 ;
"RTN","HLOTRACE",199,0)
 D WRITE^HLOTRACE("Setting timestamp of sequence queue...")
"RTN","HLOTRACE",200,0)
 Q
"RTN","HLOTRACE",201,0)
ZB24 ;S HLOCSTATE("CONNECTED")=1
"RTN","HLOTRACE",202,0)
 S HLCSTATE("LINK","SHUTDOWN")=0
"RTN","HLOTRACE",203,0)
 Q
"RTN","HLOTRACE",204,0)
 ; 
"RTN","HLOTRACE",205,0)
ASKQUE(SUB) ;
"RTN","HLOTRACE",206,0)
 N DIR,Q1,Q2
"RTN","HLOTRACE",207,0)
 S Q1=$O(^HLB("QUEUE","OUT",SUB,""))
"RTN","HLOTRACE",208,0)
 I Q1="" W !,"There are no outgoing messages queued to that link!",! Q ""
"RTN","HLOTRACE",209,0)
 S Q2=$O(^HLB("QUEUE","OUT",SUB,Q1))
"RTN","HLOTRACE",210,0)
 I Q2="" D
"RTN","HLOTRACE",211,0)
 .S DIR("B")=Q1
"RTN","HLOTRACE",212,0)
 E  I $D(^HLB("QUEUE","OUT",SUB,"DEFAULT")) D
"RTN","HLOTRACE",213,0)
 .S DIR("B")="DEFAULT"
"RTN","HLOTRACE",214,0)
 E  D
"RTN","HLOTRACE",215,0)
 .S DIR("B")=Q1
"RTN","HLOTRACE",216,0)
 S DIR(0)="F^1:20"
"RTN","HLOTRACE",217,0)
 S DIR("A")="What is the name of the queue"
"RTN","HLOTRACE",218,0)
 S DIR("?",1)="To use this tool, there must be messages aleady pending transmission."
"RTN","HLOTRACE",219,0)
 S DIR("?")="Enter the name of the queue, or '^' to exit."
"RTN","HLOTRACE",220,0)
 D ^DIR
"RTN","HLOTRACE",221,0)
 I $D(DIRUT)!(Y="") Q ""
"RTN","HLOTRACE",222,0)
 Q Y
"RTN","HLOTRACE",223,0)
 ;
"RTN","HLOTRACE",224,0)
ASKCOUNT() ;
"RTN","HLOTRACE",225,0)
 N DIR
"RTN","HLOTRACE",226,0)
 S DIR(0)="N^1:100"
"RTN","HLOTRACE",227,0)
 S DIR("A")="Send how many at a time"
"RTN","HLOTRACE",228,0)
 S DIR("B")=1
"RTN","HLOTRACE",229,0)
 S DIR("?",1)="How many messages do you want to transmit at once"
"RTN","HLOTRACE",230,0)
 S DIR("?")="while tracing the client (100 maximum)?"
"RTN","HLOTRACE",231,0)
 D ^DIR
"RTN","HLOTRACE",232,0)
 Q:$D(DTOUT)!$D(DUOUT) -1
"RTN","HLOTRACE",233,0)
 Q X
"RTN","HLOTRACE",234,0)
ASKPORT(LINK) ;
"RTN","HLOTRACE",235,0)
 Q:LINK="" ""
"RTN","HLOTRACE",236,0)
 N PORT,QUEUE
"RTN","HLOTRACE",237,0)
 S QUEUE=$O(^HLB("QUEUE","OUT",LINK_":"))
"RTN","HLOTRACE",238,0)
 Q:$P(QUEUE,":")'=LINK ""
"RTN","HLOTRACE",239,0)
 S PORT=$P(QUEUE,":",2)
"RTN","HLOTRACE",240,0)
 Q:'PORT ""
"RTN","HLOTRACE",241,0)
 S QUEUE=$O(^HLB("QUEUE","OUT",QUEUE))
"RTN","HLOTRACE",242,0)
 Q:$P(QUEUE,":")'=LINK PORT
"RTN","HLOTRACE",243,0)
 S PORT=$$ASKPORT^HLOUSRA(LINK)
"RTN","HLOTRACE",244,0)
 Q PORT
"RTN","HLOUSR")
0^14^B121177713^B92223063
"RTN","HLOUSR",1,0)
HLOUSR ;ALB/CJM/OAK/PIJ/RBN -ListManager Screen for viewing system status;12 JUN 1997 10:00 am ;08/23/2010
"RTN","HLOUSR",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,130,134,137,138,139,146,147**;Oct 13, 1995;Build 15
"RTN","HLOUSR",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOUSR",4,0)
 ;
"RTN","HLOUSR",5,0)
EN ;
"RTN","HLOUSR",6,0)
 ;
"RTN","HLOUSR",7,0)
 N HLSCREEN,TESTOPEN,HLRFRSH,HLPARMS
"RTN","HLOUSR",8,0)
 D WAIT^DICD
"RTN","HLOUSR",9,0)
 D EN^VALM("HLO SYSTEM MONITOR")
"RTN","HLOUSR",10,0)
 Q
"RTN","HLOUSR",11,0)
 ;
"RTN","HLOUSR",12,0)
BRIEF ;
"RTN","HLOUSR",13,0)
 N COUNT,LINK,QUE,FROM,TIME,STATUS,TEMP,DIR,TODAY,LIST,LNKMSG,OS
"RTN","HLOUSR",14,0)
 S HLRFRSH="BRIEF^HLOUSR"
"RTN","HLOUSR",15,0)
 S (HLSCREEN,VALMSG)="Brief System Status"
"RTN","HLOUSR",16,0)
 S VALMCNT=16
"RTN","HLOUSR",17,0)
 ;K @VALMAR
"RTN","HLOUSR",18,0)
 S OS=$$OS^%ZOSV
"RTN","HLOUSR",19,0)
 ;
"RTN","HLOUSR",20,0)
 D CLEAN^VALM10
"RTN","HLOUSR",21,0)
 S VALMBG=1
"RTN","HLOUSR",22,0)
 S VALMBCK="R"
"RTN","HLOUSR",23,0)
 S VALMDDF("COL 1")="COL1^1^80^"
"RTN","HLOUSR",24,0)
 K VALMDDF("COL 2"),VALMDDF("COL 3"),VALMDDF("COL 4"),VALMDDF("COL 5")
"RTN","HLOUSR",25,0)
 D CHGCAP^VALM("COL 1"," Brief Operational Overview")
"RTN","HLOUSR",26,0)
 S @VALMAR@(1,0)="SYSTEM STATUS:             "_$S($$CHKSTOP^HLOPROC:"STOPPED",1:"RUNNING")
"RTN","HLOUSR",27,0)
 S @VALMAR@(2,0)="PROCESS MANAGER:           "_$S($$RUNNING:"RUNNING",1:"STOPPED")
"RTN","HLOUSR",28,0)
 ;
"RTN","HLOUSR",29,0)
 ;
"RTN","HLOUSR",30,0)
 I $$CHKSTOP^HLOPROC,OS'["VMS" S TESTOPEN("LISTENER")=""
"RTN","HLOUSR",31,0)
 S TIME=$P($G(TESTOPEN("LISTENER")),"^",2)
"RTN","HLOUSR",32,0)
 I TIME,$$FMDIFF^XLFDT($$NOW^XLFDT,TIME,2)<100 D
"RTN","HLOUSR",33,0)
 .S STATUS=+TESTOPEN("LISTENER")
"RTN","HLOUSR",34,0)
 E  D
"RTN","HLOUSR",35,0)
 .;** P147 START CJM
"RTN","HLOUSR",36,0)
 .;is the Kernel listener running under the HLO process manager?
"RTN","HLOUSR",37,0)
 .S STATUS=$$KLISTEN
"RTN","HLOUSR",38,0)
 .;
"RTN","HLOUSR",39,0)
 .;if the Kernel listner is NOT running, might check the listener via the OPEN command.  With loadbalancing, the IP address of the listener link sometimes fails, so also try 'loopback'.
"RTN","HLOUSR",40,0)
 .I 'STATUS,(OS["VMS")!('$$CHKSTOP^HLOPROC) D
"RTN","HLOUSR",41,0)
 ..N IP,LINK
"RTN","HLOUSR",42,0)
 ..S LINK=$P($G(^HLD(779.1,1,0)),"^",10)
"RTN","HLOUSR",43,0)
 ..I LINK,$$GET^HLOTLNK(LINK,.LINK) D
"RTN","HLOUSR",44,0)
 ...F IP="127.0.0.1","0.0.0.0",LINK("IP") D  Q:STATUS
"RTN","HLOUSR",45,0)
 ....N POP,IO,IOF,IOST
"RTN","HLOUSR",46,0)
 ....D CALL^%ZISTCP(IP,LINK("PORT"),5)
"RTN","HLOUSR",47,0)
 ....S STATUS='POP
"RTN","HLOUSR",48,0)
 ....C:STATUS IO
"RTN","HLOUSR",49,0)
 .;
"RTN","HLOUSR",50,0)
 .S:(('STATUS)&('$$CHKSTOP^HLOPROC)) LNKMSG=$S(OS["VMS":" Please start the HLO VMS TCPIP SERVICE",1:"Please start the HLO Listener")
"RTN","HLOUSR",51,0)
 .;
"RTN","HLOUSR",52,0)
 .;** P147 END CJM
"RTN","HLOUSR",53,0)
 .;
"RTN","HLOUSR",54,0)
 .D:'STATUS CNTRL^VALM10(3,38,85,IOINHI,IOINORM)
"RTN","HLOUSR",55,0)
 .S TESTOPEN("LISTENER")=STATUS_"^"_$$NOW^XLFDT
"RTN","HLOUSR",56,0)
 ;
"RTN","HLOUSR",57,0)
 S @VALMAR@(3,0)="STANDARD LISTENER:         "_$S(STATUS:"RUNNING",1:"STOPPED   ")_$G(LNKMSG)
"RTN","HLOUSR",58,0)
 ;** P139 end **
"RTN","HLOUSR",59,0)
 ;
"RTN","HLOUSR",60,0)
 S @VALMAR@(4,0)="TASKMAN:                   "_$S($$TM^%ZTLOAD:"RUNNING",1:"STOPPPED")
"RTN","HLOUSR",61,0)
 ;
"RTN","HLOUSR",62,0)
 S (LIST,LINK)=""
"RTN","HLOUSR",63,0)
 F  S LINK=$O(^HLTMP("FAILING LINKS",LINK)) Q:LINK=""  D  I $L(LIST)>60 S LIST=LIST_",..." Q
"RTN","HLOUSR",64,0)
 .N TIME,QUE,LINKARY
"RTN","HLOUSR",65,0)
 .I $$GETLINK^HLOTLNK($P(LINK,":"),.LINKARY)
"RTN","HLOUSR",66,0)
 .S TIME=$G(^HLTMP("FAILING LINKS",LINK)) Q:TIME=""
"RTN","HLOUSR",67,0)
 .I '$G(LINKARY("SHUTDOWN")),TIME="" Q
"RTN","HLOUSR",68,0)
 .I '$G(LINKARY("SHUTDOWN")),($$HDIFF^XLFDT($H,TIME,2)<300) Q
"RTN","HLOUSR",69,0)
 .;;***patch HL*1.6*138 start
"RTN","HLOUSR",70,0)
 .S LIST=LIST_$S($L(LIST):", ",1:"")_LINK
"RTN","HLOUSR",71,0)
 .;;.S LIST=LIST_$S($L(LIST):", ",1:"")_$P(LINK,":")
"RTN","HLOUSR",72,0)
 .;; ***patch HL*1.6*138 end
"RTN","HLOUSR",73,0)
 S @VALMAR@(5,0)="DOWN LINKS: "_LIST
"RTN","HLOUSR",74,0)
 S @VALMAR@(6,0)="CLIENT LINK PROCESSES:     "_+$G(^HLC("HL7 PROCESS COUNTS","RUNNING","OUTGOING CLIENT LINK"))
"RTN","HLOUSR",75,0)
 S @VALMAR@(7,0)="IN-FILER PROCESSES:        "_+$G(^HLC("HL7 PROCESS COUNTS","RUNNING","INCOMING QUEUES"))
"RTN","HLOUSR",76,0)
 ; ***patch HL*1.6*146 START - RBN ***
"RTN","HLOUSR",77,0)
 ;S COUNT=0,LINK=""
"RTN","HLOUSR",78,0)
 ;F  S LINK=$O(^HLC("QUEUECOUNT","OUT",LINK)) Q:LINK=""  D
"RTN","HLOUSR",79,0)
 ;.S QUE=""
"RTN","HLOUSR",80,0)
 ;.F  S QUE=$O(^HLC("QUEUECOUNT","OUT",LINK,QUE)) Q:QUE=""  D
"RTN","HLOUSR",81,0)
 ;..S TEMP=$G(^HLC("QUEUECOUNT","OUT",LINK,QUE))
"RTN","HLOUSR",82,0)
 ;..S:TEMP>0 COUNT=COUNT+TEMP
"RTN","HLOUSR",83,0)
 N CNTARRAY
"RTN","HLOUSR",84,0)
 S COUNT=$$OUT^HLOQUE(.CNTARRAY)
"RTN","HLOUSR",85,0)
 ; ***patch HL*1.6*146 END - RBN ***
"RTN","HLOUSR",86,0)
 S @VALMAR@(8,0)="MESSAGES PENDING ON OUT QUEUES:    "_$$RJ(+COUNT,7)_"     ON SEQUENCE QUEUES:  "_$$RJ(+$G(^HLC("QUEUECOUNT","SEQUENCE")),7)
"RTN","HLOUSR",87,0)
 S TEMP="STOPPED OUTGOING QUEUES: "
"RTN","HLOUSR",88,0)
 S COUNT=0,QUE=""
"RTN","HLOUSR",89,0)
 F  S QUE=$O(^HLTMP("STOPPED QUEUES","OUT",QUE)) Q:QUE=""  S COUNT=COUNT+1 Q:COUNT>4  S:COUNT=1 TEMP=TEMP_QUE S:"23"[COUNT TEMP=TEMP_"; "_QUE S:COUNT=4 TEMP=TEMP_" ..."
"RTN","HLOUSR",90,0)
 S @VALMAR@(9,0)=TEMP
"RTN","HLOUSR",91,0)
 ; ***patch HL*1.6*146 START - RBN ***
"RTN","HLOUSR",92,0)
 ;S COUNT=0,QUE=""
"RTN","HLOUSR",93,0)
 ;F  S QUE=$O(^HLC("QUEUECOUNT","IN",QUE)) Q:QUE=""  D
"RTN","HLOUSR",94,0)
 ;.S FROM=""
"RTN","HLOUSR",95,0)
 ;.F  S FROM=$O(^HLC("QUEUECOUNT","IN",QUE,FROM)) Q:FROM=""  D
"RTN","HLOUSR",96,0)
 ;..S TEMP=$G(^HLC("QUEUECOUNT","IN",QUE,FROM))
"RTN","HLOUSR",97,0)
 ;..S:TEMP>0 COUNT=COUNT+TEMP
"RTN","HLOUSR",98,0)
 S COUNT=0
"RTN","HLOUSR",99,0)
 K CNTARRAY
"RTN","HLOUSR",100,0)
 S COUNT=$$IN^HLOQUE(.CNTARRAY)
"RTN","HLOUSR",101,0)
 ; ***patch HL*1.6*146 END - RBN ***
"RTN","HLOUSR",102,0)
 S @VALMAR@(10,0)="MESSAGES PENDING ON APPLICATIONS: "_$$RJ(+COUNT,7)
"RTN","HLOUSR",103,0)
 S TEMP="STOPPED INCOMING QUEUES: "
"RTN","HLOUSR",104,0)
 S COUNT=0,QUE=""
"RTN","HLOUSR",105,0)
 F  S QUE=$O(^HLTMP("STOPPED QUEUES","IN",QUE)) Q:QUE=""  S COUNT=COUNT+1 Q:COUNT>4  S:COUNT=1 TEMP=TEMP_QUE S:"23"[COUNT TEMP=TEMP_"; "_QUE S:COUNT=4 TEMP=TEMP_" ..."
"RTN","HLOUSR",106,0)
 S @VALMAR@(11,0)=TEMP
"RTN","HLOUSR",107,0)
 S @VALMAR@(12,0)="FILE 777 RECORD COUNT:         "_$$RJ($P($G(^HLTMP("FILE 777 RECORD COUNT")),"^"),10)_"     --> as of "_$$FMTE^XLFDT($P($G(^HLTMP("FILE 777 RECORD COUNT")),"^",2))
"RTN","HLOUSR",108,0)
 S @VALMAR@(13,0)="FILE 778 RECORD COUNT:         "_$$RJ($P($G(^HLTMP("FILE 778 RECORD COUNT")),"^"),10)_"     --> as of "_$$FMTE^XLFDT($P($G(^HLTMP("FILE 778 RECORD COUNT")),"^",2))
"RTN","HLOUSR",109,0)
 S TODAY=$$DT^XLFDT
"RTN","HLOUSR",110,0)
 S @VALMAR@(14,0)="MESSAGES SENT TODAY:           "_$$RJ($$ADD("OUT"),10)
"RTN","HLOUSR",111,0)
 S @VALMAR@(15,0)="MESSAGES RECEIVED TODAY:       "_$$RJ($$ADD("IN"),10)
"RTN","HLOUSR",112,0)
 S @VALMAR@(16,0)="MESSAGE ERRORS TODAY:          "_$$RJ($$ADD("EOUT")+$$ADD("EIN"),10)
"RTN","HLOUSR",113,0)
 Q
"RTN","HLOUSR",114,0)
 ;
"RTN","HLOUSR",115,0)
ADD(DIR) ;
"RTN","HLOUSR",116,0)
 N RAP,SAP,TIME,TOTAL,TYPE
"RTN","HLOUSR",117,0)
 S TOTAL=0
"RTN","HLOUSR",118,0)
 S TIME=TODAY-.0001
"RTN","HLOUSR",119,0)
 F  S TIME=$O(^HLSTATS(DIR,"HOURLY",TIME)) Q:'TIME  Q:((TIME\1)>TODAY)  D
"RTN","HLOUSR",120,0)
 .S SAP=""
"RTN","HLOUSR",121,0)
 .F  S SAP=$O(^HLSTATS(DIR,"HOURLY",TIME,SAP)) Q:SAP=""  D
"RTN","HLOUSR",122,0)
 ..Q:SAP="ACCEPT ACK"
"RTN","HLOUSR",123,0)
 ..S RAP=""
"RTN","HLOUSR",124,0)
 ..F  S RAP=$O(^HLSTATS(DIR,"HOURLY",TIME,SAP,RAP)) Q:RAP=""  D
"RTN","HLOUSR",125,0)
 ...S TYPE=""
"RTN","HLOUSR",126,0)
 ...F  S TYPE=$O(^HLSTATS(DIR,"HOURLY",TIME,SAP,RAP,TYPE)) Q:TYPE=""  D
"RTN","HLOUSR",127,0)
 ....S TOTAL=TOTAL+$G(^HLSTATS(DIR,"HOURLY",TIME,SAP,RAP,TYPE))
"RTN","HLOUSR",128,0)
 Q TOTAL
"RTN","HLOUSR",129,0)
 ;
"RTN","HLOUSR",130,0)
HELP ;
"RTN","HLOUSR",131,0)
 S X="?" D DISP^XQORM1 W !!
"RTN","HLOUSR",132,0)
 Q
"RTN","HLOUSR",133,0)
 ;
"RTN","HLOUSR",134,0)
EXIT ;
"RTN","HLOUSR",135,0)
 D CLEAN^VALM10
"RTN","HLOUSR",136,0)
 D CLEAR^VALM1
"RTN","HLOUSR",137,0)
 Q
"RTN","HLOUSR",138,0)
 ;
"RTN","HLOUSR",139,0)
EXPND ;
"RTN","HLOUSR",140,0)
 Q
"RTN","HLOUSR",141,0)
 ;
"RTN","HLOUSR",142,0)
PROCS ;
"RTN","HLOUSR",143,0)
 S HLRFRSH="PROCS^HLOUSR"
"RTN","HLOUSR",144,0)
 ;K @VALMAR
"RTN","HLOUSR",145,0)
 D CLEAN^VALM10
"RTN","HLOUSR",146,0)
 S VALMCNT=0
"RTN","HLOUSR",147,0)
 S VALMBCK="R"
"RTN","HLOUSR",148,0)
 S VALMDDF("COL 1")="COL 1^1^34^"
"RTN","HLOUSR",149,0)
 S VALMDDF("COL 2")="COL 2^35^10^MIN^H"
"RTN","HLOUSR",150,0)
 S VALMDDF("COL 3")="COL 3^47^10^MAX^H"
"RTN","HLOUSR",151,0)
 S VALMDDF("COL 4")="COL 4^59^10^#RUNNING^H"
"RTN","HLOUSR",152,0)
 S VALMDDF("COL 5")="COL 5^71^10^#QUEUED^IOBON"
"RTN","HLOUSR",153,0)
 D CHGCAP^VALM("COL 1"," Process Type")
"RTN","HLOUSR",154,0)
 N IEN
"RTN","HLOUSR",155,0)
 S IEN=0
"RTN","HLOUSR",156,0)
 F  S IEN=$O(^HLD(779.3,"C",1,IEN)) Q:'IEN  D
"RTN","HLOUSR",157,0)
 .N PROC
"RTN","HLOUSR",158,0)
 .Q:'$$GETPROC^HLOPROC1(IEN,.PROC)
"RTN","HLOUSR",159,0)
 .Q:PROC("NAME")="VMS TCP LISTENER"
"RTN","HLOUSR",160,0)
 .S VALMCNT=VALMCNT+1
"RTN","HLOUSR",161,0)
 .S @VALMAR@(VALMCNT,0)=$$LJ(PROC("NAME"),30)_$$RJ(PROC("MINIMUM"),6)_$$RJ(PROC("MAXIMUM"),12)_$$RJ(+$G(^HLC("HL7 PROCESS COUNTS","RUNNING",PROC("NAME"))),14)_$$RJ(+$G(^HLC("HL7 PROCESS COUNTS","QUEUED",PROC("NAME"))),12)
"RTN","HLOUSR",162,0)
 S VALMCNT=VALMCNT+1,@VALMAR@(VALMCNT,0)=""
"RTN","HLOUSR",163,0)
 S IEN=""
"RTN","HLOUSR",164,0)
 F  S IEN=$O(^HLTMP("HL7 RUNNING PROCESSES",IEN)) Q:IEN=""  D
"RTN","HLOUSR",165,0)
 .N NODE
"RTN","HLOUSR",166,0)
 .S NODE=$G(^HLTMP("HL7 RUNNING PROCESSES",IEN))
"RTN","HLOUSR",167,0)
 .Q:NODE=""
"RTN","HLOUSR",168,0)
 .S VALMCNT=VALMCNT+1
"RTN","HLOUSR",169,0)
 .S @VALMAR@(VALMCNT,0)="$J: "_$$LJ(IEN,9)_" ->"_$$CJ($P(NODE,"^",3),28)_"<- started at "_$$HTE^XLFDT($P(NODE,"^"))
"RTN","HLOUSR",170,0)
 Q
"RTN","HLOUSR",171,0)
 ;
"RTN","HLOUSR",172,0)
INQUEUE ;
"RTN","HLOUSR",173,0)
 N FROM
"RTN","HLOUSR",174,0)
 D CLEAN^VALM10
"RTN","HLOUSR",175,0)
 ;K @VALMAR
"RTN","HLOUSR",176,0)
 S HLRFRSH="INQUEUE^HLOUSR"
"RTN","HLOUSR",177,0)
 S (HLSCREEN,VALMSG)="Incoming Queues ('!' = stopped queues)"
"RTN","HLOUSR",178,0)
 S VALMCNT=0
"RTN","HLOUSR",179,0)
 S VALMBCK="R"
"RTN","HLOUSR",180,0)
 S VALMDDF("COL 1")="COL 1^1^40^ From^H"
"RTN","HLOUSR",181,0)
 S VALMDDF("COL 2")="COL 2^45^20^Queue^H"
"RTN","HLOUSR",182,0)
 S VALMDDF("COL 3")="COL 3^70^10^Count^H"
"RTN","HLOUSR",183,0)
 K VALMDDF("COL 4"),VALMDDF("COL 5")
"RTN","HLOUSR",184,0)
 D CHGCAP^VALM("COL 1"," From")
"RTN","HLOUSR",185,0)
 S FROM=""
"RTN","HLOUSR",186,0)
 F  S FROM=$O(^HLC("QUEUECOUNT","IN",FROM)) Q:FROM=""  D
"RTN","HLOUSR",187,0)
 .N COUNT,QUE,SHOW
"RTN","HLOUSR",188,0)
 .S SHOW=$$LJ(FROM,40)_"  "
"RTN","HLOUSR",189,0)
 .S QUE=""
"RTN","HLOUSR",190,0)
 .F  S QUE=$O(^HLC("QUEUECOUNT","IN",FROM,QUE)) Q:QUE=""  D
"RTN","HLOUSR",191,0)
 ..S COUNT=$G(^HLC("QUEUECOUNT","IN",FROM,QUE))
"RTN","HLOUSR",192,0)
 ..Q:COUNT<0
"RTN","HLOUSR",193,0)
 ..S VALMCNT=VALMCNT+1
"RTN","HLOUSR",194,0)
 ..S @VALMAR@(VALMCNT,0)=SHOW_$$LJ($S($$STOPPED^HLOQUE("IN",QUE):"!",1:"")_QUE,21)_" "_$$RJ(COUNT,10)
"RTN","HLOUSR",195,0)
 ..S SHOW=$$LJ("",40)_"  "
"RTN","HLOUSR",196,0)
 Q
"RTN","HLOUSR",197,0)
VIEWLINK ;
"RTN","HLOUSR",198,0)
 N C,QUIT,LINK,LINKARY,TEMP
"RTN","HLOUSR",199,0)
 S (QUIT,C,LINK)=""
"RTN","HLOUSR",200,0)
 S VALMBCK="R"
"RTN","HLOUSR",201,0)
 ;
"RTN","HLOUSR",202,0)
 ;currently HL7 (Optimized) only does TCP
"RTN","HLOUSR",203,0)
 S LINK=$$ASKLINK
"RTN","HLOUSR",204,0)
 Q:LINK=""
"RTN","HLOUSR",205,0)
 Q:'$$GETLINK^HLOTLNK(LINK,.LINKARY)
"RTN","HLOUSR",206,0)
 S LINK=LINK_":"_LINKARY("PORT")
"RTN","HLOUSR",207,0)
 W !,"Hit any key to stop...",!
"RTN","HLOUSR",208,0)
 F  D  Q:QUIT
"RTN","HLOUSR",209,0)
 .N COUNT,QUE
"RTN","HLOUSR",210,0)
 .S (COUNT,QUE)=""
"RTN","HLOUSR",211,0)
 .F  S QUE=$O(^HLC("QUEUECOUNT","OUT",LINK,QUE)) Q:QUE=""  S TEMP=$G(^HLC("QUEUECOUNT","OUT",LINK,QUE)) S:TEMP>0 COUNT=COUNT+TEMP
"RTN","HLOUSR",212,0)
 .W $C(13),"                             ",$C(13),"MESSAGES PENDING TRANSMISSION: ",IOBON,$$RJ(+COUNT,10),IOBOFF
"RTN","HLOUSR",213,0)
 .R *C:1 I $T S QUIT=1
"RTN","HLOUSR",214,0)
 Q
"RTN","HLOUSR",215,0)
 ;
"RTN","HLOUSR",216,0)
CJ(STRING,LEN) ;
"RTN","HLOUSR",217,0)
 Q $$CJ^XLFSTR($E(STRING,1,LEN),LEN)
"RTN","HLOUSR",218,0)
LJ(STRING,LEN) ;
"RTN","HLOUSR",219,0)
 Q $$LJ^XLFSTR($E(STRING,1,LEN),LEN)
"RTN","HLOUSR",220,0)
RJ(STRING,LEN) ;
"RTN","HLOUSR",221,0)
 Q $$RJ^XLFSTR($E(STRING,1,LEN),LEN)
"RTN","HLOUSR",222,0)
 ;
"RTN","HLOUSR",223,0)
RUNNING() ;Process Manager running?
"RTN","HLOUSR",224,0)
 N RUNNING
"RTN","HLOUSR",225,0)
 L +^HLTMP("PROCESS MANAGER"):0
"RTN","HLOUSR",226,0)
 S RUNNING='$T
"RTN","HLOUSR",227,0)
 I 'RUNNING L -^HLTMP("PROCESS MANAGER")
"RTN","HLOUSR",228,0)
 Q RUNNING
"RTN","HLOUSR",229,0)
 ;
"RTN","HLOUSR",230,0)
TESTLINK ;
"RTN","HLOUSR",231,0)
 N LINKNAME,OK,PORT,LINK
"RTN","HLOUSR",232,0)
 S VALMBCK="R"
"RTN","HLOUSR",233,0)
 S LINKNAME=$$ASKLINK
"RTN","HLOUSR",234,0)
 Q:LINKNAME=""
"RTN","HLOUSR",235,0)
 ;**P138 START
"RTN","HLOUSR",236,0)
 S PORT=$$ASKPORT^HLOUSRA(LINKNAME)
"RTN","HLOUSR",237,0)
 Q:'PORT
"RTN","HLOUSR",238,0)
 S LINK=LINKNAME_":"_PORT
"RTN","HLOUSR",239,0)
 ;S OK=$$IFOPEN^HLOUSR1(LINKNAME)
"RTN","HLOUSR",240,0)
 S OK=$$IFOPEN^HLOUSR1(LINK)
"RTN","HLOUSR",241,0)
 ;** P138 END
"RTN","HLOUSR",242,0)
 I OK W !,LINK_" IS operational..."
"RTN","HLOUSR",243,0)
 E  W !,LINK_" is NOT operational..."
"RTN","HLOUSR",244,0)
 W !,"Hit any key to continue..."
"RTN","HLOUSR",245,0)
 R *C:DTIME
"RTN","HLOUSR",246,0)
 Q
"RTN","HLOUSR",247,0)
 ;
"RTN","HLOUSR",248,0)
ASKLINK() ;
"RTN","HLOUSR",249,0)
 N DIC,TCP,X,Y,DTOUT,DUOUT
"RTN","HLOUSR",250,0)
 S DIC=870
"RTN","HLOUSR",251,0)
 S DIC(0)="AEMNQ"
"RTN","HLOUSR",252,0)
 S TCP=$O(^HLCS(869.1,"B","TCP",0))
"RTN","HLOUSR",253,0)
 S DIC("A")="Select a TCP link:"
"RTN","HLOUSR",254,0)
 S DIC("S")="I $P(^(0),U,3)=TCP"
"RTN","HLOUSR",255,0)
 D FULL^VALM1
"RTN","HLOUSR",256,0)
 D ^DIC
"RTN","HLOUSR",257,0)
 I +Y'=-1,'$D(DTOUT),'$D(DUOUT) Q $P(Y,"^",2)
"RTN","HLOUSR",258,0)
 Q ""
"RTN","HLOUSR",259,0)
 ;
"RTN","HLOUSR",260,0)
STOP ;
"RTN","HLOUSR",261,0)
 I '$$ASKYESNO^HLOUSR2("Are you SURE that you want to stop sending and receiving messages","NO") S VALMBCK="" Q
"RTN","HLOUSR",262,0)
 ;
"RTN","HLOUSR",263,0)
 D STOPHL7^HLOPROC1
"RTN","HLOUSR",264,0)
 S VALMBCK="R",VALMSG="HL7 (Optimized) has been stopped...."
"RTN","HLOUSR",265,0)
 H 5
"RTN","HLOUSR",266,0)
 D @HLRFRSH
"RTN","HLOUSR",267,0)
 ;D:HLSCREEN="Brief System Status" BRIEF^HLOUSR
"RTN","HLOUSR",268,0)
 ;D:HLSCREEN="Running Processes" PROCS^HLOUSR
"RTN","HLOUSR",269,0)
 Q
"RTN","HLOUSR",270,0)
 ;
"RTN","HLOUSR",271,0)
UPDMODE ;realtime
"RTN","HLOUSR",272,0)
 Q:'$L(HLRFRSH)
"RTN","HLOUSR",273,0)
 N TOP,BOTTOM,DX,DY,IOTM,IOBM,LINE,OLD,OLDCNT
"RTN","HLOUSR",274,0)
 S OLDCNT=VALMCNT
"RTN","HLOUSR",275,0)
 W !!!!!,IOINHI,"Hit any key to escape realtime display mode...",IOINORM
"RTN","HLOUSR",276,0)
 S IOTM=20,IOBM=23 W @IOSTBM
"RTN","HLOUSR",277,0)
 S TOP=VALMBG
"RTN","HLOUSR",278,0)
 S BOTTOM=TOP+20
"RTN","HLOUSR",279,0)
 F LINE=TOP:1:BOTTOM D
"RTN","HLOUSR",280,0)
 .I LINE>VALMCNT S @VALMAR@(LINE,0)=$$LJ(" ",80) Q
"RTN","HLOUSR",281,0)
 .S @VALMAR@(LINE,0)=$$LJ($G(@VALMAR@(LINE,0)),80)
"RTN","HLOUSR",282,0)
 F LINE=TOP:1:BOTTOM D
"RTN","HLOUSR",283,0)
 .S OLD(LINE)=$G(@VALMAR@(LINE,0))
"RTN","HLOUSR",284,0)
 F LINE=17:1:BOTTOM D
"RTN","HLOUSR",285,0)
 .S DX=50,DY=22 X IOXY W !
"RTN","HLOUSR",286,0)
 .D WRITE^VALM10(LINE)
"RTN","HLOUSR",287,0)
 D  F  R *C:4 Q:$T  D
"RTN","HLOUSR",288,0)
 .D @HLRFRSH
"RTN","HLOUSR",289,0)
 .;**START PATCH 138**
"RTN","HLOUSR",290,0)
 .S OLDCNT=VALMCNT
"RTN","HLOUSR",291,0)
 .;**END PATCH 138**
"RTN","HLOUSR",292,0)
 .F LINE=TOP:1:BOTTOM D
"RTN","HLOUSR",293,0)
 ..I LINE>VALMCNT S @VALMAR@(LINE,0)=$$LJ(" ",80) Q
"RTN","HLOUSR",294,0)
 ..S @VALMAR@(LINE,0)=$$LJ($G(@VALMAR@(LINE,0)),80)
"RTN","HLOUSR",295,0)
 .S VALMCNT=BOTTOM
"RTN","HLOUSR",296,0)
 .F LINE=TOP:1:BOTTOM IF OLD(LINE)'=$G(@VALMAR@(LINE,0)) D
"RTN","HLOUSR",297,0)
 ..S OLD(LINE)=$G(@VALMAR@(LINE,0))
"RTN","HLOUSR",298,0)
 ..S DX=50,DY=22 X IOXY W !
"RTN","HLOUSR",299,0)
 ..D WRITE^VALM10(LINE)
"RTN","HLOUSR",300,0)
 ;**START PATCH 138**
"RTN","HLOUSR",301,0)
 S VALMCNT=OLDCNT
"RTN","HLOUSR",302,0)
 I VALMCNT<VALMBG S VALMBG=VALMCNT
"RTN","HLOUSR",303,0)
 ;**END PATCH 138**
"RTN","HLOUSR",304,0)
 S VALMBCK="R"
"RTN","HLOUSR",305,0)
 Q
"RTN","HLOUSR",306,0)
 ;
"RTN","HLOUSR",307,0)
EDITSITE ;
"RTN","HLOUSR",308,0)
 ;edit HLO System Parameters
"RTN","HLOUSR",309,0)
 N DR,DA,DIE
"RTN","HLOUSR",310,0)
 S DA=$O(^HLD(779.1,0))
"RTN","HLOUSR",311,0)
 Q:'DA
"RTN","HLOUSR",312,0)
 S DIE="^HLD(779.1,"
"RTN","HLOUSR",313,0)
 S DR="[HLO EDIT SYSTEM PARAMETERS]"
"RTN","HLOUSR",314,0)
 D ^DIE
"RTN","HLOUSR",315,0)
 Q
"RTN","HLOUSR",316,0)
 ;
"RTN","HLOUSR",317,0)
LOGALL ;
"RTN","HLOUSR",318,0)
 N ON,CHANGE,DATA
"RTN","HLOUSR",319,0)
 ;Will turn on/off logging of all errors
"RTN","HLOUSR",320,0)
 S ON=$G(^HLTMP("LOG ALL ERRORS"))
"RTN","HLOUSR",321,0)
 W !!,"Logging of all HLO errors is turned ",$S(ON:"ON",1:"OFF"),"."
"RTN","HLOUSR",322,0)
 W !!,"Logging of all HLO errors, including READ and WRITE errors, should be turned",!,"on only for short periods for troubleshooting purposes.",!
"RTN","HLOUSR",323,0)
 S CHANGE=$$ASKYESNO^HLOUSR2("Do you want logging of all HLO errors turned "_$S(ON:"OFF",1:"ON"),$S(ON:"YES",1:"NO"))
"RTN","HLOUSR",324,0)
 Q:'CHANGE
"RTN","HLOUSR",325,0)
 S ON='ON
"RTN","HLOUSR",326,0)
 S ^HLTMP("LOG ALL ERRORS")=ON
"RTN","HLOUSR",327,0)
 W !,"Logging of all HLO errors is turned ",$S(ON:"ON",1:"OFF"),"."
"RTN","HLOUSR",328,0)
 Q
"RTN","HLOUSR",329,0)
 ;
"RTN","HLOUSR",330,0)
KLISTEN() ;
"RTN","HLOUSR",331,0)
 ;checks if the Kernel multi-listener is running
"RTN","HLOUSR",332,0)
 N DOLLARJ,FOUND
"RTN","HLOUSR",333,0)
 S DOLLARJ=""
"RTN","HLOUSR",334,0)
 S FOUND=0
"RTN","HLOUSR",335,0)
 F  S DOLLARJ=$O(^HLTMP("HL7 RUNNING PROCESSES",DOLLARJ)) Q:DOLLARJ=""  I $P($G(^HLTMP("HL7 RUNNING PROCESSES",DOLLARJ)),"^",3)["TASKMAN MULTI-LISTENER" S FOUND=1 Q
"RTN","HLOUSR",336,0)
 Q FOUND
"RTN","HLOUSR1")
0^19^B106982040^B106022744
"RTN","HLOUSR1",1,0)
HLOUSR1 ;ALB/CJM/OAK/PIJ -ListManager Screen for viewing messages;12 JUN 1997 10:00 am ;03/21/2010
"RTN","HLOUSR1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,134,137,138,143,147**;Oct 13, 1995;Build 15
"RTN","HLOUSR1",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOUSR1",4,0)
 ;
"RTN","HLOUSR1",5,0)
EN ;
"RTN","HLOUSR1",6,0)
 N MSGIEN,SEGS
"RTN","HLOUSR1",7,0)
 S MSGIEN=$$PICKMSG
"RTN","HLOUSR1",8,0)
 I 'MSGIEN S VALMBCK="R" Q
"RTN","HLOUSR1",9,0)
 D EN^VALM("HLO SINGLE MESSAGE DISPLAY")
"RTN","HLOUSR1",10,0)
 Q
"RTN","HLOUSR1",11,0)
 ;
"RTN","HLOUSR1",12,0)
HDR ;
"RTN","HLOUSR1",13,0)
 ;
"RTN","HLOUSR1",14,0)
 Q
"RTN","HLOUSR1",15,0)
 ;
"RTN","HLOUSR1",16,0)
BLANK ;
"RTN","HLOUSR1",17,0)
 S VALMCNT=0
"RTN","HLOUSR1",18,0)
 D EXIT
"RTN","HLOUSR1",19,0)
 Q
"RTN","HLOUSR1",20,0)
DISPLAY ;
"RTN","HLOUSR1",21,0)
 K @VALMAR
"RTN","HLOUSR1",22,0)
 S VALMBCK="R"
"RTN","HLOUSR1",23,0)
 N MSG
"RTN","HLOUSR1",24,0)
 S VALMBG=1
"RTN","HLOUSR1",25,0)
 Q:'MSGIEN
"RTN","HLOUSR1",26,0)
 D SHOWMSG($P(MSGIEN,"^"),$P(MSGIEN,"^",2))
"RTN","HLOUSR1",27,0)
 Q
"RTN","HLOUSR1",28,0)
 ;
"RTN","HLOUSR1",29,0)
PICKMSG(DEFAULT) ;
"RTN","HLOUSR1",30,0)
 ;ask the user to select a message & return its ien
"RTN","HLOUSR1",31,0)
 ;Input: DEFAULT (optional) message id to display to user as default
"RTN","HLOUSR1",32,0)
 N MSGIEN,DIR,COUNT,LIST
"RTN","HLOUSR1",33,0)
 D FULL^VALM1
"RTN","HLOUSR1",34,0)
 S DIR(0)="F3:30"
"RTN","HLOUSR1",35,0)
 S DIR("A")="Message ID"
"RTN","HLOUSR1",36,0)
 S:$L($G(DEFAULT)) DIR("B")=DEFAULT
"RTN","HLOUSR1",37,0)
 S DIR("?")="Enter the full Message Control ID or Batch Control ID of the message, or '^' to exit."
"RTN","HLOUSR1",38,0)
PICK D ^DIR
"RTN","HLOUSR1",39,0)
 I $D(DIRUT)!(Y="") Q 0
"RTN","HLOUSR1",40,0)
 I $G(@VALMAR@("INDEX",Y)) Q $G(@VALMAR@("INDEX",Y))
"RTN","HLOUSR1",41,0)
 S COUNT=$$FINDMSG^HLOMSG1(Y,.LIST)
"RTN","HLOUSR1",42,0)
 I COUNT="0" W !!,"That message can not be found! Try Again",! G PICK
"RTN","HLOUSR1",43,0)
 I COUNT=1 Q LIST(1)
"RTN","HLOUSR1",44,0)
 I COUNT>1 D
"RTN","HLOUSR1",45,0)
 .N ITEM
"RTN","HLOUSR1",46,0)
 .W !,"There is more than one message with that ID! You must choose one to display.",1
"RTN","HLOUSR1",47,0)
 .S ITEM=0
"RTN","HLOUSR1",48,0)
 .F  S ITEM=$O(LIST(ITEM)) Q:'ITEM  D
"RTN","HLOUSR1",49,0)
 ..N MSG
"RTN","HLOUSR1",50,0)
 ..Q:'$$GETMSG^HLOMSG(+LIST(ITEM),.MSG)
"RTN","HLOUSR1",51,0)
 ..W !,"[",ITEM,"]","  DT/TM: ",$$FMTE^XLFDT(MSG("DT/TM CREATED"),2),"   STATUS: ",MSG("STATUS")
"RTN","HLOUSR1",52,0)
 .S DIR(0)="NO^1:"_COUNT,DIR("A")="Choose",DIR("?")="Choose one message from the list"
"RTN","HLOUSR1",53,0)
 .D ^DIR
"RTN","HLOUSR1",54,0)
 .I Y S Y=LIST(Y)
"RTN","HLOUSR1",55,0)
 Q Y
"RTN","HLOUSR1",56,0)
 ;
"RTN","HLOUSR1",57,0)
HELP ;Help code
"RTN","HLOUSR1",58,0)
 S X="?" D DISP^XQORM1 W !!
"RTN","HLOUSR1",59,0)
 Q
"RTN","HLOUSR1",60,0)
 ;
"RTN","HLOUSR1",61,0)
EXIT ;Exit code
"RTN","HLOUSR1",62,0)
 D CLEAN^VALM10
"RTN","HLOUSR1",63,0)
 D CLEAR^VALM1
"RTN","HLOUSR1",64,0)
 S VALMBCK="R"
"RTN","HLOUSR1",65,0)
 ;
"RTN","HLOUSR1",66,0)
 Q
"RTN","HLOUSR1",67,0)
 ;
"RTN","HLOUSR1",68,0)
EXPND ;Expand code
"RTN","HLOUSR1",69,0)
 Q
"RTN","HLOUSR1",70,0)
 ;
"RTN","HLOUSR1",71,0)
CJ(STRING,LEN) ;
"RTN","HLOUSR1",72,0)
 Q $$CJ^XLFSTR(STRING,LEN)
"RTN","HLOUSR1",73,0)
LJ(STRING,LEN) ;
"RTN","HLOUSR1",74,0)
 Q $$LJ^XLFSTR(STRING,LEN)
"RTN","HLOUSR1",75,0)
SP(LEN,CHAR) ;
"RTN","HLOUSR1",76,0)
 ;return padding - " " is the default pad character
"RTN","HLOUSR1",77,0)
 N STR
"RTN","HLOUSR1",78,0)
 S:$G(CHAR)="" CHAR=" "
"RTN","HLOUSR1",79,0)
 S $P(STR,CHAR,LEN)=CHAR
"RTN","HLOUSR1",80,0)
 Q STR
"RTN","HLOUSR1",81,0)
 ;
"RTN","HLOUSR1",82,0)
SHOWMSG(MSGIEN,SUBIEN) ;
"RTN","HLOUSR1",83,0)
 ;Description:
"RTN","HLOUSR1",84,0)
 ;
"RTN","HLOUSR1",85,0)
 ;Input:
"RTN","HLOUSR1",86,0)
 ;Output:
"RTN","HLOUSR1",87,0)
 ;
"RTN","HLOUSR1",88,0)
 N MSG,I,TEMP,LINE,HDR,TRIES,STATUS
"RTN","HLOUSR1",89,0)
 S VALMCNT=0
"RTN","HLOUSR1",90,0)
 S SUBIEN=+$G(SUBIEN)
"RTN","HLOUSR1",91,0)
 I '$$GETMSG^HLOMSG(MSGIEN,.MSG) W !,"UNABLE TO DISPLAY THE MESSAGE",!! Q
"RTN","HLOUSR1",92,0)
 I SUBIEN S STATUS=MSG("STATUS") D GETMSGB^HLOMSG1(.MSG,SUBIEN,.MSG) I MSG("STATUS")="" S MSG("STATUS")=STATUS
"RTN","HLOUSR1",93,0)
 S HDR(1)=MSG("HDR",1),HDR(2)=MSG("HDR",2)
"RTN","HLOUSR1",94,0)
 I $$PARSEHDR^HLOPRS(.HDR)
"RTN","HLOUSR1",95,0)
 S I=0
"RTN","HLOUSR1",96,0)
 ;** administrative information **
"RTN","HLOUSR1",97,0)
 S @VALMAR@($$I,0)=$$CJ("Administrative Information",80)
"RTN","HLOUSR1",98,0)
 D CNTRL^VALM10(VALMCNT,26,30,IORVON,IORVOFF)
"RTN","HLOUSR1",99,0)
 ;; ***patch HL*1.6*138 start
"RTN","HLOUSR1",100,0)
 S LINE="MsgID: "_$$LJ(MSG("ID"),18) ;;
"RTN","HLOUSR1",101,0)
 S:MSG("ACK TO")]"" LINE=LINE_$$LJ(" Application Ack To:",26)_MSG("ACK TO") ;;
"RTN","HLOUSR1",102,0)
 S:MSG("ACK BY")]"" LINE=LINE_$$LJ(" Application Ack'd By:",26)_MSG("ACK BY") ;;
"RTN","HLOUSR1",103,0)
 S @VALMAR@($$I,0)=LINE ;;
"RTN","HLOUSR1",104,0)
 ;;
"RTN","HLOUSR1",105,0)
 S LINE=""
"RTN","HLOUSR1",106,0)
 S:MSG("DIRECTION")="OUT" TRIES=$G(^HLB(MSGIEN,"TRIES"))
"RTN","HLOUSR1",107,0)
 ;
"RTN","HLOUSR1",108,0)
 ;determine current status - as opposed to final status
"RTN","HLOUSR1",109,0)
 D
"RTN","HLOUSR1",110,0)
 .I MSG("STATUS")="SU" S MSG("STATUS")="SUCCESSFUL" Q
"RTN","HLOUSR1",111,0)
 .I MSG("STATUS")="ER" S MSG("STATUS")="ERROR" Q
"RTN","HLOUSR1",112,0)
 .I MSG("DIRECTION")="IN" D  Q
"RTN","HLOUSR1",113,0)
 ..I '$G(MSG("STATUS","APP HANDOFF")) S MSG("STATUS")="PENDING ON RECEIVING APPLICATION" Q
"RTN","HLOUSR1",114,0)
 .I MSG("DIRECTION")="OUT" D  Q
"RTN","HLOUSR1",115,0)
 ..I MSG("DT/TM")="" D  Q
"RTN","HLOUSR1",116,0)
 ...I $O(^HLB("QUEUE","OUT",MSG("STATUS","LINK NAME")_":"_MSG("STATUS","PORT"),MSG("STATUS","QUEUE"),0))=MSG("IEN") S MSG("STATUS")="TRANSMISSION IN PROGRESS" Q
"RTN","HLOUSR1",117,0)
 ...S MSG("STATUS")="PENDING ON OUTGOING QUEUE" Q
"RTN","HLOUSR1",118,0)
 ..I $G(HDR("APP ACK TYPE"))="AL",'$G(MSG("STATUS","APP ACK'D")),$G(MSG("ACK BY"))="" S MSG("STATUS")="TRANSMITTED, PENDING RECEIPT OF APPLICATION ACKNOWLEDGEMENT" Q
"RTN","HLOUSR1",119,0)
 ;; ***patch HL*1.6*138 end
"RTN","HLOUSR1",120,0)
 ;
"RTN","HLOUSR1",121,0)
 S LINE="Status: "_$$LJ(MSG("STATUS"),79)
"RTN","HLOUSR1",122,0)
 S @VALMAR@($$I,0)=LINE
"RTN","HLOUSR1",123,0)
 I MSG("STATUS","ERROR TEXT")]"" S @VALMAR@($$I,0)="Error: "_"** "_MSG("STATUS","ERROR TEXT")_" **"
"RTN","HLOUSR1",124,0)
 ;;**138 start cjm
"RTN","HLOUSR1",125,0)
 ;S @VALMAR@($$I,0)="Dir:   "_$$LJ($S(MSG("DIRECTION")="IN":"INCOMING",1:"OUTGOING"),10)_$$LJ("  Trans Dt/Tm: ",12)_$$FMTE^XLFDT(MSG("DT/TM"),2)_$$LJ("  Purge DT/TM: ",8)_$$FMTE^XLFDT(MSG("STATUS","PURGE"),2)
"RTN","HLOUSR1",126,0)
 S @VALMAR@($$I,0)="Direction: "_$$LJ($S(MSG("DIRECTION")="IN":"IN",1:"OUT"),4)_$$LJ("  TransDt/Tm"_$S($G(TRIES):"("_TRIES_"x): ",1:": "),12)_$$FMTE^XLFDT(MSG("DT/TM"),2)_$$LJ("  Purge DT/TM: ",8)_$$FMTE^XLFDT(MSG("STATUS","PURGE"),2)
"RTN","HLOUSR1",127,0)
 ;** 138 end cjm
"RTN","HLOUSR1",128,0)
 S @VALMAR@($$I,0)="Link:  "_$$LJ(MSG("STATUS","LINK NAME"),29)_"   "_$$LJ("Queue: ",13)_MSG("STATUS","QUEUE")
"RTN","HLOUSR1",129,0)
 I $L($G(MSG("STATUS","SEQUENCE QUEUE"))) D
"RTN","HLOUSR1",130,0)
 .S @VALMAR@($$I,0)="Sequence Queue: "_MSG("STATUS","SEQUENCE QUEUE")_"    Moved: "_$S(MSG("STATUS","MOVED TO OUT QUEUE"):"YES",1:"NO")
"RTN","HLOUSR1",131,0)
 I MSG("STATUS","ACCEPT ACK'D") D
"RTN","HLOUSR1",132,0)
 .S @VALMAR@($$I,0)="Accept Ack: "_$$LJ(MSG("STATUS","ACCEPT ACK ID"),26)_$$LJ(" DT/TM Ack'd: ",14)_$$FMTE^XLFDT(MSG("STATUS","ACCEPT ACK DT/TM"),2)
"RTN","HLOUSR1",133,0)
 .S @VALMAR@($$I,0)="   "_MSG("STATUS","ACCEPT ACK MSA")
"RTN","HLOUSR1",134,0)
 I MSG("DIRECTION")="IN" D
"RTN","HLOUSR1",135,0)
 .S LINE="App Response Rtn: "
"RTN","HLOUSR1",136,0)
 .;START HL*1.6*138 CJM
"RTN","HLOUSR1",137,0)
 .;I $L($G(MSG("STATUS","APP ACK RESPONSE"))) S LINE=$$LJ(LINE_MSG("STATUS","APP ACK RESPONSE"),38)_" Executed: "_$S(MSG("STATUS","APP HANDOFF"):"   YES",1:"   NO")
"RTN","HLOUSR1",138,0)
 .S LINE=$$LJ(LINE_$S($L($G(MSG("STATUS","ACTION"))):MSG("STATUS","ACTION"),1:"n/a"),38)_" Executed: "_$S('$L($G(MSG("STATUS","ACTION"))):"n/a",MSG("STATUS","APP HANDOFF"):"   YES",1:"   NO")
"RTN","HLOUSR1",139,0)
 .;;END HL*1.6*138 CJM
"RTN","HLOUSR1",140,0)
 .S @VALMAR@($$I,0)=LINE
"RTN","HLOUSR1",141,0)
 I MSG("DIRECTION")="OUT",(MSG("STATUS","APP ACK'D")!MSG("STATUS","ACCEPT ACK'D")) D
"RTN","HLOUSR1",142,0)
 .S LINE=""
"RTN","HLOUSR1",143,0)
 .I MSG("STATUS","ACCEPT ACK'D") D
"RTN","HLOUSR1",144,0)
 ..I MSG("STATUS","ACCEPT ACK RESPONSE")="" S MSG("STATUS","ACCEPT ACK RESPONSE")="n/a"
"RTN","HLOUSR1",145,0)
 ..S LINE="Accept Ack Rtn: "_MSG("STATUS","ACCEPT ACK RESPONSE")
"RTN","HLOUSR1",146,0)
 .S LINE=$$LJ(LINE,39)
"RTN","HLOUSR1",147,0)
 .I MSG("STATUS","APP ACK'D") D
"RTN","HLOUSR1",148,0)
 ..I MSG("STATUS","APP ACK RESPONSE")="" S MSG("STATUS","APP ACK RESPONSE")="n/a"
"RTN","HLOUSR1",149,0)
 ..S LINE=LINE_"App Ack Rtn: "_MSG("STATUS","APP ACK RESPONSE")
"RTN","HLOUSR1",150,0)
 .S @VALMAR@($$I,0)=LINE
"RTN","HLOUSR1",151,0)
 ;
"RTN","HLOUSR1",152,0)
 ;** the message text **
"RTN","HLOUSR1",153,0)
 S @VALMAR@($$I,0)=""
"RTN","HLOUSR1",154,0)
 I '$G(SUBIEN) D
"RTN","HLOUSR1",155,0)
 .S @VALMAR@($$I,0)=$$CJ("Message Text",80)
"RTN","HLOUSR1",156,0)
 .D CNTRL^VALM10(VALMCNT,33,16,IORVON,IORVOFF)
"RTN","HLOUSR1",157,0)
 E  D
"RTN","HLOUSR1",158,0)
 .S @VALMAR@($$I,0)=$$CJ("Individual Message Text (Batched)",80)
"RTN","HLOUSR1",159,0)
 .D CNTRL^VALM10(VALMCNT,23,35,IORVON,IORVOFF)
"RTN","HLOUSR1",160,0)
 ;; START 138
"RTN","HLOUSR1",161,0)
 ;D SHOWBODY(.MSG,$G(SUBIEN))
"RTN","HLOUSR1",162,0)
 D SHOWBODY(.MSG,$G(SUBIEN),.SEGS)
"RTN","HLOUSR1",163,0)
 ;; END 138
"RTN","HLOUSR1",164,0)
 ;
"RTN","HLOUSR1",165,0)
 ;** display its application acknowledgment **
"RTN","HLOUSR1",166,0)
 ;**P143 START CJM
"RTN","HLOUSR1",167,0)
 ;I MSG("ACK BY")]"",$$FINDMSG^HLOMSG1(MSG("ACK BY"),.TEMP)=1 S MSGIEN=TEMP(1) D
"RTN","HLOUSR1",168,0)
 I $G(MSG("ACK BY IEN")) S MSGIEN=MSG("ACK BY IEN") D
"RTN","HLOUSR1",169,0)
 .;**P143 END CJM
"RTN","HLOUSR1",170,0)
 .N MSG,STATUS
"RTN","HLOUSR1",171,0)
 .Q:'$$GETMSG^HLOMSG(+MSGIEN,.MSG)
"RTN","HLOUSR1",172,0)
 .I $P(MSGIEN,"^",2) S STATUS=MSG("STATUS") D GETMSGB^HLOMSG1(.MSG,SUBIEN,.MSG) I MSG("STATUS")="" S MSG("STATUS")=STATUS
"RTN","HLOUSR1",173,0)
 .S @VALMAR@($$I,0)=""
"RTN","HLOUSR1",174,0)
 .S @VALMAR@($$I,0)=$$CJ("Application Acknowledgment",80)
"RTN","HLOUSR1",175,0)
 .D CNTRL^VALM10(VALMCNT,26,30,IORVON,IORVOFF)
"RTN","HLOUSR1",176,0)
 .D SHOWBODY(.MSG,$P(MSGIEN,"^",2))
"RTN","HLOUSR1",177,0)
 ;
"RTN","HLOUSR1",178,0)
 ;** display the original message **
"RTN","HLOUSR1",179,0)
 ;**P143 START CJM
"RTN","HLOUSR1",180,0)
 ;I MSG("ACK TO")]"",$$FINDMSG^HLOMSG1(MSG("ACK TO"),.TEMP)=1 S MSGIEN=TEMP(1) D
"RTN","HLOUSR1",181,0)
 I $G(MSG("ACK TO IEN")) S MSGIEN=MSG("ACK TO IEN") D
"RTN","HLOUSR1",182,0)
 .;**P143 END CJM
"RTN","HLOUSR1",183,0)
 .N MSG
"RTN","HLOUSR1",184,0)
 .Q:'$$GETMSG^HLOMSG(+MSGIEN,.MSG)
"RTN","HLOUSR1",185,0)
 .I $P(MSGIEN,"^",2) S STATUS=MSG("STATUS") D GETMSGB^HLOMSG1(.MSG,SUBIEN,.MSG) I MSG("STATUS")="" S MSG("STATUS")=STATUS
"RTN","HLOUSR1",186,0)
 .S @VALMAR@($$I,0)=""
"RTN","HLOUSR1",187,0)
 .S @VALMAR@($$I,0)=$$CJ("Original Message",80)
"RTN","HLOUSR1",188,0)
 .D CNTRL^VALM10(VALMCNT,26,30,IORVON,IORVOFF)
"RTN","HLOUSR1",189,0)
 .D SHOWBODY(.MSG,$P(MSGIEN,"^",2))
"RTN","HLOUSR1",190,0)
 Q
"RTN","HLOUSR1",191,0)
 ;
"RTN","HLOUSR1",192,0)
SHOWBODY(MSG,SUBIEN,SEGS) ;
"RTN","HLOUSR1",193,0)
 N NODE,I,SEG,QUIT
"RTN","HLOUSR1",194,0)
 S QUIT=0
"RTN","HLOUSR1",195,0)
 S SEGS("ARY")=VALMAR
"RTN","HLOUSR1",196,0)
 S SEGS("TOP")=VALMCNT+1
"RTN","HLOUSR1",197,0)
 M SEG=MSG("HDR")
"RTN","HLOUSR1",198,0)
 D ADD(.SEG,.SEGS)
"RTN","HLOUSR1",199,0)
 S MSG("BATCH","CURRENT MESSAGE")=0
"RTN","HLOUSR1",200,0)
 I MSG("BATCH") D
"RTN","HLOUSR1",201,0)
 .I $G(SUBIEN) D  Q
"RTN","HLOUSR1",202,0)
 ..S MSG("BATCH","CURRENT MESSAGE")=SUBIEN
"RTN","HLOUSR1",203,0)
 ..F  Q:'$$HLNEXT^HLOMSG(.MSG,.SEG)  D ADD(.SEG,.SEGS)
"RTN","HLOUSR1",204,0)
 .S MSG("BATCH","CURRENT MESSAGE")=0
"RTN","HLOUSR1",205,0)
 .N LAST S LAST=0
"RTN","HLOUSR1",206,0)
 .F  Q:'$$NEXTMSG^HLOMSG(.MSG,.SEG)  D  Q:QUIT
"RTN","HLOUSR1",207,0)
 ..D ADD(.SEG,.SEGS)
"RTN","HLOUSR1",208,0)
 ..S LAST=MSG("BATCH","CURRENT MESSAGE")
"RTN","HLOUSR1",209,0)
 ..F  Q:'$$HLNEXT^HLOMSG(.MSG,.SEG)  D ADD(.SEG,.SEGS)
"RTN","HLOUSR1",210,0)
 .I MSG("DIRECTION")="OUT" K SEG S SEG(1)="BTS"_$E($G(MSG("HDR",1)),4)_LAST D ADD(.SEG,.SEGS)
"RTN","HLOUSR1",211,0)
 .;
"RTN","HLOUSR1",212,0)
 E  D
"RTN","HLOUSR1",213,0)
 .F  Q:'$$HLNEXT^HLOMSG(.MSG,.SEG)  D  Q:QUIT
"RTN","HLOUSR1",214,0)
 ..D ADD(.SEG,.SEGS)
"RTN","HLOUSR1",215,0)
 S SEGS("BOT")=VALMCNT
"RTN","HLOUSR1",216,0)
 Q
"RTN","HLOUSR1",217,0)
I() ;
"RTN","HLOUSR1",218,0)
 S VALMCNT=VALMCNT+1
"RTN","HLOUSR1",219,0)
 Q VALMCNT
"RTN","HLOUSR1",220,0)
ADD(SEG,SEGS) ;
"RTN","HLOUSR1",221,0)
 N QUIT,I,J,LINE
"RTN","HLOUSR1",222,0)
 S QUIT=0
"RTN","HLOUSR1",223,0)
 S SEGS=$G(SEGS)+1
"RTN","HLOUSR1",224,0)
 S (I,J)=1
"RTN","HLOUSR1",225,0)
 S LINE(1)=$E(SEG(1),1,80),SEG(1)=$E(SEG(1),81,9999)
"RTN","HLOUSR1",226,0)
 I SEG(1)="" K SEG(1)
"RTN","HLOUSR1",227,0)
 D SHIFT(.I,.J)
"RTN","HLOUSR1",228,0)
 S @VALMAR@($$I,0)=LINE(1)
"RTN","HLOUSR1",229,0)
 ;; START 138
"RTN","HLOUSR1",230,0)
 D CNTRL^VALM10(VALMCNT,1,3,IOINHI,IOINORM)
"RTN","HLOUSR1",231,0)
 ;;END 138
"RTN","HLOUSR1",232,0)
 S SEGS(SEGS)=VALMCNT
"RTN","HLOUSR1",233,0)
 S I=1
"RTN","HLOUSR1",234,0)
 F  S I=$O(LINE(I)) Q:'I  D
"RTN","HLOUSR1",235,0)
 .S @VALMAR@($$I,0)=LINE(I)
"RTN","HLOUSR1",236,0)
 .;;START 138
"RTN","HLOUSR1",237,0)
 .;D CNTRL^VALM10(VALMCNT,1,1,IORVON,IORVOFF)
"RTN","HLOUSR1",238,0)
 .;END 138
"RTN","HLOUSR1",239,0)
 Q
"RTN","HLOUSR1",240,0)
 ;
"RTN","HLOUSR1",241,0)
SHIFT(I,J) ;
"RTN","HLOUSR1",242,0)
 I '$D(SEG(I)) S I=$O(SEG(0)) Q:'I
"RTN","HLOUSR1",243,0)
 I $L(LINE(J))<80 D
"RTN","HLOUSR1",244,0)
 .N LEN
"RTN","HLOUSR1",245,0)
 .S LEN=$L(LINE(J))
"RTN","HLOUSR1",246,0)
 .S LINE(J)=LINE(J)_$E(SEG(I),1,80-LEN)
"RTN","HLOUSR1",247,0)
 .S SEG(I)=$E(SEG(I),81-LEN,9999)
"RTN","HLOUSR1",248,0)
 .I SEG(I)="" K SEG(I)
"RTN","HLOUSR1",249,0)
 E  D
"RTN","HLOUSR1",250,0)
 .S J=J+1
"RTN","HLOUSR1",251,0)
 .S LINE(J)=""
"RTN","HLOUSR1",252,0)
 D SHIFT(.I,.J)
"RTN","HLOUSR1",253,0)
 Q
"RTN","HLOUSR1",254,0)
 ;
"RTN","HLOUSR1",255,0)
SCRLMODE ;scroll mode
"RTN","HLOUSR1",256,0)
 Q:'$L(HLRFRSH)
"RTN","HLOUSR1",257,0)
 N QUIT,IOTM,IOBM,DX,DY,LINE,IOTM,IOBM
"RTN","HLOUSR1",258,0)
 W !!,IOINHI,"Hit any key to escape scroll mode...",IOINORM
"RTN","HLOUSR1",259,0)
 S IOTM=3,IOBM=23
"RTN","HLOUSR1",260,0)
 S QUIT=0
"RTN","HLOUSR1",261,0)
 S LINE=$S(VALMCNT<17:1,1:17)
"RTN","HLOUSR1",262,0)
 W @IOSTBM
"RTN","HLOUSR1",263,0)
 S DX=1,DY=$S(VALMCNT<17:VALMCNT+1,1:17) X IOXY
"RTN","HLOUSR1",264,0)
 F I=1:1 D  Q:QUIT
"RTN","HLOUSR1",265,0)
 .;every 10 seconds refresh the data
"RTN","HLOUSR1",266,0)
 .I I>42 D @HLRFRSH S I=0
"RTN","HLOUSR1",267,0)
 .I LINE+1>VALMCNT D
"RTN","HLOUSR1",268,0)
 ..S TEMP=$G(@VALMAR@(LINE,0))
"RTN","HLOUSR1",269,0)
 ..W !,IOUON,TEMP_$$SP(80-$L(TEMP)),IOUOFF
"RTN","HLOUSR1",270,0)
 .E  W !,$G(@VALMAR@(LINE,0))
"RTN","HLOUSR1",271,0)
 .S LINE=LINE+1
"RTN","HLOUSR1",272,0)
 .I LINE>VALMCNT S LINE=1
"RTN","HLOUSR1",273,0)
 .I (I=22)!(I=43) R *C:5 I $T S QUIT=1 Q
"RTN","HLOUSR1",274,0)
 S VALMBG=LINE-23 I VALMBG<0 S VALMBG=1
"RTN","HLOUSR1",275,0)
 S VALMBCK="R"
"RTN","HLOUSR1",276,0)
 Q
"RTN","HLOUSR1",277,0)
HLP ;
"RTN","HLOUSR1",278,0)
 Q
"RTN","HLOUSR1",279,0)
 ;
"RTN","HLOUSR1",280,0)
IFOPEN(LINK,TIME) ;
"RTN","HLOUSR1",281,0)
 ;returns 1 if the link can be opened, otherwise 0
"RTN","HLOUSR1",282,0)
 ;
"RTN","HLOUSR1",283,0)
 ;Inputs:
"RTN","HLOUSR1",284,0)
 ;  LINK - name of the link (required), optionally post-fixed with ":"_<port #>, will default to that defined for link
"RTN","HLOUSR1",285,0)
 ;  TIME (optional) defaults to 15 seconds
"RTN","HLOUSR1",286,0)
 ;
"RTN","HLOUSR1",287,0)
 N LINKNAME,LINKARY,POP,IO,IOF,IOST,OPEN,PORT
"RTN","HLOUSR1",288,0)
 S OPEN=0
"RTN","HLOUSR1",289,0)
 ;
"RTN","HLOUSR1",290,0)
 ;**P147 CJM adds TIME as an optional input parameter
"RTN","HLOUSR1",291,0)
 I '$G(TIME) S TIME=15
"RTN","HLOUSR1",292,0)
 ;**P147 CJM END
"RTN","HLOUSR1",293,0)
 ;
"RTN","HLOUSR1",294,0)
 S LINKNAME=$P(LINK,":")
"RTN","HLOUSR1",295,0)
 S PORT=$P(LINK,":",2)
"RTN","HLOUSR1",296,0)
 Q:LINKNAME="" 0
"RTN","HLOUSR1",297,0)
 Q:'$$GETLINK^HLOTLNK(LINKNAME,.LINKARY) 0
"RTN","HLOUSR1",298,0)
 S:PORT LINKARY("PORT")=PORT
"RTN","HLOUSR1",299,0)
 Q:'$G(LINKARY("PORT")) 0
"RTN","HLOUSR1",300,0)
 I LINKARY("IP")="",LINKARY("DOMAIN")="",LINKARY("LLP")="TCP",LINKARY("SERVER") D
"RTN","HLOUSR1",301,0)
 .N DATA
"RTN","HLOUSR1",302,0)
 .S LINKARY("DOMAIN")=$P($G(^HLD(779.1,1,0)),"^")
"RTN","HLOUSR1",303,0)
 .Q:LINKARY("DOMAIN")=""
"RTN","HLOUSR1",304,0)
 .S DATA(.08)=LINKARY("DOMAIN")
"RTN","HLOUSR1",305,0)
 .Q:$$UPD^HLOASUB1(870,LINKARY("IEN"),.DATA)
"RTN","HLOUSR1",306,0)
 D:$G(LINKARY("IP"))'=""
"RTN","HLOUSR1",307,0)
 .D CALL^%ZISTCP(LINKARY("IP"),LINKARY("PORT"),TIME)
"RTN","HLOUSR1",308,0)
 .S OPEN='POP
"RTN","HLOUSR1",309,0)
 I 'OPEN,LINKARY("DOMAIN")'="",$G(^HLTMP("DNS LAST",LINKARY("IEN")))<$$DT^XLFDT D
"RTN","HLOUSR1",310,0)
 .N IP
"RTN","HLOUSR1",311,0)
 .S ^HLTMP("DNS LAST",LINKARY("IEN"))=$$DT^XLFDT
"RTN","HLOUSR1",312,0)
 .S IP=$$DNS^HLOTCP(LINKARY("DOMAIN"))
"RTN","HLOUSR1",313,0)
 .I IP'="",IP'=LINKARY("IP") D
"RTN","HLOUSR1",314,0)
 ..N DATA
"RTN","HLOUSR1",315,0)
 ..S DATA(400.01)=IP,LINKARY("IP")=IP
"RTN","HLOUSR1",316,0)
 ..Q:$$UPD^HLOASUB1(870,LINKARY("IEN"),.DATA)
"RTN","HLOUSR1",317,0)
 ..D CALL^%ZISTCP(LINKARY("IP"),LINKARY("PORT"),TIME)
"RTN","HLOUSR1",318,0)
 ..S OPEN='POP
"RTN","HLOUSR1",319,0)
 C:OPEN IO
"RTN","HLOUSR1",320,0)
 ;D CLOSE^%ZISTCP
"RTN","HLOUSR1",321,0)
 Q OPEN
"RTN","HLOUSR2")
0^2^B85470396^B47461747
"RTN","HLOUSR2",1,0)
HLOUSR2 ;ALB/CJM -ListManager Screen for viewing message errors;12 JUN 1997 10:00 am ;07/27/2010
"RTN","HLOUSR2",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,134,137,138,147**;Oct 13, 1995;Build 15
"RTN","HLOUSR2",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified
"RTN","HLOUSR2",4,0)
 ;
"RTN","HLOUSR2",5,0)
EN ;
"RTN","HLOUSR2",6,0)
 D WAIT^DICD
"RTN","HLOUSR2",7,0)
 D EN^VALM("HLO MESSAGE VIEWER")
"RTN","HLOUSR2",8,0)
 Q
"RTN","HLOUSR2",9,0)
 ;
"RTN","HLOUSR2",10,0)
SHOWLIST ;
"RTN","HLOUSR2",11,0)
 N PARMS,I,ERRCOUNT,SCREEN
"RTN","HLOUSR2",12,0)
 S (VALMBG,VALMCNT,I,ERRCOUNT,SCREEN)=0
"RTN","HLOUSR2",13,0)
 D CLEAN^VALM10
"RTN","HLOUSR2",14,0)
 S VALMBG=1
"RTN","HLOUSR2",15,0)
 I '$$ASKPARMS(.PARMS) S VALMBCK="" Q
"RTN","HLOUSR2",16,0)
 ;
"RTN","HLOUSR2",17,0)
 I PARMS("SCR") S SCREEN=$$GETSCRN(+PARMS("SCR"),.SCREEN)
"RTN","HLOUSR2",18,0)
 I PARMS("ALL") D
"RTN","HLOUSR2",19,0)
 .N APP
"RTN","HLOUSR2",20,0)
 .S APP=""
"RTN","HLOUSR2",21,0)
 .F  S APP=$O(^HLB("ERRORS",APP)) Q:APP=""  D  Q:ERRCOUNT>PARMS("MAX")
"RTN","HLOUSR2",22,0)
 ..N TIME,IEN
"RTN","HLOUSR2",23,0)
 ..S TIME=PARMS("START")
"RTN","HLOUSR2",24,0)
 ..Q:($O(^HLB("ERRORS",APP,TIME))="")
"RTN","HLOUSR2",25,0)
 ..S @VALMAR@($$I,0)="Application: "_APP
"RTN","HLOUSR2",26,0)
 ..D CNTRL^VALM10(VALMCNT,14,$L(APP),IOINHI,IOINORM)
"RTN","HLOUSR2",27,0)
 ..F  S TIME=$O(^HLB("ERRORS",APP,TIME)) Q:'TIME  Q:ERRCOUNT>PARMS("MAX")  S IEN="" F  S IEN=$O(^HLB("ERRORS",APP,TIME,IEN)) Q:IEN=""  D ADDTO(IEN,TIME,.SCREEN,.ERRCOUNT) Q:ERRCOUNT>PARMS("MAX")
"RTN","HLOUSR2",28,0)
 E  D
"RTN","HLOUSR2",29,0)
 .N APP
"RTN","HLOUSR2",30,0)
 .S APP=PARMS("APP")
"RTN","HLOUSR2",31,0)
 .N TIME,IEN
"RTN","HLOUSR2",32,0)
 .S TIME=PARMS("START")
"RTN","HLOUSR2",33,0)
 .Q:$O(^HLB("ERRORS",APP,TIME))=""
"RTN","HLOUSR2",34,0)
 .S @VALMAR@($$I,0)="Application: "_APP
"RTN","HLOUSR2",35,0)
 .D CNTRL^VALM10(VALMCNT,14,$L(APP),IOINHI,IOINORM)
"RTN","HLOUSR2",36,0)
 .F  S TIME=$O(^HLB("ERRORS",APP,TIME)) Q:'TIME  Q:ERRCOUNT>PARMS("MAX")  S IEN="" F  S IEN=$O(^HLB("ERRORS",APP,TIME,IEN)) Q:IEN=""  D ADDTO(IEN,TIME,.SCREEN,.ERRCOUNT) Q:ERRCOUNT>PARMS("MAX")
"RTN","HLOUSR2",37,0)
SHOW S VALMBCK="R"
"RTN","HLOUSR2",38,0)
 ;
"RTN","HLOUSR2",39,0)
 Q
"RTN","HLOUSR2",40,0)
ADDTO(IEN,TIME,SCREEN,ERRCOUNT) ;
"RTN","HLOUSR2",41,0)
 N NODE,MSG,LIST,SKIP
"RTN","HLOUSR2",42,0)
 Q:'$$STARTMSG^HLOPRS(.MSG,+IEN)
"RTN","HLOUSR2",43,0)
 ;S ERRCOUNT=ERRCOUNT+1
"RTN","HLOUSR2",44,0)
 ;application errors could be an error to a msg within a batch
"RTN","HLOUSR2",45,0)
 ;also, need to go to the ack msg to get the error text from the MSA segment
"RTN","HLOUSR2",46,0)
 ;
"RTN","HLOUSR2",47,0)
 N SUBIEN,MSA,ERRTEXT
"RTN","HLOUSR2",48,0)
 S (ERRTEXT,MSA)=""
"RTN","HLOUSR2",49,0)
 S SUBIEN=$P(IEN,"^",2)
"RTN","HLOUSR2",50,0)
 ;within batch?
"RTN","HLOUSR2",51,0)
 D:SUBIEN GETMSGB^HLOMSG1(.MSG,SUBIEN,.MSG)
"RTN","HLOUSR2",52,0)
 S ERRTEXT=MSG("STATUS","ERROR TEXT")
"RTN","HLOUSR2",53,0)
 I ERRTEXT="",MSG("ACK BY")]"",($$FINDMSG^HLOMSG1(MSG("ACK BY"),.LIST)=1) D
"RTN","HLOUSR2",54,0)
 .N MSG,SEG,FS,AIEN
"RTN","HLOUSR2",55,0)
 .S AIEN=+LIST(1),SUBIEN=$P(LIST(1),"^",2)
"RTN","HLOUSR2",56,0)
 .Q:'$$STARTMSG^HLOPRS(.MSG,AIEN)
"RTN","HLOUSR2",57,0)
 .I SUBIEN S MSG("BATCH","CURRENT MESSAGE")=SUBIEN,MSG("LINE COUNT")=0
"RTN","HLOUSR2",58,0)
 .; ** Start HL*1.6*138 PIJ **
"RTN","HLOUSR2",59,0)
 .;;F  Q:'$$HLNEXT^HLOMSG(.MSG,.SEG)  I $E(SEG(1),1,3)="MSA" S MSA=SEG(1),FS=$E(MSA,4),ERRTEXT=$P(MSA,FS,4) Q
"RTN","HLOUSR2",60,0)
 .F  Q:'$$HLNEXT^HLOMSG(.MSG,.SEG)  I $E(SEG(1),1,3)="MSA" S MSA=SEG(1),FS=$E(MSA,4) D  Q
"RTN","HLOUSR2",61,0)
 ..S ERRTEXT=$$ESCAPE^HLOPBLD(.MSG,$P(MSA,FS,4))
"RTN","HLOUSR2",62,0)
 .; ** End HL*1.6*138 **
"RTN","HLOUSR2",63,0)
 I ERRTEXT="",MSG("ACK BY")="" D
"RTN","HLOUSR2",64,0)
 .N FS
"RTN","HLOUSR2",65,0)
 .S FS=$E(MSG("HDR",1),4)
"RTN","HLOUSR2",66,0)
 .I $L(FS) S ERRTEXT=$P($G(MSG("STATUS","ACCEPT ACK MSA")),FS,4)
"RTN","HLOUSR2",67,0)
 I SCREEN,'$$SCREEN(ERRTEXT,.SCREEN) Q
"RTN","HLOUSR2",68,0)
 S ERRCOUNT=ERRCOUNT+1
"RTN","HLOUSR2",69,0)
 S @VALMAR@($$I,0)="  "_$$LJ(MSG("ID"),25)_$S(MSG("BATCH"):"BATCH   ",1:$$LJ($G(MSG("MESSAGE TYPE"))_"~"_$G(MSG("EVENT")),8))_$$LJ($$FMTE^XLFDT(MSG("DT/TM CREATED"),2),20)_$E(ERRTEXT,1,35)
"RTN","HLOUSR2",70,0)
 D CNTRL^VALM10(VALMCNT,3,25,IOINHI,IOINORM)
"RTN","HLOUSR2",71,0)
 I $L(ERRTEXT)>35 D
"RTN","HLOUSR2",72,0)
 .S @VALMAR@($$I,0)=$$RJ(" ",45)_$E(ERRTEXT,36,115)
"RTN","HLOUSR2",73,0)
 S:MSG("ID")]"" @VALMAR@("INDEX",MSG("ID"))=IEN
"RTN","HLOUSR2",74,0)
 Q
"RTN","HLOUSR2",75,0)
 ;
"RTN","HLOUSR2",76,0)
ASKPARMS(PARMS) ;
"RTN","HLOUSR2",77,0)
 K PARMS
"RTN","HLOUSR2",78,0)
 S PARMS("START")=$$ASKBEGIN("T-1")
"RTN","HLOUSR2",79,0)
 I 'PARMS("START") Q 0
"RTN","HLOUSR2",80,0)
 S PARMS("MAX")=$$ASKMAX()
"RTN","HLOUSR2",81,0)
 Q:'(PARMS("MAX")>-1) 0
"RTN","HLOUSR2",82,0)
 S PARMS("ALL")=$$ASKYESNO("Include ALL applications","YES")
"RTN","HLOUSR2",83,0)
 ;
"RTN","HLOUSR2",84,0)
 ; *** BEGIN HL*1.6*147 - RBN
"RTN","HLOUSR2",85,0)
 ; 
"RTN","HLOUSR2",86,0)
 ;I PARMS("ALL") Q 1
"RTN","HLOUSR2",87,0)
 I PARMS("ALL")="" Q 0
"RTN","HLOUSR2",88,0)
 ;S PARMS("APP")=$$ASKAPP()
"RTN","HLOUSR2",89,0)
 I 'PARMS("ALL") D  Q:PARMS("APP")="" 0
"RTN","HLOUSR2",90,0)
 . S PARMS("APP")=$$ASKAPP()
"RTN","HLOUSR2",91,0)
 S PARMS("SCR")=$$ASKSCR()
"RTN","HLOUSR2",92,0)
 ;
"RTN","HLOUSR2",93,0)
 ; ** END HL*1.6*147 - RBN
"RTN","HLOUSR2",94,0)
 ; 
"RTN","HLOUSR2",95,0)
 Q 1
"RTN","HLOUSR2",96,0)
 ;
"RTN","HLOUSR2",97,0)
ASKMAX()        ;
"RTN","HLOUSR2",98,0)
 N DIR
"RTN","HLOUSR2",99,0)
 S DIR(0)="N^1:30000:0"
"RTN","HLOUSR2",100,0)
 S DIR("A")="Maximum List Size"
"RTN","HLOUSR2",101,0)
 S DIR("B")=1000
"RTN","HLOUSR2",102,0)
 S DIR("?",1)="In case a large number of errors meet your search criteria, what are the"
"RTN","HLOUSR2",103,0)
 S DIR("?")="maximum number of errors to display? (30,000 maximum)"
"RTN","HLOUSR2",104,0)
 D ^DIR
"RTN","HLOUSR2",105,0)
 Q:$D(DTOUT)!$D(DUOUT) -1
"RTN","HLOUSR2",106,0)
 Q X-1
"RTN","HLOUSR2",107,0)
 ;
"RTN","HLOUSR2",108,0)
ASKAPP() ;
"RTN","HLOUSR2",109,0)
 D FULL^VALM1
"RTN","HLOUSR2",110,0)
 S VALMBCK="R"
"RTN","HLOUSR2",111,0)
 N DIR
"RTN","HLOUSR2",112,0)
 S DIR(0)="F^3:60"
"RTN","HLOUSR2",113,0)
 S DIR("A")="Receiving Application"
"RTN","HLOUSR2",114,0)
 S DIR("?")="Enter the full name of the application, or '^' to exit."
"RTN","HLOUSR2",115,0)
 D ^DIR
"RTN","HLOUSR2",116,0)
 I $D(DIRUT)!(Y="") Q ""
"RTN","HLOUSR2",117,0)
 Q Y
"RTN","HLOUSR2",118,0)
 ;
"RTN","HLOUSR2",119,0)
 ; *** BEGIN HL*1.6*147 - RBN
"RTN","HLOUSR2",120,0)
 ;
"RTN","HLOUSR2",121,0)
ASKSCR() ;
"RTN","HLOUSR2",122,0)
 D FULL^VALM1
"RTN","HLOUSR2",123,0)
 S VALMBCK="R"
"RTN","HLOUSR2",124,0)
 N DIR
"RTN","HLOUSR2",125,0)
 S DIR(0)="PO^779.11"
"RTN","HLOUSR2",126,0)
 S DIR("A")="Error Screen (optional)"
"RTN","HLOUSR2",127,0)
 S DIR("B")=""
"RTN","HLOUSR2",128,0)
 S DIR("?")="Enter the full name of the error screen.  This entry is optional"
"RTN","HLOUSR2",129,0)
 D ^DIR
"RTN","HLOUSR2",130,0)
 I $D(DIRUT)!'(Y>0) Q ""
"RTN","HLOUSR2",131,0)
 Q Y
"RTN","HLOUSR2",132,0)
 ;
"RTN","HLOUSR2",133,0)
 ;
"RTN","HLOUSR2",134,0)
ASKYESNO(PROMPT,DEFAULT) ;
"RTN","HLOUSR2",135,0)
 ;Description: Displays PROMPT, appending '?'.  Expects a YES NO response
"RTN","HLOUSR2",136,0)
 ;Input:
"RTN","HLOUSR2",137,0)
 ;   PROMPT - text to display as prompt.  Appends '?'
"RTN","HLOUSR2",138,0)
 ;   DEFAULT - (optional) YES or NO.  If not passed, defaults to YES
"RTN","HLOUSR2",139,0)
 ;Output:
"RTN","HLOUSR2",140,0)
 ;  Function value: 1 if yes, 0 if no, "" if '^' entered or timeout
"RTN","HLOUSR2",141,0)
 ;
"RTN","HLOUSR2",142,0)
 N DIR,Y
"RTN","HLOUSR2",143,0)
 S DIR(0)="Y"
"RTN","HLOUSR2",144,0)
 S DIR("A")=PROMPT
"RTN","HLOUSR2",145,0)
 S DIR("B")=$S($G(DEFAULT)="NO":"NO",1:"YES")
"RTN","HLOUSR2",146,0)
 D ^DIR
"RTN","HLOUSR2",147,0)
 Q:$D(DIRUT) ""
"RTN","HLOUSR2",148,0)
 Q Y
"RTN","HLOUSR2",149,0)
 ;
"RTN","HLOUSR2",150,0)
STRTSTPQ ;
"RTN","HLOUSR2",151,0)
 ;action to start or stop a queue, either incoming or outgoing
"RTN","HLOUSR2",152,0)
 ;
"RTN","HLOUSR2",153,0)
 N STOP,INOROUT,QUE
"RTN","HLOUSR2",154,0)
 S VALMBCK="R"
"RTN","HLOUSR2",155,0)
 D FULL^VALM1
"RTN","HLOUSR2",156,0)
 ;ask if stop or start
"RTN","HLOUSR2",157,0)
 D  Q:STOP=""
"RTN","HLOUSR2",158,0)
 .N DIR
"RTN","HLOUSR2",159,0)
 .S DIR(0)="S^1:START;2:STOP"
"RTN","HLOUSR2",160,0)
 .S DIR("A")="Do you want to START or STOP a queue"
"RTN","HLOUSR2",161,0)
 .S DIR("B")="1"
"RTN","HLOUSR2",162,0)
 .D ^DIR
"RTN","HLOUSR2",163,0)
 .S STOP=$S(Y=1:0,Y=2:1,1:"")
"RTN","HLOUSR2",164,0)
 ;ask if in or out
"RTN","HLOUSR2",165,0)
 D  Q:INOROUT=""
"RTN","HLOUSR2",166,0)
 .N DIR
"RTN","HLOUSR2",167,0)
 .S DIR(0)="S^I:INCOMING;O:OUTGOING"
"RTN","HLOUSR2",168,0)
 .S DIR("A")="Do you want to "_$S(STOP:"stop",1:"start")_" an incoming queue or an outgoing queue"
"RTN","HLOUSR2",169,0)
 .S DIR("B")="I"
"RTN","HLOUSR2",170,0)
 .D ^DIR
"RTN","HLOUSR2",171,0)
 .S INOROUT=$S(Y="I":"IN",Y="O":"OUT",1:"")
"RTN","HLOUSR2",172,0)
 S QUE=$$ASKQUE(INOROUT)
"RTN","HLOUSR2",173,0)
 Q:QUE=""
"RTN","HLOUSR2",174,0)
 I STOP=$$STOPPED^HLOQUE(INOROUT,QUE) D
"RTN","HLOUSR2",175,0)
 .N C
"RTN","HLOUSR2",176,0)
 .I STOP D
"RTN","HLOUSR2",177,0)
 ..W !,"That queue is already stopped!"
"RTN","HLOUSR2",178,0)
 .E  W !,"That queue is not stopped!"
"RTN","HLOUSR2",179,0)
 .W !,IOINHI,"Hit any key to continue...",IOINORM
"RTN","HLOUSR2",180,0)
 .R *C:DTIME
"RTN","HLOUSR2",181,0)
 E  D
"RTN","HLOUSR2",182,0)
 .N C
"RTN","HLOUSR2",183,0)
 .D:STOP STOPQUE^HLOQUE(INOROUT,QUE)
"RTN","HLOUSR2",184,0)
 .D:'STOP STARTQUE^HLOQUE(INOROUT,QUE)
"RTN","HLOUSR2",185,0)
 .W !,"DONE!"
"RTN","HLOUSR2",186,0)
 .W !,IOINHI,"Hit any key to continue...",IOINORM
"RTN","HLOUSR2",187,0)
 .R *C:DTIME
"RTN","HLOUSR2",188,0)
 .D @HLRFRSH
"RTN","HLOUSR2",189,0)
 Q
"RTN","HLOUSR2",190,0)
 ;
"RTN","HLOUSR2",191,0)
ASKQUE(DIR) ;
"RTN","HLOUSR2",192,0)
 N QUEUE
"RTN","HLOUSR2",193,0)
AGAIN W !,"Enter the full, exact name of queue:"
"RTN","HLOUSR2",194,0)
 S QUEUE=""
"RTN","HLOUSR2",195,0)
 R QUEUE:60 I '$T Q ""
"RTN","HLOUSR2",196,0)
 I $E(QUEUE)="?" W !,"Each message is placed on a queue that has an arbitrary name up to 20",!,"characters long." I $$ASKYESNO("Would you like to see a list of the queues that currently exist","NO") D  G AGAIN
"RTN","HLOUSR2",197,0)
 .N SUB,QUE,QUIT,COUNT
"RTN","HLOUSR2",198,0)
 .K ^TMP($J,"HLO QUEUES")
"RTN","HLOUSR2",199,0)
 .S SUB=""
"RTN","HLOUSR2",200,0)
 .F  S SUB=$O(^HLB("QUEUE",DIR,SUB)) Q:SUB=""  D
"RTN","HLOUSR2",201,0)
 ..S QUE=""
"RTN","HLOUSR2",202,0)
 ..F  S QUE=$O(^HLB("QUEUE",DIR,SUB,QUE)) Q:QUE=""  S ^TMP($J,"HLO QUEUES",QUE)=""
"RTN","HLOUSR2",203,0)
 .S QUE=""
"RTN","HLOUSR2",204,0)
 .S IOSL=$G(IOSL,20)
"RTN","HLOUSR2",205,0)
 .S (COUNT,QUIT)=0
"RTN","HLOUSR2",206,0)
 .W !
"RTN","HLOUSR2",207,0)
 .F  S QUE=$O(^TMP($J,"HLO QUEUES",QUE)) Q:QUE=""  Q:QUIT  D
"RTN","HLOUSR2",208,0)
 ..W !,QUE
"RTN","HLOUSR2",209,0)
 ..S COUNT=COUNT+1
"RTN","HLOUSR2",210,0)
 ..I COUNT>(IOSL-3) D
"RTN","HLOUSR2",211,0)
 ...N Y
"RTN","HLOUSR2",212,0)
 ...D PAUSE^VALM1
"RTN","HLOUSR2",213,0)
 ...I 'Y S QUIT=1
"RTN","HLOUSR2",214,0)
 ...S COUNT=0
"RTN","HLOUSR2",215,0)
 .W !
"RTN","HLOUSR2",216,0)
 .K ^TMP($J,"HLO QUEUES")
"RTN","HLOUSR2",217,0)
 Q:$E(QUEUE)="?" ""
"RTN","HLOUSR2",218,0)
 Q:$E(QUEUE)="^" ""
"RTN","HLOUSR2",219,0)
 Q QUEUE
"RTN","HLOUSR2",220,0)
 ;
"RTN","HLOUSR2",221,0)
ASKBEGIN(DEFAULT) ;
"RTN","HLOUSR2",222,0)
 ;Description: Asks the user to enter a beginning date.
"RTN","HLOUSR2",223,0)
 ;Input: DEFAULT - the suggested default dt/time (optional)
"RTN","HLOUSR2",224,0)
 ;Output: Returns the date as the function value, or 0 if the user does not select a date
"RTN","HLOUSR2",225,0)
 ;
"RTN","HLOUSR2",226,0)
 ;
"RTN","HLOUSR2",227,0)
 N %DT
"RTN","HLOUSR2",228,0)
 S %DT="AEST"
"RTN","HLOUSR2",229,0)
 S %DT("A")="Enter the beginning date/time: "
"RTN","HLOUSR2",230,0)
 S %DT("B")=$$FMTE^XLFDT($S($L($G(DEFAULT)):DEFAULT,1:$$FMADD^XLFDT(DT,-1)))
"RTN","HLOUSR2",231,0)
 S %DT(0)="-NOW"
"RTN","HLOUSR2",232,0)
 Q:$D(DTOUT) 0
"RTN","HLOUSR2",233,0)
 D ^%DT
"RTN","HLOUSR2",234,0)
 I Y=-1 Q 0
"RTN","HLOUSR2",235,0)
 Q Y
"RTN","HLOUSR2",236,0)
 ;
"RTN","HLOUSR2",237,0)
ASKEND(BEGIN) ;
"RTN","HLOUSR2",238,0)
 ;Description: Asks the user to enter an ending date/time
"RTN","HLOUSR2",239,0)
 ;Input: BEGIN - the earliest date/time allowed
"RTN","HLOUSR2",240,0)
 ;Output: Returns the date as the function value, or 0 if the user does not select a date/time
"RTN","HLOUSR2",241,0)
 ;
"RTN","HLOUSR2",242,0)
 N %DT
"RTN","HLOUSR2",243,0)
 S %DT="AEST"
"RTN","HLOUSR2",244,0)
 S %DT("A")="Enter the ending date/time: "
"RTN","HLOUSR2",245,0)
 S %DT("B")="NOW"
"RTN","HLOUSR2",246,0)
 S %DT(0)=BEGIN
"RTN","HLOUSR2",247,0)
 Q:$D(DTOUT) 0
"RTN","HLOUSR2",248,0)
 D ^%DT
"RTN","HLOUSR2",249,0)
 I Y=-1 Q 0
"RTN","HLOUSR2",250,0)
 Q Y
"RTN","HLOUSR2",251,0)
 ;
"RTN","HLOUSR2",252,0)
LJ(STRING,LEN) ;
"RTN","HLOUSR2",253,0)
 Q $$LJ^XLFSTR(STRING,LEN)
"RTN","HLOUSR2",254,0)
RJ(STRING,LEN) ;
"RTN","HLOUSR2",255,0)
 Q $$RJ^XLFSTR(STRING,LEN)
"RTN","HLOUSR2",256,0)
 ;
"RTN","HLOUSR2",257,0)
I() ;
"RTN","HLOUSR2",258,0)
 S VALMCNT=VALMCNT+1
"RTN","HLOUSR2",259,0)
 Q VALMCNT
"RTN","HLOUSR2",260,0)
 ;
"RTN","HLOUSR2",261,0)
HEADER ;
"RTN","HLOUSR2",262,0)
 Q
"RTN","HLOUSR2",263,0)
HELP ;
"RTN","HLOUSR2",264,0)
 N ARY
"RTN","HLOUSR2",265,0)
 S ARY(1)="An error screen allows you to specify what type of errors"
"RTN","HLOUSR2",266,0)
 S ARY(2)="appear in the error display. There are two types of screens:"
"RTN","HLOUSR2",267,0)
 S ARY(3)=""
"RTN","HLOUSR2",268,0)
 S ARY(4)="EXCLUDE screens allow you to specify what errors to exclude from the display."
"RTN","HLOUSR2",269,0)
 S ARY(5)=""
"RTN","HLOUSR2",270,0)
 S ARY(6)="INCLUDE screens allow you to specify what errors to include in the display."
"RTN","HLOUSR2",271,0)
 S ARY(7)=""
"RTN","HLOUSR2",272,0)
 S ARY(8)="With either type of screen, if a string on your list matches text within"
"RTN","HLOUSR2",273,0)
 S ARY(9)="the error message then the error is included or excluded from the"
"RTN","HLOUSR2",274,0)
 S ARY(10)="display, depending on the type of screen."
"RTN","HLOUSR2",275,0)
 D EN^DDIOL(.ARY)
"RTN","HLOUSR2",276,0)
 Q
"RTN","HLOUSR2",277,0)
 ;
"RTN","HLOUSR2",278,0)
GETSCRN(IEN,SCREEN) ;
"RTN","HLOUSR2",279,0)
 ;pass SCREEN by reference
"RTN","HLOUSR2",280,0)
 ;returns 1 on success, 0 on failure
"RTN","HLOUSR2",281,0)
 ;
"RTN","HLOUSR2",282,0)
 N NODE,TYPE,I,ERROR
"RTN","HLOUSR2",283,0)
 K SCREEN
"RTN","HLOUSR2",284,0)
 S NODE=$G(^HLD(779.11,IEN,0))
"RTN","HLOUSR2",285,0)
 S TYPE=$P(NODE,"^",5)
"RTN","HLOUSR2",286,0)
 I TYPE'=0,TYPE'=1 Q 0
"RTN","HLOUSR2",287,0)
 S SCREEN("TYPE")=$S(TYPE=0:"EXCLUDE",1:"INCLUDE")
"RTN","HLOUSR2",288,0)
 S SCREEN("IEN")=IEN
"RTN","HLOUSR2",289,0)
 S I=0
"RTN","HLOUSR2",290,0)
 F  S I=$O(^HLD(779.11,IEN,1,I)) Q:'I  S ERROR=$G(^HLD(779.11,IEN,1,I,0))  I ERROR'="" S SCREEN("ERRORS",I)=$P(ERROR,"^"),SCREEN("ERRORS",I,"PARTIAL")=+$P(ERROR,"^",2)
"RTN","HLOUSR2",291,0)
 Q 1
"RTN","HLOUSR2",292,0)
SCREEN(ERROR,SCREEN) ;
"RTN","HLOUSR2",293,0)
 ;Returns 1 if the ERROR should be added to the display based on the SCREEN
"RTN","HLOUSR2",294,0)
 ;
"RTN","HLOUSR2",295,0)
 I ERROR="" Q $S(SCREEN("TYPE")="EXCLUDE":1,1:0)
"RTN","HLOUSR2",296,0)
 ;
"RTN","HLOUSR2",297,0)
 N ADD,I,TEXT
"RTN","HLOUSR2",298,0)
 ;
"RTN","HLOUSR2",299,0)
 S I=0
"RTN","HLOUSR2",300,0)
 S ADD=$S(SCREEN("TYPE")="INCLUDE":0,1:1)
"RTN","HLOUSR2",301,0)
 ;
"RTN","HLOUSR2",302,0)
 F  S I=$O(SCREEN("ERRORS",I)) Q:'I  S TEXT=$G(SCREEN("ERRORS",I)) I $L(TEXT),$S(SCREEN("ERRORS",I,"PARTIAL"):ERROR[TEXT,1:TEXT=ERROR) S ADD=$S(SCREEN("TYPE")="INCLUDE":1,1:0) Q
"RTN","HLOUSR2",303,0)
 ;
"RTN","HLOUSR2",304,0)
 Q ADD
"RTN","HLOUSR3")
0^12^B69258883^B66849245
"RTN","HLOUSR3",1,0)
HLOUSR3 ;ALB/CJM/RBN -ListManager Screen for viewing messages(continued);12 JUN 1997 10:00 am ;01/07/2010
"RTN","HLOUSR3",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,134,138,139,147**;Oct 13, 1995;Build 15
"RTN","HLOUSR3",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOUSR3",4,0)
 ;
"RTN","HLOUSR3",5,0)
 ;
"RTN","HLOUSR3",6,0)
EN ; Main entry point.
"RTN","HLOUSR3",7,0)
 N HLPARMS
"RTN","HLOUSR3",8,0)
 D FULL^VALM1
"RTN","HLOUSR3",9,0)
 I '$$ASK(.HLPARMS) S VALMBCK="R" Q
"RTN","HLOUSR3",10,0)
 D WAIT^DICD
"RTN","HLOUSR3",11,0)
 D EN^VALM("HLO MESSAGE SEARCH")
"RTN","HLOUSR3",12,0)
 Q
"RTN","HLOUSR3",13,0)
SEARCH ; Find a message.
"RTN","HLOUSR3",14,0)
 N I,APP,START,END,DIR,MSG,EVENT,TIME
"RTN","HLOUSR3",15,0)
 D EXIT
"RTN","HLOUSR3",16,0)
 S I=""
"RTN","HLOUSR3",17,0)
 F  S I=$O(HLPARMS(I)) Q:I=""  S @I=HLPARMS(I)
"RTN","HLOUSR3",18,0)
 K HLPARMS
"RTN","HLOUSR3",19,0)
 S (VALMCNT,I)=0
"RTN","HLOUSR3",20,0)
 S TIME=START
"RTN","HLOUSR3",21,0)
 F  S TIME=$O(^HLB("SEARCH",DIR,TIME)) Q:'TIME  Q:TIME>END  Q:VALMCNT>MAX  D
"RTN","HLOUSR3",22,0)
 .N SAPP S SAPP=""
"RTN","HLOUSR3",23,0)
 .S:APP'="" SAPP=$O(^HLB("SEARCH",DIR,TIME,APP),-1)
"RTN","HLOUSR3",24,0)
 .F  S SAPP=$O(^HLB("SEARCH",DIR,TIME,SAPP)) Q:SAPP=""  Q:$E(SAPP,1,$L(APP))]APP  Q:VALMCNT>MAX  D:$E(SAPP,1,$L(APP))=APP
"RTN","HLOUSR3",25,0)
 ..N SMSG S SMSG=""
"RTN","HLOUSR3",26,0)
 ..S:MSG'="" SMSG=$O(^HLB("SEARCH",DIR,TIME,SAPP,MSG),-1)
"RTN","HLOUSR3",27,0)
 ..F  S SMSG=$O(^HLB("SEARCH",DIR,TIME,SAPP,SMSG)) Q:SMSG=""  Q:$E(SMSG,1,$L(MSG))]MSG  Q:VALMCNT>MAX  D:$E(SMSG,1,$L(MSG))=MSG
"RTN","HLOUSR3",28,0)
 ...N SEVENT S SEVENT=""
"RTN","HLOUSR3",29,0)
 ...S:EVENT'="" SEVENT=$O(^HLB("SEARCH",DIR,TIME,SAPP,SMSG,EVENT),-1)
"RTN","HLOUSR3",30,0)
 ...F  S SEVENT=$O(^HLB("SEARCH",DIR,TIME,SAPP,SMSG,SEVENT)) Q:SEVENT=""  Q:$E(SEVENT,1,$L(EVENT))]EVENT  Q:VALMCNT>MAX  D:$E(SEVENT,1,$L(EVENT))=EVENT
"RTN","HLOUSR3",31,0)
 ....N IEN
"RTN","HLOUSR3",32,0)
 ....S IEN=""
"RTN","HLOUSR3",33,0)
 ....F  S IEN=$O(^HLB("SEARCH",DIR,TIME,SAPP,SMSG,SEVENT,IEN)) Q:IEN=""  Q:VALMCNT>MAX  D ADDTO(DIR,TIME,SAPP,SMSG,SEVENT,IEN)
"RTN","HLOUSR3",34,0)
 ;
"RTN","HLOUSR3",35,0)
 ;
"RTN","HLOUSR3",36,0)
END ; Return to List Manager.
"RTN","HLOUSR3",37,0)
 S VALMBCK="R"
"RTN","HLOUSR3",38,0)
 ;
"RTN","HLOUSR3",39,0)
 Q
"RTN","HLOUSR3",40,0)
ADDTO(DIR,TIME,APP,MSG,EVENT,IEN) ; Add message to queue.
"RTN","HLOUSR3",41,0)
 N HDR,FS,LOC,MSGID
"RTN","HLOUSR3",42,0)
 S MSGID=$S($P(IEN,"^",2):$P($G(^HLB(+IEN,3,$P(IEN,"^",2),0)),"^",2),1:$P($G(^HLB(IEN,0)),"^",1))
"RTN","HLOUSR3",43,0)
 S HDR=$G(^HLB(+IEN,1))
"RTN","HLOUSR3",44,0)
 S FS=$E(HDR,4)
"RTN","HLOUSR3",45,0)
 I FS'="" D
"RTN","HLOUSR3",46,0)
 .I DIR="IN" S LOC=$P(HDR,FS,4)
"RTN","HLOUSR3",47,0)
 .I DIR'="IN" S LOC=$P(HDR,FS,6)
"RTN","HLOUSR3",48,0)
 E  S LOC=""
"RTN","HLOUSR3",49,0)
 S @VALMAR@($$I,0)=$$LJ(MSGID,25)_$$LJ(APP,30)_" "_MSG_"~"_EVENT
"RTN","HLOUSR3",50,0)
 D CNTRL^VALM10(VALMCNT,1,25,IOINHI,IOINORM)
"RTN","HLOUSR3",51,0)
 S @VALMAR@($$I,0)="     "_$$LJ($$FMTE^XLFDT(TIME,2),20)_$$LJ(LOC,60)
"RTN","HLOUSR3",52,0)
 S @VALMAR@($$I,0)=""
"RTN","HLOUSR3",53,0)
 Q
"RTN","HLOUSR3",54,0)
LJ(STRING,LEN) ;
"RTN","HLOUSR3",55,0)
 Q $$LJ^XLFSTR(STRING,LEN)
"RTN","HLOUSR3",56,0)
 ;
"RTN","HLOUSR3",57,0)
I() ;
"RTN","HLOUSR3",58,0)
 S VALMCNT=VALMCNT+1
"RTN","HLOUSR3",59,0)
 Q VALMCNT
"RTN","HLOUSR3",60,0)
 ;
"RTN","HLOUSR3",61,0)
ASK(PARMS) ; Ask for parameter values.
"RTN","HLOUSR3",62,0)
 N SUB
"RTN","HLOUSR3",63,0)
 F SUB="START","END","EVENT","APP","MSG","DIR" S PARMS(SUB)=""
"RTN","HLOUSR3",64,0)
 S PARMS("START")=$$ASKBEGIN^HLOUSR2()
"RTN","HLOUSR3",65,0)
 Q:'PARMS("START") 0
"RTN","HLOUSR3",66,0)
 S PARMS("END")=$$ASKEND^HLOUSR2(PARMS("START"))
"RTN","HLOUSR3",67,0)
 Q:'PARMS("END") 0
"RTN","HLOUSR3",68,0)
 S PARMS("APP")=$$ASKAPP()
"RTN","HLOUSR3",69,0)
 Q:PARMS("APP")=-1 0
"RTN","HLOUSR3",70,0)
 S PARMS("MSG")=$$ASKMSG()
"RTN","HLOUSR3",71,0)
 Q:PARMS("MSG")=-1 0
"RTN","HLOUSR3",72,0)
 S PARMS("EVENT")=$$ASKEVENT()
"RTN","HLOUSR3",73,0)
 Q:PARMS("EVENT")=-1 0
"RTN","HLOUSR3",74,0)
 S PARMS("DIR")=$$ASKDIR()
"RTN","HLOUSR3",75,0)
 Q:PARMS("DIR")=-1 0
"RTN","HLOUSR3",76,0)
 ;** P139 START CJM
"RTN","HLOUSR3",77,0)
 S PARMS("DIR")=$S(PARMS("DIR")="I":"IN",PARMS("DIR")="i":"IN",1:"OUT")
"RTN","HLOUSR3",78,0)
 ;** P139 END CJM
"RTN","HLOUSR3",79,0)
 S PARMS("MAX")=$$ASKMAX()
"RTN","HLOUSR3",80,0)
 Q:'(PARMS("MAX")>-1) 0
"RTN","HLOUSR3",81,0)
 Q 1
"RTN","HLOUSR3",82,0)
 ;
"RTN","HLOUSR3",83,0)
ASKMAX() ; Ask for the maximum number of messages.
"RTN","HLOUSR3",84,0)
 N DIR
"RTN","HLOUSR3",85,0)
 S DIR(0)="N^1:30000:0"
"RTN","HLOUSR3",86,0)
 S DIR("A")="Maximum List Size"
"RTN","HLOUSR3",87,0)
 S DIR("B")=1000
"RTN","HLOUSR3",88,0)
 S DIR("?",1)="In case a large number of messages meet your search criteria, what are the"
"RTN","HLOUSR3",89,0)
 S DIR("?")="maximum number of messages to display? (30,000 maximum)"
"RTN","HLOUSR3",90,0)
 D ^DIR
"RTN","HLOUSR3",91,0)
 Q:$D(DTOUT)!$D(DUOUT) -1
"RTN","HLOUSR3",92,0)
 Q 3*(X-1)
"RTN","HLOUSR3",93,0)
ASKAPP() ; Ask for application name.
"RTN","HLOUSR3",94,0)
 N DIR
"RTN","HLOUSR3",95,0)
 S DIR(0)="FO^0:60"
"RTN","HLOUSR3",96,0)
 S DIR("A")="Application"
"RTN","HLOUSR3",97,0)
 S DIR("?",1)="Enter the name of the application, or '^' to exit."
"RTN","HLOUSR3",98,0)
 S DIR("?")="You can enter just the first part of the name."
"RTN","HLOUSR3",99,0)
 D ^DIR
"RTN","HLOUSR3",100,0)
 Q:$D(DTOUT)!$D(DUOUT) -1
"RTN","HLOUSR3",101,0)
 Q X
"RTN","HLOUSR3",102,0)
ASKMSG() ;
"RTN","HLOUSR3",103,0)
 N DIR
"RTN","HLOUSR3",104,0)
 S DIR(0)="FO^0:3"
"RTN","HLOUSR3",105,0)
 S DIR("A")="HL7 Message Type"
"RTN","HLOUSR3",106,0)
 S DIR("?",1)="Enter the 3 character message type (e.g. MFN, ADT), or '^' to exit."
"RTN","HLOUSR3",107,0)
 S DIR("?")="You can enter just the first character or two."
"RTN","HLOUSR3",108,0)
 D ^DIR
"RTN","HLOUSR3",109,0)
 Q:$D(DTOUT)!$D(DUOUT) -1
"RTN","HLOUSR3",110,0)
 Q X
"RTN","HLOUSR3",111,0)
ASKEVENT() ; Ask for event.
"RTN","HLOUSR3",112,0)
 N DIR
"RTN","HLOUSR3",113,0)
 S DIR(0)="FO^0:3"
"RTN","HLOUSR3",114,0)
 S DIR("A")="HL7 Event"
"RTN","HLOUSR3",115,0)
 S DIR("?",1)="Enter the 3 character event type, or '^' to exit."
"RTN","HLOUSR3",116,0)
 S DIR("?")="You can enter just the first character or two."
"RTN","HLOUSR3",117,0)
 D ^DIR
"RTN","HLOUSR3",118,0)
 Q:$D(DTOUT)!$D(DUOUT) -1
"RTN","HLOUSR3",119,0)
 Q X
"RTN","HLOUSR3",120,0)
ASKDIR() ; Ask message direction
"RTN","HLOUSR3",121,0)
 N DIR
"RTN","HLOUSR3",122,0)
 S DIR(0)="S^I:INCOMING;O:OUTGOING"
"RTN","HLOUSR3",123,0)
 S DIR("A")="Incoming or Outgoing"
"RTN","HLOUSR3",124,0)
 S DIR("?",1)="Are you searching for an incoming message or an outgoing message?"
"RTN","HLOUSR3",125,0)
 S DIR("?")="You can enter '^' to exit"
"RTN","HLOUSR3",126,0)
 D ^DIR
"RTN","HLOUSR3",127,0)
 Q:$D(DTOUT)!$D(DUOUT) -1
"RTN","HLOUSR3",128,0)
 Q X
"RTN","HLOUSR3",129,0)
HDR ; Set the List Manager header
"RTN","HLOUSR3",130,0)
 S VALMHDR(1)="MsgID                    Application                    MsgType"
"RTN","HLOUSR3",131,0)
 Q
"RTN","HLOUSR3",132,0)
HLP ;
"RTN","HLOUSR3",133,0)
 Q
"RTN","HLOUSR3",134,0)
EXIT ; Clean up and exit back to List Manager
"RTN","HLOUSR3",135,0)
 D CLEAN^VALM10
"RTN","HLOUSR3",136,0)
 D CLEAR^VALM1
"RTN","HLOUSR3",137,0)
 S VALMBCK="R"
"RTN","HLOUSR3",138,0)
 Q
"RTN","HLOUSR3",139,0)
 ;
"RTN","HLOUSR3",140,0)
SETPURGE ; Set a message up for purging.
"RTN","HLOUSR3",141,0)
 N MSG,DIR
"RTN","HLOUSR3",142,0)
 S VALMBCK="R"
"RTN","HLOUSR3",143,0)
 Q:'$G(MSGIEN)
"RTN","HLOUSR3",144,0)
 Q:'$$GETMSG^HLOMSG(+MSGIEN,.MSG)
"RTN","HLOUSR3",145,0)
 I MSG("STATUS")="",'MSG("STATUS","PURGE") W !,"Can not set purge yet!" D PAUSE^VALM1 Q
"RTN","HLOUSR3",146,0)
 S DIR(0)="D^"_DT_":"_$$FMADD^XLFDT(DT,+45)_":E"
"RTN","HLOUSR3",147,0)
 S DIR("A")="When should the message be purged?"
"RTN","HLOUSR3",148,0)
 D ^DIR
"RTN","HLOUSR3",149,0)
 D:Y SETPURGE^HLOAPI3(+MSGIEN,Y),DISPLAY^HLOUSR1
"RTN","HLOUSR3",150,0)
 Q
"RTN","HLOUSR3",151,0)
SCREEN() ;  Screen for message purge status.
"RTN","HLOUSR3",152,0)
 N TRUE
"RTN","HLOUSR3",153,0)
 S TRUE=1
"RTN","HLOUSR3",154,0)
 I $P($G(X),"^",3)="SET PURGE" D  Q TRUE
"RTN","HLOUSR3",155,0)
 .N MSG
"RTN","HLOUSR3",156,0)
 .I '$G(MSGIEN) S TRUE=0 Q
"RTN","HLOUSR3",157,0)
 .I '$$GETMSG^HLOMSG(+MSGIEN,.MSG) S TRUE=0 Q
"RTN","HLOUSR3",158,0)
 .I MSG("STATUS")="",'MSG("STATUS","PURGE") S TRUE=0
"RTN","HLOUSR3",159,0)
 S:'TRUE VALMBCK="R"
"RTN","HLOUSR3",160,0)
 Q TRUE
"RTN","HLOUSR3",161,0)
 ;;**Start Patch HL*1.6.138 **
"RTN","HLOUSR3",162,0)
 ;;The following three subroutines have been added for HL*1.6*138 - RBN
"RTN","HLOUSR3",163,0)
 ;;
"RTN","HLOUSR3",164,0)
RESEND ; If outbound message has been sent, resends it.
"RTN","HLOUSR3",165,0)
 N CONF
"RTN","HLOUSR3",166,0)
 D OWNSKEY^XUSRB(.CONF,"HLOMGR",DUZ)
"RTN","HLOUSR3",167,0)
 I CONF(0)'=1 D  Q
"RTN","HLOUSR3",168,0)
 . W !,"**** You are not authorized to use this option ****" D PAUSE^VALM1 Q
"RTN","HLOUSR3",169,0)
 ;Q:$$VERIFY^HLOQUE1()=-1
"RTN","HLOUSR3",170,0)
 N MSG,DIR,ERROR,FLG,OLDIEN,SYS
"RTN","HLOUSR3",171,0)
 S OLDIEN=MSGIEN
"RTN","HLOUSR3",172,0)
 I $G(OPT1DIS) D  K OPT1DIS Q
"RTN","HLOUSR3",173,0)
 . W !,"Sorry that option is not available for this message." D PAUSE^VALM1 Q
"RTN","HLOUSR3",174,0)
 S VALMBCK="R"
"RTN","HLOUSR3",175,0)
 Q:'$G(MSGIEN)
"RTN","HLOUSR3",176,0)
 Q:'$$GETMSG^HLOMSG(+MSGIEN,.MSG)
"RTN","HLOUSR3",177,0)
 I MSG("DIRECTION")'="OUT" W !,"Message is not an outbound message" D PAUSE^VALM1 Q
"RTN","HLOUSR3",178,0)
 I MSG("STATUS")="",'MSG("DT/TM") W !,"Message has not been sent!" D PAUSE^VALM1 Q
"RTN","HLOUSR3",179,0)
 Q:'$$ASKYESNO^HLOUSR2("Are you SURE you want to resend MsgID: "_MSG("ID"),"NO")
"RTN","HLOUSR3",180,0)
 S MSGIEN=$$RESEND^HLOAPI3(+MSGIEN,.ERROR)
"RTN","HLOUSR3",181,0)
 I $G(ERROR) W ERROR D PAUSE^VALM1 Q
"RTN","HLOUSR3",182,0)
 W !,"The message has been copied to MsgID ",MSGIEN," which will be displayed next"
"RTN","HLOUSR3",183,0)
 I $$ASKYESNO^HLOUSR2("Do you want the original message purged?","NO") D
"RTN","HLOUSR3",184,0)
 . D SYSPARMS^HLOSITE(.SYS)
"RTN","HLOUSR3",185,0)
 . S HLOPURDT=$$FMADD^XLFDT($$NOW^XLFDT,0,SYS("ERROR PURGE"),0,0)
"RTN","HLOUSR3",186,0)
 . S FLG=$$SETPURGE^HLOAPI3(OLDIEN,HLOPURDT)
"RTN","HLOUSR3",187,0)
 S FLG=$$GETMSG^HLOMSG(+MSGIEN,.MSG)
"RTN","HLOUSR3",188,0)
 D DISPLAY^HLOUSR1
"RTN","HLOUSR3",189,0)
 Q
"RTN","HLOUSR3",190,0)
 ;
"RTN","HLOUSR3",191,0)
REPROC ; If inbound message has been processed, reprocesses it.
"RTN","HLOUSR3",192,0)
 N CONF
"RTN","HLOUSR3",193,0)
 D FULL^VALM1
"RTN","HLOUSR3",194,0)
 D OWNSKEY^XUSRB(.CONF,"HLOMGR",DUZ)
"RTN","HLOUSR3",195,0)
 I CONF(0)'=1 D  Q
"RTN","HLOUSR3",196,0)
 . W !,"**** You are not authorized to use this option ****" D PAUSE^VALM1 Q
"RTN","HLOUSR3",197,0)
 ;Q:$$VERIFY^HLOQUE1()=-1
"RTN","HLOUSR3",198,0)
 N MSG,DIR,ERROR,SYSPARM
"RTN","HLOUSR3",199,0)
 I $G(OPT2DIS) D  K OPT2DIS Q
"RTN","HLOUSR3",200,0)
 . W !,"Sorry that option is not available for this message." D PAUSE^VALM1 Q
"RTN","HLOUSR3",201,0)
 S VALMBCK="R"
"RTN","HLOUSR3",202,0)
 Q:'$G(MSGIEN)
"RTN","HLOUSR3",203,0)
 Q:'$$GETMSG^HLOMSG(+MSGIEN,.MSG)
"RTN","HLOUSR3",204,0)
 I MSG("DIRECTION")'="IN" W !,"Message is not an inbound message" D PAUSE^VALM1 Q
"RTN","HLOUSR3",205,0)
 I MSG("STATUS")="",'MSG("STATUS","APP HANDOFF") W !,"Message has not been processed" D PAUSE^VALM1 Q
"RTN","HLOUSR3",206,0)
 Q:'$$ASKYESNO^HLOUSR2("Are you SURE you want to reprocess MsgID: "_MSG("ID"),"NO")
"RTN","HLOUSR3",207,0)
 I '$$PROCNOW^HLOAPI3(+MSGIEN,"",.ERROR) W ERROR D PAUSE^VALM1 Q
"RTN","HLOUSR3",208,0)
 W !,"Done!  The message has been reprocessed by the application."
"RTN","HLOUSR3",209,0)
 S DIR(0)="D^"_DT_":"_$$FMADD^XLFDT(DT,+45)_":E"
"RTN","HLOUSR3",210,0)
 I '$$ASKYESNO^HLOUSR2("Do you want to purge the message?","NO") D
"RTN","HLOUSR3",211,0)
 . D SYSPARMS^HLOSITE(.SYSPARM)
"RTN","HLOUSR3",212,0)
 . S HLOPURDT=$$FMADD^XLFDT($$NOW^XLFDT,0,SYSPARM("ERROR PURGE"),0,0)
"RTN","HLOUSR3",213,0)
 . S FLG=$$SETPURGE^HLOAPI3(MSGIEN,HLOPURDT)
"RTN","HLOUSR3",214,0)
 Q
"RTN","HLOUSR3",215,0)
 ;
"RTN","HLOUSR3",216,0)
MSGPREP ; Enable or disable menu options
"RTN","HLOUSR3",217,0)
 N MSG,FDA,ERR
"RTN","HLOUSR3",218,0)
 D GETMSG^HLOMSG(MSGIEN,.MSG)
"RTN","HLOUSR3",219,0)
 I 'MSG("DT/TM") D            ; Message has not been sent/processed
"RTN","HLOUSR3",220,0)
 .  S (OPT1DIS,OPT2DIS)=1
"RTN","HLOUSR3",221,0)
 I MSG("DIRECTION")="OUT" D   ; Msg outbound and sent ; disable MP
"RTN","HLOUSR3",222,0)
 .  S OPT2DIS=1
"RTN","HLOUSR3",223,0)
 I MSG("DIRECTION")="IN" D    ; Msg inbound and sent ; disable MR
"RTN","HLOUSR3",224,0)
 .  S OPT1DIS=1
"RTN","HLOUSR3",225,0)
 S VALMBCK="R"
"RTN","HLOUSR3",226,0)
 Q
"RTN","HLOUSR3",227,0)
 ;;**End Patch HL*1.6*138 **
"RTN","HLOUSR3",228,0)
 ;
"RTN","HLOUSR4")
0^13^B15343784^B15146335
"RTN","HLOUSR4",1,0)
HLOUSR4 ;ALB/CJM -ListManager screen for reporting sequence queues;12 JUN 1997 10:00 am ;01/04/2010
"RTN","HLOUSR4",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**137,138,147**;Oct 13, 1995;Build 15
"RTN","HLOUSR4",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOUSR4",4,0)
 ;
"RTN","HLOUSR4",5,0)
 ;
"RTN","HLOUSR4",6,0)
EN ;
"RTN","HLOUSR4",7,0)
 K HLPARMS ;not newed so they'll be left for realtime mode
"RTN","HLOUSR4",8,0)
 N OLDRFRSH
"RTN","HLOUSR4",9,0)
 S OLDRFRSH=$G(HLRFRSH)
"RTN","HLOUSR4",10,0)
 D CLEAN^VALM10
"RTN","HLOUSR4",11,0)
 D FULL^VALM1
"RTN","HLOUSR4",12,0)
 S HLRFRSH="SEARCH^HLOUSR4(.HLPARMS)"
"RTN","HLOUSR4",13,0)
 I '$$ASK(.HLPARMS) S VALMBCK="R" Q
"RTN","HLOUSR4",14,0)
 D EN^VALM("HLO SEQUENCE QUEUES")
"RTN","HLOUSR4",15,0)
 S HLRFRSH=OLDRFRSH
"RTN","HLOUSR4",16,0)
 I $L(HLRFRSH) D @HLRFRSH
"RTN","HLOUSR4",17,0)
 Q
"RTN","HLOUSR4",18,0)
HDR ;
"RTN","HLOUSR4",19,0)
 S (HLSCREEN,VALMSG)="Sequence Queues"
"RTN","HLOUSR4",20,0)
 Q
"RTN","HLOUSR4",21,0)
 ;
"RTN","HLOUSR4",22,0)
SEARCH(HLPARMS) ;
"RTN","HLOUSR4",23,0)
 N MIN,LATEONLY,NS,QUE,ARY,COUNT,NOW,TIME,NODE
"RTN","HLOUSR4",24,0)
 S MIN=+$G(HLPARMS("MIN")),LATEONLY=+$G(HLPARMS("LATEONLY")),NS=$G(HLPARMS("NS"))
"RTN","HLOUSR4",25,0)
 S VALMCNT=0
"RTN","HLOUSR4",26,0)
 S NOW=$$NOW^XLFDT
"RTN","HLOUSR4",27,0)
 D CLEAN^VALM10
"RTN","HLOUSR4",28,0)
 ;
"RTN","HLOUSR4",29,0)
 S ARY="^HLB(""QUEUE"",""SEQUENCE"")"
"RTN","HLOUSR4",30,0)
 S QUE=NS
"RTN","HLOUSR4",31,0)
 D:$L(NS)  F  S QUE=$O(@ARY@(QUE)) Q:QUE=""  Q:'($E(QUE,1,$L(NS))=NS)  D
"RTN","HLOUSR4",32,0)
 .S NODE=$G(@ARY@(QUE))
"RTN","HLOUSR4",33,0)
 .S TIME=$P(NODE,"^",2)
"RTN","HLOUSR4",34,0)
 .I LATEONLY Q:'TIME  Q:TIME>NOW
"RTN","HLOUSR4",35,0)
 .;** start 138 cjm
"RTN","HLOUSR4",36,0)
 .;S IEN=0
"RTN","HLOUSR4",37,0)
 .;S COUNT=$S($L($P(NODE,"^")):1,1:0)
"RTN","HLOUSR4",38,0)
 .;F  S IEN=$O(@ARY@(QUE,IEN)) Q:'IEN  S COUNT=COUNT+1
"RTN","HLOUSR4",39,0)
 .S COUNT=+$G(^HLC("QUEUECOUNT","SEQUENCE",QUE))
"RTN","HLOUSR4",40,0)
 .;** end 138
"RTN","HLOUSR4",41,0)
 .I MIN,COUNT<MIN,'(TIME&(TIME<NOW)) Q
"RTN","HLOUSR4",42,0)
 .D ADDTO(QUE,COUNT,NODE)
"RTN","HLOUSR4",43,0)
END S VALMBCK="R"
"RTN","HLOUSR4",44,0)
 ;
"RTN","HLOUSR4",45,0)
 Q
"RTN","HLOUSR4",46,0)
ADDTO(QUE,COUNT,NODE) ;
"RTN","HLOUSR4",47,0)
 N LINE,MSGID
"RTN","HLOUSR4",48,0)
 ;
"RTN","HLOUSR4",49,0)
 S MSGID=""
"RTN","HLOUSR4",50,0)
 I $P(NODE,"^") S MSGID=$P($G(^HLB(+NODE,0)),"^",1)
"RTN","HLOUSR4",51,0)
 S LINE=$$LJ(QUE,30)_$$RJ(COUNT,7)_"  "_$$LJ(MSGID,18)
"RTN","HLOUSR4",52,0)
 I $P(NODE,"^",2),$P(NODE,"^",2)<NOW S LINE=LINE_$$FMTE^XLFDT($P(NODE,"^",2),"2FM")_"  "_$S($P(NODE,"^",3):"YES",1:"NO")
"RTN","HLOUSR4",53,0)
 S @VALMAR@($$I,0)=LINE
"RTN","HLOUSR4",54,0)
 Q
"RTN","HLOUSR4",55,0)
 ;
"RTN","HLOUSR4",56,0)
LJ(STRING,LEN) ;
"RTN","HLOUSR4",57,0)
 Q $$LJ^XLFSTR(STRING,LEN)
"RTN","HLOUSR4",58,0)
 ;
"RTN","HLOUSR4",59,0)
RJ(STRING,LEN) ;
"RTN","HLOUSR4",60,0)
 Q $$RJ^XLFSTR(STRING,LEN)
"RTN","HLOUSR4",61,0)
 ;
"RTN","HLOUSR4",62,0)
I() ;
"RTN","HLOUSR4",63,0)
 S VALMCNT=VALMCNT+1
"RTN","HLOUSR4",64,0)
 Q VALMCNT
"RTN","HLOUSR4",65,0)
 ;
"RTN","HLOUSR4",66,0)
ASK(PARMS) ;
"RTN","HLOUSR4",67,0)
 N SUB
"RTN","HLOUSR4",68,0)
 F SUB="NS","MIN","LATEONLY" S PARMS(SUB)=""
"RTN","HLOUSR4",69,0)
 S PARMS("NS")=$$ASKQUE
"RTN","HLOUSR4",70,0)
 Q:(PARMS("NS")=-1) 0
"RTN","HLOUSR4",71,0)
 S PARMS("LATEONLY")=$$ASKYESNO^HLOUSR2("Include only queues that are late","NO")
"RTN","HLOUSR4",72,0)
 Q:(PARMS("LATEONLY")=-1) 0
"RTN","HLOUSR4",73,0)
 S PARMS("MIN")=$$ASKMIN
"RTN","HLOUSR4",74,0)
 Q:(PARMS("MIN")<0) 0
"RTN","HLOUSR4",75,0)
 Q 1
"RTN","HLOUSR4",76,0)
 ;
"RTN","HLOUSR4",77,0)
ASKMIN() ;
"RTN","HLOUSR4",78,0)
 N DIR
"RTN","HLOUSR4",79,0)
 S DIR(0)="N^1:999999:0"
"RTN","HLOUSR4",80,0)
 S DIR("A")="Minimum Queue Size"
"RTN","HLOUSR4",81,0)
 S DIR("B")=1
"RTN","HLOUSR4",82,0)
 S DIR("?",1)="If you would like to limit the report to include only the"
"RTN","HLOUSR4",83,0)
 S DIR("?")="longer queues then you must specify the minimum size to include."
"RTN","HLOUSR4",84,0)
 D ^DIR
"RTN","HLOUSR4",85,0)
 Q:$D(DTOUT)!$D(DUOUT) -1
"RTN","HLOUSR4",86,0)
 Q X
"RTN","HLOUSR4",87,0)
ASKQUE() ;
"RTN","HLOUSR4",88,0)
 N DIR
"RTN","HLOUSR4",89,0)
 S DIR(0)="FO^0:40"
"RTN","HLOUSR4",90,0)
 S DIR("A")="Sequence Queue Namespace"
"RTN","HLOUSR4",91,0)
 S DIR("?")="Enter the namespace for the queues, or '^' to exit."
"RTN","HLOUSR4",92,0)
 D ^DIR
"RTN","HLOUSR4",93,0)
 Q:$D(DTOUT)!$D(DUOUT) -1
"RTN","HLOUSR4",94,0)
 Q X
"RTN","HLOUSR4",95,0)
 ;
"RTN","HLOUSR4",96,0)
ADVANCE ;
"RTN","HLOUSR4",97,0)
 N DIR,QUE,MSG,RET,DEFAULT
"RTN","HLOUSR4",98,0)
 S VALMBCK="R"
"RTN","HLOUSR4",99,0)
 S QUE=$$GETQ()
"RTN","HLOUSR4",100,0)
 Q:'$L(QUE)
"RTN","HLOUSR4",101,0)
 ;** START HL*1.6*138 CJM
"RTN","HLOUSR4",102,0)
 S DEFAULT=$P($G(^HLB("QUEUE","SEQUENCE",QUE)),"^")
"RTN","HLOUSR4",103,0)
 S:DEFAULT DEFAULT=$P($G(^HLB(DEFAULT,0)),"^")
"RTN","HLOUSR4",104,0)
 ;S MSG=$$PICKMSG^HLOUSR1()
"RTN","HLOUSR4",105,0)
 S MSG=$$PICKMSG^HLOUSR1(.DEFAULT)
"RTN","HLOUSR4",106,0)
 ;** END HL*1.6*138 CJM
"RTN","HLOUSR4",107,0)
 Q:'MSG
"RTN","HLOUSR4",108,0)
 S RET=$$ADVANCE^HLOQUE(QUE,MSG)
"RTN","HLOUSR4",109,0)
 I 'RET D
"RTN","HLOUSR4",110,0)
 .W !,"Sorry, that queue was not pending that message!" D PAUSE^VALM1
"RTN","HLOUSR4",111,0)
 E  D
"RTN","HLOUSR4",112,0)
 .W !,"The queue has been advanced!" D PAUSE^VALM1
"RTN","HLOUSR4",113,0)
 ;
"RTN","HLOUSR4",114,0)
 D SEARCH(.HLPARMS)
"RTN","HLOUSR4",115,0)
 Q
"RTN","HLOUSR4",116,0)
GETQ() ;returns the name of the sequence queue
"RTN","HLOUSR4",117,0)
 S DIR(0)="FO^0:40"
"RTN","HLOUSR4",118,0)
 S DIR("A")="Sequence Queue"
"RTN","HLOUSR4",119,0)
 S DIR("?")="Enter the full name of the queue, or '^' to exit."
"RTN","HLOUSR4",120,0)
 D ^DIR K DIR
"RTN","HLOUSR4",121,0)
 Q:$D(DTOUT)!$D(DUOUT) ""
"RTN","HLOUSR4",122,0)
 Q X
"RTN","HLOUSR6")
0^1^B27362137^B24863677
"RTN","HLOUSR6",1,0)
HLOUSR6 ;OAK/RBN -ListManager screen for reporting outbound queues;12 JUN 1997 10:00 am ;07/02/2010
"RTN","HLOUSR6",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**138,146,147**;Oct 13, 1995;Build 15
"RTN","HLOUSR6",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOUSR6",4,0)
 ;
"RTN","HLOUSR6",5,0)
 ;
"RTN","HLOUSR6",6,0)
EN ; Created list of outbound queues.
"RTN","HLOUSR6",7,0)
 N HLRFRSH,OLDRFRSH
"RTN","HLOUSR6",8,0)
 S OLDRFRSH=$G(HLRFRSH)
"RTN","HLOUSR6",9,0)
 D WAIT^DICD
"RTN","HLOUSR6",10,0)
 D EN^VALM("HLO DISPLAY OUT-GOING QUEUES")
"RTN","HLOUSR6",11,0)
 S HLRFRSH=OLDRFRSH
"RTN","HLOUSR6",12,0)
 I $L(HLRFRSH) D @HLRFRSH
"RTN","HLOUSR6",13,0)
 S VALMBCK="R"
"RTN","HLOUSR6",14,0)
 Q
"RTN","HLOUSR6",15,0)
 ;
"RTN","HLOUSR6",16,0)
INIT ; -- init variables and list array
"RTN","HLOUSR6",17,0)
 D OUTQUE
"RTN","HLOUSR6",18,0)
 D HDR
"RTN","HLOUSR6",19,0)
 D SHOW^VALM
"RTN","HLOUSR6",20,0)
 S VALMBCK="R"
"RTN","HLOUSR6",21,0)
 Q
"RTN","HLOUSR6",22,0)
 ;
"RTN","HLOUSR6",23,0)
HDR ; Header info. for the outbound queue display.
"RTN","HLOUSR6",24,0)
 N COUNT,LINK,QUE,FROM,TIME,STATUS,TEMP,DIR,TODAY,LIST,HLSCREEN
"RTN","HLOUSR6",25,0)
 S HLRFRSH="OUTQUE^HLOUSR6"
"RTN","HLOUSR6",26,0)
 S HLSCREEN="HLO Outbound Queues"
"RTN","HLOUSR6",27,0)
 S VALM("TITLE")="HLO Outbound Queues"
"RTN","HLOUSR6",28,0)
 S VALMSG="Outgoing Queues *down links !stopped queues"
"RTN","HLOUSR6",29,0)
 ;;; START HL*1.6*147  RBN - Commmented the next line out - prevents list from scrolling.
"RTN","HLOUSR6",30,0)
 ;S VALMCNT=16
"RTN","HLOUSR6",31,0)
 ;;; End HL*1.6*147
"RTN","HLOUSR6",32,0)
 S VALMBG=1
"RTN","HLOUSR6",33,0)
 S VALMDDF("COL 1")="COL1^1^80^"
"RTN","HLOUSR6",34,0)
 K VALMDDF("COL 2"),VALMDDF("COL 3"),VALMDDF("COL 4"),VALMDDF("COL 5")
"RTN","HLOUSR6",35,0)
 Q
"RTN","HLOUSR6",36,0)
 ;
"RTN","HLOUSR6",37,0)
OUTQUE ;
"RTN","HLOUSR6",38,0)
 N LINK,TOP,COUNT,LINE
"RTN","HLOUSR6",39,0)
 F LINE=1:1:16 D SET^VALM10(LINE,"")
"RTN","HLOUSR6",40,0)
 S VALMCNT=0
"RTN","HLOUSR6",41,0)
 S HLRFRSH="OUTQUE^HLOUSR6"
"RTN","HLOUSR6",42,0)
 S VALMAR="^TMP(""HLO OUTBOUND QUEUES"",$J)"
"RTN","HLOUSR6",43,0)
 S VALMBCK="R"
"RTN","HLOUSR6",44,0)
 S VALMDDF("COL 1")="COL 1^2^20^ Link^H"
"RTN","HLOUSR6",45,0)
 ;
"RTN","HLOUSR6",46,0)
 ;**p147 start cjm
"RTN","HLOUSR6",47,0)
 ;S VALMDDF("COL 2")="COL 2^28^20^Queue^H"
"RTN","HLOUSR6",48,0)
 S VALMDDF("COL 2")="COL 2^26^20^Queue/Priority^H"
"RTN","HLOUSR6",49,0)
 ;**P147 END CJM
"RTN","HLOUSR6",50,0)
 ;
"RTN","HLOUSR6",51,0)
 S VALMDDF("COL 3")="COL 3^50^20^Count^H"
"RTN","HLOUSR6",52,0)
 S VALMDDF("COL 4")="COL 4^65^20^Top Message^H"
"RTN","HLOUSR6",53,0)
 K VALMDDF("COL 5")
"RTN","HLOUSR6",54,0)
 D CHGCAP^VALM("COL 1"," Link")
"RTN","HLOUSR6",55,0)
 S LINK=""
"RTN","HLOUSR6",56,0)
 F  S LINK=$O(^HLC("QUEUECOUNT","OUT",LINK)) Q:LINK=""  D
"RTN","HLOUSR6",57,0)
 .N COUNT,QUE,SHOW
"RTN","HLOUSR6",58,0)
 .S SHOW=LINK
"RTN","HLOUSR6",59,0)
 .I $D(^HLTMP("FAILING LINKS",SHOW)) S SHOW="*"_SHOW
"RTN","HLOUSR6",60,0)
 .S (TOP,QUE)=""
"RTN","HLOUSR6",61,0)
 .F  S QUE=$O(^HLC("QUEUECOUNT","OUT",LINK,QUE)) Q:QUE=""  D
"RTN","HLOUSR6",62,0)
 ..S COUNT=$G(^HLC("QUEUECOUNT","OUT",LINK,QUE))
"RTN","HLOUSR6",63,0)
 ..Q:COUNT<1
"RTN","HLOUSR6",64,0)
 ..S VALMCNT=VALMCNT+1
"RTN","HLOUSR6",65,0)
 ..S TOP=$$GETTOP()
"RTN","HLOUSR6",66,0)
 ..I $E(SHOW)="*" D
"RTN","HLOUSR6",67,0)
 ...S @VALMAR@(VALMCNT,0)=$$LJ(SHOW,20)_$$CJ($S($$STOPPED^HLOQUE("OUT",QUE):"!",1:"")_QUE_"/"_$$GETPRTY^HLOQUE(QUE,LINK),21)_"   "_$$RJ(COUNT,10)_$$RJ(TOP,20),SHOW="   "
"RTN","HLOUSR6",68,0)
 ...D CNTRL^VALM10(VALMCNT,1,1,IOBON,IOBOFF)
"RTN","HLOUSR6",69,0)
 ..E  S @VALMAR@(VALMCNT,0)=$$LJ(SHOW,20)_$$CJ($S($$STOPPED^HLOQUE("OUT",QUE):"!",1:"")_QUE_"/"_$$GETPRTY^HLOQUE(QUE,LINK),21)_"   "_$$RJ(COUNT,10)_$$RJ(TOP,20),SHOW="   "
"RTN","HLOUSR6",70,0)
 S VALMBCK="R"
"RTN","HLOUSR6",71,0)
 Q
"RTN","HLOUSR6",72,0)
 ;
"RTN","HLOUSR6",73,0)
CJ(STRING,LEN) ;
"RTN","HLOUSR6",74,0)
 Q $$CJ^XLFSTR($E(STRING,1,LEN),LEN)
"RTN","HLOUSR6",75,0)
LJ(STRING,LEN) ;
"RTN","HLOUSR6",76,0)
 Q $$LJ^XLFSTR($E(STRING,1,LEN),LEN)
"RTN","HLOUSR6",77,0)
RJ(STRING,LEN) ;
"RTN","HLOUSR6",78,0)
 Q $$RJ^XLFSTR($E(STRING,1,LEN),LEN)
"RTN","HLOUSR6",79,0)
 ;
"RTN","HLOUSR6",80,0)
CLEAN ; Clean up before leaving
"RTN","HLOUSR6",81,0)
 K ^TMP("HLO OUTBOUND QUEUES",$J)
"RTN","HLOUSR6",82,0)
 Q
"RTN","HLOUSR6",83,0)
 ;
"RTN","HLOUSR6",84,0)
GETTOP() ; Get top message in queue
"RTN","HLOUSR6",85,0)
 N TOP,QUIT
"RTN","HLOUSR6",86,0)
 S (TOP,QUIT)=0
"RTN","HLOUSR6",87,0)
 F  S TOP=$O(^HLB("QUEUE","OUT",LINK,QUE,TOP)) Q:'TOP  D  Q:QUIT
"RTN","HLOUSR6",88,0)
 .N NODE
"RTN","HLOUSR6",89,0)
 .S NODE=$G(^HLB(TOP,0))
"RTN","HLOUSR6",90,0)
 .I NODE="" K ^HLB("QUEUE","OUT",LINK,QUE,TOP) Q
"RTN","HLOUSR6",91,0)
 .S TOP=$P(NODE,"^",1),QUIT=1
"RTN","HLOUSR6",92,0)
 Q TOP
"RTN","HLOUSR6",93,0)
 ;
"RTN","HLOUSR6",94,0)
DELTOP ; Deletes the top message on a queue
"RTN","HLOUSR6",95,0)
 N CONF,HLOLNAM,HLOQNAM,LOCERR,TOP,LINKNAME,PORT,ERROR
"RTN","HLOUSR6",96,0)
 S VALMBCK="R"
"RTN","HLOUSR6",97,0)
 D OWNSKEY^XUSRB(.CONF,"HLOMGR",DUZ)
"RTN","HLOUSR6",98,0)
 I CONF(0)'=1 D  Q
"RTN","HLOUSR6",99,0)
 . W !,"**** You are not authorized to use this option ****" D PAUSE^VALM1
"RTN","HLOUSR6",100,0)
 ;**P146 START CJM
"RTN","HLOUSR6",101,0)
 ;S LOCERR=$$GETLNK^HLOAPI5()
"RTN","HLOUSR6",102,0)
 ;Q:($G(LOCERR)="Q")
"RTN","HLOUSR6",103,0)
 ;I $G(LOCERR)=-1 W !,"Sorry, that was an invalid link" D PAUSE^VALM1 Q
"RTN","HLOUSR6",104,0)
 S LINKNAME=$$ASKLINK^HLOUSR
"RTN","HLOUSR6",105,0)
 I LINKNAME="" W !,"Sorry, that is are no messages pending on that link." D PAUSE^VALM1 Q
"RTN","HLOUSR6",106,0)
 D
"RTN","HLOUSR6",107,0)
 .N PORT2
"RTN","HLOUSR6",108,0)
 .S ERROR=0
"RTN","HLOUSR6",109,0)
 .S PORT=$O(^HLB("QUEUE","OUT",LINKNAME_":"))
"RTN","HLOUSR6",110,0)
 .I ($P(PORT,":")'=LINKNAME) S PORT="" Q
"RTN","HLOUSR6",111,0)
 .S PORT2=$O(^HLB("QUEUE","OUT",LINKNAME_":"_$P(PORT,":",2)))
"RTN","HLOUSR6",112,0)
 .I ($P(PORT2,":")'=LINKNAME) S PORT=$P(PORT,":",2) Q
"RTN","HLOUSR6",113,0)
 .S PORT=$$ASKPORT^HLOUSRA(LINKNAME)
"RTN","HLOUSR6",114,0)
 .I 'PORT S ERROR=1
"RTN","HLOUSR6",115,0)
 Q:ERROR
"RTN","HLOUSR6",116,0)
 S HLOLNAM=LINKNAME_":"_PORT
"RTN","HLOUSR6",117,0)
 ;S LOCERR=$$GETQUE^HLOAPI5()
"RTN","HLOUSR6",118,0)
 ;I $G(LOCERR)="Q" Q
"RTN","HLOUSR6",119,0)
 ;I $G(LOCERR)=-1 W !,"Sorry, that was an invalid queue" D PAUSE^VALM1 Q
"RTN","HLOUSR6",120,0)
 S HLOQNAM=$$ASKQUE(HLOLNAM)
"RTN","HLOUSR6",121,0)
 Q:HLOQNAM=""
"RTN","HLOUSR6",122,0)
 L +^HLB("QUEUE","OUT",HLOLNAM,HLOQNAM):5 D
"RTN","HLOUSR6",123,0)
 .I '$T W !,"That queue is currently locked, please try again later." D PAUSE^VALM1 Q
"RTN","HLOUSR6",124,0)
 .D
"RTN","HLOUSR6",125,0)
 ..S TOP=$O(^HLB("QUEUE","OUT",HLOLNAM,HLOQNAM,""))
"RTN","HLOUSR6",126,0)
 ..I 'TOP W !,"There are no messages pending on that queue!" D PAUSE^VALM1 Q
"RTN","HLOUSR6",127,0)
 ..Q:'$$ASKYESNO^HLOUSR2("Are you SURE you want to dequeue MsgID: "_$$MSGID^HLOPRS(TOP),"NO")
"RTN","HLOUSR6",128,0)
 ..;Q:$$VERIFY^HLOQUE1()=-1
"RTN","HLOUSR6",129,0)
 ..D DEQUE^HLOQUE(HLOLNAM,HLOQNAM,"OUT",TOP)
"RTN","HLOUSR6",130,0)
 ..D OUTQUE
"RTN","HLOUSR6",131,0)
 ..;
"RTN","HLOUSR6",132,0)
 .L -^HLB("QUEUE","OUT",HLOLNAM,HLOQNAM)
"RTN","HLOUSR6",133,0)
 ;K ^HLB("QUEUE","OUT",HLOLNAM,HLOQNAM,TOP)
"RTN","HLOUSR6",134,0)
 ;S ^HLC("QUEUECOUNT","OUT",HLOLNAM,HLOQNAM)=^HLC("QUEUECOUNT","OUT",HLOLNAM,HLOQNAM)-1
"RTN","HLOUSR6",135,0)
 ;S:^HLC("QUEUECOUNT","OUT",HLOLNAM,HLOQNAM)<0 ^HLC("QUEUECOUNT","OUT",HLOLNAM,HLOQNAM)=0
"RTN","HLOUSR6",136,0)
 ;D OUTQUE
"RTN","HLOUSR6",137,0)
 ;**P146 END CJM
"RTN","HLOUSR6",138,0)
 Q
"RTN","HLOUSR6",139,0)
 ;
"RTN","HLOUSR6",140,0)
 ;
"RTN","HLOUSR6",141,0)
 ;**P146 START CJM
"RTN","HLOUSR6",142,0)
ASKQUE(LINK) ;
"RTN","HLOUSR6",143,0)
 ;Input: LINK=<link>:<port>
"RTN","HLOUSR6",144,0)
 ;Ouput: function returns the queue name, or "" if not selected
"RTN","HLOUSR6",145,0)
 N X,QUE,Y,DUOUT,DEFAULT
"RTN","HLOUSR6",146,0)
 S DIR(0)="F"
"RTN","HLOUSR6",147,0)
 S DIR("A")="Enter queue name "
"RTN","HLOUSR6",148,0)
 S DEFAULT=$O(^HLB("QUEUE","OUT",LINK,""))
"RTN","HLOUSR6",149,0)
 I DEFAULT="" S DEFAULT="DEFAULT"
"RTN","HLOUSR6",150,0)
 S DIR("B")=DEFAULT
"RTN","HLOUSR6",151,0)
 S DIR("?",1)="Enter the queue name as displayed in the HLO System Monitor"
"RTN","HLOUSR6",152,0)
 S DIR("?",2)="                 Outgoing Queue display."
"RTN","HLOUSR6",153,0)
 D ^DIR
"RTN","HLOUSR6",154,0)
 K DIR
"RTN","HLOUSR6",155,0)
 I $G(DUOUT)!(Y="") Q ""
"RTN","HLOUSR6",156,0)
 Q Y
"RTN","HLOUSR6",157,0)
 ;**P146 END CJM
"RTN","HLOUSR7")
0^8^B22703242^n/a
"RTN","HLOUSR7",1,0)
HLOUSR7 ;OIFO-ALB/CJM - Deleting HLO queues ;01/07/2010
"RTN","HLOUSR7",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**138,139,146,147**;Oct 13, 1995;Build 15
"RTN","HLOUSR7",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOUSR7",4,0)
 ;
"RTN","HLOUSR7",5,0)
 ;
"RTN","HLOUSR7",6,0)
SPURGE ; Entry point from ListManager for deleting sequential queues.
"RTN","HLOUSR7",7,0)
 N CONF,LINK,QUE,PORT,WHEN,COUNT,IEN
"RTN","HLOUSR7",8,0)
 S VALMBCK="R"
"RTN","HLOUSR7",9,0)
 D OWNSKEY^XUSRB(.CONF,"HLOMGR",DUZ)
"RTN","HLOUSR7",10,0)
 I CONF(0)'=1 D  Q
"RTN","HLOUSR7",11,0)
 . W !,"**** You are not authorized to use this option ****" D PAUSE^VALM1 Q
"RTN","HLOUSR7",12,0)
 S QUE=$$GETQ^HLOUSR4()
"RTN","HLOUSR7",13,0)
 Q:QUE=""
"RTN","HLOUSR7",14,0)
 I '$D(^HLB("QUEUE","SEQUENCE",QUE)) W !,"There are no messages on that queue!" D PAUSE^VALM1 Q
"RTN","HLOUSR7",15,0)
 W !!,"Deleting a queue in error will result in lost messages!"
"RTN","HLOUSR7",16,0)
 Q:'$$ASKYESNO^HLOUSR2("Are you SURE you want to delete that queue","NO")
"RTN","HLOUSR7",17,0)
 W !!,"After removing the messages from the sequence queue they will deleted"
"RTN","HLOUSR7",18,0)
 W !,"When do you want to schedule the messages to be purged?"
"RTN","HLOUSR7",19,0)
 S WHEN=$$ASKWHEN($$FMADD^XLFDT($$NOW^XLFDT,7),"Date/Time to schedule purge:")
"RTN","HLOUSR7",20,0)
 Q:'WHEN
"RTN","HLOUSR7",21,0)
 S (IEN,COUNT)=0
"RTN","HLOUSR7",22,0)
 F  S IEN=$O(^HLB("QUEUE","SEQUENCE",QUE,IEN)) Q:'IEN  S COUNT=COUNT+1 Q:COUNT>100
"RTN","HLOUSR7",23,0)
 I COUNT>100,$$ASKTASK() D
"RTN","HLOUSR7",24,0)
 .S ZTRTN="SEQPURGE^HLOUSR7"
"RTN","HLOUSR7",25,0)
 .S ZTDESC="HLO QUEUE PURGE"
"RTN","HLOUSR7",26,0)
 .S ZTDTH=$H
"RTN","HLOUSR7",27,0)
 .S ZTIO=""
"RTN","HLOUSR7",28,0)
 .S ZTSAVE("QUE")=QUE,ZTSAVE("WHEN")=""
"RTN","HLOUSR7",29,0)
 .D ^%ZTLOAD
"RTN","HLOUSR7",30,0)
 .I '$G(ZTSK) W !!,?5,"UNABLE TO SCHEDULE PURGE JOB",!
"RTN","HLOUSR7",31,0)
 .I $G(ZTSK) W !!,?5,"Purge job is scheduled, task #"_ZTSK
"RTN","HLOUSR7",32,0)
 .D PAUSE^VALM1
"RTN","HLOUSR7",33,0)
 E  D
"RTN","HLOUSR7",34,0)
 .D SEQPURGE
"RTN","HLOUSR7",35,0)
 .I $L(HLRFRSH) D @HLRFRSH
"RTN","HLOUSR7",36,0)
 Q
"RTN","HLOUSR7",37,0)
 ;
"RTN","HLOUSR7",38,0)
OPURGE ; Entry point from ListManager for deleting outgoing queues.
"RTN","HLOUSR7",39,0)
 N CONF,LINK,QUE,PORT,WHEN,COUNT,IEN
"RTN","HLOUSR7",40,0)
 S VALMBCK="R"
"RTN","HLOUSR7",41,0)
 D OWNSKEY^XUSRB(.CONF,"HLOMGR",DUZ)
"RTN","HLOUSR7",42,0)
 I CONF(0)'=1 D  Q
"RTN","HLOUSR7",43,0)
 . W !,"**** You are not authorized to use this option ****" D PAUSE^VALM1 Q
"RTN","HLOUSR7",44,0)
 S LINK=$$ASKLINK^HLOUSR
"RTN","HLOUSR7",45,0)
 Q:LINK=""
"RTN","HLOUSR7",46,0)
 W !
"RTN","HLOUSR7",47,0)
 S PORT=$$ASKPORT^HLOTRACE(LINK)
"RTN","HLOUSR7",48,0)
 I 'PORT W !,"There are no outgoing messages for that destination!" Q
"RTN","HLOUSR7",49,0)
 S LINK=LINK_":"_PORT
"RTN","HLOUSR7",50,0)
 W !
"RTN","HLOUSR7",51,0)
 S QUE=$$ASKQUE^HLOTRACE(LINK)
"RTN","HLOUSR7",52,0)
 I QUE=""  W !,"There are no outgoing messages for that destination!" Q
"RTN","HLOUSR7",53,0)
 W !!,"Deleting a queue in error will result in lost messages!"
"RTN","HLOUSR7",54,0)
 Q:'$$ASKYESNO^HLOUSR2("Are you SURE you want to delete that queue","NO")
"RTN","HLOUSR7",55,0)
 W !!,"After removing the messages from the outgoing queue they will deleted"
"RTN","HLOUSR7",56,0)
 W !,"When do you want to schedule the messages to be purged?"
"RTN","HLOUSR7",57,0)
 S WHEN=$$ASKWHEN($$FMADD^XLFDT($$NOW^XLFDT,7),"Date/Time to schedule purge:")
"RTN","HLOUSR7",58,0)
 Q:'WHEN
"RTN","HLOUSR7",59,0)
 S (IEN,COUNT)=0
"RTN","HLOUSR7",60,0)
 F  S IEN=$O(^HLB("QUEUE","OUT",LINK,QUE,IEN)) Q:'IEN  S COUNT=COUNT+1 Q:COUNT>100
"RTN","HLOUSR7",61,0)
 I COUNT>100,$$ASKTASK() D
"RTN","HLOUSR7",62,0)
 .S ZTRTN="OUTPURGE^HLOUSR7"
"RTN","HLOUSR7",63,0)
 .S ZTDESC="HLO QUEUE PURGE"
"RTN","HLOUSR7",64,0)
 .S ZTDTH=$H
"RTN","HLOUSR7",65,0)
 .S ZTIO=""
"RTN","HLOUSR7",66,0)
 .S ZTSAVE("LINK")="",ZTSAVE("QUE")=QUE,ZTSAVE("WHEN")=""
"RTN","HLOUSR7",67,0)
 .D ^%ZTLOAD
"RTN","HLOUSR7",68,0)
 .I '$G(ZTSK) W !!,?5,"UNABLE TO SCHEDULE PURGE JOB",!
"RTN","HLOUSR7",69,0)
 .I $G(ZTSK) W !!,?5,"Purge job is scheduled, task #"_ZTSK
"RTN","HLOUSR7",70,0)
 .D PAUSE^VALM1
"RTN","HLOUSR7",71,0)
 E  D
"RTN","HLOUSR7",72,0)
 .D OUTPURGE
"RTN","HLOUSR7",73,0)
 .D OUTQUE^HLOUSR6
"RTN","HLOUSR7",74,0)
 Q
"RTN","HLOUSR7",75,0)
 ;
"RTN","HLOUSR7",76,0)
ASKTASK() ;
"RTN","HLOUSR7",77,0)
 W !!,"There are a lot of messages pending on that queue!"
"RTN","HLOUSR7",78,0)
 Q $$ASKYESNO^HLOUSR2("Would you like to delete the queue in the background via a separate task","YES")
"RTN","HLOUSR7",79,0)
 ;
"RTN","HLOUSR7",80,0)
  ;
"RTN","HLOUSR7",81,0)
ASKWHEN(DEFAULT,PROMPT)       ;
"RTN","HLOUSR7",82,0)
 ;Description: Asks the user to enter a dt/tm.
"RTN","HLOUSR7",83,0)
 ;Input: DEFAULT - the suggested default dt/time (optional, defaults to NOW)
"RTN","HLOUSR7",84,0)
 ;PROMPT - optional prompt
"RTN","HLOUSR7",85,0)
 ;Output: Returns the date as the function value, or 0 if the user does not select a date
"RTN","HLOUSR7",86,0)
 ;
"RTN","HLOUSR7",87,0)
 ;
"RTN","HLOUSR7",88,0)
 N %DT
"RTN","HLOUSR7",89,0)
 S %DT="AEST"
"RTN","HLOUSR7",90,0)
 S:$L($G(PROMPT)) %DT("A")=PROMPT
"RTN","HLOUSR7",91,0)
 S %DT("B")=$$FMTE^XLFDT($S($L($G(DEFAULT)):DEFAULT,1:"NOW"))
"RTN","HLOUSR7",92,0)
 S %DT(0)="NOW"
"RTN","HLOUSR7",93,0)
 Q:$D(DTOUT) 0
"RTN","HLOUSR7",94,0)
 D ^%DT
"RTN","HLOUSR7",95,0)
 I Y=-1 Q 0
"RTN","HLOUSR7",96,0)
 Q Y
"RTN","HLOUSR7",97,0)
OUTPURGE ;Purge outgoing queue
"RTN","HLOUSR7",98,0)
 N MSG,CNT
"RTN","HLOUSR7",99,0)
 N MSG
"RTN","HLOUSR7",100,0)
 S (CNT,MSG)=0
"RTN","HLOUSR7",101,0)
 I '$D(ZTQUEUED) W !,"Removing messages....",!
"RTN","HLOUSR7",102,0)
 F  S MSG=$O(^HLB("QUEUE","OUT",LINK,QUE,MSG)) Q:'MSG  D
"RTN","HLOUSR7",103,0)
 .S CNT=CNT+1
"RTN","HLOUSR7",104,0)
 .I '(CNT#100),'$D(ZTQUEUED) W "."
"RTN","HLOUSR7",105,0)
 .I '(CNT#70000),'$D(ZTQUEUED) W "!"
"RTN","HLOUSR7",106,0)
 .D DEQUE^HLOQUE(LINK,QUE,"OUT",MSG)
"RTN","HLOUSR7",107,0)
 .I $$SETPURGE^HLOAPI3(MSG,WHEN) S $P(^HLB(MSG,0),"^",21)="MESSAGE GENERATED IN ERROR AND NOT TRANSMITTED"
"RTN","HLOUSR7",108,0)
 Q
"RTN","HLOUSR7",109,0)
 ;
"RTN","HLOUSR7",110,0)
SEQPURGE ;Purge sequence queue
"RTN","HLOUSR7",111,0)
 N MSG,CNT
"RTN","HLOUSR7",112,0)
 S (CNT,MSG)=0
"RTN","HLOUSR7",113,0)
 I '$D(ZTQUEUED) W !,"Removing messages....",!
"RTN","HLOUSR7",114,0)
 F  S MSG=$O(^HLB("QUEUE","SEQUENCE",QUE,MSG)) Q:'MSG  D
"RTN","HLOUSR7",115,0)
 .S CNT=CNT+1
"RTN","HLOUSR7",116,0)
 .I '(CNT#100),'$D(ZTQUEUED) W "."
"RTN","HLOUSR7",117,0)
 .I '(CNT#70000),'$D(ZTQUEUED) W "!"
"RTN","HLOUSR7",118,0)
 .K ^HLB("QUEUE","SEQUENCE",QUE,MSG)
"RTN","HLOUSR7",119,0)
 .I $$SETPURGE^HLOAPI3(MSG,WHEN) S $P(^HLB(MSG,0),"^",21)="MESSAGE GENERATED IN ERROR AND NOT TRANSMITTED"
"RTN","HLOUSR7",120,0)
 I $$INC^HLOSITE($NA(^HLC("QUEUECOUNT","SEQUENCE")),-$G(^HLC("QUEUECOUNT","SEQUENCE",QUE)))
"RTN","HLOUSR7",121,0)
 S ^HLC("QUEUECOUNT","SEQUENCE",QUE)=0
"RTN","HLOUSR7",122,0)
 S ^HLB("QUEUE","SEQUENCE",QUE)=""
"RTN","HLOUSR7",123,0)
 Q
"SEC","^DIC",779.11,779.11,0,"AUDIT")
@
"SEC","^DIC",779.11,779.11,0,"DD")
@
"SEC","^DIC",779.11,779.11,0,"DEL")
@
"SEC","^DIC",779.11,779.11,0,"LAYGO")
@
"SEC","^DIC",779.11,779.11,0,"RD")
@
"SEC","^DIC",779.11,779.11,0,"WR")
@
"VER")
8.0^22.0
"^DD",779.1,779.1,0)
FIELD^^.13^13
"^DD",779.1,779.1,0,"DDA")
N
"^DD",779.1,779.1,0,"DT")
3100324
"^DD",779.1,779.1,0,"IX","B",779.1,.01)

"^DD",779.1,779.1,0,"NM","HLO SYSTEM PARAMETERS")

"^DD",779.1,779.1,0,"VRPK")
HL
"^DD",779.1,779.1,.01,0)
DOMAIN NAME^RF^^0;1^K:$L(X)>64!($L(X)<3)!'(X'?1P.E) X
"^DD",779.1,779.1,.01,1,0)
^.1
"^DD",779.1,779.1,.01,1,1,0)
779.1^B
"^DD",779.1,779.1,.01,1,1,1)
S ^HLD(779.1,"B",$E(X,1,60),DA)=""
"^DD",779.1,779.1,.01,1,1,2)
K ^HLD(779.1,"B",$E(X,1,60),DA)
"^DD",779.1,779.1,.01,3)
The domain name for this system.  It will be used to populate component 2 of the Sending Facility field of the HL7 message header.
"^DD",779.1,779.1,.01,21,0)
^^2^2^3040805^
"^DD",779.1,779.1,.01,21,1,0)
The domain name for this system.  It will be used to populate component 2
"^DD",779.1,779.1,.01,21,2,0)
of the Sending Facility field of the HL7 message headers.
"^DD",779.1,779.1,.01,"DT")
3040805
"^DD",779.1,779.1,.02,0)
STATION NUMBER^F^^0;2^K:$L(X)>7!($L(X)<3) X
"^DD",779.1,779.1,.02,3)
Enter the station number with suffix that this system belongs under.  It will be used in component 1 of the Sending Facility field of the HL7 message header.
"^DD",779.1,779.1,.02,"DT")
3040805
"^DD",779.1,779.1,.03,0)
PRODUCTION ID^RS^P:production;T:training;^0;3^Q
"^DD",779.1,779.1,.03,3)
ENTER P if this is a production system, T otherwise.
"^DD",779.1,779.1,.03,"DT")
3040805
"^DD",779.1,779.1,.04,0)
MAXIMUM STRING LENGTH^NJ5,0^^0;4^K:+X'=X!(X>99999)!(X<1)!(X?.E1"."1N.N) X
"^DD",779.1,779.1,.04,3)
This is the maximum length for strings built by HLO when local applications create new messages to send.
"^DD",779.1,779.1,.04,21,0)
^^4^4^3050706^
"^DD",779.1,779.1,.04,21,1,0)
This parameter determines the maximum length for strings that HLO will create
"^DD",779.1,779.1,.04,21,2,0)
when messages are being built.  It doesn't apply to servers, as the size of
"^DD",779.1,779.1,.04,21,3,0)
input buffer used by TCP/IP determines the maximum string length created by a
"^DD",779.1,779.1,.04,21,4,0)
single read.
"^DD",779.1,779.1,.04,"DT")
3050706
"^DD",779.1,779.1,.05,0)
BUFFER SIZE FOR HL7 (BYTES)^NJ5,0^^0;5^K:+X'=X!(X>20000)!(X<10000)!(X?.E1"."1.N) X
"^DD",779.1,779.1,.05,3)
This parameter represents the size of the buffer used by HLO for its background processes.  It defaults to 15000 bytes, but may be set from 10,000 bytes to 20,000 bytes.
"^DD",779.1,779.1,.05,"DT")
3050805
"^DD",779.1,779.1,.06,0)
BUFFER SIZE FOR USER (BYTES)^NJ5,0^^0;6^K:+X'=X!(X>10000)!(X<512)!(X?.E1"."1.N) X
"^DD",779.1,779.1,.06,3)
This parameter is the size of the buffer used by HLO in the context of an online user.  It defaults to 5000, but may be reset to between 512 and 10000 bytes.
"^DD",779.1,779.1,.06,"DT")
3050805
"^DD",779.1,779.1,.07,0)
NORMAL MSG RETENTION (HOURS)^NJ2,0^^0;7^K:+X'=X!(X>96)!(X<36)!(X?.E1"."1.N) X
"^DD",779.1,779.1,.07,3)
How many hours should successfully completed messages remain on your system? (36-96 hours, defaults to 36 hours) 
"^DD",779.1,779.1,.07,21,0)
^^7^7^3050317^^^
"^DD",779.1,779.1,.07,21,1,0)
This field controls the purging of HL7 messages whose completion status
"^DD",779.1,779.1,.07,21,2,0)
is SUCCESSFUL. It is in hours, since messages normally should be purged 
"^DD",779.1,779.1,.07,21,3,0)
very soon after completion, with an allowed range of 36 to 94 hours.
"^DD",779.1,779.1,.07,21,4,0)
 
"^DD",779.1,779.1,.07,21,5,0)
36 is the default because this 1) will result in most messages being purged
"^DD",779.1,779.1,.07,21,6,0)
at night and 2) provides sufficient time for the Capacity Planning statistics
"^DD",779.1,779.1,.07,21,7,0)
to be extracted. 
"^DD",779.1,779.1,.07,"DT")
3050317
"^DD",779.1,779.1,.08,0)
BAD MESSAGE RETENTION (DAYS)^NJ2,0^^0;8^K:+X'=X!(X>45)!(X<5)!(X?.E1"."1.N) X
"^DD",779.1,779.1,.08,3)
How many days should message with errors remain on your system?  (7-45 days, defaults to 7 days)
"^DD",779.1,779.1,.08,21,0)
^^4^4^3041115^
"^DD",779.1,779.1,.08,21,1,0)
This field controls the purging of HL7 messages that do not complete
"^DD",779.1,779.1,.08,21,2,0)
successfully.  The period should be reasonably long to allow
"^DD",779.1,779.1,.08,21,3,0)
investigation, but because of the extremely high daily volume of
"^DD",779.1,779.1,.08,21,4,0)
messages purging must occur quickly.
"^DD",779.1,779.1,.08,"DT")
3041115
"^DD",779.1,779.1,.09,0)
HLO ON/OFF SWITCH^S^0:OFF;1:ON;^0;9^Q
"^DD",779.1,779.1,.09,3)
Set to 0 to turn off messaging and all HL7 processes.
"^DD",779.1,779.1,.09,"DT")
3050503
"^DD",779.1,779.1,.1,0)
HLO STANDARD LISTENER^*P870'^HLCS(870,^0;10^S DIC("S")="I ($P($G(^HLCS(870,Y,400)),""^"",3)=""M"")!($P($G(^HLCS(870,Y,400)),""^"",3)=""S"")" D ^DIC K DIC S DIC=$G(DIE),X=+Y K:Y<0 X
"^DD",779.1,779.1,.1,3)
Select an entry from the HL Logical Link file that is the listener that remote applications will normally connect to.
"^DD",779.1,779.1,.1,12)
This screen allows only server entries to be selected.
"^DD",779.1,779.1,.1,12.1)
S DIC("S")="I ($P($G(^HLCS(870,Y,400)),""^"",3)=""M"")!($P($G(^HLCS(870,Y,400)),""^"",3)=""S"")"
"^DD",779.1,779.1,.1,"DT")
3050601
"^DD",779.1,779.1,.11,0)
HLO RECOUNT ON/OFF FLAG^S^0:OFF;1:ON;^0;11^Q
"^DD",779.1,779.1,.11,3)
Set to 1 to disallow update of queues when a recount is being performed.
"^DD",779.1,779.1,.11,"DT")
3071025
"^DD",779.1,779.1,.12,0)
UNSENT MSG RETENTION (DAYS)^NJ3,0^^0;12^K:+X'=X!(X>999)!(X<1)!(X?.E1"."1.N) X
"^DD",779.1,779.1,.12,3)
How many days should an unsent message be kept before it is purged? (default value is 45 days)
"^DD",779.1,779.1,.12,"DT")
3080723
"^DD",779.1,779.1,.13,0)
BOX-VOLUME PAIR^P14.7'^%ZIS(14.7,^0;13^Q
"^DD",779.1,779.1,.13,3)
Enter the BOX-VOLUME pair that HLO processes should run on.
"^DD",779.1,779.1,.13,21,0)
^^13^13^3100324^
"^DD",779.1,779.1,.13,21,1,0)
The BOX-VOLUME PAIR parameter allows a site to specify which CPU and volume
"^DD",779.1,779.1,.13,21,2,0)
set the HLO processes should run on.  This parameter only controls procesess
"^DD",779.1,779.1,.13,21,3,0)
started by the HLO Process Manager by calling the Taskmanager APIs.
"^DD",779.1,779.1,.13,21,4,0)

"^DD",779.1,779.1,.13,21,5,0)
This parameter is optional.
"^DD",779.1,779.1,.13,21,6,0)

"^DD",779.1,779.1,.13,21,7,0)
For VMS sites, this parameter generally does NOT control what node to run
"^DD",779.1,779.1,.13,21,8,0)
the listener on, because VMS sites should use VMS TCPIP Services for their
"^DD",779.1,779.1,.13,21,9,0)
listener.
"^DD",779.1,779.1,.13,21,10,0)

"^DD",779.1,779.1,.13,21,11,0)
For Cache/NT sites using a load balancer, this parameter can be used to
"^DD",779.1,779.1,.13,21,12,0)
specify what node to run the listener on. 
"^DD",779.1,779.1,.13,21,13,0)

"^DD",779.1,779.1,.13,"DT")
3100324
"^DD",779.11,779.11,0)
FIELD^^1^6
"^DD",779.11,779.11,0,"DDA")
N
"^DD",779.11,779.11,0,"DT")
3100727
"^DD",779.11,779.11,0,"IX","B",779.11,.01)

"^DD",779.11,779.11,0,"NM","HLO ERROR SCREENS")

"^DD",779.11,779.11,.01,0)
SCREEN NAME^RF^^0;1^K:$L(X)>30!(X?.N)!($L(X)<3)!'(X'?1P.E) X
"^DD",779.11,779.11,.01,1,0)
^.1
"^DD",779.11,779.11,.01,1,1,0)
779.11^B
"^DD",779.11,779.11,.01,1,1,1)
S ^HLD(779.11,"B",$E(X,1,30),DA)=""
"^DD",779.11,779.11,.01,1,1,2)
K ^HLD(779.11,"B",$E(X,1,30),DA)
"^DD",779.11,779.11,.01,3)
The name should be 3-30 characters, namespaced and descriptive.
"^DD",779.11,779.11,.01,21,0)
^^3^3^3100129^
"^DD",779.11,779.11,.01,21,1,0)
This is the name to identify the screen. It should be namespaced and
"^DD",779.11,779.11,.01,21,2,0)
descriptive.
"^DD",779.11,779.11,.01,21,3,0)

"^DD",779.11,779.11,.01,"DT")
3100129
"^DD",779.11,779.11,1,0)
DESCRIPTION^779.111^^2;0
"^DD",779.11,779.11,1,21,0)
^^3^3^3100129^
"^DD",779.11,779.11,1,21,1,0)
This should contain a full description of how this screen should be used, i.e.,
"^DD",779.11,779.11,1,21,2,0)
its purpose.
"^DD",779.11,779.11,1,21,3,0)

"^DD",779.11,779.11,1,23,0)
^^1^1^3100129^
"^DD",779.11,779.11,1,23,1,0)

"^DD",779.11,779.11,2,0)
CREATOR^RP200'^VA(200,^0;3^Q
"^DD",779.11,779.11,2,3)
Enter the name of person creating this screen.
"^DD",779.11,779.11,2,21,0)
^^2^2^3100129^^^
"^DD",779.11,779.11,2,21,1,0)
This is the person who created the screen.
"^DD",779.11,779.11,2,21,2,0)

"^DD",779.11,779.11,2,"DT")
3100129
"^DD",779.11,779.11,3,0)
DATE/TIME CREATED^RD^^0;4^S %DT="ETXR" D ^%DT S X=Y K:Y<1 X
"^DD",779.11,779.11,3,3)
Enter the date and time the screen was created.
"^DD",779.11,779.11,3,21,0)
^^5^5^3100129^^^
"^DD",779.11,779.11,3,21,1,0)
This field contains the date/time the screen was created.
"^DD",779.11,779.11,3,21,2,0)

"^DD",779.11,779.11,3,21,3,0)

"^DD",779.11,779.11,3,21,4,0)

"^DD",779.11,779.11,3,21,5,0)

"^DD",779.11,779.11,3,"DT")
3100129
"^DD",779.11,779.11,4,0)
TYPE OF SCREEN^RS^0:EXCLUDE;1:INCLUDE;^0;5^Q
"^DD",779.11,779.11,4,3)
Enter 'EXCLUDE' to exclude specific errors from the display, or 'INCLUDE' to include only specific errors from the display.
"^DD",779.11,779.11,4,4)
D HELP^HLOUSR2
"^DD",779.11,779.11,4,21,0)
^^7^7^3090824^
"^DD",779.11,779.11,4,21,1,0)
This field is used to determine the type of error screen
"^DD",779.11,779.11,4,21,2,0)
to be applied to the error list.  There are two types:
"^DD",779.11,779.11,4,21,3,0)

"^DD",779.11,779.11,4,21,4,0)
EXCLUDE (0) - excludes the error messages from being displayed
"^DD",779.11,779.11,4,21,5,0)
INCLUDE (1) - includes the error messages on the display.
"^DD",779.11,779.11,4,21,6,0)
 
"^DD",779.11,779.11,4,21,7,0)

"^DD",779.11,779.11,4,"DT")
3100727
"^DD",779.11,779.11,5,0)
ERRORS^779.115^^1;0
"^DD",779.11,779.11,5,21,0)
^^19^19^3100129^^^
"^DD",779.11,779.11,5,21,1,0)
This is a list of strings used to determine what errors should display.
"^DD",779.11,779.11,5,21,2,0)
Each string is compared to each error that would otherwise be included
"^DD",779.11,779.11,5,21,3,0)
in the display.  If the string matches a string that occurs within the
"^DD",779.11,779.11,5,21,4,0)
error, the error is either:
"^DD",779.11,779.11,5,21,5,0)

"^DD",779.11,779.11,5,21,6,0)
INCLUDE type screens - the error will be included in the display.
"^DD",779.11,779.11,5,21,7,0)
EXCLUDE type screens - the error will be excluded from the display.
"^DD",779.11,779.11,5,21,8,0)

"^DD",779.11,779.11,5,21,9,0)
This is the verbatim text of the error to be screened. A list of possible
"^DD",779.11,779.11,5,21,10,0)
errors is in the HLO Technical Manual. Alternately, you may cut and paste text
"^DD",779.11,779.11,5,21,11,0)
from the error display into this field. You might screen errors for the
"^DD",779.11,779.11,5,21,12,0)
following purposes:
"^DD",779.11,779.11,5,21,13,0)
1)  To exclude certain errors from the display.  Some of the errors don't
"^DD",779.11,779.11,5,21,14,0)
require any action on your part.
"^DD",779.11,779.11,5,21,15,0)
2)  To display only certain errors.   These are critical errors which you want
"^DD",779.11,779.11,5,21,16,0)
to act on quickly.  You KNOW from experience what those errors are. 
"^DD",779.11,779.11,5,21,17,0)

"^DD",779.11,779.11,5,21,18,0)

"^DD",779.11,779.11,5,21,19,0)

"^DD",779.11,779.11,5,23,0)
^^3^3^3100129^^^
"^DD",779.11,779.11,5,23,1,0)

"^DD",779.11,779.11,5,23,2,0)

"^DD",779.11,779.11,5,23,3,0)

"^DD",779.11,779.111,0)
DESCRIPTION SUB-FIELD^^.01^1
"^DD",779.11,779.111,0,"DT")
3100129
"^DD",779.11,779.111,0,"NM","DESCRIPTION")

"^DD",779.11,779.111,0,"UP")
779.11
"^DD",779.11,779.111,.01,0)
DESCRIPTION^Wx^^0;1
"^DD",779.11,779.111,.01,3)
Enter a full explanation for the purpose of this screen.
"^DD",779.11,779.111,.01,"DT")
3100129
"^DD",779.11,779.115,0)
ERRORS SUB-FIELD^^.02^2
"^DD",779.11,779.115,0,"DT")
3100727
"^DD",779.11,779.115,0,"IX","B",779.115,.01)

"^DD",779.11,779.115,0,"NM","ERRORS")

"^DD",779.11,779.115,0,"UP")
779.11
"^DD",779.11,779.115,.01,0)
ERRORS^MF^^0;1^K:$L(X)>200!($L(X)<1) X
"^DD",779.11,779.115,.01,1,0)
^.1
"^DD",779.11,779.115,.01,1,1,0)
779.115^B
"^DD",779.11,779.115,.01,1,1,1)
S ^HLD(779.11,DA(1),1,"B",$E(X,1,30),DA)=""
"^DD",779.11,779.115,.01,1,1,2)
K ^HLD(779.11,DA(1),1,"B",$E(X,1,30),DA)
"^DD",779.11,779.115,.01,3)
Answer must be 1-200 characters in length.
"^DD",779.11,779.115,.01,4)

"^DD",779.11,779.115,.01,"DT")
3100727
"^DD",779.11,779.115,.02,0)
PARTIAL MATCH OK?^S^0:NO;1:YES;^0;2^Q
"^DD",779.11,779.115,.02,3)
If the actual error message contains the text that you entered, should it be considered a match even if there are additional characters in the actual error message?
"^DD",779.11,779.115,.02,"DT")
3100727
"^DD",779.3,779.3,0)
FIELD^^.16^16
"^DD",779.3,779.3,0,"DDA")
N
"^DD",779.3,779.3,0,"DT")
3100324
"^DD",779.3,779.3,0,"IX","B",779.3,.01)

"^DD",779.3,779.3,0,"IX","C",779.3,.02)

"^DD",779.3,779.3,0,"NM","HLO PROCESS REGISTRY")

"^DD",779.3,779.3,0,"VRPK")
HL
"^DD",779.3,779.3,.01,0)
PROCESS NAME^RF^^0;1^K:$L(X)>30!(X?.N)!($L(X)<3)!'(X'?1P.E) X
"^DD",779.3,779.3,.01,1,0)
^.1
"^DD",779.3,779.3,.01,1,1,0)
779.3^B
"^DD",779.3,779.3,.01,1,1,1)
S ^HLD(779.3,"B",$E(X,1,30),DA)=""
"^DD",779.3,779.3,.01,1,1,2)
K ^HLD(779.3,"B",$E(X,1,30),DA)
"^DD",779.3,779.3,.01,3)
Give the type of process a unique name, 3-30 characters.
"^DD",779.3,779.3,.01,21,0)
^^1^1^3041115^
"^DD",779.3,779.3,.01,21,1,0)
A unique name for the type of process.
"^DD",779.3,779.3,.01,"DT")
3041115
"^DD",779.3,779.3,.02,0)
ACTIVE^S^0:NO;1:YES;^0;2^Q
"^DD",779.3,779.3,.02,1,0)
^.1
"^DD",779.3,779.3,.02,1,1,0)
779.3^C
"^DD",779.3,779.3,.02,1,1,1)
S ^HLD(779.3,"C",$E(X,1,30),DA)=""
"^DD",779.3,779.3,.02,1,1,2)
K ^HLD(779.3,"C",$E(X,1,30),DA)
"^DD",779.3,779.3,.02,1,1,"%D",0)
^^2^2^3081106^
"^DD",779.3,779.3,.02,1,1,"%D",1,0)
Used to find active process types.
"^DD",779.3,779.3,.02,1,1,"%D",2,0)

"^DD",779.3,779.3,.02,1,1,"DT")
3081106
"^DD",779.3,779.3,.02,3)
Enter 1 to activate these processes, 0 to inactivate.
"^DD",779.3,779.3,.02,21,0)
^^4^4^3050805^^^^
"^DD",779.3,779.3,.02,21,1,0)
A flag that indicates whether or not this type of process is active under 
"^DD",779.3,779.3,.02,21,2,0)
the HLO Process Manager. Some processes may not apply to some 
"^DD",779.3,779.3,.02,21,3,0)
systems, for example, a particular site may not use the Taskman 
"^DD",779.3,779.3,.02,21,4,0)
multi-listener. 
"^DD",779.3,779.3,.02,"DT")
3081106
"^DD",779.3,779.3,.03,0)
MINIMUM ACTIVE PROCESSES^NJ2,0^^0;3^K:+X'=X!(X>99)!(X<0)!(X?.E1"."1.N) X
"^DD",779.3,779.3,.03,3)
How many of these processes should be running at a minimum when HL7 messaging is on?
"^DD",779.3,779.3,.03,21,0)
^^3^3^3050805^^^
"^DD",779.3,779.3,.03,21,1,0)
This field indicates the minimum number of concurrent processes of this 
"^DD",779.3,779.3,.03,21,2,0)
type.  The exact number changes as the HLO Process Manager starts and 
"^DD",779.3,779.3,.03,21,3,0)
stops processes in response to changes in workload.
"^DD",779.3,779.3,.03,"DT")
3050805
"^DD",779.3,779.3,.04,0)
MAXIMUM ACTIVE PROCESSES^NJ3,0^^0;4^K:+X'=X!(X>999)!(X<1)!(X?.E1"."1.N) X
"^DD",779.3,779.3,.04,3)
How many of these processes should be running at a maximum when the HL7 messaging system is on?
"^DD",779.3,779.3,.04,"DT")
3040907
"^DD",779.3,779.3,.05,0)
SCHEDULING FREQUENCY (minutes)^NJ4,0^^0;5^K:+X'=X!(X>9999)!(X<0)!(X?.E1"."1N.N) X
"^DD",779.3,779.3,.05,3)
This is how long the Process Manager should wait between checks to see if another process of this type should be started.  Enter 0 to 9999.
"^DD",779.3,779.3,.05,21,0)
^.001^2^2^3041221^^
"^DD",779.3,779.3,.05,21,1,0)
This is how long the Process Manager should wait between checks to see if 
"^DD",779.3,779.3,.05,21,2,0)
another process of this type should be started.
"^DD",779.3,779.3,.05,"DT")
3050919
"^DD",779.3,779.3,.06,0)
DT/TM LAST STARTED OR STOPPED^D^^0;6^S %DT="ESTR" D ^%DT S X=Y K:Y<1 X
"^DD",779.3,779.3,.06,3)
DT/TM the process manager last started or stopped one of these.
"^DD",779.3,779.3,.06,21,0)
^^2^2^3041115^
"^DD",779.3,779.3,.06,21,1,0)
The date and time when a process of this type was last started or 
"^DD",779.3,779.3,.06,21,2,0)
stopped.
"^DD",779.3,779.3,.06,"DT")
3041115
"^DD",779.3,779.3,.07,0)
HANG TIME (seconds)^NJ3,0^^0;7^K:+X'=X!(X>999)!(X<0)!(X?.E1"."1.N) X
"^DD",779.3,779.3,.07,3)
If the process cannot find work, how many seconds should it hang before looking again?
"^DD",779.3,779.3,.07,21,0)
^^2^2^3041115^
"^DD",779.3,779.3,.07,21,1,0)
This is how long a process should wait between attempts to find work to 
"^DD",779.3,779.3,.07,21,2,0)
do.
"^DD",779.3,779.3,.07,"DT")
3041115
"^DD",779.3,779.3,.08,0)
GET WORK FUNCTION (TAG)^RF^^0;8^K:$L(X)>8!($L(X)<1) X
"^DD",779.3,779.3,.08,3)
What function will this process call to find work (optional routine entry point)
"^DD",779.3,779.3,.08,21,0)
^^1^1^3041115^
"^DD",779.3,779.3,.08,21,1,0)
The M entry point to the GET WORK function for this process type.
"^DD",779.3,779.3,.08,"DT")
3041115
"^DD",779.3,779.3,.09,0)
GET WORK FUNCTION (ROUTINE)^RF^^0;9^K:$L(X)>8!($L(X)<1) X
"^DD",779.3,779.3,.09,3)
What function should this process call to find work? (routine name only)
"^DD",779.3,779.3,.09,21,0)
^^1^1^3041115^
"^DD",779.3,779.3,.09,21,1,0)
The routine in which this process type has located its GET WORK function.
"^DD",779.3,779.3,.09,"DT")
3041115
"^DD",779.3,779.3,.1,0)
DO WORK FUNCTION (TAG)^F^^0;10^K:$L(X)>8!($L(X)<1) X
"^DD",779.3,779.3,.1,3)
What function should this process call to do its work? Enter the optional entry point only in this field.
"^DD",779.3,779.3,.1,21,0)
^^1^1^3041115^
"^DD",779.3,779.3,.1,21,1,0)
The M entry point for the process's DO WORK function.
"^DD",779.3,779.3,.1,"DT")
3041115
"^DD",779.3,779.3,.11,0)
DO WORK FUNCTION (ROUTINE)^F^^0;11^K:$L(X)>8!($L(X)<1) X
"^DD",779.3,779.3,.11,3)
What function should this process call to do its work?  Enter the routine name only in this field.
"^DD",779.3,779.3,.11,21,0)
^^1^1^3041115^
"^DD",779.3,779.3,.11,21,1,0)
The routine in which the process's DO WORK function is located.
"^DD",779.3,779.3,.11,"DT")
3041115
"^DD",779.3,779.3,.12,0)
MAX TRIES FINDING WORK^NJ4,0^^0;12^K:+X'=X!(X>9999)!(X<0)!(X?.E1"."1.N) X
"^DD",779.3,779.3,.12,3)
How many times should the process look for work before giving up?
"^DD",779.3,779.3,.12,21,0)
^^3^3^3041115^
"^DD",779.3,779.3,.12,21,1,0)
How many times should the process look for work and then quit if it 
"^DD",779.3,779.3,.12,21,2,0)
cannot find anything to do?  It'll hang between attempts the specified 
"^DD",779.3,779.3,.12,21,3,0)
length of time.
"^DD",779.3,779.3,.12,"DT")
3041115
"^DD",779.3,779.3,.13,0)
PERSISTENT^S^0:NO;1:YES;^0;13^Q
"^DD",779.3,779.3,.13,3)
Should processes of this type be restarted automatically if they die?
"^DD",779.3,779.3,.13,21,0)
^^2^2^3041115^
"^DD",779.3,779.3,.13,21,1,0)
Setting this field to YES results in the process being made persistent 
"^DD",779.3,779.3,.13,21,2,0)
via the Taskman persistent parameter.
"^DD",779.3,779.3,.13,"DT")
3041115
"^DD",779.3,779.3,.14,0)
DEDICATED LINK^FX^^0;14^K:$L(X)>10!($L(X)<3) X
"^DD",779.3,779.3,.14,3)
If this process is a listener, you must enter the name of an HL LOGICAL LINK that is a listener and whose TCP/IP PORT (OPTIMIZED) field contains the correct port number.
"^DD",779.3,779.3,.14,4)

"^DD",779.3,779.3,.14,21,0)
^^4^4^3041115^
"^DD",779.3,779.3,.14,21,1,0)
The primary use of this field is for TCP/IP listener processes, and 
"^DD",779.3,779.3,.14,21,2,0)
indicates which port (via the HL Logical Link) that the process should be 
"^DD",779.3,779.3,.14,21,3,0)
listening on.  However, it could be used to dedicate a client link 
"^DD",779.3,779.3,.14,21,4,0)
process to a particular link.
"^DD",779.3,779.3,.14,"DT")
3050706
"^DD",779.3,779.3,.15,0)
VMS TCP SERVICE^S^1:YES;0:NO;^0;15^Q
"^DD",779.3,779.3,.15,3)
If this process is a listener, enter YES if it is a VMS TCP service rather than a Taskman process.
"^DD",779.3,779.3,.15,21,0)
^^5^5^3040923^
"^DD",779.3,779.3,.15,21,1,0)
VMS services are not started or stopped via the HL7 Process Manager.  
"^DD",779.3,779.3,.15,21,2,0)
However, on a VMS system, these services are an important part of the HL7
"^DD",779.3,779.3,.15,21,3,0)
system, and so an entry in the HL7 Process Registry should be created for 
"^DD",779.3,779.3,.15,21,4,0)
them.  The Process Manager will use the PING functionality to verify that 
"^DD",779.3,779.3,.15,21,5,0)
the listener is running.
"^DD",779.3,779.3,.15,"DT")
3040923
"^DD",779.3,779.3,.16,0)
BOX-VOLUME PAIR^P14.7'^%ZIS(14.7,^0;16^Q
"^DD",779.3,779.3,.16,3)
Select the node that this process should run on (optional).
"^DD",779.3,779.3,.16,21,0)
^^20^20^3100324^
"^DD",779.3,779.3,.16,21,1,0)
The BOX-VOLUME PAIR field (#13) in the HLO SYSTEM PARAMETERS file (#779.1)
"^DD",779.3,779.3,.16,21,2,0)
may be used to optionally specify the node that the HL7 (optimized) software
"^DD",779.3,779.3,.16,21,3,0)
should run on. 
"^DD",779.3,779.3,.16,21,4,0)

"^DD",779.3,779.3,.16,21,5,0)
The BOX-VLUME PAIR field (#16) of the HLO PROCESS REGISTRY file (#779.3) may be
"^DD",779.3,779.3,.16,21,6,0)
used to optionally specify the ndoe that a specify type of HL7 (optimized)
"^DD",779.3,779.3,.16,21,7,0)
software should execute on.  If this field has a value, it will override
"^DD",779.3,779.3,.16,21,8,0)
the value in the HLO SYSTEM PARAMETERS file (#779.1) for this type of
"^DD",779.3,779.3,.16,21,9,0)
HLO process.
"^DD",779.3,779.3,.16,21,10,0)

"^DD",779.3,779.3,.16,21,11,0)
It is generally not necessary to designate which node an HLO process will
"^DD",779.3,779.3,.16,21,12,0)
execute on.  The primary exception may be to allow a Cache/NT site to
"^DD",779.3,779.3,.16,21,13,0)
utilize multiple listeners running on multiple nodes.
"^DD",779.3,779.3,.16,21,14,0)

"^DD",779.3,779.3,.16,21,15,0)
Cache/VMS sites should not utilize listeners running under the HLO Process
"^DD",779.3,779.3,.16,21,16,0)
Manager. Instead, those sites should utilize the VMS TCPIP Services. If 
"^DD",779.3,779.3,.16,21,17,0)
desired for load balancing, such a service may be run on multiple nodes. The
"^DD",779.3,779.3,.16,21,18,0)
BOX-VOLUME PAIR  parameters do NOT affect listeners that utilize the
"^DD",779.3,779.3,.16,21,19,0)
VMS TCPIP Services.
"^DD",779.3,779.3,.16,21,20,0)

"^DD",779.3,779.3,.16,"DT")
3100324
"^DD",779.9,779.9,0)
FIELD^^1^5
"^DD",779.9,779.9,0,"DDA")
N
"^DD",779.9,779.9,0,"DT")
3100129
"^DD",779.9,779.9,0,"ID",.02)
W "   ",@("$P($P($C(59)_$S($D(^DD(779.9,.02,0)):$P(^(0),U,3),1:0)_$E("_DIC_"Y,0),0),$C(59)_$P(^(0),U,2)_"":"",2),$C(59),1)")
"^DD",779.9,779.9,0,"ID",.04)
W "   ",$P(^(0),U,4)
"^DD",779.9,779.9,0,"IX","B",779.9,.01)

"^DD",779.9,779.9,0,"NM","HLO PRIORITY QUEUES")

"^DD",779.9,779.9,.01,0)
QUEUE^RF^^0;1^K:$L(X)>20!($L(X)<3)!'(X'?1P.E) X
"^DD",779.9,779.9,.01,1,0)
^.1^^-1
"^DD",779.9,779.9,.01,1,1,0)
779.9^B
"^DD",779.9,779.9,.01,1,1,1)
S ^HLD(779.9,"B",$E(X,1,30),DA)=""
"^DD",779.9,779.9,.01,1,1,2)
K ^HLD(779.9,"B",$E(X,1,30),DA)
"^DD",779.9,779.9,.01,3)
Enter the name of a message queue, 3 to 20 characters.
"^DD",779.9,779.9,.01,21,0)
^^2^2^3090819^
"^DD",779.9,779.9,.01,21,1,0)
The name of either an outgoing or incoming queue.
"^DD",779.9,779.9,.01,21,2,0)

"^DD",779.9,779.9,.01,"DT")
3100120
"^DD",779.9,779.9,.02,0)
DIRECTION^RS^IN:INCOMING;OUT:OUTGOING;^0;2^Q
"^DD",779.9,779.9,.02,1,0)
^.1^^0
"^DD",779.9,779.9,.02,3)
What direction is the queue's messages?
"^DD",779.9,779.9,.02,21,0)
^^10^10^3100129^^^
"^DD",779.9,779.9,.02,21,1,0)
HLO includes queues that contain incoming messages and other queues that
"^DD",779.9,779.9,.02,21,2,0)
contain outgoing messages.  For example, there may be two queues named
"^DD",779.9,779.9,.02,21,3,0)
'MPI ADT~A08', with one for messages being transmitted to another system, and
"^DD",779.9,779.9,.02,21,4,0)
the other queue of the same name for messages that were received from other
"^DD",779.9,779.9,.02,21,5,0)
systems.
"^DD",779.9,779.9,.02,21,6,0)

"^DD",779.9,779.9,.02,21,7,0)
At present this field will automatically default to OUTGOING.  A future
"^DD",779.9,779.9,.02,21,8,0)
enhancment may support the assignment of priorties for incomming queues.
"^DD",779.9,779.9,.02,21,9,0)

"^DD",779.9,779.9,.02,21,10,0)

"^DD",779.9,779.9,.02,"DT")
3100129
"^DD",779.9,779.9,.03,0)
APPLIES TO ALL LINKS (YES/NO)^RS^1:YES;0:NO;^0;3^Q
"^DD",779.9,779.9,.03,3)
Answer YES if this priority applies to all links for this queue. A YES does not preclude entering a different priority for a specific queue.
"^DD",779.9,779.9,.03,21,0)
^^15^15^3100201^^^^
"^DD",779.9,779.9,.03,21,1,0)
Enter YES if the priority should be applied to all queues of the given name, 
"^DD",779.9,779.9,.03,21,2,0)
regardless of the link the queue is for.
"^DD",779.9,779.9,.03,21,3,0)

"^DD",779.9,779.9,.03,21,4,0)
It is allowed that even if set to YES, a different priority can be assigned
"^DD",779.9,779.9,.03,21,5,0)
to that queue for specific links, and that priority for the queue/link will
"^DD",779.9,779.9,.03,21,6,0)
override the more general one.
"^DD",779.9,779.9,.03,21,7,0)

"^DD",779.9,779.9,.03,21,8,0)
If this field is set to NO, that means that the PRIORITY field (#.04) is 
"^DD",779.9,779.9,.03,21,9,0)
ignored.  A priority can still be assigned to a specific queue by specifying
"^DD",779.9,779.9,.03,21,10,0)
the specific link, along with the priority for that queue/link. 
"^DD",779.9,779.9,.03,21,11,0)

"^DD",779.9,779.9,.03,21,12,0)
If it is set to NO or left blank then the queue would assume the default
"^DD",779.9,779.9,.03,21,13,0)
priority of 50, unless overridden in the LINKS multiple.
"^DD",779.9,779.9,.03,21,14,0)

"^DD",779.9,779.9,.03,21,15,0)

"^DD",779.9,779.9,.03,"DT")
3100201
"^DD",779.9,779.9,.04,0)
PRIORITY^NJ3,0^^0;4^K:+X'=X!(X>100)!(X<20)!(X?.E1"."1.N) X
"^DD",779.9,779.9,.04,1,0)
^.1^^0
"^DD",779.9,779.9,.04,3)
Enter a whole number between 20 and 100.  Queues given a higher priority will be serviced more often.  The default priority is 50.
"^DD",779.9,779.9,.04,21,0)
^^8^8^3100129^^^
"^DD",779.9,779.9,.04,21,1,0)
A priority is an integer between 20 and 100, with a default value of 50.
"^DD",779.9,779.9,.04,21,2,0)
The lower the priority, the less frequently the queue will be serviced.
"^DD",779.9,779.9,.04,21,3,0)
Conversely, the higher a queue's priority the more frequently it will be
"^DD",779.9,779.9,.04,21,4,0)
serviced.  The recommended use of the priority functionality is to reserve
"^DD",779.9,779.9,.04,21,5,0)
its use to the operations staff. A queue's priority should be increased
"^DD",779.9,779.9,.04,21,6,0)
if experience shows that it tends to get backed up.
"^DD",779.9,779.9,.04,21,7,0)

"^DD",779.9,779.9,.04,21,8,0)

"^DD",779.9,779.9,.04,"DT")
3100129
"^DD",779.9,779.9,1,0)
LINKS^779.91P^^1;0
"^DD",779.9,779.9,1,21,0)
^^6^6^3100129^^^
"^DD",779.9,779.9,1,21,1,0)
A link is an entry in the HL Logical Link file (#870).  It defines a
"^DD",779.9,779.9,1,21,2,0)
a destination point for HL7 messages, and the lower level communication
"^DD",779.9,779.9,1,21,3,0)
protocol that should be used to transmit messages to that destination.
"^DD",779.9,779.9,1,21,4,0)

"^DD",779.9,779.9,1,21,5,0)

"^DD",779.9,779.9,1,21,6,0)

"^DD",779.9,779.9,1,23,0)
^^1^1^3100129^
"^DD",779.9,779.9,1,23,1,0)

"^DD",779.9,779.91,0)
LINKS SUB-FIELD^^.02^2
"^DD",779.9,779.91,0,"DT")
3100120
"^DD",779.9,779.91,0,"IX","B",779.91,.01)

"^DD",779.9,779.91,0,"NM","LINKS")

"^DD",779.9,779.91,0,"UP")
779.9
"^DD",779.9,779.91,.01,0)
LINK^MP870'^HLCS(870,^0;1^Q
"^DD",779.9,779.91,.01,1,0)
^.1
"^DD",779.9,779.91,.01,1,1,0)
779.91^B
"^DD",779.9,779.91,.01,1,1,1)
S ^HLD(779.9,DA(1),1,"B",$E(X,1,30),DA)=""
"^DD",779.9,779.91,.01,1,1,2)
K ^HLD(779.9,DA(1),1,"B",$E(X,1,30),DA)
"^DD",779.9,779.91,.01,3)
Select the specific link that the queue priority will apply to.
"^DD",779.9,779.91,.01,21,0)
^^3^3^3100129^
"^DD",779.9,779.91,.01,21,1,0)
This is a link which will have special priority separate from the general
"^DD",779.9,779.91,.01,21,2,0)
priority of the queue.
"^DD",779.9,779.91,.01,21,3,0)

"^DD",779.9,779.91,.01,"DT")
3100129
"^DD",779.9,779.91,.02,0)
LINK-SPECIFIC PRIORITY^NJ3,0^^0;2^K:+X'=X!(X>100)!(X<20)!(X?.E1"."1.N) X
"^DD",779.9,779.91,.02,3)
Enter the priority as a number 20-100. A higher priority will cause the queue to be serviced more frequently.  The default priority is 50.
"^DD",779.9,779.91,.02,21,0)
^^4^4^3091104^
"^DD",779.9,779.91,.02,21,1,0)
Entering a priority here will cause it to be specific to this link.  If the 
"^DD",779.9,779.91,.02,21,2,0)
priority is not entered here, the priority will be derived from the PRIORITY
"^DD",779.9,779.91,.02,21,3,0)
field at the higher level in file 779.9.
"^DD",779.9,779.91,.02,21,4,0)

"^DD",779.9,779.91,.02,"DT")
3091123
"^DIC",779.1,779.1,0)
HLO SYSTEM PARAMETERS^779.1
"^DIC",779.1,779.1,0,"GL")
^HLD(779.1,
"^DIC",779.1,779.1,"%",0)
^1.005^^0
"^DIC",779.1,779.1,"%D",0)
^1.001^2^2^3050801^^^^
"^DIC",779.1,779.1,"%D",1,0)
This file contains parameters used by the HLO (HL7 Optimized)
"^DIC",779.1,779.1,"%D",2,0)
that are specific to the system the software is installed on.
"^DIC",779.1,"B","HLO SYSTEM PARAMETERS",779.1)

"^DIC",779.11,779.11,0)
HLO ERROR SCREENS^779.11
"^DIC",779.11,779.11,0,"GL")
^HLD(779.11,
"^DIC",779.11,779.11,"%",0)
^1.005^^
"^DIC",779.11,779.11,"%D",0)
^^15^15^3100129^^^
"^DIC",779.11,779.11,"%D",1,0)
The Health Leven Seven (Optimized) software (HLO) was released as patch 
"^DIC",779.11,779.11,"%D",2,0)
HL*1.6*126 to the HL7 v1.6 software package.  Although it is structurally and 
"^DIC",779.11,779.11,"%D",3,0)
functionally an independent system, it is officially part of HL7 1.6.  This is 
"^DIC",779.11,779.11,"%D",4,0)
a messaging system similar to the old HL7 1.6 package, but it was designed from 
"^DIC",779.11,779.11,"%D",5,0)
the ground up and is more robust, more capable, and supports a much higher 
"^DIC",779.11,779.11,"%D",6,0)
message throughput.  
"^DIC",779.11,779.11,"%D",7,0)

"^DIC",779.11,779.11,"%D",8,0)
This file is used create screens for reporting HLO messaging errors. A screen
"^DIC",779.11,779.11,"%D",9,0)
is a list of criteria used to either include or exclude specific error types
"^DIC",779.11,779.11,"%D",10,0)
in an error report.  
"^DIC",779.11,779.11,"%D",11,0)

"^DIC",779.11,779.11,"%D",12,0)
A screen is identified by its name.  The name should be namespaced and be
"^DIC",779.11,779.11,"%D",13,0)
descriptive as to its intended use.
"^DIC",779.11,779.11,"%D",14,0)

"^DIC",779.11,779.11,"%D",15,0)

"^DIC",779.11,"B","HLO ERROR SCREENS",779.11)

"^DIC",779.3,779.3,0)
HLO PROCESS REGISTRY^779.3
"^DIC",779.3,779.3,0,"GL")
^HLD(779.3,
"^DIC",779.3,779.3,"%",0)
^1.005^^0
"^DIC",779.3,779.3,"%D",0)
^^2^2^3050801^^^
"^DIC",779.3,779.3,"%D",1,0)
The process registry is used by the HLO process manager to start, stop, and
"^DIC",779.3,779.3,"%D",2,0)
manage all of the processes used by the HLO system.
"^DIC",779.3,"B","HLO PROCESS REGISTRY",779.3)

"^DIC",779.9,779.9,0)
HLO PRIORITY QUEUES^779.9
"^DIC",779.9,779.9,0,"GL")
^HLD(779.9,
"^DIC",779.9,779.9,"%",0)
^1.005^^
"^DIC",779.9,779.9,"%D",0)
^^45^45^3100129^^^^
"^DIC",779.9,779.9,"%D",1,0)
The Health Leven Seven (Optimized) software (HLO) was released as patch
"^DIC",779.9,779.9,"%D",2,0)
HL*1.6*126 to the HL7 v1.6 software package.  Although it is structurally and 
"^DIC",779.9,779.9,"%D",3,0)
functionally an independent system, it is officially part of HL7 1.6.  This is
"^DIC",779.9,779.9,"%D",4,0)
a messaging system similar to the old HL7 1.6 package, but it was designed from
"^DIC",779.9,779.9,"%D",5,0)
the ground up and is more robust, more capable, and supports a much higher
"^DIC",779.9,779.9,"%D",6,0)
message throughput.  
"^DIC",779.9,779.9,"%D",7,0)

"^DIC",779.9,779.9,"%D",8,0)
This file contains the priorities of HLO queues as assigned by the system
"^DIC",779.9,779.9,"%D",9,0)
operations staff. 
"^DIC",779.9,779.9,"%D",10,0)

"^DIC",779.9,779.9,"%D",11,0)
It is not necessary to assign a priority to a queue.  However, doing so
"^DIC",779.9,779.9,"%D",12,0)
will change the frequency that HLO services the queue.  Important queues that
"^DIC",779.9,779.9,"%D",13,0)
tend to be backed up should be assigned a higher priority.  Less important
"^DIC",779.9,779.9,"%D",14,0)
queues may be assigned a lower priority.  The goal of setting queue priorities
"^DIC",779.9,779.9,"%D",15,0)
is to balance the HLO resources over the queues in order to obtain a desired
"^DIC",779.9,779.9,"%D",16,0)
performance.
"^DIC",779.9,779.9,"%D",17,0)

"^DIC",779.9,779.9,"%D",18,0)
Currently priorities may be set only for outgoing queues, though the file
"^DIC",779.9,779.9,"%D",19,0)
was designed to also support the assignment of priorities for incomming queues.
"^DIC",779.9,779.9,"%D",20,0)
The option for entering the type of queue (incomming or outgoing) currently
"^DIC",779.9,779.9,"%D",21,0)
will automatically default to outgoing. A future enhancment may support
"^DIC",779.9,779.9,"%D",22,0)
the ability to assign priorities to incomming queues.
"^DIC",779.9,779.9,"%D",23,0)

"^DIC",779.9,779.9,"%D",24,0)
To set the priority the name of the queue must be specified.  As explained, 
"^DIC",779.9,779.9,"%D",25,0)
currently the queue will be assumed to be outgoing. Optionally,if the priority
"^DIC",779.9,779.9,"%D",26,0)
is to be set only for a specific link then the link must be specified.
"^DIC",779.9,779.9,"%D",27,0)

"^DIC",779.9,779.9,"%D",28,0)
Examples:
"^DIC",779.9,779.9,"%D",29,0)

"^DIC",779.9,779.9,"%D",30,0)
You could set the priority of an outgoing queue named "HLO OUT" without
"^DIC",779.9,779.9,"%D",31,0)
specifying the link.  The effect would be to set the priority of all outgoing
"^DIC",779.9,779.9,"%D",32,0)
queues named "HLO OUT" regardless of the link.
"^DIC",779.9,779.9,"%D",33,0)

"^DIC",779.9,779.9,"%D",34,0)
You could set the priority of an outgoing queue named "HLO OUT" and also specify
"^DIC",779.9,779.9,"%D",35,0)
the link.  The effect would be to set the priority of the outgoing
"^DIC",779.9,779.9,"%D",36,0)
queue named "HLO OUT" that is sending messages via that specific link only.
"^DIC",779.9,779.9,"%D",37,0)

"^DIC",779.9,779.9,"%D",38,0)
If a queue's priority is specified to apply to all links, but that queue's
"^DIC",779.9,779.9,"%D",39,0)
priority is also specified for a specific link, that specific priority setting
"^DIC",779.9,779.9,"%D",40,0)
will override the general one.  
"^DIC",779.9,779.9,"%D",41,0)

"^DIC",779.9,779.9,"%D",42,0)

"^DIC",779.9,779.9,"%D",43,0)

"^DIC",779.9,779.9,"%D",44,0)

"^DIC",779.9,779.9,"%D",45,0)

"^DIC",779.9,"B","HLO PRIORITY QUEUES",779.9)

**END**
**END**
