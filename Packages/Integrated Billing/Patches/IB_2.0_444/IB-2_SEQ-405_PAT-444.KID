EMERGENCY Released IB*2*444 SEQ #405
Extracted from mail message
**KIDS**:IB*2.0*444^

**INSTALL NAME**
IB*2.0*444
"BLD",7911,0)
IB*2.0*444^INTEGRATED BILLING^0^3101109^y
"BLD",7911,4,0)
^9.64PA^^
"BLD",7911,6.3)
2
"BLD",7911,"ABPKG")
n
"BLD",7911,"KRN",0)
^9.67PA^779.2^20
"BLD",7911,"KRN",.4,0)
.4
"BLD",7911,"KRN",.401,0)
.401
"BLD",7911,"KRN",.402,0)
.402
"BLD",7911,"KRN",.403,0)
.403
"BLD",7911,"KRN",.5,0)
.5
"BLD",7911,"KRN",.84,0)
.84
"BLD",7911,"KRN",3.6,0)
3.6
"BLD",7911,"KRN",3.8,0)
3.8
"BLD",7911,"KRN",9.2,0)
9.2
"BLD",7911,"KRN",9.8,0)
9.8
"BLD",7911,"KRN",9.8,"NM",0)
^9.68A^1^1
"BLD",7911,"KRN",9.8,"NM",1,0)
IBCNEHL1^^0^B227587441
"BLD",7911,"KRN",9.8,"NM","B","IBCNEHL1",1)

"BLD",7911,"KRN",19,0)
19
"BLD",7911,"KRN",19.1,0)
19.1
"BLD",7911,"KRN",101,0)
101
"BLD",7911,"KRN",409.61,0)
409.61
"BLD",7911,"KRN",771,0)
771
"BLD",7911,"KRN",779.2,0)
779.2
"BLD",7911,"KRN",870,0)
870
"BLD",7911,"KRN",8989.51,0)
8989.51
"BLD",7911,"KRN",8989.52,0)
8989.52
"BLD",7911,"KRN",8994,0)
8994
"BLD",7911,"KRN","B",.4,.4)

"BLD",7911,"KRN","B",.401,.401)

"BLD",7911,"KRN","B",.402,.402)

"BLD",7911,"KRN","B",.403,.403)

"BLD",7911,"KRN","B",.5,.5)

"BLD",7911,"KRN","B",.84,.84)

"BLD",7911,"KRN","B",3.6,3.6)

"BLD",7911,"KRN","B",3.8,3.8)

"BLD",7911,"KRN","B",9.2,9.2)

"BLD",7911,"KRN","B",9.8,9.8)

"BLD",7911,"KRN","B",19,19)

"BLD",7911,"KRN","B",19.1,19.1)

"BLD",7911,"KRN","B",101,101)

"BLD",7911,"KRN","B",409.61,409.61)

"BLD",7911,"KRN","B",771,771)

"BLD",7911,"KRN","B",779.2,779.2)

"BLD",7911,"KRN","B",870,870)

"BLD",7911,"KRN","B",8989.51,8989.51)

"BLD",7911,"KRN","B",8989.52,8989.52)

"BLD",7911,"KRN","B",8994,8994)

"BLD",7911,"QDEF")
^^^^NO^^^^NO^^YES
"BLD",7911,"QUES",0)
^9.62^^
"BLD",7911,"REQB",0)
^9.611^1^1
"BLD",7911,"REQB",1,0)
IB*2.0*416^2
"BLD",7911,"REQB","B","IB*2.0*416",1)

"MBREQ")
0
"PKG",200,-1)
1^1
"PKG",200,0)
INTEGRATED BILLING^IB^INTEGRATED BILLING
"PKG",200,20,0)
^9.402P^1^1
"PKG",200,20,1,0)
2^^IBAXDR
"PKG",200,20,1,1)

"PKG",200,20,"B",2,1)

"PKG",200,22,0)
^9.49I^1^1
"PKG",200,22,1,0)
2.0^2940321^2990406^2447
"PKG",200,22,1,"PAH",1,0)
444^3101109
"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
NO
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
NO
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
YES
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
1
"RTN","IBCNEHL1")
0^1^B227587441^B225142720
"RTN","IBCNEHL1",1,0)
IBCNEHL1 ;DAOU/ALA - HL7 Process Incoming RPI Messages ;26-JUN-2002  ; Compiled December 16, 2004 15:29:01
"RTN","IBCNEHL1",2,0)
 ;;2.0;INTEGRATED BILLING;**300,345,416,444**;21-MAR-94;Build 2
"RTN","IBCNEHL1",3,0)
 ;;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","IBCNEHL1",4,0)
 ;
"RTN","IBCNEHL1",5,0)
 ;**Program Description**
"RTN","IBCNEHL1",6,0)
 ;  This program will process incoming IIV response messages.
"RTN","IBCNEHL1",7,0)
 ;  This includes updating the record in the IIV Response File,
"RTN","IBCNEHL1",8,0)
 ;  updating the Buffer record (if there is one and creating a new
"RTN","IBCNEHL1",9,0)
 ;  one if there isn't) with the appropriate Buffer Symbol and data
"RTN","IBCNEHL1",10,0)
 ;  
"RTN","IBCNEHL1",11,0)
 ;  This routine is based on IBCNEHLR which was introduced with patch 184, and subsequently
"RTN","IBCNEHL1",12,0)
 ;  patched with patches 252 and 271.  IBCNEHLR is obsolete and deleted with patch 300.
"RTN","IBCNEHL1",13,0)
 ;
"RTN","IBCNEHL1",14,0)
 ;**Modified by  Date        Reason
"RTN","IBCNEHL1",15,0)
 ;  DAOU/BHS     10/04/2002  Added logic to update the service date in
"RTN","IBCNEHL1",16,0)
 ;                           the TQ entry so long as the Error Action is
"RTN","IBCNEHL1",17,0)
 ;                           not Please submit original transaction.
"RTN","IBCNEHL1",18,0)
 ;  DAOU/DB      03/11/2004  Added logic to utilize new status flag
"RTN","IBCNEHL1",19,0)
 ;                           transmitted to VistA from EC (IIVSTAT)
"RTN","IBCNEHL1",20,0)
 ;               03/15/2004  Update other retries to comm failure (if
"RTN","IBCNEHL1",21,0)
 ;                           not response rcvd)
"RTN","IBCNEHL1",22,0)
 ;  DAOU/BEE     07/14/2004  Cleaned up routine - Made more readable
"RTN","IBCNEHL1",23,0)
 ;                           Cleaned up variables                          
"RTN","IBCNEHL1",24,0)
 ;  PROXICOM/RTO 08/23/2006  Fixed logic issue when determining whether
"RTN","IBCNEHL1",25,0)
 ;                           to update a buffer entry
"RTN","IBCNEHL1",26,0)
 ;
"RTN","IBCNEHL1",27,0)
 ;  Variables
"RTN","IBCNEHL1",28,0)
 ;    SEG = HL7 Segment Name
"RTN","IBCNEHL1",29,0)
 ;    MSGID = Original Message Control ID
"RTN","IBCNEHL1",30,0)
 ;    ACK =  Acknowledgment (AA=Accepted, AE=Error)
"RTN","IBCNEHL1",31,0)
 ;    ERTXT = Error Message Text
"RTN","IBCNEHL1",32,0)
 ;    ERFLG = Error quit flag
"RTN","IBCNEHL1",33,0)
 ;    ERACT = Error Action
"RTN","IBCNEHL1",34,0)
 ;    ERCON = Error Condition
"RTN","IBCNEHL1",35,0)
 ;    RIEN = Response Record IEN
"RTN","IBCNEHL1",36,0)
 ;    IIVSTAT = EC generated flag interpreting status of response
"RTN","IBCNEHL1",37,0)
 ;              1 = +
"RTN","IBCNEHL1",38,0)
 ;              6 = -
"RTN","IBCNEHL1",39,0)
 ;              V = #
"RTN","IBCNEHL1",40,0)
 ;    MAP = Array that maps EC's IIV status flag to IIV STATUS TABLE (#365.15)   IEN
"RTN","IBCNEHL1",41,0)
 ;
"RTN","IBCNEHL1",42,0)
EN ; Entry Point
"RTN","IBCNEHL1",43,0)
 N AUTO,EBDA,ERFLG,ERROR,G2OFLG,HCT,HLCMP,HLREP,HLSCMP,IIVSTAT,IRIEN,MAP,MGRP,RIEN,RSUPDT,SEG,SUBID,TRACE,UP,ACK
"RTN","IBCNEHL1",44,0)
 S (ERFLG,G2OFLG)=0,MGRP=$$MGRP^IBCNEUT5(),HCT=1,SUBID="",IIVSTAT=""
"RTN","IBCNEHL1",45,0)
 ;
"RTN","IBCNEHL1",46,0)
 S HLCMP=$E(HL("ECH")) ; HL7 component separator
"RTN","IBCNEHL1",47,0)
 S HLSCMP=$E(HL("ECH"),4) ; HL7 subcomponent separator
"RTN","IBCNEHL1",48,0)
 S HLREP=$E(HL("ECH"),2) ; HL7 repetition separator
"RTN","IBCNEHL1",49,0)
 ; Create map from EC to VistA
"RTN","IBCNEHL1",50,0)
 S MAP(1)=8,MAP(6)=9,MAP("V")=21
"RTN","IBCNEHL1",51,0)
 ;
"RTN","IBCNEHL1",52,0)
 ;  Loop through the message and find each segment for processing
"RTN","IBCNEHL1",53,0)
 F  S HCT=$O(^TMP($J,"IBCNEHLI",HCT)) Q:HCT=""  D  Q:ERFLG
"RTN","IBCNEHL1",54,0)
 . D SPAR^IBCNEHLU
"RTN","IBCNEHL1",55,0)
 . S SEG=$G(IBSEG(1))
"RTN","IBCNEHL1",56,0)
 . ; check if we are inside G2O group of segments
"RTN","IBCNEHL1",57,0)
 . I SEG="ZTY" S G2OFLG=1
"RTN","IBCNEHL1",58,0)
 . I G2OFLG,SEG'="ZTY",SEG'="CTD" S G2OFLG=0
"RTN","IBCNEHL1",59,0)
 . ; If we are outside of Z_Benefit_group, kill EB multiple ien
"RTN","IBCNEHL1",60,0)
 . I +$G(EBDA),".MSH.MSA.PRD.PID.GT1.IN1.IN3."[("."_SEG_".")!('G2OFLG&(SEG="CTD")) K EBDA
"RTN","IBCNEHL1",61,0)
 . ;
"RTN","IBCNEHL1",62,0)
 . I SEG="MSA" D MSA^IBCNEHL2(.ERACT,.ERCON,.ERROR,.ERTXT,.IBSEG,MGRP,.RIEN,.TRACE) Q:ERFLG
"RTN","IBCNEHL1",63,0)
 . ;
"RTN","IBCNEHL1",64,0)
 . ;  Contact Segment
"RTN","IBCNEHL1",65,0)
 . I SEG="CTD",'G2OFLG D CTD^IBCNEHL2(.ERROR,.IBSEG,RIEN)
"RTN","IBCNEHL1",66,0)
 . ;
"RTN","IBCNEHL1",67,0)
 . ;  Patient Segment
"RTN","IBCNEHL1",68,0)
 . I SEG="PID" D PID^IBCNEHL2(.ERFLG,.ERROR,.IBSEG,RIEN)
"RTN","IBCNEHL1",69,0)
 . ;
"RTN","IBCNEHL1",70,0)
 . ;  Guarantor Segment
"RTN","IBCNEHL1",71,0)
 . I SEG="GT1" D GT1^IBCNEHL2(.ERROR,.IBSEG,RIEN,.SUBID)
"RTN","IBCNEHL1",72,0)
 . ;
"RTN","IBCNEHL1",73,0)
 . ;  Insurance Segment
"RTN","IBCNEHL1",74,0)
 . I SEG="IN1" D IN1^IBCNEHL2(.ERROR,.IBSEG,RIEN,SUBID)
"RTN","IBCNEHL1",75,0)
 . ;
"RTN","IBCNEHL1",76,0)
 . ;  Addt'l Insurance Segment
"RTN","IBCNEHL1",77,0)
 . ;I SEG="IN2" ; for future expansion, add IN2 tag to IBCNEHL2
"RTN","IBCNEHL1",78,0)
 . ;
"RTN","IBCNEHL1",79,0)
 . ;  Addt'l Insurance - Cert Segment
"RTN","IBCNEHL1",80,0)
 . I SEG="IN3" D IN3^IBCNEHL2(.ERROR,.IBSEG,RIEN)
"RTN","IBCNEHL1",81,0)
 . ;
"RTN","IBCNEHL1",82,0)
 . ;  Eligibility/Benefit Segment
"RTN","IBCNEHL1",83,0)
 . I SEG="ZEB" D ZEB^IBCNEHL2(.EBDA,.ERROR,.IBSEG,RIEN)
"RTN","IBCNEHL1",84,0)
 . ;
"RTN","IBCNEHL1",85,0)
 . ; Healthcare Delivery Segment
"RTN","IBCNEHL1",86,0)
 . I SEG="ZHS" D ZHS^IBCNEHL4(EBDA,.ERROR,.IBSEG,RIEN)
"RTN","IBCNEHL1",87,0)
 . ;
"RTN","IBCNEHL1",88,0)
 . ; Reference ID Segment
"RTN","IBCNEHL1",89,0)
 . I SEG="ZRF" D ZRF^IBCNEHL4(EBDA,.ERROR,.IBSEG,RIEN)
"RTN","IBCNEHL1",90,0)
 . ;
"RTN","IBCNEHL1",91,0)
 . ; Subscriber Date Segment
"RTN","IBCNEHL1",92,0)
 . I SEG="ZSD" D ZSD^IBCNEHL4(EBDA,.ERROR,.IBSEG,RIEN)
"RTN","IBCNEHL1",93,0)
 . ;
"RTN","IBCNEHL1",94,0)
 . ; Subscriber Additional Info Segment
"RTN","IBCNEHL1",95,0)
 . I SEG="ZII" D ZII^IBCNEHL4(EBDA,.ERROR,.IBSEG,RIEN)
"RTN","IBCNEHL1",96,0)
 . ;
"RTN","IBCNEHL1",97,0)
 . ; Benefit Related Entity Segment
"RTN","IBCNEHL1",98,0)
 . I SEG="ZTY" D ZTY^IBCNEHL4(EBDA,.ERROR,.IBSEG,RIEN)
"RTN","IBCNEHL1",99,0)
 . ;
"RTN","IBCNEHL1",100,0)
 . ; Benefit Related Entity Contact Segment
"RTN","IBCNEHL1",101,0)
 . I SEG="CTD",G2OFLG D G2OCTD^IBCNEHL4(EBDA,.ERROR,.IBSEG,RIEN)
"RTN","IBCNEHL1",102,0)
 . ;
"RTN","IBCNEHL1",103,0)
 . ;  Notes Segment
"RTN","IBCNEHL1",104,0)
 . I SEG="NTE" D NTE^IBCNEHL2(EBDA,.IBSEG,RIEN)
"RTN","IBCNEHL1",105,0)
 ;
"RTN","IBCNEHL1",106,0)
 S AUTO=$$AUTOUPD(RIEN)
"RTN","IBCNEHL1",107,0)
 I $G(ACK)'="AE",$G(ERACT)="",$G(ERTXT)="",'$D(ERROR),+AUTO D  Q
"RTN","IBCNEHL1",108,0)
 .D:$P(AUTO,U,3)'="" AUTOFIL($P(AUTO,U,2),$P(AUTO,U,3),$P(AUTO,U,6))
"RTN","IBCNEHL1",109,0)
 .D:$P(AUTO,U,4)'="" AUTOFIL($P(AUTO,U,2),$P(AUTO,U,4),$P(AUTO,U,6))
"RTN","IBCNEHL1",110,0)
 .Q
"RTN","IBCNEHL1",111,0)
 D FIL
"RTN","IBCNEHL1",112,0)
 Q
"RTN","IBCNEHL1",113,0)
 ;
"RTN","IBCNEHL1",114,0)
 ; =================================================================
"RTN","IBCNEHL1",115,0)
AUTOFIL(DFN,IEN312,ISSUB) ; Finish processing the response message - file directly into patient insurance
"RTN","IBCNEHL1",116,0)
 ;
"RTN","IBCNEHL1",117,0)
 N BUFF,DATA,ERROR,IENS,PREL,RDATA0,RDATA1,RDATA5,RSTYPE,TQN,TSTAMP
"RTN","IBCNEHL1",118,0)
 ;
"RTN","IBCNEHL1",119,0)
 Q:$G(RIEN)=""
"RTN","IBCNEHL1",120,0)
 S TSTAMP=$$NOW^XLFDT(),IENS=IEN312_","_DFN_","
"RTN","IBCNEHL1",121,0)
 S RDATA0=$G(^IBCN(365,RIEN,0)),RDATA1=$G(^IBCN(365,RIEN,1)),RDATA5=$G(^IBCN(365,RIEN,5))
"RTN","IBCNEHL1",122,0)
 S TQN=$P(RDATA0,U,5),RSTYPE=$P(RDATA0,U,10)
"RTN","IBCNEHL1",123,0)
 I ISSUB S DATA(2.312,IENS,17)=$P(RDATA1,U) ; name
"RTN","IBCNEHL1",124,0)
 S DATA(2.312,IENS,3.01)=$P(RDATA1,U,2) ; dob
"RTN","IBCNEHL1",125,0)
 S DATA(2.312,IENS,3.05)=$P(RDATA1,U,3) ; ssn
"RTN","IBCNEHL1",126,0)
 I ISSUB,$P(RDATA1,U,8)'="" S DATA(2.312,IENS,6)=$P(RDATA1,U,8) ; whose insurance
"RTN","IBCNEHL1",127,0)
 S PREL=$$PREL($P(RDATA1,U,9),$$GET1^DIQ(2.312,IENS,4.03,"I"))
"RTN","IBCNEHL1",128,0)
 I ISSUB,PREL'="" S DATA(2.312,IENS,4.03)=PREL ; pt. relationship
"RTN","IBCNEHL1",129,0)
 ;
"RTN","IBCNEHL1",130,0)
 S DATA(2.312,IENS,1.03)=TSTAMP ; date last verified
"RTN","IBCNEHL1",131,0)
 S DATA(2.312,IENS,1.04)="" ; last verified by
"RTN","IBCNEHL1",132,0)
 S DATA(2.312,IENS,1.05)=TSTAMP ; date last edited
"RTN","IBCNEHL1",133,0)
 S DATA(2.312,IENS,1.06)="" ; last edited by
"RTN","IBCNEHL1",134,0)
 S DATA(2.312,IENS,1.09)=5 ; source of info = eIV
"RTN","IBCNEHL1",135,0)
 ;subscriber address
"RTN","IBCNEHL1",136,0)
 S DATA(2.312,IENS,3.06)=$P(RDATA5,U) ; street line 1
"RTN","IBCNEHL1",137,0)
 S DATA(2.312,IENS,3.07)=$P(RDATA5,U,2) ; street line 2
"RTN","IBCNEHL1",138,0)
 S DATA(2.312,IENS,3.08)=$P(RDATA5,U,3) ; city
"RTN","IBCNEHL1",139,0)
 S DATA(2.312,IENS,3.09)=$P(RDATA5,U,4) ; state
"RTN","IBCNEHL1",140,0)
 S DATA(2.312,IENS,3.1)=$P(RDATA5,U,5) ; zip
"RTN","IBCNEHL1",141,0)
 ;
"RTN","IBCNEHL1",142,0)
 D FILE^DIE("ET","DATA","ERROR") I $D(ERROR) D WARN K ERROR D FIL Q
"RTN","IBCNEHL1",143,0)
 ; set eIV auto-update field separately because of the trigger on field 1.05
"RTN","IBCNEHL1",144,0)
 K DATA S DATA(2.312,IENS,4.04)="YES" D FILE^DIE("ET","DATA","ERROR") I $D(ERROR) D WARN Q
"RTN","IBCNEHL1",145,0)
 ; file new EB data
"RTN","IBCNEHL1",146,0)
 S ERFLG=$$EBFILE(DFN,IEN312,RIEN,1)
"RTN","IBCNEHL1",147,0)
 ; bail out if something went wrong during filing of EB data
"RTN","IBCNEHL1",148,0)
 I $G(ERFLG) Q
"RTN","IBCNEHL1",149,0)
 ; update insurance record ien in transmission queue
"RTN","IBCNEHL1",150,0)
 D UPDIREC(RIEN,IEN312)
"RTN","IBCNEHL1",151,0)
 ;  For an original response, set the Transmission Queue Status to 'Response Received' &
"RTN","IBCNEHL1",152,0)
 ;  update remaining retries to comm failure (5)
"RTN","IBCNEHL1",153,0)
 I $G(RSTYPE)="O" D SST^IBCNEUT2(TQN,3),RSTA^IBCNEUT7(TQN)
"RTN","IBCNEHL1",154,0)
 ; update buffer file entry so only stub remains and status is changed
"RTN","IBCNEHL1",155,0)
 S BUFF=+$P($G(^IBCN(365,RIEN,0)),U,4)
"RTN","IBCNEHL1",156,0)
 I BUFF D
"RTN","IBCNEHL1",157,0)
 .D STATUS^IBCNBEE(BUFF,"A",0,0,0) ; update buffer entry's status to accepted
"RTN","IBCNEHL1",158,0)
 .D DELDATA^IBCNBED(BUFF) ; delete buffer's insurance/patient data
"RTN","IBCNEHL1",159,0)
 .Q
"RTN","IBCNEHL1",160,0)
 Q
"RTN","IBCNEHL1",161,0)
 ;
"RTN","IBCNEHL1",162,0)
FIL ; Finish processing the response message - file into insurance buffer
"RTN","IBCNEHL1",163,0)
 ;
"RTN","IBCNEHL1",164,0)
 ; Input Variables
"RTN","IBCNEHL1",165,0)
 ; ERACT, ERFLG, ERROR, IIVSTAT, MAP, RIEN, TRACE
"RTN","IBCNEHL1",166,0)
 ;
"RTN","IBCNEHL1",167,0)
 ; If no record IEN, quit
"RTN","IBCNEHL1",168,0)
 I $G(RIEN)="" Q
"RTN","IBCNEHL1",169,0)
 ;
"RTN","IBCNEHL1",170,0)
 N BUFF,DFN,FILEIT,IBFDA,IBIEN,IBQFL,RDAT0,RSRVDT,RSTYPE,SYMBOL,TQDATA,TQN,TQSRVDT
"RTN","IBCNEHL1",171,0)
 ; Initialize variables from the Response File
"RTN","IBCNEHL1",172,0)
 S RDAT0=$G(^IBCN(365,RIEN,0)),TQN=$P(RDAT0,U,5)
"RTN","IBCNEHL1",173,0)
 S TQDATA=$G(^IBCN(365.1,TQN,0))
"RTN","IBCNEHL1",174,0)
 S IBQFL=$P(TQDATA,U,11)
"RTN","IBCNEHL1",175,0)
 S DFN=$P(RDAT0,U,2),BUFF=$P(RDAT0,U,4)
"RTN","IBCNEHL1",176,0)
 S IBIEN=$P(TQDATA,U,5),RSTYPE=$P(RDAT0,U,10)
"RTN","IBCNEHL1",177,0)
 S RSRVDT=$P($G(^IBCN(365,RIEN,1)),U,10)
"RTN","IBCNEHL1",178,0)
 ;
"RTN","IBCNEHL1",179,0)
 ; If an unknown error action or an error filing the response message,
"RTN","IBCNEHL1",180,0)
 ; send a warning email message
"RTN","IBCNEHL1",181,0)
 ; Note - A call to UEACT will always set ERFLAG=1
"RTN","IBCNEHL1",182,0)
 I ",W,X,R,P,C,N,Y,S,"'[(","_$G(ERACT)_",")&($G(ERACT)'="")!$D(ERROR) D UEACT
"RTN","IBCNEHL1",183,0)
 ;
"RTN","IBCNEHL1",184,0)
 ; If an error occurred, processing complete
"RTN","IBCNEHL1",185,0)
 I $G(ERFLG)=1 Q
"RTN","IBCNEHL1",186,0)
 ;
"RTN","IBCNEHL1",187,0)
 ;  For an original response, set the Transmission Queue Status to 'Response Received' &
"RTN","IBCNEHL1",188,0)
 ;  update remaining retries to comm failure (5)
"RTN","IBCNEHL1",189,0)
 I $G(RSTYPE)="O" D SST^IBCNEUT2(TQN,3),RSTA^IBCNEUT7(TQN)
"RTN","IBCNEHL1",190,0)
 ;
"RTN","IBCNEHL1",191,0)
 ; Update the TQ service date to the date in the response file
"RTN","IBCNEHL1",192,0)
 ; if they are different AND the Error Action <>
"RTN","IBCNEHL1",193,0)
 ; 'P' for 'Please submit original transaction'
"RTN","IBCNEHL1",194,0)
 ;
"RTN","IBCNEHL1",195,0)
 ; *** Temporary change to suppress update of service & freshness dates.
"RTN","IBCNEHL1",196,0)
 ; *** To reinstate, remove comment (;) from next line.
"RTN","IBCNEHL1",197,0)
 ;I TQN'="",$G(RSTYPE)="O" D
"RTN","IBCNEHL1",198,0)
 ;. S TQSRVDT=$P($G(^IBCN(365.1,TQN,0)),U,12)
"RTN","IBCNEHL1",199,0)
 ;. I RSRVDT'="",TQSRVDT'=RSRVDT,$G(ERACT)'="P" D SAVETQ^IBCNEUT2(TQN,RSRVDT)
"RTN","IBCNEHL1",200,0)
 ;. ; update freshness date by same delta
"RTN","IBCNEHL1",201,0)
 ;. D SAVFRSH^IBCNEUT5(TQN,+$$FMDIFF^XLFDT(RSRVDT,TQSRVDT,1))
"RTN","IBCNEHL1",202,0)
 ;
"RTN","IBCNEHL1",203,0)
 ;  Check for error action
"RTN","IBCNEHL1",204,0)
 I $G(ERACT)'=""!($G(ERTXT)'="") D ERROR^IBCNEHL3(TQN,ERACT,ERCON,TRACE) G FILX
"RTN","IBCNEHL1",205,0)
 ;
"RTN","IBCNEHL1",206,0)
 ; Stop processing if identification response and not an active policy
"RTN","IBCNEHL1",207,0)
 S FILEIT=1
"RTN","IBCNEHL1",208,0)
 I $G(IIVSTAT)=6,TQN]"" D
"RTN","IBCNEHL1",209,0)
 . I TQDATA="" Q
"RTN","IBCNEHL1",210,0)
 . I IBQFL'="I" Q
"RTN","IBCNEHL1",211,0)
 . S FILEIT=0
"RTN","IBCNEHL1",212,0)
 I 'FILEIT G FILX
"RTN","IBCNEHL1",213,0)
 ;
"RTN","IBCNEHL1",214,0)
 ;  If there is an associated buffer entry & one or both of the following
"RTN","IBCNEHL1",215,0)
 ;  is true, stop filing (don't update buffer entry)
"RTN","IBCNEHL1",216,0)
 ;  1) buffer status is not 'Entered'
"RTN","IBCNEHL1",217,0)
 ;  2) the buffer entry is verified (* symbol)
"RTN","IBCNEHL1",218,0)
 I BUFF'="",($P($G(^IBA(355.33,BUFF,0)),U,4)'="E")!($$SYMBOL^IBCNBLL(BUFF)="*") G FILX
"RTN","IBCNEHL1",219,0)
 ;
"RTN","IBCNEHL1",220,0)
 ;  Set buffer symbol based on value returned from EC
"RTN","IBCNEHL1",221,0)
 S SYMBOL=MAP(IIVSTAT)
"RTN","IBCNEHL1",222,0)
 ;
"RTN","IBCNEHL1",223,0)
 ;  If there is an associated buffer entry, update the buffer entry w/
"RTN","IBCNEHL1",224,0)
 ;  response data
"RTN","IBCNEHL1",225,0)
 I BUFF'="" D RP^IBCNEBF(RIEN,"",BUFF)
"RTN","IBCNEHL1",226,0)
 ;
"RTN","IBCNEHL1",227,0)
 ;  If no associated buffer entry, create one & populate w/ response
"RTN","IBCNEHL1",228,0)
 ;  data (routine call sets IBFDA)
"RTN","IBCNEHL1",229,0)
 I BUFF="" D RP^IBCNEBF(RIEN,1) S BUFF=+IBFDA,UP(365,RIEN_",",.04)=BUFF
"RTN","IBCNEHL1",230,0)
 ;
"RTN","IBCNEHL1",231,0)
 ;  Set eIV Processed Date to now
"RTN","IBCNEHL1",232,0)
 S UP(355.33,BUFF_",",.15)=$$NOW^XLFDT()
"RTN","IBCNEHL1",233,0)
 D FILE^DIE("I","UP","ERROR")
"RTN","IBCNEHL1",234,0)
FILX ;
"RTN","IBCNEHL1",235,0)
 Q
"RTN","IBCNEHL1",236,0)
 ;
"RTN","IBCNEHL1",237,0)
 ; =================================================================
"RTN","IBCNEHL1",238,0)
WARN ;  Create and send a response processing error warning message
"RTN","IBCNEHL1",239,0)
 ;
"RTN","IBCNEHL1",240,0)
 ; Input Variables
"RTN","IBCNEHL1",241,0)
 ; ERROR, TRACE
"RTN","IBCNEHL1",242,0)
 ;
"RTN","IBCNEHL1",243,0)
 ; Output Variables
"RTN","IBCNEHL1",244,0)
 ; ERFLG=1
"RTN","IBCNEHL1",245,0)
 ;
"RTN","IBCNEHL1",246,0)
 N MCT,MSG,SUBCNT,VEN,XMY
"RTN","IBCNEHL1",247,0)
 S VEN=0,MCT=8,ERFLG=1,SUBCNT=""
"RTN","IBCNEHL1",248,0)
 S MSG(1)="IMPORTANT: Error While Processing Response Message from the EC"
"RTN","IBCNEHL1",249,0)
 S MSG(2)="-------------------------------------------------------------"
"RTN","IBCNEHL1",250,0)
 S MSG(3)="*** IRM *** Please contact Help Desk because the"
"RTN","IBCNEHL1",251,0)
 S MSG(4)="response message received from the Eligibility Communicator"
"RTN","IBCNEHL1",252,0)
 S MSG(5)="could not be processed.  Programming changes may be necessary"
"RTN","IBCNEHL1",253,0)
 S MSG(6)="to properly handle the response."
"RTN","IBCNEHL1",254,0)
 S MSG(7)="The associated Trace # is "_$S($G(TRACE)="":"Unknown",1:TRACE)_". If applicable,"
"RTN","IBCNEHL1",255,0)
 S MSG(8)="please review the response with the eIV Response Report by Trace#."
"RTN","IBCNEHL1",256,0)
 F  S VEN=$O(ERROR("DIERR",VEN)) Q:'VEN  D
"RTN","IBCNEHL1",257,0)
 . F  S SUBCNT=$O(ERROR("DIERR",VEN,"TEXT",SUBCNT)) Q:'SUBCNT  D
"RTN","IBCNEHL1",258,0)
 . . S MCT=MCT+1,MSG(MCT)=ERROR("DIERR",VEN,"TEXT",SUBCNT)
"RTN","IBCNEHL1",259,0)
 . S MCT=MCT+1,MSG(MCT)=" "
"RTN","IBCNEHL1",260,0)
 D MSG^IBCNEUT5(MGRP,MSG(1),"MSG(",,.XMY)
"RTN","IBCNEHL1",261,0)
 Q
"RTN","IBCNEHL1",262,0)
 ;
"RTN","IBCNEHL1",263,0)
 ; =================================================================
"RTN","IBCNEHL1",264,0)
UEACT ; Send warning msg if Unknown Error Action Code was received or
"RTN","IBCNEHL1",265,0)
 ; encountered problem filing date
"RTN","IBCNEHL1",266,0)
 ;
"RTN","IBCNEHL1",267,0)
 ; Input Variables
"RTN","IBCNEHL1",268,0)
 ; ERROR, IBIEN, IBQFL, RIEN, RSTYPE, TQDATA, TRACE
"RTN","IBCNEHL1",269,0)
 ;
"RTN","IBCNEHL1",270,0)
 ; Output Variables
"RTN","IBCNEHL1",271,0)
 ; ERFLG=1 (SET IN WARN TAG)
"RTN","IBCNEHL1",272,0)
 ;
"RTN","IBCNEHL1",273,0)
 N DFN,SYMBOL
"RTN","IBCNEHL1",274,0)
 D WARN  ; send warning msg
"RTN","IBCNEHL1",275,0)
 ;
"RTN","IBCNEHL1",276,0)
 ; If the response could not be created or there is no associated TQ entry, stop processing
"RTN","IBCNEHL1",277,0)
 I '$G(RIEN)!(TQDATA="") Q
"RTN","IBCNEHL1",278,0)
 ;
"RTN","IBCNEHL1",279,0)
 ;  For an original response, set the Transmission Queue Status to 'Response Received' &
"RTN","IBCNEHL1",280,0)
 ;  update remaining retries to comm failure (5)
"RTN","IBCNEHL1",281,0)
 I $G(RSTYPE)="O" D SST^IBCNEUT2(TQN,3),RSTA^IBCNEUT7(TQN)
"RTN","IBCNEHL1",282,0)
 ;
"RTN","IBCNEHL1",283,0)
 ; If it is an identification and policy is not active don't
"RTN","IBCNEHL1",284,0)
 ; create buffer entry
"RTN","IBCNEHL1",285,0)
 I IBQFL="I",IIVSTAT'=1 Q
"RTN","IBCNEHL1",286,0)
 ;
"RTN","IBCNEHL1",287,0)
 ; If unsolicited message or no buffer in TQ, create new buffer entry
"RTN","IBCNEHL1",288,0)
 I RSTYPE="U" S IBIEN=""
"RTN","IBCNEHL1",289,0)
 I IBIEN="" D  Q
"RTN","IBCNEHL1",290,0)
 .  S DFN=$P(TQDATA,U,2)        ; Determine Patient DFN
"RTN","IBCNEHL1",291,0)
 .  S SYMBOL=22 D BUF^IBCNEHL3  ; Create a new buffer entry
"RTN","IBCNEHL1",292,0)
 ;
"RTN","IBCNEHL1",293,0)
 ;Update buffer symbol
"RTN","IBCNEHL1",294,0)
 D BUFF^IBCNEUT2(IBIEN,22)
"RTN","IBCNEHL1",295,0)
 ;
"RTN","IBCNEHL1",296,0)
 Q
"RTN","IBCNEHL1",297,0)
AUTOUPD(RIEN) ;
"RTN","IBCNEHL1",298,0)
 ; Returns "1^file 2 ien^file 2.312 ien^2nd file 2.312 ien^Medicare flag^subsriber flag", if entry
"RTN","IBCNEHL1",299,0)
 ; in file 365 is eligible for auto-update, returns 0 otherwise.
"RTN","IBCNEHL1",300,0)
 ;
"RTN","IBCNEHL1",301,0)
 ; Medicare flag: 1 for Medicare, 0 otherwise
"RTN","IBCNEHL1",302,0)
 ; Subscriber flag: 1 if patient is the subscriber, 0 otherwise
"RTN","IBCNEHL1",303,0)
 ;
"RTN","IBCNEHL1",304,0)
 ; For non-Medicare response: 1st file 2.312 ien is set, 2nd file 2.312 ien is empty, pieces 5-7 are empty
"RTN","IBCNEHL1",305,0)
 ; For Medicare response: 1st file 2.312 ien contains ien for Medicare Part A, 2nd file 2.312 ien contains ien for Medicare Part B,
"RTN","IBCNEHL1",306,0)
 ;                        either one may be empty, but at least one of them is set if entry is eligible.
"RTN","IBCNEHL1",307,0)
 ;
"RTN","IBCNEHL1",308,0)
 ; RIEN - ien in file 365
"RTN","IBCNEHL1",309,0)
 ;
"RTN","IBCNEHL1",310,0)
 N APPIEN,GDATA,GIEN,GNAME,GNUM,GOK,IEN2,IEN312,IEN36,IDATA0,IDATA3,ISSUB,MWNRA,MWNRB,MWNRIEN,MWNRTYP
"RTN","IBCNEHL1",311,0)
 N ONEPOL,PIEN,RDATA0,RDATA1,RES,TQIEN
"RTN","IBCNEHL1",312,0)
 S RES=0
"RTN","IBCNEHL1",313,0)
 I +$G(RIEN)'>0 Q RES  ; invalid ien for file 365
"RTN","IBCNEHL1",314,0)
 I $G(IIVSTAT)'=1 Q RES ; only auto-update 'active policy' responses
"RTN","IBCNEHL1",315,0)
 S RDATA0=$G(^IBCN(365,RIEN,0)),RDATA1=$G(^IBCN(365,RIEN,1))
"RTN","IBCNEHL1",316,0)
 S PIEN=$P(RDATA0,U,3) I +PIEN>0 S APPIEN=$$PYRAPP^IBCNEUT5("IIV",PIEN)
"RTN","IBCNEHL1",317,0)
 I +$G(APPIEN)'>0 Q RES  ; couldn't find eIV application entry
"RTN","IBCNEHL1",318,0)
 I $P(^IBE(365.12,PIEN,1,APPIEN,0),U,7)=0 Q RES  ; auto-accept is OFF
"RTN","IBCNEHL1",319,0)
 S IEN2=$P(RDATA0,U,2) I +IEN2'>0 Q RES  ; couldn't find patient
"RTN","IBCNEHL1",320,0)
 S MWNRIEN=$P($G(^IBE(350.9,1,51)),U,25),MWNRTYP=0,(MWNRA,MWNRB)=""
"RTN","IBCNEHL1",321,0)
 I PIEN=MWNRIEN S MWNRTYP=$$ISMCR^IBCNEHLU(RIEN)
"RTN","IBCNEHL1",322,0)
 S ONEPOL=$$ONEPOL^IBCNEHLU(PIEN,IEN2)
"RTN","IBCNEHL1",323,0)
 ; try to find a matching pat. insurance
"RTN","IBCNEHL1",324,0)
 S IEN36="" F  S IEN36=$O(^DIC(36,"AC",PIEN,IEN36)) Q:IEN36=""!(RES>0)  D
"RTN","IBCNEHL1",325,0)
 .S IEN312="" F  S IEN312=$O(^DPT(IEN2,.312,"B",IEN36,IEN312)) Q:IEN312=""!(RES>0&('+MWNRTYP))  D
"RTN","IBCNEHL1",326,0)
 ..S IDATA0=$G(^DPT(IEN2,.312,IEN312,0)),IDATA3=$G(^DPT(IEN2,.312,IEN312,3))
"RTN","IBCNEHL1",327,0)
 ..I $$EXPIRED^IBCNEDE2($P(IDATA0,U,4)) Q  ; Insurance policy has expired
"RTN","IBCNEHL1",328,0)
 ..S ISSUB=$$PATISSUB^IBCNEHLU(IDATA0)
"RTN","IBCNEHL1",329,0)
 ..; Patient is the subscriber
"RTN","IBCNEHL1",330,0)
 ..I ISSUB,'$$CHK1 Q
"RTN","IBCNEHL1",331,0)
 ..; Patient is the dependent
"RTN","IBCNEHL1",332,0)
 ..I 'ISSUB,'$$CHK2(MWNRTYP) Q
"RTN","IBCNEHL1",333,0)
 ..; check group number
"RTN","IBCNEHL1",334,0)
 ..S GNUM=$P(RDATA1,U,7),GIEN=+$P(IDATA0,U,18),GOK=1
"RTN","IBCNEHL1",335,0)
 ..; check non-Medicare group number
"RTN","IBCNEHL1",336,0)
 ..I '+MWNRTYP D  Q:'GOK  ; Group number doesn't match
"RTN","IBCNEHL1",337,0)
 ...I 'ONEPOL D
"RTN","IBCNEHL1",338,0)
 ....I GIEN'>0 S GOK=0 Q
"RTN","IBCNEHL1",339,0)
 ....S GNUM1=$P($G(^IBA(355.3,GIEN,0)),U,4)
"RTN","IBCNEHL1",340,0)
 ....I GNUM=""!(GNUM1="")!(GNUM'=GNUM1) S GOK=0
"RTN","IBCNEHL1",341,0)
 ....Q
"RTN","IBCNEHL1",342,0)
 ...I ONEPOL D
"RTN","IBCNEHL1",343,0)
 ....I GNUM'="",GIEN'="" S GNUM1=$P($G(^IBA(355.3,GIEN,0)),U,4) I GNUM1'="",GNUM'=GNUM1 S GOK=0
"RTN","IBCNEHL1",344,0)
 ....Q
"RTN","IBCNEHL1",345,0)
 ...Q
"RTN","IBCNEHL1",346,0)
 ..; check for Medicare part A/B
"RTN","IBCNEHL1",347,0)
 ..I +MWNRTYP D  Q:'GOK  ; Group number doesn't match
"RTN","IBCNEHL1",348,0)
 ...I GIEN'>0 S GOK=0 Q
"RTN","IBCNEHL1",349,0)
 ...S GDATA=$G(^IBA(355.3,GIEN,0))
"RTN","IBCNEHL1",350,0)
 ...I $P(GDATA,U,14)="A" D
"RTN","IBCNEHL1",351,0)
 ....I $P(MWNRTYP,U,2)="MA"!($P(MWNRTYP,U,2)="B") S MWNRA=IEN312 Q
"RTN","IBCNEHL1",352,0)
 ....S GOK=0
"RTN","IBCNEHL1",353,0)
 ....Q
"RTN","IBCNEHL1",354,0)
 ...I $P(GDATA,U,14)="B" D
"RTN","IBCNEHL1",355,0)
 ....I $P(MWNRTYP,U,2)="MB"!($P(MWNRTYP,U,2)="B") S MWNRB=IEN312 Q
"RTN","IBCNEHL1",356,0)
 ....S GOK=0
"RTN","IBCNEHL1",357,0)
 ....Q
"RTN","IBCNEHL1",358,0)
 ...Q
"RTN","IBCNEHL1",359,0)
 ..S RES=1_U_IEN2_U_$S(+MWNRTYP:MWNRA_U_MWNRB_U_1,1:IEN312_U_U_0)
"RTN","IBCNEHL1",360,0)
 ..S $P(RES,U,6)=ISSUB
"RTN","IBCNEHL1",361,0)
 ..Q
"RTN","IBCNEHL1",362,0)
 .Q
"RTN","IBCNEHL1",363,0)
 Q RES
"RTN","IBCNEHL1",364,0)
 ;
"RTN","IBCNEHL1",365,0)
CHK1() ; check auto-update criteria for patient who is the subscriber
"RTN","IBCNEHL1",366,0)
 ; called from tag AUTOUPD, uses variables defined there
"RTN","IBCNEHL1",367,0)
 ;
"RTN","IBCNEHL1",368,0)
 ; returns 1 if givent policy satisfies auto-update criteria, returns 0 otherwise
"RTN","IBCNEHL1",369,0)
 N RES
"RTN","IBCNEHL1",370,0)
 S RES=0
"RTN","IBCNEHL1",371,0)
 I $P(RDATA1,U,5)'=$P(IDATA0,U,2) G CHK1X  ; Subscriber ID doesn't match
"RTN","IBCNEHL1",372,0)
 I $P(RDATA1,U,2)'=$P(IDATA3,U) G CHK1X  ; DOB doesn't match
"RTN","IBCNEHL1",373,0)
 I '$$NAMECMP($P(RDATA1,U),$P(IDATA0,U,17)) G CHK1X  ; Insured's name doesn't match
"RTN","IBCNEHL1",374,0)
 S RES=1
"RTN","IBCNEHL1",375,0)
CHK1X ;
"RTN","IBCNEHL1",376,0)
 Q RES
"RTN","IBCNEHL1",377,0)
 ;
"RTN","IBCNEHL1",378,0)
CHK2(MWNRTYP) ; check auto-update criteria for patient who is not the subscriber
"RTN","IBCNEHL1",379,0)
 ; called from tag AUTOUPD, uses variables defined there
"RTN","IBCNEHL1",380,0)
 ;
"RTN","IBCNEHL1",381,0)
 ; returns 1 if policy satisfies auto-update criteria, returns 0 otherwise
"RTN","IBCNEHL1",382,0)
 N DOB,ID,IDATA5,IENS,NAME,PDOB,PNAME,RES
"RTN","IBCNEHL1",383,0)
 S RES=0
"RTN","IBCNEHL1",384,0)
 S IDATA5=$G(^DPT(IEN2,.312,IEN312,5))
"RTN","IBCNEHL1",385,0)
 S IENS=IEN2_","
"RTN","IBCNEHL1",386,0)
 S ID=$P(RDATA1,U,5)
"RTN","IBCNEHL1",387,0)
 I ID'=$P(IDATA0,U,2),ID'=$P(IDATA5,U) G CHK2X  ; both Subscriber ID and Patient ID don't match
"RTN","IBCNEHL1",388,0)
 S DOB=$P(RDATA1,U,2),PDOB=$$GET1^DIQ(2,IENS,.03,"I")
"RTN","IBCNEHL1",389,0)
 I DOB'=$P(IDATA3,U),DOB'=PDOB G CHK2X  ; both Subscriber and Patient DOB don't match
"RTN","IBCNEHL1",390,0)
 S NAME=$P(RDATA1,U),PNAME=$$GET1^DIQ(2,IENS,.01)
"RTN","IBCNEHL1",391,0)
 I '+MWNRTYP,'$$NAMECMP(NAME,$P(IDATA0,U,17)),'$$NAMECMP(NAME,PNAME) G CHK2X  ; non-Medicare, both Subscriber and Patient name don't match
"RTN","IBCNEHL1",392,0)
 I +MWNRTYP,'$$NAMECMP(NAME,PNAME) G CHK2X  ; Medicare, Ptient name doesn't match
"RTN","IBCNEHL1",393,0)
 S RES=1
"RTN","IBCNEHL1",394,0)
CHK2X ;
"RTN","IBCNEHL1",395,0)
 Q RES
"RTN","IBCNEHL1",396,0)
 ;
"RTN","IBCNEHL1",397,0)
PREL(CODE,EXCODE) ; convert pat. relationship to insured code to HIPAA
"RTN","IBCNEHL1",398,0)
 ; CODE - code to convert
"RTN","IBCNEHL1",399,0)
 ; EXCODE - existing VistA code either from 2.312/4.03 or 355.33/60.14
"RTN","IBCNEHL1",400,0)
 N CSTR,RES
"RTN","IBCNEHL1",401,0)
 S CSTR=".01.18.19." ; codes for self, spouse, and child
"RTN","IBCNEHL1",402,0)
 S RES="" I $G(CODE)="" Q RES  ; nothing to convert
"RTN","IBCNEHL1",403,0)
 I CODE="09" Q RES  ; code for "unknown" = no change
"RTN","IBCNEHL1",404,0)
 I CODE="34" S:CSTR[("."_$G(EXCODE)_".") RES="G8" Q RES  ; G8 if existing code is self/spouse/child, no change otherwise
"RTN","IBCNEHL1",405,0)
 S RES=$$PRELCNV^IBCNSP1(CODE,1)
"RTN","IBCNEHL1",406,0)
 Q RES
"RTN","IBCNEHL1",407,0)
 ;
"RTN","IBCNEHL1",408,0)
UPDIREC(RIEN,IEN312) ; update insurance record field in transmission queue (365.1/.13)
"RTN","IBCNEHL1",409,0)
 ; RIEN - ien in eIV Response file (365)
"RTN","IBCNEHL1",410,0)
 ; IEN312 - ien in pat. insurance multiple (2.312)
"RTN","IBCNEHL1",411,0)
 ;
"RTN","IBCNEHL1",412,0)
 N DATA,ERROR,IENS
"RTN","IBCNEHL1",413,0)
 I RIEN'>0!(IEN312'>0) Q
"RTN","IBCNEHL1",414,0)
 S IENS=$P($G(^IBCN(365,RIEN,0)),U,5)_"," I IENS="," Q
"RTN","IBCNEHL1",415,0)
 S DATA(365.1,IENS,.13)=IEN312
"RTN","IBCNEHL1",416,0)
 D FILE^DIE("ET","DATA","ERROR")
"RTN","IBCNEHL1",417,0)
 Q
"RTN","IBCNEHL1",418,0)
 ;
"RTN","IBCNEHL1",419,0)
EBFILE(DFN,IEN312,RIEN,AFLG) ; file eligibility/benefit data from file 365 into file 2.312
"RTN","IBCNEHL1",420,0)
 ; DFN - file 2 ien
"RTN","IBCNEHL1",421,0)
 ; IEN312 - file 2.312 ien
"RTN","IBCNEHL1",422,0)
 ; RIEN - file 365 ien
"RTN","IBCNEHL1",423,0)
 ; AFLG - 1 if called from autoupdate, 0 if called from ins. buffer process entry
"RTN","IBCNEHL1",424,0)
 ; Returns "" on success, ERFLG on failure. Also called from ACCEPT^IBCNBAR for manual processing of ins. buffer entry.
"RTN","IBCNEHL1",425,0)
 ;
"RTN","IBCNEHL1",426,0)
 ;
"RTN","IBCNEHL1",427,0)
 N DA,DIK,DATA,DATA1,EBIENS,ERFLG,ERROR,GIEN,GSKIP,IENROOT,IENS,IENSTR,TYPE,TYPE1,Z,Z1,Z2
"RTN","IBCNEHL1",428,0)
 ; delete existing EB data
"RTN","IBCNEHL1",429,0)
 S DIK="^DPT("_DFN_",.312,"_IEN312_",6,",DA(2)=DFN,DA(1)=IEN312
"RTN","IBCNEHL1",430,0)
 S Z="" F  S Z=$O(^DPT(DFN,.312,IEN312,6,"B",Z)) Q:Z=""  S DA=$O(^DPT(DFN,.312,IEN312,6,"B",Z,"")) D ^DIK
"RTN","IBCNEHL1",431,0)
 ; file new EB data
"RTN","IBCNEHL1",432,0)
 S IENSTR=IEN312_","_DFN_","
"RTN","IBCNEHL1",433,0)
 S GIEN=+$P($G(^DPT(DFN,.312,IEN312,0)),U,18)
"RTN","IBCNEHL1",434,0)
 S Z="" F  S Z=$O(^IBCN(365,RIEN,2,"B",Z)) Q:Z=""!$G(ERFLG)  D
"RTN","IBCNEHL1",435,0)
 .S EBIENS=$O(^IBCN(365,RIEN,2,"B",Z,""))_","_RIEN_","
"RTN","IBCNEHL1",436,0)
 .; if filing Medicare Part A/B data, make sure we only file the correct EB group
"RTN","IBCNEHL1",437,0)
 .S GSKIP=0 I GIEN>0 D
"RTN","IBCNEHL1",438,0)
 ..S TYPE=$$GET1^DIQ(365.02,EBIENS,.05)
"RTN","IBCNEHL1",439,0)
 ..S TYPE1=$P($G(^IBA(355.3,GIEN,0)),U,14)
"RTN","IBCNEHL1",440,0)
 ..I TYPE="MA",TYPE1="B" S GSKIP=1
"RTN","IBCNEHL1",441,0)
 ..I TYPE="MB",TYPE1="A" S GSKIP=1
"RTN","IBCNEHL1",442,0)
 ..Q
"RTN","IBCNEHL1",443,0)
 .I GSKIP Q  ; wrong Medicare Part A/B EB group - skip it
"RTN","IBCNEHL1",444,0)
 .D GETS^DIQ(365.02,EBIENS,"**",,"DATA","ERROR") I $D(ERROR) D:AFLG WARN Q
"RTN","IBCNEHL1",445,0)
 .; make sure we have data to file
"RTN","IBCNEHL1",446,0)
 .I '$D(DATA(365.02)) Q
"RTN","IBCNEHL1",447,0)
 .S IENS="+1,"_IENSTR,Z1=$O(DATA(365.02,"")) M DATA1(2.322,IENS)=DATA(365.02,Z1)
"RTN","IBCNEHL1",448,0)
 .D UPDATE^DIE("E","DATA1","IENROOT","ERROR") I $D(ERROR) D:AFLG WARN Q
"RTN","IBCNEHL1",449,0)
 .S IENS="+1,"_IENROOT(1)_","_IENSTR K DATA1,IENROOT
"RTN","IBCNEHL1",450,0)
 .S Z2="" F  S Z2=$O(DATA(365.26,Z2)) Q:Z2=""!$G(ERFLG)  D
"RTN","IBCNEHL1",451,0)
 ..M DATA1(2.3226,IENS)=DATA(365.26,Z2) D UPDATE^DIE("E","DATA1",,"ERROR") K DATA1 I $D(ERROR) D:AFLG WARN
"RTN","IBCNEHL1",452,0)
 ..Q
"RTN","IBCNEHL1",453,0)
 .S Z2="" F  S Z2=$O(DATA(365.27,Z2)) Q:Z2=""!$G(ERFLG)  D
"RTN","IBCNEHL1",454,0)
 ..M DATA1(2.3227,IENS)=DATA(365.27,Z2) D UPDATE^DIE("E","DATA1",,"ERROR") K DATA1 I $D(ERROR) D:AFLG WARN
"RTN","IBCNEHL1",455,0)
 ..Q
"RTN","IBCNEHL1",456,0)
 .S Z2="" F  S Z2=$O(DATA(365.28,Z2)) Q:Z2=""!$G(ERFLG)  D
"RTN","IBCNEHL1",457,0)
 ..M DATA1(2.3228,IENS)=DATA(365.28,Z2) D UPDATE^DIE("E","DATA1",,"ERROR") K DATA1 I $D(ERROR) D:AFLG WARN
"RTN","IBCNEHL1",458,0)
 ..Q
"RTN","IBCNEHL1",459,0)
 .S Z2="" F  S Z2=$O(DATA(365.29,Z2)) Q:Z2=""!$G(ERFLG)  D
"RTN","IBCNEHL1",460,0)
 ..M DATA1(2.3229,IENS)=DATA(365.29,Z2) D UPDATE^DIE("E","DATA1",,"ERROR") K DATA1 I $D(ERROR) D:AFLG WARN
"RTN","IBCNEHL1",461,0)
 ..Q
"RTN","IBCNEHL1",462,0)
 .S Z2="" F  S Z2=$O(DATA(365.291,Z2)) Q:Z2=""!$G(ERFLG)  D
"RTN","IBCNEHL1",463,0)
 ..M DATA1(2.32291,IENS)=DATA(365.291,Z2) D UPDATE^DIE("E","DATA1",,"ERROR") K DATA1 I $D(ERROR) D:AFLG WARN
"RTN","IBCNEHL1",464,0)
 ..Q
"RTN","IBCNEHL1",465,0)
 .K DATA
"RTN","IBCNEHL1",466,0)
 .Q
"RTN","IBCNEHL1",467,0)
 Q $G(ERFLG)
"RTN","IBCNEHL1",468,0)
 ;
"RTN","IBCNEHL1",469,0)
NAMECMP(NAME1,NAME2) ; check if 2 names have the same first name and last name components
"RTN","IBCNEHL1",470,0)
 ; NAME1, NAME2 - names to compare, should be in "last,first [middle]" format
"RTN","IBCNEHL1",471,0)
 ;
"RTN","IBCNEHL1",472,0)
 ; returns 1 if both first name and last name are the same between two names, returns 0 otherwise
"RTN","IBCNEHL1",473,0)
 N NM1,NM2,RES
"RTN","IBCNEHL1",474,0)
 S RES=0
"RTN","IBCNEHL1",475,0)
 S NM1=$$HLNAME^HLFNC(NAME1),NM2=$$HLNAME^HLFNC(NAME2)
"RTN","IBCNEHL1",476,0)
 I $P(NM1,U)=$P(NM2,U),$P(NM1,U,2)=$P(NM2,U,2) S RES=1
"RTN","IBCNEHL1",477,0)
 Q RES
"VER")
8.0^22.0
"BLD",7911,6)
^405
**END**
**END**
