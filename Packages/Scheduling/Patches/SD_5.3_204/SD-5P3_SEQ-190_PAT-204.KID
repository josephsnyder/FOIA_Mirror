Released SD*5.3*204 SEQ #190
Extracted from mail message
**KIDS**:SD*5.3*204^

**INSTALL NAME**
SD*5.3*204
"BLD",1931,0)
SD*5.3*204^SCHEDULING^0^3000218^y
"BLD",1931,1,0)
^^3^3^3000218^
"BLD",1931,1,1,0)
SD*5.3*204, Phase III NOIS fixes.
"BLD",1931,1,2,0)
 
"BLD",1931,1,3,0)
Release build. 
"BLD",1931,4,0)
^9.64PA^404.49^2
"BLD",1931,4,404.44,0)
404.44
"BLD",1931,4,404.44,2,0)
^9.641^404.44^1
"BLD",1931,4,404.44,2,404.44,0)
PCMM PARAMETER  (File-top level)
"BLD",1931,4,404.44,2,404.44,1,0)
^9.6411^15^2
"BLD",1931,4,404.44,2,404.44,1,14,0)
RPC TIME LIMIT
"BLD",1931,4,404.44,2,404.44,1,15,0)
HL7 TRANSMIT LIMIT
"BLD",1931,4,404.44,222)
y^n^p^^n^^n^o^n
"BLD",1931,4,404.49,0)
404.49
"BLD",1931,4,404.49,2,0)
^9.641^404.49^1
"BLD",1931,4,404.49,2,404.49,0)
PCMM HL7 ID  (File-top level)
"BLD",1931,4,404.49,2,404.49,1,0)
^9.6411^.02^1
"BLD",1931,4,404.49,2,404.49,1,.02,0)
INTEGRATION ID
"BLD",1931,4,404.49,222)
y^n^p^^^^n
"BLD",1931,4,"APDD",404.44,404.44)

"BLD",1931,4,"APDD",404.44,404.44,14)

"BLD",1931,4,"APDD",404.44,404.44,15)

"BLD",1931,4,"APDD",404.49,404.49)

"BLD",1931,4,"APDD",404.49,404.49,.02)

"BLD",1931,4,"B",404.44,404.44)

"BLD",1931,4,"B",404.49,404.49)

"BLD",1931,"ABNS",0)
^9.66A^^
"BLD",1931,"ABPKG")
n^y^G.PCMM DEVELOPERS@FORUM.VA.GOV
"BLD",1931,"INIT")
POST^SD53P204
"BLD",1931,"KRN",0)
^9.67PA^19^18
"BLD",1931,"KRN",.4,0)
.4
"BLD",1931,"KRN",.401,0)
.401
"BLD",1931,"KRN",.402,0)
.402
"BLD",1931,"KRN",.403,0)
.403
"BLD",1931,"KRN",.5,0)
.5
"BLD",1931,"KRN",.84,0)
.84
"BLD",1931,"KRN",3.6,0)
3.6
"BLD",1931,"KRN",3.8,0)
3.8
"BLD",1931,"KRN",9.2,0)
9.2
"BLD",1931,"KRN",9.8,0)
9.8
"BLD",1931,"KRN",9.8,"NM",0)
^9.68A^18^18
"BLD",1931,"KRN",9.8,"NM",1,0)
SCMCLK^^0^B49799907
"BLD",1931,"KRN",9.8,"NM",2,0)
SD53P204^^0^B2334712
"BLD",1931,"KRN",9.8,"NM",3,0)
SD53A204^^0^B9244900
"BLD",1931,"KRN",9.8,"NM",4,0)
SD53B204^^0^B7144281
"BLD",1931,"KRN",9.8,"NM",5,0)
SCMCCV5^^0^B13082921
"BLD",1931,"KRN",9.8,"NM",6,0)
SCAPMC8A^^0^B4309094
"BLD",1931,"KRN",9.8,"NM",7,0)
SCAPMCU3^^0^B21174319
"BLD",1931,"KRN",9.8,"NM",8,0)
SCUTBK3^^0^B13393151
"BLD",1931,"KRN",9.8,"NM",9,0)
SCMCUT^^0^B23756077
"BLD",1931,"KRN",9.8,"NM",10,0)
SCAPMC12^^0^B6077287
"BLD",1931,"KRN",9.8,"NM",11,0)
SCMCHL^^0^B18231654
"BLD",1931,"KRN",9.8,"NM",12,0)
SCMCHLB2^^0^B13614527
"BLD",1931,"KRN",9.8,"NM",13,0)
SCMCTPU2^^0^B8191584
"BLD",1931,"KRN",9.8,"NM",14,0)
SCMCHLE^^0^B5993237
"BLD",1931,"KRN",9.8,"NM",15,0)
SCMRBK^^0^B62054162
"BLD",1931,"KRN",9.8,"NM",16,0)
SCMCHLB^^0^B11493860
"BLD",1931,"KRN",9.8,"NM",17,0)
SCMCDD^^0^B43143272
"BLD",1931,"KRN",9.8,"NM",18,0)
SCMCDDA^^0^B2918971
"BLD",1931,"KRN",9.8,"NM","B","SCAPMC12",10)

"BLD",1931,"KRN",9.8,"NM","B","SCAPMC8A",6)

"BLD",1931,"KRN",9.8,"NM","B","SCAPMCU3",7)

"BLD",1931,"KRN",9.8,"NM","B","SCMCCV5",5)

"BLD",1931,"KRN",9.8,"NM","B","SCMCDD",17)

"BLD",1931,"KRN",9.8,"NM","B","SCMCDDA",18)

"BLD",1931,"KRN",9.8,"NM","B","SCMCHL",11)

"BLD",1931,"KRN",9.8,"NM","B","SCMCHLB",16)

"BLD",1931,"KRN",9.8,"NM","B","SCMCHLB2",12)

"BLD",1931,"KRN",9.8,"NM","B","SCMCHLE",14)

"BLD",1931,"KRN",9.8,"NM","B","SCMCLK",1)

"BLD",1931,"KRN",9.8,"NM","B","SCMCTPU2",13)

"BLD",1931,"KRN",9.8,"NM","B","SCMCUT",9)

"BLD",1931,"KRN",9.8,"NM","B","SCMRBK",15)

"BLD",1931,"KRN",9.8,"NM","B","SCUTBK3",8)

"BLD",1931,"KRN",9.8,"NM","B","SD53A204",3)

"BLD",1931,"KRN",9.8,"NM","B","SD53B204",4)

"BLD",1931,"KRN",9.8,"NM","B","SD53P204",2)

"BLD",1931,"KRN",19,0)
19
"BLD",1931,"KRN",19,"NM",0)
^9.68A^1^1
"BLD",1931,"KRN",19,"NM",1,0)
SCMC PCMM EDIT PRACTIT #404.52^^0
"BLD",1931,"KRN",19,"NM","B","SCMC PCMM EDIT PRACTIT #404.52",1)

"BLD",1931,"KRN",19.1,0)
19.1
"BLD",1931,"KRN",101,0)
101
"BLD",1931,"KRN",101,"NM",0)
^9.68A^1^1
"BLD",1931,"KRN",101,"NM",1,0)
SC DISPLAY TEAM INFO^^0
"BLD",1931,"KRN",101,"NM","B","SC DISPLAY TEAM INFO",1)

"BLD",1931,"KRN",409.61,0)
409.61
"BLD",1931,"KRN",771,0)
771
"BLD",1931,"KRN",869.2,0)
869.2
"BLD",1931,"KRN",870,0)
870
"BLD",1931,"KRN",8994,0)
8994
"BLD",1931,"KRN",8994,"NM",0)
^9.68A^1^1
"BLD",1931,"KRN",8994,"NM",1,0)
SCMC VERIFY C/S SYNC^^0
"BLD",1931,"KRN",8994,"NM","B","SCMC VERIFY C/S SYNC",1)

"BLD",1931,"KRN","B",.4,.4)

"BLD",1931,"KRN","B",.401,.401)

"BLD",1931,"KRN","B",.402,.402)

"BLD",1931,"KRN","B",.403,.403)

"BLD",1931,"KRN","B",.5,.5)

"BLD",1931,"KRN","B",.84,.84)

"BLD",1931,"KRN","B",3.6,3.6)

"BLD",1931,"KRN","B",3.8,3.8)

"BLD",1931,"KRN","B",9.2,9.2)

"BLD",1931,"KRN","B",9.8,9.8)

"BLD",1931,"KRN","B",19,19)

"BLD",1931,"KRN","B",19.1,19.1)

"BLD",1931,"KRN","B",101,101)

"BLD",1931,"KRN","B",409.61,409.61)

"BLD",1931,"KRN","B",771,771)

"BLD",1931,"KRN","B",869.2,869.2)

"BLD",1931,"KRN","B",870,870)

"BLD",1931,"KRN","B",8994,8994)

"BLD",1931,"PRE")
SD53P204
"BLD",1931,"QUES",0)
^9.62^^
"BLD",1931,"REQB",0)
^9.611^1^1
"BLD",1931,"REQB",1,0)
SD*5.3*209^2
"BLD",1931,"REQB","B","SD*5.3*209",1)

"FIA",404.44)
PCMM PARAMETER
"FIA",404.44,0)
^SCTM(404.44,
"FIA",404.44,0,0)
404.44
"FIA",404.44,0,1)
y^n^p^^n^^n^o^n
"FIA",404.44,0,10)

"FIA",404.44,0,11)

"FIA",404.44,0,"RLRO")

"FIA",404.44,0,"VR")
5.3^SD
"FIA",404.44,404.44)
1
"FIA",404.44,404.44,14)

"FIA",404.44,404.44,15)

"FIA",404.49)
PCMM HL7 ID
"FIA",404.49,0)
^SCPT(404.49,
"FIA",404.49,0,0)
404.49
"FIA",404.49,0,1)
y^n^p^^^^n
"FIA",404.49,0,10)

"FIA",404.49,0,11)

"FIA",404.49,0,"RLRO")

"FIA",404.49,0,"VR")
5.3^SD
"FIA",404.49,404.49)
1
"FIA",404.49,404.49,.02)

"INIT")
POST^SD53P204
"KRN",19,9064,-1)
0^1
"KRN",19,9064,0)
SCMC PCMM EDIT PRACTIT #404.52^PCMM Edit Practitioner in Position Assig. File^^R^^SC PCMM SETUP^^^^^^SCHEDULING
"KRN",19,9064,1,0)
^^2^2^2991206^^^^
"KRN",19,9064,1,1,0)
This option will allow a user to edit ONLY those entries that have an
"KRN",19,9064,1,2,0)
invalid pointer in the PRACTITIONER (#.03) field.
"KRN",19,9064,25)
EDIT^SCMCCV5
"KRN",19,9064,99.1)
58120,82872
"KRN",19,9064,"U")
PCMM EDIT PRACTITIONER IN POSI
"KRN",101,1632,-1)
0^1
"KRN",101,1632,0)
SC DISPLAY TEAM INFO^Display Team Information^^A^^^^^^^^SCHEDULING
"KRN",101,1632,1,0)
^^1^1^2990304^^^^
"KRN",101,1632,1,1,0)
Display team information for a selected patient.
"KRN",101,1632,10,0)
^101.01PA
"KRN",101,1632,15)
K ^TMP("SCTI",$J),TDFN
"KRN",101,1632,20)
D SEL^SCMCU1 S:$G(TDFN)'>0 VALMBCK="R" Q:$G(TDFN)'>0  D EN^VALM("SC TEAM INFORMATION")
"KRN",101,1632,99)
58101,51486
"KRN",8994,316,-1)
0^1
"KRN",8994,316,0)
SCMC VERIFY C/S SYNC^VERPAT^SCUTBK3^1^P
"KRN",8994,316,1,0)
^^2^2^2991209^^
"KRN",8994,316,1,1,0)
Successful result enables PCMM client to operate with PCMM server and
"KRN",8994,316,1,2,0)
returns the value to use for RPCTimeLimit.
"KRN",8994,316,2,0)
^8994.02A^1^1
"KRN",8994,316,2,1,0)
SCPATCH^1^60^1^1
"KRN",8994,316,2,1,1,0)
^^1^1^2991209^
"KRN",8994,316,2,1,1,1,0)
PatchVersion ^ ClientVersion
"KRN",8994,316,2,"B","SCPATCH",1)

"KRN",8994,316,2,"PARAMSEQ",1,1)

"KRN",8994,316,3,0)
^^2^2^2991209^
"KRN",8994,316,3,1,0)
Pre SD*5.3*204: 1 if client ok, else 0.
"KRN",8994,316,3,2,0)
Post SD*5.3*204: RPCTimeLimit [n30-300] if client ok, else 0.
"MBREQ")
0
"ORD",15,101)
101;15;;;PRO^XPDTA;PROF1^XPDIA;PROE1^XPDIA;PROF2^XPDIA;;PRODEL^XPDIA
"ORD",15,101,0)
PROTOCOL
"ORD",16,8994)
8994;16;1;;;;;;;RPCDEL^XPDIA1
"ORD",16,8994,0)
REMOTE PROCEDURE
"ORD",18,19)
19;18;;;OPT^XPDTA;OPTF1^XPDIA;OPTE1^XPDIA;OPTF2^XPDIA;;OPTDEL^XPDIA
"ORD",18,19,0)
OPTION
"PKG",16,-1)
1^1
"PKG",16,0)
SCHEDULING^SD^APPOINTMENTS,PROFILES,LETTERS,AMIS REPORTS
"PKG",16,20,0)
^9.402P^^
"PKG",16,22,0)
^9.49I^1^1
"PKG",16,22,1,0)
5.3^2941102
"PKG",16,22,1,"PAH",1,0)
204^3000218^109
"PKG",16,22,1,"PAH",1,1,0)
^^3^3^3000218
"PKG",16,22,1,"PAH",1,1,1,0)
SD*5.3*204, Phase III NOIS fixes.
"PKG",16,22,1,"PAH",1,1,2,0)
 
"PKG",16,22,1,"PAH",1,1,3,0)
Release build. 
"PRE")
SD53P204
"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
YES
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
YES
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
YES
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
18
"RTN","SCAPMC12")
0^10^B6077287
"RTN","SCAPMC12",1,0)
SCAPMC12 ;ALB/REW - Team API's: TPPR ; 2/10/00 8:14am
"RTN","SCAPMC12",2,0)
 ;;5.3;Scheduling;**41,204**;AUG 13, 1993
"RTN","SCAPMC12",3,0)
 ;;1.0
"RTN","SCAPMC12",4,0)
TPPR(SC200,SCDATES,SCPURPA,SCROLEA,SCLIST,SCERR) ; -- positions for a pract
"RTN","SCAPMC12",5,0)
 ; input:
"RTN","SCAPMC12",6,0)
 ; SC200 = ien of NEW PERSON file(#200) [required]
"RTN","SCAPMC12",7,0)
 ; SCDATES("BEGIN") = begin date to search (inclusive)
"RTN","SCAPMC12",8,0)
 ;                      [default: TODAY]
"RTN","SCAPMC12",9,0)
 ;        ("END")   = end date to search (inclusive)
"RTN","SCAPMC12",10,0)
 ;                      [default: TODAY]
"RTN","SCAPMC12",11,0)
 ;        ("INCL")  = 1: only use patients who were assigned to
"RTN","SCAPMC12",12,0)
 ;                       team for entire date range
"RTN","SCAPMC12",13,0)
 ;                    0: anytime in date range
"RTN","SCAPMC12",14,0)
 ;                      [default: 1] 
"RTN","SCAPMC12",15,0)
 ;  SCPURPA -array of pointers to team purpose file 403.47
"RTN","SCAPMC12",16,0)
 ;          if none are defined - returns all teams
"RTN","SCAPMC12",17,0)
 ;          if @SCPURPA@('exclude') is defined - exclude listed teams
"RTN","SCAPMC12",18,0)
 ;  SCROLEA - array of pointers to standard position file 403.46
"RTN","SCAPMC12",19,0)
 ;          if none are defined - returns all positions
"RTN","SCAPMC12",20,0)
 ;          if @SCROLEA@('exclude') is defined - exclude listed roles
"RTN","SCAPMC12",21,0)
 ;  SCLIST -array name to store list
"RTN","SCAPMC12",22,0)
 ;          [ex. ^TMP("SCPT",$J)]
"RTN","SCAPMC12",23,0)
 ;        
"RTN","SCAPMC12",24,0)
 ;  SCERR = array NAME to store error messages.
"RTN","SCAPMC12",25,0)
 ;          [ex. ^TMP("ORXX",$J)]
"RTN","SCAPMC12",26,0)
 ;
"RTN","SCAPMC12",27,0)
 ; Output:
"RTN","SCAPMC12",28,0)
 ;  SCLIST() = array of positions (includes SCTP xref)
"RTN","SCAPMC12",29,0)
 ;             Format:
"RTN","SCAPMC12",30,0)
 ;               Subscript: Sequential # from 1 to n
"RTN","SCAPMC12",31,0)
 ;               Piece     Description
"RTN","SCAPMC12",32,0)
 ;                 1       IEN of TEAM POSITION File (#404.57)
"RTN","SCAPMC12",33,0)
 ;                 2       Name of Position
"RTN","SCAPMC12",34,0)
 ;                 3       IEN of Team #404.51
"RTN","SCAPMC12",35,0)
 ;                 4       IEN of file #404.59 (Tm Pos History)
"RTN","SCAPMC12",36,0)
 ;                 5       current effective date
"RTN","SCAPMC12",37,0)
 ;                 6       current inactivate date (if any)
"RTN","SCAPMC12",38,0)
 ;                 7       pointer to 403.46 (role)
"RTN","SCAPMC12",39,0)
 ;                 8       Name of Standard Role
"RTN","SCAPMC12",40,0)
 ;                 9       pointer to User Class (#8930)
"RTN","SCAPMC12",41,0)
 ;                10       Name of User Class
"RTN","SCAPMC12",42,0)
 ;                Subscript: "SCTP",SCTM,IEN =""
"RTN","SCAPMC12",43,0)
 ;
"RTN","SCAPMC12",44,0)
 ;  SCERR() = Array of DIALOG file messages(errors) .
"RTN","SCAPMC12",45,0)
 ;  @SCERR@(0) = number of errors, undefined if none
"RTN","SCAPMC12",46,0)
 ;             Format:
"RTN","SCAPMC12",47,0)
 ;               Subscript: Sequential # from 1 to n
"RTN","SCAPMC12",48,0)
 ;               Piece     Description
"RTN","SCAPMC12",49,0)
 ;                 1       IEN of DIALOG file
"RTN","SCAPMC12",50,0)
 ;  Returned: 1 if ok, 0 if error
"RTN","SCAPMC12",51,0)
 ;
"RTN","SCAPMC12",52,0)
 ;
"RTN","SCAPMC12",53,0)
ST N SCTPA,SCTPA,SCTPA0,SCTP,SCR,SCACTHIS,SCTM,SCTPPR,SCPTA
"RTN","SCAPMC12",54,0)
 N SCLSEQ,SCN,SCESEQ,SCPARM,SCBEGIN,SCEND,SCINCL,SCDTS
"RTN","SCAPMC12",55,0)
 ; -- initialize control variables
"RTN","SCAPMC12",56,0)
 G:'$$OKDATA PRACQ
"RTN","SCAPMC12",57,0)
 ; -- loop through position assignment history
"RTN","SCAPMC12",58,0)
 S SCTPA=0
"RTN","SCAPMC12",59,0)
 F  S SCTPA=$O(^SCTM(404.52,"C",SC200,SCTPA)) Q:'SCTPA  D
"RTN","SCAPMC12",60,0)
 .S SCTPA0=$G(^SCTM(404.52,SCTPA,0))
"RTN","SCAPMC12",61,0)
 .S SCTP=+$P(SCTPA0,U,1)
"RTN","SCAPMC12",62,0)
 .Q:'SCTP
"RTN","SCAPMC12",63,0)
 .S SCTM=+$P($G(^SCTM(404.57,SCTP,0)),U,2)
"RTN","SCAPMC12",64,0)
 .Q:'SCTM
"RTN","SCAPMC12",65,0)
 .S SCACTHIS=$$ACTHIST^SCAPMCU2(404.52,SCTP,SCDATES,SCERR,"SCTPPR")
"RTN","SCAPMC12",66,0)
 .Q:'SCACTHIS
"RTN","SCAPMC12",67,0)
 .;
"RTN","SCAPMC12",68,0)
 .;djb/bp Next line fixes NOIS NOP-0499-11252 & ISA-0899-12551
"RTN","SCAPMC12",69,0)
 .Q:$P(SCACTHIS,"^",2)'=SCTPA
"RTN","SCAPMC12",70,0)
 .;
"RTN","SCAPMC12",71,0)
 .S SCP=+$P($G(^SCTM(404.51,+SCTM,0)),U,3)
"RTN","SCAPMC12",72,0)
 .Q:'$$OKARRAY^SCAPU1(.SCPURPA,.SCP)
"RTN","SCAPMC12",73,0)
 .S SCPTA=0
"RTN","SCAPMC12",74,0)
 .S SCR=+$P($G(^SCTM(404.57,SCTP,0)),U,3)
"RTN","SCAPMC12",75,0)
 .Q:'$$OKARRAY^SCAPU1(.SCROLEA,.SCR)
"RTN","SCAPMC12",76,0)
 .D BLD^SCAPMC24(.SCLIST,SCTM,SCTP,SCACTHIS,SCR)
"RTN","SCAPMC12",77,0)
PRACQ Q $G(@SCERR@(0))<1
"RTN","SCAPMC12",78,0)
 ;
"RTN","SCAPMC12",79,0)
OKDATA() ;setup/check variables
"RTN","SCAPMC12",80,0)
 N SCOK
"RTN","SCAPMC12",81,0)
 S SCOK=1
"RTN","SCAPMC12",82,0)
 D INIT^SCAPMCU1(.SCOK) ; set default dates & error array (if undefined)
"RTN","SCAPMC12",83,0)
 IF '$D(^VA(200,+$G(SC200),0)) D  S SCOK=0
"RTN","SCAPMC12",84,0)
 . S SCPARM("Practitioner")=$G(SC200,"Undefined")
"RTN","SCAPMC12",85,0)
 . D ERR^SCAPMCU1(.SCESEQ,4045101,.SCPARM,"",.SCERR)
"RTN","SCAPMC12",86,0)
 ;
"RTN","SCAPMC12",87,0)
 Q SCOK
"RTN","SCAPMC12",88,0)
 ;
"RTN","SCAPMC8A")
0^6^B4309094
"RTN","SCAPMC8A",1,0)
SCAPMC8A ;bp/cmf - Build "ALL" array for $$PRTP^SCAPCM8 ;13 June 1999
"RTN","SCAPMC8A",2,0)
 ;;5.3;Scheduling;**177,204**;AUG 13, 1993
"RTN","SCAPMC8A",3,0)
 ;
"RTN","SCAPMC8A",4,0)
TPALL(SCFILE) ;
"RTN","SCAPMC8A",5,0)
 N SCD1,SCD0,SCAN,SCX,SCIEN,SCFLD
"RTN","SCAPMC8A",6,0)
 N SCP1,SCP2,SCP3,SCP4,SCP5,SCP6,SCP7
"RTN","SCAPMC8A",7,0)
 ;
"RTN","SCAPMC8A",8,0)
 G:'$D(^SCTM(SCFILE,"B",SCTP)) TPQUIT
"RTN","SCAPMC8A",9,0)
 S SCD1=@SCDATES@("BEGIN")                  ;begin date range
"RTN","SCAPMC8A",10,0)
 S SCD0=@SCDATES@("END")                    ;end date range
"RTN","SCAPMC8A",11,0)
 ;
"RTN","SCAPMC8A",12,0)
LOOP S SCAN=0                                   ;incrementor
"RTN","SCAPMC8A",13,0)
 S SCP7=0                                   ;pos asgn ien
"RTN","SCAPMC8A",14,0)
 F  S SCP7=$O(^SCTM(SCFILE,"B",SCTP,SCP7)) Q:'SCP7  D
"RTN","SCAPMC8A",15,0)
 . N SCX,SCP1,SCP2,SCP3,SCP4,SCP5,SCP6
"RTN","SCAPMC8A",16,0)
 . Q:'$D(^SCTM(SCFILE,SCP7,0))
"RTN","SCAPMC8A",17,0)
 . S SCIEN=SCP7_","
"RTN","SCAPMC8A",18,0)
 . S SCFLD=$S(SCFILE=404.52:".02;.03;.04",1:".02;.04;.06")
"RTN","SCAPMC8A",19,0)
 . D GETS^DIQ(SCFILE,SCIEN,SCFLD,"IE","SCX")
"RTN","SCAPMC8A",20,0)
 . Q:'$D(SCX)
"RTN","SCAPMC8A",21,0)
 . S SCP3=$G(SCX(SCFILE,SCIEN,.02,"I"))         ;pos asgn date int
"RTN","SCAPMC8A",22,0)
 . Q:(SCP3<SCD1)!(SCP3>SCD0)
"RTN","SCAPMC8A",23,0)
 . S SCAN=SCAN+1
"RTN","SCAPMC8A",24,0)
 . S SCP1=$G(SCX(SCFILE,SCIEN,.04,"I"))         ;status int code
"RTN","SCAPMC8A",25,0)
 . S SCP2=$G(SCX(SCFILE,SCIEN,.04,"E"))         ;status ext form
"RTN","SCAPMC8A",26,0)
 . S SCP4=$G(SCX(SCFILE,SCIEN,.02,"E"))         ;pos asgn date ext
"RTN","SCAPMC8A",27,0)
 . D:SCFILE=404.52
"RTN","SCAPMC8A",28,0)
 . . S SCP5=$G(SCX(SCFILE,SCIEN,.03,"I"))         ;practition ien
"RTN","SCAPMC8A",29,0)
 . . S SCP6=$G(SCX(SCFILE,SCIEN,.03,"E"))         ;practitioner name
"RTN","SCAPMC8A",30,0)
 . . Q
"RTN","SCAPMC8A",31,0)
 . D:SCFILE=404.53
"RTN","SCAPMC8A",32,0)
 . . S SCP5=$G(SCX(SCFILE,SCIEN,.06,"I"))         ;precept posn ien
"RTN","SCAPMC8A",33,0)
 . . S SCP6=$G(SCX(SCFILE,SCIEN,.06,"E"))         ;precept posn name
"RTN","SCAPMC8A",34,0)
 . . Q
"RTN","SCAPMC8A",35,0)
 . S @SCLIST@("ALL",SCFILE,0)=SCAN
"RTN","SCAPMC8A",36,0)
 . S @SCLIST@("ALL",SCFILE,SCAN)=SCP1_U_SCP2_U_SCP3_U_SCP4_U_SCP5_U_SCP6_U_SCP7
"RTN","SCAPMC8A",37,0)
 ;
"RTN","SCAPMC8A",38,0)
TPQUIT Q
"RTN","SCAPMC8A",39,0)
 ;
"RTN","SCAPMCU3")
0^7^B21174319
"RTN","SCAPMCU3",1,0)
SCAPMCU3 ;MJK/ALB - AUTOLINK API ; 8/10/99 4:09pm
"RTN","SCAPMCU3",2,0)
 ;;5.3;Scheduling;**41,45,177,204**;AUG 13, 1993
"RTN","SCAPMCU3",3,0)
 ;
"RTN","SCAPMCU3",4,0)
GETREC(SCDATA,SCTEAM) ; -- get team record with autolink data
"RTN","SCAPMCU3",5,0)
 ; input  :    SCTEAM := ien of team
"RTN","SCAPMCU3",6,0)
 ; output : SCDATA is the return array
"RTN","SCAPMCU3",7,0)
 ;          SCDATA(0) := 0th node of Team
"RTN","SCAPMCU3",8,0)
 ;             (1..n) := autolink name ^ autolink type ^ ien of entity
"RTN","SCAPMCU3",9,0)
 ;
"RTN","SCAPMCU3",10,0)
 N SC,X
"RTN","SCAPMCU3",11,0)
 ; -- get 0th node of team
"RTN","SCAPMCU3",12,0)
 S X=$$GETEAM(SCTEAM)
"RTN","SCAPMCU3",13,0)
 ; -- add to return array
"RTN","SCAPMCU3",14,0)
 D SET(X,0,.SCDATA)
"RTN","SCAPMCU3",15,0)
 ; -- find all autolinks for team
"RTN","SCAPMCU3",16,0)
 D SCAN(SCTEAM,.SC)
"RTN","SCAPMCU3",17,0)
 ; -- build autolink string and add to return array
"RTN","SCAPMCU3",18,0)
 D BUILD(.SC,.SCDATA)
"RTN","SCAPMCU3",19,0)
 Q
"RTN","SCAPMCU3",20,0)
 ;
"RTN","SCAPMCU3",21,0)
BUILD(SC,SCDATA) ; -- build string to send and add to return array
"RTN","SCAPMCU3",22,0)
 N SCLINK,SCINC,X,SCGLB,SCTYPE
"RTN","SCAPMCU3",23,0)
 S SCINC=1
"RTN","SCAPMCU3",24,0)
 S SCLINK=""
"RTN","SCAPMCU3",25,0)
 F  S SCLINK=$O(SC(SCLINK)) Q:SCLINK=""  D
"RTN","SCAPMCU3",26,0)
 . S X=SCLINK
"RTN","SCAPMCU3",27,0)
 . IF X["DIC(42," S SCGLB="^DIC(42)",SCTYPE="WARD"
"RTN","SCAPMCU3",28,0)
 . IF X["DIC(45.7," S SCGLB="^DIC(45.7)",SCTYPE="SPECIALTY"
"RTN","SCAPMCU3",29,0)
 . IF X["VA(200," S SCGLB="^VA(200)",SCTYPE="PRACTITIONER"
"RTN","SCAPMCU3",30,0)
 . IF X["DG(405.4," S SCGLB="^DG(405.4)",SCTYPE="ROOM"
"RTN","SCAPMCU3",31,0)
 . IF X["SC(" S SCGLB="^SC",SCTYPE="CLINIC"
"RTN","SCAPMCU3",32,0)
 . ; - add data to return array
"RTN","SCAPMCU3",33,0)
 . IF $D(@SCGLB@(+SCLINK,0)) D SET($P(^(0),U)_U_SCTYPE_U_+SCLINK,.SCINC,.SCDATA)
"RTN","SCAPMCU3",34,0)
 Q
"RTN","SCAPMCU3",35,0)
 ;
"RTN","SCAPMCU3",36,0)
SET(X,INC,SCDATA) ; -- set value in return array
"RTN","SCAPMCU3",37,0)
 S INC=$G(INC)+1,SCDATA(INC)=X
"RTN","SCAPMCU3",38,0)
 Q
"RTN","SCAPMCU3",39,0)
 ;
"RTN","SCAPMCU3",40,0)
SETREC(SCOK,SCTEAM,SC) ; -- add/edit autolink data to Team record
"RTN","SCAPMCU3",41,0)
 ; input  :    SCTEAM := ien of team
"RTN","SCAPMCU3",42,0)
 ; output : SC is the input array
"RTN","SCAPMCU3",43,0)
 ;           SC(1..n) := autolink name ^ autolink type ^ ien of entity
"RTN","SCAPMCU3",44,0)
 ;
"RTN","SCAPMCU3",45,0)
 N SCTYPE,SCROOT,SCGLB,SCLINK,SCLINKI,SCI,SCOLD,SCNEW
"RTN","SCAPMCU3",46,0)
 ; -- build array of current autolink assignments
"RTN","SCAPMCU3",47,0)
 D SCAN(SCTEAM,.SCOLD)
"RTN","SCAPMCU3",48,0)
 ;
"RTN","SCAPMCU3",49,0)
 ; -- compare current with input  and add autolinks if in
"RTN","SCAPMCU3",50,0)
 ;    input array but not in current array
"RTN","SCAPMCU3",51,0)
 S SCI=0 F  S SCI=$O(SC(SCI)) Q:'SCI  S SCX=SC(SCI) D
"RTN","SCAPMCU3",52,0)
 . S SCTYPE=$P(SCX,U,2)
"RTN","SCAPMCU3",53,0)
 . D ROOT(SCTYPE,.SCROOT,.SCGLB)
"RTN","SCAPMCU3",54,0)
 . S SCLINK=+$P(SCX,U,3)_";"_SCROOT
"RTN","SCAPMCU3",55,0)
 . S SCNEW(SCLINK)=""
"RTN","SCAPMCU3",56,0)
 . IF '$D(SCOLD(SCLINK)),SCGLB]"",$D(@SCGLB@(+SCLINK,0)) D ADD(SCTEAM,SCLINK)
"RTN","SCAPMCU3",57,0)
 ;
"RTN","SCAPMCU3",58,0)
 ; -- compare current with input and delete autolinks if not
"RTN","SCAPMCU3",59,0)
 ;    in input array but in current array
"RTN","SCAPMCU3",60,0)
 S SCLINK=""
"RTN","SCAPMCU3",61,0)
 F  S SCLINK=$O(SCOLD(SCLINK)) Q:'SCLINK  IF '$D(SCNEW(SCLINK)) D
"RTN","SCAPMCU3",62,0)
 . S SCLINKI=+SCOLD(SCLINK)
"RTN","SCAPMCU3",63,0)
 . IF SCLINKI D DELETE(SCLINKI)
"RTN","SCAPMCU3",64,0)
 S SCOK=1
"RTN","SCAPMCU3",65,0)
 Q
"RTN","SCAPMCU3",66,0)
 ;
"RTN","SCAPMCU3",67,0)
ADD(SCTEAM,SCLINK) ; -- add an autolink to a Team
"RTN","SCAPMCU3",68,0)
 N DIC,DD,DO,DLAYGO
"RTN","SCAPMCU3",69,0)
 S DIC="^SCTM(404.56,",DLAYGO=404.56,DIC(0)="L",X=SCTEAM,DIC("DR")=".02////^S X=SCLINK"
"RTN","SCAPMCU3",70,0)
 D FILE^DICN
"RTN","SCAPMCU3",71,0)
 Q
"RTN","SCAPMCU3",72,0)
 ;
"RTN","SCAPMCU3",73,0)
DELETE(SCLINKI) ; -- delete an autolink from a Team
"RTN","SCAPMCU3",74,0)
 N DIK,DA
"RTN","SCAPMCU3",75,0)
 IF $D(^SCTM(404.56,SCLINKI,0)) D
"RTN","SCAPMCU3",76,0)
 . S DIK="^SCTM(404.56,",DA=SCLINKI D ^DIK
"RTN","SCAPMCU3",77,0)
 Q
"RTN","SCAPMCU3",78,0)
 ;
"RTN","SCAPMCU3",79,0)
GETEAM(SCTEAM) ; -- retrieve Team demographics
"RTN","SCAPMCU3",80,0)
 Q $G(^SCTM(404.51,+$G(SCTEAM),0))
"RTN","SCAPMCU3",81,0)
 ;
"RTN","SCAPMCU3",82,0)
SCAN(SCTEAM,SC) ; -- build an array of current autolink assignments
"RTN","SCAPMCU3",83,0)
 N SCLINK
"RTN","SCAPMCU3",84,0)
 S SCLINK=""
"RTN","SCAPMCU3",85,0)
 F  S SCLINK=$O(^SCTM(404.56,"APRIMARY",+$G(SCTEAM),SCLINK)) Q:SCLINK=""  S SC(SCLINK)=+$O(^(SCLINK,0))
"RTN","SCAPMCU3",86,0)
 Q
"RTN","SCAPMCU3",87,0)
 ;
"RTN","SCAPMCU3",88,0)
ROOT(SCTYPE,SCROOT,SCGLB) ; -- determine global root of autolink type
"RTN","SCAPMCU3",89,0)
 S (SCROOT,SCGLB)=""
"RTN","SCAPMCU3",90,0)
 IF SCTYPE="WARD" S SCROOT="DIC(42,",SCGLB="^DIC(42)"
"RTN","SCAPMCU3",91,0)
 IF SCTYPE="SPECIALTY" S SCROOT="DIC(45.7,",SCGLB="^DIC(45.7)"
"RTN","SCAPMCU3",92,0)
 IF SCTYPE="PRACTITIONER" S SCROOT="VA(200,",SCGLB="^VA(200)"
"RTN","SCAPMCU3",93,0)
 IF SCTYPE="ROOM" S SCROOT="DG(405.4,",SCGLB="^DG(405.4)"
"RTN","SCAPMCU3",94,0)
 IF SCTYPE="CLINIC" S SCROOT="SC(",SCGLB="^SC"
"RTN","SCAPMCU3",95,0)
 Q
"RTN","SCAPMCU3",96,0)
 ;
"RTN","SCAPMCU3",97,0)
GETLINK(SC,SCTYPE,SCIEN) ; -- get autolink entity data
"RTN","SCAPMCU3",98,0)
 ;  input:  SCTYPE   := type of autolink (WARD, SPECIALTY, ectc.)
"RTN","SCAPMCU3",99,0)
 ;          SCIEN    := ien of entity
"RTN","SCAPMCU3",100,0)
 ; output:  SC(1..n) := list of Team names autolinked to entity
"RTN","SCAPMCU3",101,0)
 ;                    
"RTN","SCAPMCU3",102,0)
 ;
"RTN","SCAPMCU3",103,0)
 N SCTEAM,SCROOT,SCGLB,SCINC,SCLINK
"RTN","SCAPMCU3",104,0)
 ; -- deterine global root for autolink entity
"RTN","SCAPMCU3",105,0)
 D ROOT(SCTYPE,.SCROOT,.SCGLB)
"RTN","SCAPMCU3",106,0)
 ; -- set variable pointer value for autolink entity
"RTN","SCAPMCU3",107,0)
 S SCLINK=+SCIEN_";"_$G(SCROOT)
"RTN","SCAPMCU3",108,0)
 ; -- find Teams with autolinks to this entity
"RTN","SCAPMCU3",109,0)
 S (SCINC,SCTEAM)=0
"RTN","SCAPMCU3",110,0)
 IF $O(^SCTM(404.56,"AC",SCLINK,SCTEAM)) D
"RTN","SCAPMCU3",111,0)
 . F  S SCTEAM=$O(^SCTM(404.56,"AC",SCLINK,SCTEAM)) Q:'SCTEAM  D
"RTN","SCAPMCU3",112,0)
 . . S SCINC=SCINC+1
"RTN","SCAPMCU3",113,0)
 . . S SC(SCINC)=$P($G(^SCTM(404.51,SCTEAM,0)),U)
"RTN","SCAPMCU3",114,0)
 ELSE  D
"RTN","SCAPMCU3",115,0)
 . S SCINC=SCINC+1
"RTN","SCAPMCU3",116,0)
 . S SC(SCINC)="No links found."
"RTN","SCAPMCU3",117,0)
 Q
"RTN","SCAPMCU3",118,0)
 ;
"RTN","SCAPMCU3",119,0)
PCPROV(SCTP,DATE,PCAP) ;returns ien & name of practitioner filling position
"RTN","SCAPMCU3",120,0)
 ;Input: SCTP=team position ifn of primary care position assignment
"RTN","SCAPMCU3",121,0)
 ;Input: DATE=relevant date
"RTN","SCAPMCU3",122,0)
 ;Input: PCAP= '1' for pc provider
"RTN","SCAPMCU3",123,0)
 ;             '2' for attending provider
"RTN","SCAPMCU3",124,0)
 ;             '3' for pc associate provider
"RTN","SCAPMCU3",125,0)
 ;
"RTN","SCAPMCU3",126,0)
 ;   Returned [Error or None Found:"", Else: sc200^practname]
"RTN","SCAPMCU3",127,0)
 ;
"RTN","SCAPMCU3",128,0)
 N X,SCPRDTS,SCPR,SCPP,ERR,SCI,SCII,SCPRX,SCSUB,SCX,SCY
"RTN","SCAPMCU3",129,0)
 S SCPP=0,DATE=$G(DATE,DT),SCPRDTS("INCL")=0
"RTN","SCAPMCU3",130,0)
 S (SCPRDTS("BEGIN"),SCPRDTS("END"))=DATE
"RTN","SCAPMCU3",131,0)
 ;bp/cmf 204 original code next line [SCALLHIS param not needed]
"RTN","SCAPMCU3",132,0)
 ;S X=$$PRTPC^SCAPMC(SCTP,"SCPRDTS","SCPR","ERR",1,0)
"RTN","SCAPMCU3",133,0)
 ;bp/cmf 204 change code next line
"RTN","SCAPMCU3",134,0)
 S X=$$PRTPC^SCAPMC(SCTP,"SCPRDTS","SCPR","ERR",0,0)
"RTN","SCAPMCU3",135,0)
 ;regroup providers
"RTN","SCAPMCU3",136,0)
 S SCI=0 F  S SCI=$O(SCPR(SCI)) Q:'SCI  D
"RTN","SCAPMCU3",137,0)
 .S SCSUB="" F  S SCSUB=$O(SCPR(SCI,SCSUB)) Q:SCSUB=""  D
"RTN","SCAPMCU3",138,0)
 ..I SCSUB="PREC" S SCPP=1 Q:PCAP=3  ;precepted position flag
"RTN","SCAPMCU3",139,0)
 ..S SCII="" F  S SCII=$O(SCPR(SCI,SCSUB,SCII)) Q:SCII=""  D
"RTN","SCAPMCU3",140,0)
 ...S SCX=$P(SCPR(SCI,SCSUB,SCII),U,1,2) Q:'SCX
"RTN","SCAPMCU3",141,0)
 ...S SCY=$S(PCAP=2:$P(SCSUB,"-"),1:SCSUB)
"RTN","SCAPMCU3",142,0)
 ...S SCPRX(SCY)=$G(SCPRX(SCY))+1,SCPRX(SCY,SCPRX(SCY))=SCX
"RTN","SCAPMCU3",143,0)
 ...Q
"RTN","SCAPMCU3",144,0)
 ..Q
"RTN","SCAPMCU3",145,0)
 .Q
"RTN","SCAPMCU3",146,0)
 ;return preceptor pc provider
"RTN","SCAPMCU3",147,0)
 I PCAP=1,SCPP,$G(SCPRX("PREC"))=1 Q SCPRX("PREC",1)
"RTN","SCAPMCU3",148,0)
 ;return non-preceptor pc provider
"RTN","SCAPMCU3",149,0)
 I PCAP=1,'SCPP,$G(SCPRX("PROV-U"))=1 Q SCPRX("PROV-U",1)
"RTN","SCAPMCU3",150,0)
 ;return attending provider
"RTN","SCAPMCU3",151,0)
 I PCAP=2,$G(SCPRX("PROV"))=1 Q SCPRX("PROV",1)
"RTN","SCAPMCU3",152,0)
 ;return associate provider
"RTN","SCAPMCU3",153,0)
 I PCAP=3,SCPP,$G(SCPRX("PROV-P"))=1 Q SCPRX("PROV-P",1)
"RTN","SCAPMCU3",154,0)
 ;bp/cmf 204 original code next line [-1 busts documented output]
"RTN","SCAPMCU3",155,0)
 ;Q -1
"RTN","SCAPMCU3",156,0)
 ;bp/cmf 204 change code next line ["" is documented output]
"RTN","SCAPMCU3",157,0)
 Q ""
"RTN","SCMCCV5")
0^5^B13082921
"RTN","SCMCCV5",1,0)
SCMCCV5 ;ALB/JAM;Allow edits of invalid .03 field in 404.52;12/1/99@1055
"RTN","SCMCCV5",2,0)
 ;;5.3;Scheduling;**204**;DEC 01, 1999
"RTN","SCMCCV5",3,0)
 ;
"RTN","SCMCCV5",4,0)
EDIT ;Entry point for cnahes to .03 field in file 404.52
"RTN","SCMCCV5",5,0)
 N SCEND
"RTN","SCMCCV5",6,0)
 D HDR(0)
"RTN","SCMCCV5",7,0)
 S SCEND=0
"RTN","SCMCCV5",8,0)
 F  D PROCESS I SCEND Q
"RTN","SCMCCV5",9,0)
 K DIE,^TMP("PCMM PRACTITIONER",$J),DTOUT,DUOUT,DIROUT,DR,DA,X,Y
"RTN","SCMCCV5",10,0)
 Q
"RTN","SCMCCV5",11,0)
 ;
"RTN","SCMCCV5",12,0)
PROCESS ;Get list of invalid .03 field in file 404.52, select and then edit
"RTN","SCMCCV5",13,0)
 N SCIEN,FND
"RTN","SCMCCV5",14,0)
 K ^TMP("PCMM PRACTITIONER",$J)
"RTN","SCMCCV5",15,0)
 S FND=$$LST()
"RTN","SCMCCV5",16,0)
 I 'FND W "No Entries found" S SCEND=1 Q
"RTN","SCMCCV5",17,0)
 ;select a valid IEN to edit
"RTN","SCMCCV5",18,0)
 S SCIEN=$$GETIEN() I 'SCIEN S SCEND=1 Q
"RTN","SCMCCV5",19,0)
 ;edit .03 field
"RTN","SCMCCV5",20,0)
REP D TPHIS(SCIEN)
"RTN","SCMCCV5",21,0)
 K DA,DR,DIE S DIE="^SCTM(404.52,",DA=SCIEN
"RTN","SCMCCV5",22,0)
 S DR=".03Practitioner" D ^DIE K DR
"RTN","SCMCCV5",23,0)
 I $D(DTOUT)!($D(DUOUT)) S SCEND=1 Q
"RTN","SCMCCV5",24,0)
 I $G(Y)<0 Q
"RTN","SCMCCV5",25,0)
 ;verify practitioner response
"RTN","SCMCCV5",26,0)
 K DA,DIR,DIROUT,DIRUT,DTOUT,DUOUT
"RTN","SCMCCV5",27,0)
 S DIR(0)="Y",DIR("A")="         ...OK",DIR("B")="Yes"
"RTN","SCMCCV5",28,0)
 S DIR("?")="Enter Yes or <RT> to accept or No to change response"
"RTN","SCMCCV5",29,0)
 D ^DIR K DIR I Y Q
"RTN","SCMCCV5",30,0)
 I $D(DTOUT)!$D(DUOUT)!($D(DIROUT)) Q
"RTN","SCMCCV5",31,0)
 G REP
"RTN","SCMCCV5",32,0)
 Q
"RTN","SCMCCV5",33,0)
 ;
"RTN","SCMCCV5",34,0)
GETIEN() ;Select IEN from FILE 404.52
"RTN","SCMCCV5",35,0)
 N DIR,X,Y
"RTN","SCMCCV5",36,0)
 S DIR("A")="Select IEN",DIR("?")="^D LSTIEN^SCMCCV5"
"RTN","SCMCCV5",37,0)
 S DIR(0)="FO^^K:'$D(^TMP(""PCMM PRACTITIONER"",$J,X)) X"
"RTN","SCMCCV5",38,0)
 D ^DIR I $D(DIRUT) Q 0
"RTN","SCMCCV5",39,0)
 D DSP(X)
"RTN","SCMCCV5",40,0)
 Q X
"RTN","SCMCCV5",41,0)
 ;
"RTN","SCMCCV5",42,0)
LSTIEN ;Display a list of .03 entries stored in ^TMP("PCMM PRACTITIONER",$J
"RTN","SCMCCV5",43,0)
 N IEN,SCSTP
"RTN","SCMCCV5",44,0)
 S (IEN,SCSTP)=0
"RTN","SCMCCV5",45,0)
 D HDR(1)
"RTN","SCMCCV5",46,0)
 F  S IEN=$O(^TMP("PCMM PRACTITIONER",$J,IEN)) Q:'IEN  D  I SCSTP Q
"RTN","SCMCCV5",47,0)
 . I ($Y+3>IOSL) D  I 'Y S SCSTP=1 Q
"RTN","SCMCCV5",48,0)
 . . S DIR(0)="E",DIR("A")="Enter RETURN to continue or '^' to exit"
"RTN","SCMCCV5",49,0)
 . . D ^DIR D:Y HDR(1)
"RTN","SCMCCV5",50,0)
 . D DSP(IEN)
"RTN","SCMCCV5",51,0)
 I 'SCSTP W !,?20,"To Edit, enter an IEN number from the displayed list"
"RTN","SCMCCV5",52,0)
 Q
"RTN","SCMCCV5",53,0)
 ;
"RTN","SCMCCV5",54,0)
HDR(FL) ;Print header for list of invalid entries in file 404.52
"RTN","SCMCCV5",55,0)
 W @IOF
"RTN","SCMCCV5",56,0)
 W !,?23,$S(FL:"LIST OF",1:"EDITING")_" INVALID PRACTITIONER ENTRY",!!
"RTN","SCMCCV5",57,0)
 I FL D
"RTN","SCMCCV5",58,0)
 . W ?20,"IEN",?27,"Effective Date",?44,"Team",?68,"Status",!
"RTN","SCMCCV5",59,0)
 . W ?20,"---",?27,"--------------",?44,"----",?68,"------",!
"RTN","SCMCCV5",60,0)
 Q
"RTN","SCMCCV5",61,0)
 ;
"RTN","SCMCCV5",62,0)
DSP(DIEN) ;Display record from file 404.52 for DIEN entry
"RTN","SCMCCV5",63,0)
 N SCDAT,SCDT,SCSTA,SCTP
"RTN","SCMCCV5",64,0)
 I $G(DIEN)="" Q
"RTN","SCMCCV5",65,0)
 S SCDAT=$G(^SCTM(404.52,DIEN,0)),Y=$P(SCDAT,U,2) X ^DD("DD") S SCDT=Y
"RTN","SCMCCV5",66,0)
 S SCTP=$P(SCDAT,U) S:SCTP'="" SCTP=$P($G(^SCTM(404.57,SCTP,0)),U)
"RTN","SCMCCV5",67,0)
 S SCSTA=$S($P(SCDAT,U,4):"Active",1:"Inactive")
"RTN","SCMCCV5",68,0)
 W ?20,DIEN,?27,SCDT,?44,$E(SCTP,1,20),?68,SCSTA,!
"RTN","SCMCCV5",69,0)
 Q
"RTN","SCMCCV5",70,0)
 ;
"RTN","SCMCCV5",71,0)
TPHIS(SCIEN) ;Display complete position history for team position
"RTN","SCMCCV5",72,0)
 N ZDATE,ZLIST,ZERROR,SCX,SCY,TP,C,SCSTP,SCNAM
"RTN","SCMCCV5",73,0)
 S TP=$P(^SCTM(404.52,SCIEN,0),U) I TP="" Q
"RTN","SCMCCV5",74,0)
 S ZDATE("BEGIN")=1,ZDATE("END")=9999999,ZDATE("INCL")=0,SCSTP=0,C=1
"RTN","SCMCCV5",75,0)
 S SCX=$$PRTP^SCAPMC(TP,"ZDATE","ZLIST","ZERROR",0,1)
"RTN","SCMCCV5",76,0)
 I 'SCX!($D(ZERROR)) Q
"RTN","SCMCCV5",77,0)
 W !?25,"TEAM POSITION HISTORY"
"RTN","SCMCCV5",78,0)
 W !?10,"Effective Date",?30,"Staff",?54,"Status",!
"RTN","SCMCCV5",79,0)
 S SCX=0 F  S SCX=$O(ZLIST("ALL",404.52,SCX)) Q:'SCX  D  I SCSTP Q
"RTN","SCMCCV5",80,0)
 . S SCY=ZLIST("ALL",404.52,SCX),SCNAM=$P(SCY,U,6),C=C+1
"RTN","SCMCCV5",81,0)
 . I '(C#10) S DIR(0)="E" D ^DIR W ! I 'Y S SCSTP=1 Q
"RTN","SCMCCV5",82,0)
 . W:SCNAM="" ?6,"***"
"RTN","SCMCCV5",83,0)
 . W ?10,$P(SCY,U,4),?30,$E(SCNAM,1,20),?54,$P(SCY,U,2)
"RTN","SCMCCV5",84,0)
 . W:SCNAM="" " ***" W !
"RTN","SCMCCV5",85,0)
 Q
"RTN","SCMCCV5",86,0)
 ;
"RTN","SCMCCV5",87,0)
LST() ;Returns list of invalid entries from file #404.52 for field .03
"RTN","SCMCCV5",88,0)
 ;This subroutine checks the POSITION ASSIGNMENT HISTORY FILE (#404.52)
"RTN","SCMCCV5",89,0)
 ;for invalid pointers stored in the PRACTITIONER field (#.03) and
"RTN","SCMCCV5",90,0)
 ;returns a list of all such entries ien.
"RTN","SCMCCV5",91,0)
 ;
"RTN","SCMCCV5",92,0)
 ; Output:-  
"RTN","SCMCCV5",93,0)
 ;    ^TMP("PCMM PRACTITIONER",$J,IEN - Name of array to return list
"RTN","SCMCCV5",94,0)
 ;                                      Array subsripted by ien number
"RTN","SCMCCV5",95,0)
 ;     Returns - 1 if entry found, 0 no entry found
"RTN","SCMCCV5",96,0)
 ;
"RTN","SCMCCV5",97,0)
 N IEN,PRAC
"RTN","SCMCCV5",98,0)
 S IEN=0
"RTN","SCMCCV5",99,0)
 F  S IEN=$O(^SCTM(404.52,IEN)) Q:'IEN  I $G(^SCTM(404.52,IEN,0))'="" D
"RTN","SCMCCV5",100,0)
 . S PRAC=$P(^SCTM(404.52,IEN,0),U,3)
"RTN","SCMCCV5",101,0)
 . I PRAC<0!('$D(^VA(200,PRAC))) S ^TMP("PCMM PRACTITIONER",$J,IEN)="" Q
"RTN","SCMCCV5",102,0)
 . I $D(^USR(8930.3,"B",PRAC))!('$$USEUSR^SCMCTPU) Q
"RTN","SCMCCV5",103,0)
 . S ^TMP("PCMM PRACTITIONER",$J,IEN)=""
"RTN","SCMCCV5",104,0)
 Q $S($D(^TMP("PCMM PRACTITIONER",$J)):1,1:0)
"RTN","SCMCDD")
0^17^B43143272
"RTN","SCMCDD",1,0)
SCMCDD ;ALB/REW - DD Calls used by PCMM ; 6 November 1995
"RTN","SCMCDD",2,0)
 ;;5.3;Scheduling;**41,51,177,204**;AUG 13, 1993
"RTN","SCMCDD",3,0)
 ;1
"RTN","SCMCDD",4,0)
NEWHIST(FILE,IEN,DATE,SCERR,STATUS) ; PCMM history files - new record's dt & status
"RTN","SCMCDD",5,0)
 ; Complete
"RTN","SCMCDD",6,0)
 ; input:
"RTN","SCMCDD",7,0)
 ;   FILE   = 404.52,404.53,404.58, or 404.59
"RTN","SCMCDD",8,0)
 ;   IEN    = if file=404.58 - pointer to 404.51
"RTN","SCMCDD",9,0)
 ;            otherwise      - pointer to 404.57
"RTN","SCMCDD",10,0)
 ;   DATE   = effective date
"RTN","SCMCDD",11,0)
 ;   SCERR  = [default = "SCERR"]
"RTN","SCMCDD",12,0)
 ;   STATUS = [optional] 1=active/0=inactive - IF undefined don't check
"RTN","SCMCDD",13,0)
 ; output:
"RTN","SCMCDD",14,0)
 ;   Returned: 1 if ok to add, 0 if not^message^external
"RTN","SCMCDD",15,0)
 ;  Note: For 404.52: special case
"RTN","SCMCDD",16,0)
 ;   @scerr = error message array
"RTN","SCMCDD",17,0)
 N SCDATES,SCX,SCOK,DIERR,SCLASTDT,Y,X
"RTN","SCMCDD",18,0)
 N SCLSEQ,SCN,SCESEQ,SCPARM,SCP,SCBEGIN,SCEND,SCINCL,SCDTS
"RTN","SCMCDD",19,0)
 S SCOK=1
"RTN","SCMCDD",20,0)
 ;verify date is after last date
"RTN","SCMCDD",21,0)
 S SCLASTDT=$$LASTDATE^SCAPMCU1(FILE,IEN)
"RTN","SCMCDD",22,0)
 IF SCLASTDT&(SCLASTDT'<DATE) D  G QTNWHIST
"RTN","SCMCDD",23,0)
 .S Y=SCLASTDT D DD^%DT
"RTN","SCMCDD",24,0)
 .S SCOK="0^New Date is not after last historical date("_Y_")"_U_SCLASTDT
"RTN","SCMCDD",25,0)
 S SCX=$$DATES^SCAPMCU1(FILE,IEN,DATE)
"RTN","SCMCDD",26,0)
 IF SCX<0 D  G QTNWHIST
"RTN","SCMCDD",27,0)
 .S SCOK=0_U_"Error in ACTHIST call"
"RTN","SCMCDD",28,0)
 .S SCPARM("NEW ENTRY")="Error in ACTHIST call"
"RTN","SCMCDD",29,0)
 .D ERR^SCAPMCU1(.SCESEQ,4045101,.SCPARM,"",.SCERR)
"RTN","SCMCDD",30,0)
 IF DATE'>$P(SCX,U,2)!(DATE'>$P(SCX,U,3)) D  G QTNWHIST
"RTN","SCMCDD",31,0)
 .S SCOK=0_U_"Date On or Before Last Entry"
"RTN","SCMCDD",32,0)
 .S SCPARM("EFFECTIVE DATE")=DATE
"RTN","SCMCDD",33,0)
 .D ERR^SCAPMCU1(.SCESEQ,4045101,.SCPARM,"",.SCERR)
"RTN","SCMCDD",34,0)
 ;bp/cmf 204 new code begin
"RTN","SCMCDD",35,0)
 I $$BADNEWDT^SCMCDDA G QTNWHIST
"RTN","SCMCDD",36,0)
 ;bp/cmf 204 new code end
"RTN","SCMCDD",37,0)
 ;skip to end if status is not defined
"RTN","SCMCDD",38,0)
 IF '$D(STATUS)!($G(STATUS)="") G QTNWHIST
"RTN","SCMCDD",39,0)
 IF STATUS=+SCX D  G QTNWHIST
"RTN","SCMCDD",40,0)
 .S SCOK=0_U_"Status Must Change from Prior Entry -  Current Status is "_$S(STATUS:"Active",1:"Inactive")
"RTN","SCMCDD",41,0)
QTNWHIST Q SCOK
"RTN","SCMCDD",42,0)
 ;
"RTN","SCMCDD",43,0)
OKDEL(FILE,HISTIEN,SCERR) ;PCMM history files - delete record
"RTN","SCMCDD",44,0)
 ; input:
"RTN","SCMCDD",45,0)
 ;   FILE   = History File: 404.52,404.53,404.58, or 404.59
"RTN","SCMCDD",46,0)
 ;   HISTIEN    = Entry in FILE
"RTN","SCMCDD",47,0)
 ;   SCERR  = [default = "SCERR"]
"RTN","SCMCDD",48,0)
 ; output:
"RTN","SCMCDD",49,0)
 ;   Returned: 1 if ok to delete, 0 if not^message
"RTN","SCMCDD",50,0)
 ;   @scerr = error message array
"RTN","SCMCDD",51,0)
 N SCLASTDT,SCX,ROOT,SCNODE,SCOK,SCSTATUS
"RTN","SCMCDD",52,0)
 S SCOK=1
"RTN","SCMCDD",53,0)
 S ROOT="^SCTM("_FILE_","_HISTIEN_",0)"
"RTN","SCMCDD",54,0)
 S SCNODE=$G(@ROOT)
"RTN","SCMCDD",55,0)
 S SCLASTDT=$$LASTDATE^SCAPMCU1(FILE,$P(SCNODE,U,1)) ;1st pc=tm or pos
"RTN","SCMCDD",56,0)
 IF SCLASTDT'=$P(SCNODE,U,2) D  G QTOKDEL
"RTN","SCMCDD",57,0)
 .S Y=SCLASTDT D DD^%DT
"RTN","SCMCDD",58,0)
 .S SCOK=0_U_"Date is not last historical date ("_Y_")"_U_SCLASTDT
"RTN","SCMCDD",59,0)
 ;if active check if ok to inactivate
"RTN","SCMCDD",60,0)
 S SCSTATUS=+$P(SCNODE,U,+($S((FILE=404.52)!(FILE=404.53):4,1:3)))
"RTN","SCMCDD",61,0)
 S:SCSTATUS SCOK=$$OKINACT(FILE,$P(SCNODE,U,1),SCLASTDT,.SCERR)
"RTN","SCMCDD",62,0)
QTOKDEL Q SCOK
"RTN","SCMCDD",63,0)
 ;
"RTN","SCMCDD",64,0)
OKINACT(FILE,IEN,DATE,SCERR) ;PCMM history files - inactivate record?
"RTN","SCMCDD",65,0)
 ; input:
"RTN","SCMCDD",66,0)
 ; ** Complete **
"RTN","SCMCDD",67,0)
 ; input:
"RTN","SCMCDD",68,0)
 ;   FILE   = History File: 404.52,404.53,404.58, or 404.59
"RTN","SCMCDD",69,0)
 ;   IEN    = IEN of non-History File:
"RTN","SCMCDD",70,0)
 ;                Team Position (#404.57) for 404.52 & 404.59
"RTN","SCMCDD",71,0)
 ;                Team (#404.51) for 404.58
"RTN","SCMCDD",72,0)
 ;   DATE   = Date to inactivate
"RTN","SCMCDD",73,0)
 ;   SCERR  = [default = "SCERR"]
"RTN","SCMCDD",74,0)
 ; output:
"RTN","SCMCDD",75,0)
 ;   Returned: 1=ok on date/0 ow^1=ok in future/0 ow^message^techmessage
"RTN","SCMCDD",76,0)
 ;   @scerr = error message array
"RTN","SCMCDD",77,0)
 N SCLASTDT,SCX,ROOT,SCNODE,SCSTAT,SCOK,SCI,SCTP,SCOK,SCTPLST,SCPTLST,SCCLIN
"RTN","SCMCDD",78,0)
 S SCOK=1
"RTN","SCMCDD",79,0)
 S SCLASTDT=$$LASTDATE^SCAPMCU1(FILE,IEN)
"RTN","SCMCDD",80,0)
 IF DATE<SCLASTDT D  G QTOKIN
"RTN","SCMCDD",81,0)
 .S Y=SCLASTDT D DD^%DT
"RTN","SCMCDD",82,0)
 .S SCOK="0^^Date is before last historical date("_Y_")"_U_SCLASTDT
"RTN","SCMCDD",83,0)
 S SCDT("BEGIN")=DATE
"RTN","SCMCDD",84,0)
 S SCDT("END")=3990101 ;infinite future
"RTN","SCMCDD",85,0)
 S SCDT("INCL")=0 ;does not have to be continuous
"RTN","SCMCDD",86,0)
 S SCX=$$ACTHIST^SCAPMCU2(FILE,IEN,"SCDT",.SCERR)
"RTN","SCMCDD",87,0)
 IF SCX'>0 D  G QTOKIN
"RTN","SCMCDD",88,0)
 .S:SCX<0 SCOK="0^^Error in active history call"
"RTN","SCMCDD",89,0)
 .IF 'SCX D
"RTN","SCMCDD",90,0)
 ..S Y=DATE D DD^%DT
"RTN","SCMCDD",91,0)
 ..S SCOK="0^^Entry not active for date("_Y_")"_U_DATE
"RTN","SCMCDD",92,0)
TEAMHIS IF FILE=404.58 D
"RTN","SCMCDD",93,0)
 .; -- check positions for team
"RTN","SCMCDD",94,0)
 .IF '$$TPTM^SCAPMC(IEN,"SCDT",,,"SCTPLST",.SCERR) S SCOK=0_U_U_"Error in Position List Call" Q
"RTN","SCMCDD",95,0)
 .F SCI=1:1 S SCTP=$P($G(SCTPLST(SCI)),U,1) Q:'SCTP  D  Q:'SCOK
"RTN","SCMCDD",96,0)
 ..; -- check if position is active
"RTN","SCMCDD",97,0)
 ..IF '$P(SCTPLST(SCI),U,6)!($P(SCTPLST(SCI),U,6)>DATE) D  Q
"RTN","SCMCDD",98,0)
 ...S Y=$P(SCTPLST(SCI),U,2) D DD^%DT
"RTN","SCMCDD",99,0)
 ...S SCOK="0^^Active Team Position^"_$P($G(^SCTM(404.57,SCTP,0)),U,1)_" as of "_Y_U_SCTP_U_$P(SCTPLST(SCI),U,1)
"RTN","SCMCDD",100,0)
 ..S SCX=$$OKINACT(404.59,SCTP,DATE,.SCERR)
"RTN","SCMCDD",101,0)
 ..S:$P(SCX,U,1,2)["1" SCOK=SCX
"RTN","SCMCDD",102,0)
 .; -- check for patients assigned to team - 999 - maybe able to remove
"RTN","SCMCDD",103,0)
 .IF '$$PTTM^SCAPMC(IEN,"SCDT","^TMP($J,""SCPTLST"")",.SCERR) S SCOK=0_U_U_"Error in Patient List Call" Q
"RTN","SCMCDD",104,0)
 .F SCI=1:1 S SCPT=$P($G(^TMP($J,"SCPTLST",SCI)),U,1) Q:'SCPT  D  Q:'SCOK
"RTN","SCMCDD",105,0)
 ..IF $P(^TMP($J,"SCPTLST",SCI),U,4)>DATE S SCOK="1^0^Patient "_$P(^TMP($J,"SCPTLST",SCI),U,2)_" is active in the future" Q
"RTN","SCMCDD",106,0)
 ..IF $P(^TMP($J,"SCPTLST",SCI),U,5)<DATE S SCOK=0_U_U_"Patient ("_$P(^TMP($J,"SCPTLST",SCI),U,2)_") is active"_U_$P(^TMP($J,"SCPTLST",SCI),U,1)_U_$P(^TMP($J,"SCPTLST",SCI),U,2) Q
"RTN","SCMCDD",107,0)
POSHIS IF FILE=404.59 D
"RTN","SCMCDD",108,0)
 .; -- check for practitioners assigned to position
"RTN","SCMCDD",109,0)
 .IF '$$PRTP^SCAPMC(IEN,"SCDT","SCPRLST",.SCERR) S SCOK=0_U_U_"Error in Practitioner List Call" Q
"RTN","SCMCDD",110,0)
 .F SCI=1:1 S SCPR=$P($G(SCPRLST(SCI)),U,1) Q:'SCPR  D  Q:'SCOK
"RTN","SCMCDD",111,0)
 ..IF $P(SCPRLST(SCI),U,7)>DATE S SCOK="1^0^Team Member "_$P(SCPRLST(SCI),U,2)_" is active in the future in position "_U_$P(SCPRLST(SCI),U,1)_U_IEN Q
"RTN","SCMCDD",112,0)
 ..IF $P(SCPRLST(SCI),U,8)<DATE S SCOK="0^^Team Member "_$P(SCPRLST(SCI),U,2)_" is active in position "_U_$P(SCPRLST(SCI),U,1)_U_IEN Q
"RTN","SCMCDD",113,0)
 .;check if a clinic is assigned to position
"RTN","SCMCDD",114,0)
 .S SCCLIN=$P($G(^SCTM(404.57,IEN,0)),U,9) Q:'SCCLIN  D
"RTN","SCMCDD",115,0)
 ..S SCOK="0^^Clinic ("_$P($G(^SC(SCCLIN,0)),U,1)_") is associated with position"_U_SCCLIN
"RTN","SCMCDD",116,0)
 .;check for patients assigned to position
"RTN","SCMCDD",117,0)
 .IF '$$PTTP^SCAPMC(IEN,"SCDT","^TMP($J,""SCPTLST"")",.SCERR) S SCOK="0^^Error in patient list call" Q
"RTN","SCMCDD",118,0)
 .F SCI=1:1 S SCPT=$P($G(^TMP($J,"SCPTLST",SCI)),U,1) Q:'SCPT  D  Q:'SCOK
"RTN","SCMCDD",119,0)
 ..IF $P(SCPTLST(SCI),U,4)>DATE S SCOK="1^0^Patient "_$P(SCPTLST(SCI),U,1)_" is active in the future" Q
"RTN","SCMCDD",120,0)
 ..IF $P(^TMP($J,"SCPTLST",SCI),U,5)<DATE S SCOK=0_U_U_"Patient "_$P(^TMP($J,"SCPTLST",SCI),U,2)_" is active"_U_$P(^TMP($J,"SCPTLST",SCI),U,1) Q
"RTN","SCMCDD",121,0)
 ;IF FILE=404.52 or 404.53 - NO FURTHER CHECKS NEEDED
"RTN","SCMCDD",122,0)
QTOKIN Q SCOK
"RTN","SCMCDD",123,0)
 ;
"RTN","SCMCDD",124,0)
OKCHGDT(FILE,HISTIEN,DATE,SCERR) ;PCMM history files - ok to change date?
"RTN","SCMCDD",125,0)
 ; input:
"RTN","SCMCDD",126,0)
 ;   FILE   = History File: 404.52,404.53,404.58, or 404.59
"RTN","SCMCDD",127,0)
 ;   HISTIEN - IEN of History File (404.52,404.58 or 404.59)
"RTN","SCMCDD",128,0)
 ;   SCERR  = [default = "SCERR"]
"RTN","SCMCDD",129,0)
 ; output:
"RTN","SCMCDD",130,0)
 ;   Returned: 1 if ok to change date, 0 if not^message
"RTN","SCMCDD",131,0)
 ;   @scerr = error message array
"RTN","SCMCDD",132,0)
 N SCX,ROOT,SCNODE,SCSTAT,SCOK
"RTN","SCMCDD",133,0)
 S SCOK=1
"RTN","SCMCDD",134,0)
 S ROOT="^SCTM("_FILE_","_HISTIEN_",0)"
"RTN","SCMCDD",135,0)
 S SCNODE=$G(@ROOT)
"RTN","SCMCDD",136,0)
 IF 'SCNODE S SCOK="0^Bad or Corrupt File Entry"_U_HISTIEN G QTOKCHK
"RTN","SCMCDD",137,0)
 S SCSTAT=$S(FILE=404.52:$P(SCNODE,U,4),1:$P(SCNODE,U,3))
"RTN","SCMCDD",138,0)
 ;check next & previous effective dates (must be of other status)
"RTN","SCMCDD",139,0)
 ; i.e. if active check next & previous for inactive
"RTN","SCMCDD",140,0)
 S SCX=$$DTAFTER^SCAPMCU2(FILE,$P(SCNODE,U,1),('SCSTAT),$P(SCNODE,U,2))
"RTN","SCMCDD",141,0)
 IF SCX&(DATE'<SCX) D  G QTOKCHK
"RTN","SCMCDD",142,0)
 .S Y=+SCX D DD^%DT
"RTN","SCMCDD",143,0)
 .S SCOK=0_U_"Date Must be before "_Y_U_SCX
"RTN","SCMCDD",144,0)
 S SCX=$$DTBEFORE^SCAPMCU2(FILE,$P(SCNODE,U,1),('SCSTAT),$P(SCNODE,U,2))
"RTN","SCMCDD",145,0)
 IF DATE'>SCX D  G QTOKCHK
"RTN","SCMCDD",146,0)
 .S Y=+SCX D DD^%DT
"RTN","SCMCDD",147,0)
 .S SCOK=0_U_"Date Must be after "_Y_U_SCX
"RTN","SCMCDD",148,0)
 ;bp/cmf 204 new code begin
"RTN","SCMCDD",149,0)
 I $$BADCHGDT^SCMCDDA G QTOKCHK
"RTN","SCMCDD",150,0)
 ;bp/cmf 204 new code end
"RTN","SCMCDD",151,0)
 ;
"RTN","SCMCDD",152,0)
QTOKCHK Q SCOK
"RTN","SCMCDDA")
0^18^B2918971
"RTN","SCMCDDA",1,0)
SCMCDDA ;bp/cmf - extension of SCMCDD ; 21 December 1999
"RTN","SCMCDDA",2,0)
 ;;5.3;Scheduling;**204**;AUG 13, 1993
"RTN","SCMCDDA",3,0)
 ;1
"RTN","SCMCDDA",4,0)
BADNEWDT() ; not a stand alone function!!  called from NEWHIST^SCMCDD
"RTN","SCMCDDA",5,0)
 ;       ; ensure team/team position is active on DATE
"RTN","SCMCDDA",6,0)
 I FILE=404.59 D  I +SCOK=0 Q 1
"RTN","SCMCDDA",7,0)
 . D OKTMTP(IEN,DATE)
"RTN","SCMCDDA",8,0)
 . Q
"RTN","SCMCDDA",9,0)
 ;
"RTN","SCMCDDA",10,0)
 I FILE=404.52 D  I +SCOK=0 Q 1
"RTN","SCMCDDA",11,0)
 . D OKTMTP(IEN,DATE)
"RTN","SCMCDDA",12,0)
 . D OKTP(IEN,DATE)
"RTN","SCMCDDA",13,0)
 . ;;bp/cmf if not active, delete newhist entry here?!? [SCHIEN]
"RTN","SCMCDDA",14,0)
 . Q
"RTN","SCMCDDA",15,0)
 ;
"RTN","SCMCDDA",16,0)
 Q 0
"RTN","SCMCDDA",17,0)
 ;
"RTN","SCMCDDA",18,0)
BADCHGDT() ; not a stand alone function!!  called from OKCHGDT^SCMCDD
"RTN","SCMCDDA",19,0)
 I FILE=404.59 D  I +SCOK=0 Q 1
"RTN","SCMCDDA",20,0)
 . N SCTP
"RTN","SCMCDDA",21,0)
 . S SCTP=$P(SCNODE,U)
"RTN","SCMCDDA",22,0)
 . D OKTMTP(SCTP,DATE)
"RTN","SCMCDDA",23,0)
 . Q
"RTN","SCMCDDA",24,0)
 ;
"RTN","SCMCDDA",25,0)
 I FILE=404.52 D  I +SCOK=0 Q Q
"RTN","SCMCDDA",26,0)
 . N SCTP
"RTN","SCMCDDA",27,0)
 . S SCTP=$P(SCNODE,U)
"RTN","SCMCDDA",28,0)
 . D OKTMTP(SCTP,DATE)
"RTN","SCMCDDA",29,0)
 . D OKTP(SCTP,DATE)
"RTN","SCMCDDA",30,0)
 . Q
"RTN","SCMCDDA",31,0)
 ;
"RTN","SCMCDDA",32,0)
 Q 0
"RTN","SCMCDDA",33,0)
 ;
"RTN","SCMCDDA",34,0)
OKTMTP(SC1,SC2) ;
"RTN","SCMCDDA",35,0)
 ; sc1 := team position ien
"RTN","SCMCDDA",36,0)
 ; sc2 := assignment date
"RTN","SCMCDDA",37,0)
 N SCNODE,SCTM
"RTN","SCMCDDA",38,0)
 S SCNODE=$G(^SCTM(404.57,SC1,0),"BAD")
"RTN","SCMCDDA",39,0)
 I SCNODE="BAD" S SCOK="0^Bad Team Position entry." Q
"RTN","SCMCDDA",40,0)
 S SCTM=$P(SCNODE,U,2)
"RTN","SCMCDDA",41,0)
 S SCNODE=$G(^SCTM(404.51,SCTM,0),"BAD")
"RTN","SCMCDDA",42,0)
 I SCNODE="BAD" S SCOK="0^Bad Team entry." Q
"RTN","SCMCDDA",43,0)
 S SCX=+$$DATES^SCAPMCU1(404.58,SCTM,SC2)
"RTN","SCMCDDA",44,0)
 I SCX<1 S SCOK="0^Team not active on selected date."
"RTN","SCMCDDA",45,0)
 Q
"RTN","SCMCDDA",46,0)
 ;
"RTN","SCMCDDA",47,0)
OKTP(SC1,SC2) ;
"RTN","SCMCDDA",48,0)
 ; sc1 := team position ien
"RTN","SCMCDDA",49,0)
 ; sc2 := assignment date
"RTN","SCMCDDA",50,0)
 S SCX=+$$DATES^SCAPMCU1(404.59,SC1,SC2)
"RTN","SCMCDDA",51,0)
 I SCX<1 S SCOK="0^Team Position not active on selected date."
"RTN","SCMCDDA",52,0)
 Q
"RTN","SCMCDDA",53,0)
 ;
"RTN","SCMCHL")
0^11^B18231654
"RTN","SCMCHL",1,0)
SCMCHL ;BP/DJB - PCMM HL7 Main Calling Point ; 12/6/99 2:06pm
"RTN","SCMCHL",2,0)
 ;;5.3;Scheduling;**177,204**;May 01, 1999
"RTN","SCMCHL",3,0)
 ;
"RTN","SCMCHL",4,0)
 ;Reference routine: SCDXMSG
"RTN","SCMCHL",5,0)
MAIN(MODE,XMITARRY,VARPTR) ;Main entry point to generate Primary Care HL7
"RTN","SCMCHL",6,0)
 ;messages to NPCD in Austin. Loop thru PCMM HL7 EVENT file (#404.48)
"RTN","SCMCHL",7,0)
 ;and generate HL7 message for each appropriate event.
"RTN","SCMCHL",8,0)
 ;
"RTN","SCMCHL",9,0)
 ;Input:
"RTN","SCMCHL",10,0)
 ;  MODE     - Mode of operation.
"RTN","SCMCHL",11,0)
 ;              1: Generate mode - Generate HL7 messages. (Default).
"RTN","SCMCHL",12,0)
 ;              2: Review mode   - HL7 segments will be built in array
"RTN","SCMCHL",13,0)
 ;                                 XMITARRY and may be reviewed. HL7
"RTN","SCMCHL",14,0)
 ;                                 messages WILL NOT be generated, and
"RTN","SCMCHL",15,0)
 ;                                 processed events will not be
"RTN","SCMCHL",16,0)
 ;                                 removed from the transmit xref in
"RTN","SCMCHL",17,0)
 ;                                 PCMM HL7 EVENT file.
"RTN","SCMCHL",18,0)
 ;  XMITARRY - Array to store HL7 segments (full global ref).
"RTN","SCMCHL",19,0)
 ;             Default=^TMP("PCMM","HL7",$J)
"RTN","SCMCHL",20,0)
 ;   VARPTR  - For testing purposes, you may pass in an EVENT POINTER
"RTN","SCMCHL",21,0)
 ;             value. This value will be used rather than $ORDERing
"RTN","SCMCHL",22,0)
 ;             thru "AACXMIT" xref in PCMM HL7 EVENT file.
"RTN","SCMCHL",23,0)
 ;             Examples:
"RTN","SCMCHL",24,0)
 ;                "2290;SCPT(404.43," (Patient Team Position Assign)
"RTN","SCMCHL",25,0)
 ;                "725;SCTM(404.52,"  (Position Assign History)
"RTN","SCMCHL",26,0)
 ;                "1;SCTM(404.53,"    (Preceptor Assign History)
"RTN","SCMCHL",27,0)
 ;Output: None
"RTN","SCMCHL",28,0)
 ;
"RTN","SCMCHL",29,0)
 NEW ERRCNT,IEN,MSG,MSGCNT,RESULT
"RTN","SCMCHL",30,0)
 NEW SCEVIEN,SCFAC
"RTN","SCMCHL",31,0)
 NEW HL,HLECH,HLEID,HLFS,HLQ,HLP,XMITERR
"RTN","SCMCHL",32,0)
 ;
"RTN","SCMCHL",33,0)
 ;Initialize variables - set global locations
"RTN","SCMCHL",34,0)
 S:$G(MODE)'=2 MODE=1 ;Default mode = "Generate"
"RTN","SCMCHL",35,0)
 S:$G(XMITARRY)="" XMITARRY="^TMP(""PCMM"",""HL7"","_$J_")" ;Segments
"RTN","SCMCHL",36,0)
 S XMITERR="^TMP(""PCMM"",""ERR"","_$J_")" ;Errors
"RTN","SCMCHL",37,0)
 S MSGCNT=0
"RTN","SCMCHL",38,0)
 ;
"RTN","SCMCHL",39,0)
 ;Get pointer to sending event
"RTN","SCMCHL",40,0)
 S HLEID=$$HLEID()
"RTN","SCMCHL",41,0)
 I 'HLEID D  Q
"RTN","SCMCHL",42,0)
 . S MSG="Unable to initialize HL7 variables - protocol not found"
"RTN","SCMCHL",43,0)
 . D ERRBULL^SCMCHLM(MSG)
"RTN","SCMCHL",44,0)
 ;
"RTN","SCMCHL",45,0)
 ;Initialize HL7 variables
"RTN","SCMCHL",46,0)
 D INIT^HLFNC2(HLEID,.HL)
"RTN","SCMCHL",47,0)
 I $O(HL(""))="" D  Q
"RTN","SCMCHL",48,0)
 . D ERRBULL^SCMCHLM($P(HL,"^",2))
"RTN","SCMCHL",49,0)
 ;
"RTN","SCMCHL",50,0)
 ;Get faciltiy number
"RTN","SCMCHL",51,0)
 S SCFAC=+$P($$SITE^VASITE(),"^",3)
"RTN","SCMCHL",52,0)
 ;
"RTN","SCMCHL",53,0)
 ;User passed in an EVENT POINTER value
"RTN","SCMCHL",54,0)
 I $G(VARPTR)]"" D MANUAL Q
"RTN","SCMCHL",55,0)
 ;
"RTN","SCMCHL",56,0)
LOOP ;Loop thru EVENT POINTER xref and send message for each unique one.
"RTN","SCMCHL",57,0)
 ;The SCLIMIT counter in the FOR loop allows sites to limit number of
"RTN","SCMCHL",58,0)
 ;entries processed at any one time. Sites can adjust SCLIMIT in the
"RTN","SCMCHL",59,0)
 ;PCMM PARAMETER file if there are too many entries in the "AACXMIT"
"RTN","SCMCHL",60,0)
 ;xref to be completed in a single evening.
"RTN","SCMCHL",61,0)
 ;For example, setting LIMIT to 100 will only process the first 100
"RTN","SCMCHL",62,0)
 ;entries. To process all entries, set LIMIT back to 999999.
"RTN","SCMCHL",63,0)
 ;
"RTN","SCMCHL",64,0)
 NEW SCI,SCLIMIT
"RTN","SCMCHL",65,0)
 S SCLIMIT=$P($G(^SCTM(404.44,1,1)),U,5) ;Limit # of events processed
"RTN","SCMCHL",66,0)
 S:'SCLIMIT SCLIMIT=999999 ;Process all entries
"RTN","SCMCHL",67,0)
 S VARPTR=""
"RTN","SCMCHL",68,0)
 F SCI=1:1:SCLIMIT S VARPTR=$O(^SCPT(404.48,"AACXMIT",VARPTR)) Q:VARPTR=""  D
"RTN","SCMCHL",69,0)
 . KILL @XMITARRY ;Initialize array
"RTN","SCMCHL",70,0)
 . ;
"RTN","SCMCHL",71,0)
 . ;Preserve the Event IEN. Used to process a deletion.
"RTN","SCMCHL",72,0)
 . S SCEVIEN=$O(^SCPT(404.48,"AACXMIT",VARPTR,"")) Q:'SCEVIEN
"RTN","SCMCHL",73,0)
 . ;
"RTN","SCMCHL",74,0)
 . ;Build segment array
"RTN","SCMCHL",75,0)
 . S RESULT=$$BUILD^SCMCHLB(VARPTR,.HL,.XMITARRY)
"RTN","SCMCHL",76,0)
 . I +RESULT<0 D  Q  ;Error occurred when building segment array
"RTN","SCMCHL",77,0)
 . . S @XMITERR@(VARPTR)=$P(RESULT,"^",2)
"RTN","SCMCHL",78,0)
 . ;
"RTN","SCMCHL",79,0)
 . ;If in Review mode, display info and Quit.
"RTN","SCMCHL",80,0)
 . I MODE=2 D  Q  ;
"RTN","SCMCHL",81,0)
 . . W !,VARPTR_"  "_$S('$D(@XMITARRY):"No ",1:"")_"Data Found"
"RTN","SCMCHL",82,0)
 . ;
"RTN","SCMCHL",83,0)
 . ;If no segments built, turn off transmission flag and Quit.
"RTN","SCMCHL",84,0)
 . I '$D(@XMITARRY) D FLAG(VARPTR) Q
"RTN","SCMCHL",85,0)
 . ;
"RTN","SCMCHL",86,0)
 . ;Generate message.
"RTN","SCMCHL",87,0)
 . ;
"RTN","SCMCHL",88,0)
 . ;djb/bp Fix how MSGCNT variable is incremented.
"RTN","SCMCHL",89,0)
 . ;Old code start
"RTN","SCMCHL",90,0)
 . ;S MSGCNT=$$GENERATE^SCMCHLG()
"RTN","SCMCHL",91,0)
 . ;I MSGCNT D FLAG(VARPTR) ;Turn off transmission flag
"RTN","SCMCHL",92,0)
 . ;Old code end
"RTN","SCMCHL",93,0)
 . ;New code start
"RTN","SCMCHL",94,0)
 . Q:'$$GENERATE^SCMCHLG()  ;^SCMCHLG Increments MSGCNT
"RTN","SCMCHL",95,0)
 . D FLAG(VARPTR) ;Turn off transmission flag
"RTN","SCMCHL",96,0)
 . ;New code end
"RTN","SCMCHL",97,0)
 . ;
"RTN","SCMCHL",98,0)
 . Q
"RTN","SCMCHL",99,0)
 ;
"RTN","SCMCHL",100,0)
 I '$D(ZTQUEUED) W !,MSGCNT," messages sent."
"RTN","SCMCHL",101,0)
 ;
"RTN","SCMCHL",102,0)
 ;Send completion bulletin and clean up arrays.
"RTN","SCMCHL",103,0)
 I MODE=1 D  ;Don't do this if in DISPLAY mode.
"RTN","SCMCHL",104,0)
 . S ERRCNT=$$COUNT^SCMCHLS(XMITERR)
"RTN","SCMCHL",105,0)
 . D CMPLBULL^SCMCHLM(MSGCNT,ERRCNT,XMITERR)
"RTN","SCMCHL",106,0)
 . KILL @XMITARRY,@XMITERR
"RTN","SCMCHL",107,0)
 Q
"RTN","SCMCHL",108,0)
 ;
"RTN","SCMCHL",109,0)
MANUAL ;User passed in a specific variable pointer value. This value will
"RTN","SCMCHL",110,0)
 ;be used rather than $ORDERing thru "AACXMIT" xref.
"RTN","SCMCHL",111,0)
 ;
"RTN","SCMCHL",112,0)
 NEW SCMANUAL
"RTN","SCMCHL",113,0)
 S SCMANUAL=1 ;Indicates variable pointer was manually entered.
"RTN","SCMCHL",114,0)
 ;             A delete cannot be processed.
"RTN","SCMCHL",115,0)
 ;
"RTN","SCMCHL",116,0)
 ;Initialize array
"RTN","SCMCHL",117,0)
 KILL @XMITARRY
"RTN","SCMCHL",118,0)
 ;
"RTN","SCMCHL",119,0)
 ;Build segment array
"RTN","SCMCHL",120,0)
 S RESULT=$$BUILD^SCMCHLB(VARPTR,.HL,.XMITARRY)
"RTN","SCMCHL",121,0)
 I +RESULT<0 D  Q  ;Error occurred when building segment array
"RTN","SCMCHL",122,0)
 . S @XMITERR@(VARPTR)=$P(RESULT,"^",2)
"RTN","SCMCHL",123,0)
 W !,VARPTR_"  "_$S('$D(@XMITARRY):"No ",1:"")_"Data Found",!
"RTN","SCMCHL",124,0)
 ;
"RTN","SCMCHL",125,0)
 ;Generate message - FOR TESTING PURPOSES ONLY!
"RTN","SCMCHL",126,0)
 ;S RESULT=$$GENERATE^SCMCHLG()
"RTN","SCMCHL",127,0)
 Q
"RTN","SCMCHL",128,0)
 ;
"RTN","SCMCHL",129,0)
FLAG(VARPTR) ;Turn off transmission flag. This removes event from "AACXMIT"
"RTN","SCMCHL",130,0)
 ;xref in PCMM HL7 EVENT file.
"RTN","SCMCHL",131,0)
 ;Input:
"RTN","SCMCHL",132,0)
 ;   VARPTR - Internal value of EVENT POINTER field
"RTN","SCMCHL",133,0)
 ;
"RTN","SCMCHL",134,0)
 Q:$G(VARPTR)']""
"RTN","SCMCHL",135,0)
 NEW IEN
"RTN","SCMCHL",136,0)
 S IEN=0
"RTN","SCMCHL",137,0)
 F  S IEN=$O(^SCPT(404.48,"AACXMIT",VARPTR,IEN)) Q:'IEN  D  ;
"RTN","SCMCHL",138,0)
 . D TRANSMIT^SCMCHLE(IEN,0)
"RTN","SCMCHL",139,0)
 Q
"RTN","SCMCHL",140,0)
 ;
"RTN","SCMCHL",141,0)
HLEID() ;Return pointer to sending event
"RTN","SCMCHL",142,0)
 Q +$O(^ORD(101,"B","PCMM SEND SERVER FOR ADT-A08",0))
"RTN","SCMCHLB")
0^16^B11493860
"RTN","SCMCHLB",1,0)
SCMCHLB ;BP/DJB - PCMM HL7 Bld Segment Array ; 12/13/99 10:32am
"RTN","SCMCHLB",2,0)
 ;;5.3;Scheduling;**177,204**;May 01, 1999
"RTN","SCMCHLB",3,0)
 ;;5.3;Scheduling;**177,204t0,210**;May 01, 1999
"RTN","SCMCHLB",4,0)
 ;
"RTN","SCMCHLB",5,0)
BUILD(VARPTR,HL,XMITARRY) ;Build an array of HL7 segments based on EVENT
"RTN","SCMCHLB",6,0)
 ;POINTER field in PCMM HL7 EVENT file (#404.48).
"RTN","SCMCHLB",7,0)
 ;
"RTN","SCMCHLB",8,0)
 ;Input:
"RTN","SCMCHLB",9,0)
 ;     VARPTR   - EVENT POINTER field in PCMM HL7 EVENT file.
"RTN","SCMCHLB",10,0)
 ;     HL       - Array of HL7 variables (pass by reference).
"RTN","SCMCHLB",11,0)
 ;                Output of call to INIT^HLFNC2().
"RTN","SCMCHLB",12,0)
 ;     XMITARRY - Array to store HL7 segments (full global ref).
"RTN","SCMCHLB",13,0)
 ;                Default=^TMP("HLS",$J)
"RTN","SCMCHLB",14,0)
 ;Output:
"RTN","SCMCHLB",15,0)
 ;     XMITARRY(n,segment) array of segments.
"RTN","SCMCHLB",16,0)
 ;        Examples:
"RTN","SCMCHLB",17,0)
 ;           ^TMP("PCMM","HL7",$J,2290,"PID")...= PID segment
"RTN","SCMCHLB",18,0)
 ;           ^TMP("PCMM","HL7",$J,2290,"ZPC",ID)= ZPC segments
"RTN","SCMCHLB",19,0)
 ;     -1^Error = Unable to build message / bad input
"RTN","SCMCHLB",20,0)
 ;
"RTN","SCMCHLB",21,0)
 ;Note: The calling program must initialize (i.e. KILL) XMITARRY.
"RTN","SCMCHLB",22,0)
 ;
"RTN","SCMCHLB",23,0)
 ;Declare variables
"RTN","SCMCHLB",24,0)
 NEW RESULT,SCIEN,SCGLB
"RTN","SCMCHLB",25,0)
 NEW HLECH,HLEID,HLFS,HLQ
"RTN","SCMCHLB",26,0)
 ;
"RTN","SCMCHLB",27,0)
 ;Convert VARPTR (ien;global) to SCIEN & SCGLB
"RTN","SCMCHLB",28,0)
 S RESULT=$$CHECK^SCMCHLB1($G(VARPTR))
"RTN","SCMCHLB",29,0)
 ;
"RTN","SCMCHLB",30,0)
 I 'RESULT Q "-1^Did not pass valid variable pointer"
"RTN","SCMCHLB",31,0)
 ;
"RTN","SCMCHLB",32,0)
 ;Initialize HL7 variables
"RTN","SCMCHLB",33,0)
 S HLECH=HL("ECH")
"RTN","SCMCHLB",34,0)
 S HLFS=HL("FS")
"RTN","SCMCHLB",35,0)
 S HLQ=HL("Q")
"RTN","SCMCHLB",36,0)
 ;
"RTN","SCMCHLB",37,0)
 I RESULT=2 D  G QUIT ;........................Process a deletion
"RTN","SCMCHLB",38,0)
 . I SCGLB="SCPT(404.43," D PTP^SCMCHLB2 Q  ;..Delete - File 404.43
"RTN","SCMCHLB",39,0)
 . I SCGLB="SCTM(404.52," D POS^SCMCHLB2 Q  ;..Delete - File 404.52
"RTN","SCMCHLB",40,0)
 . I SCGLB="SCTM(404.53," D PRE^SCMCHLB2 Q  ;..Delete - File 404.53
"RTN","SCMCHLB",41,0)
 I SCGLB="SCPT(404.43," D PTP(SCIEN) G QUIT ;..File 404.43
"RTN","SCMCHLB",42,0)
 I SCGLB="SCTM(404.52," D POS G QUIT ;.........File 404.52
"RTN","SCMCHLB",43,0)
 I SCGLB="SCTM(404.53," D PRE G QUIT ;.........File 404.53
"RTN","SCMCHLB",44,0)
QUIT Q 1
"RTN","SCMCHLB",45,0)
 ;
"RTN","SCMCHLB",46,0)
 ;==================================================================
"RTN","SCMCHLB",47,0)
 ;
"RTN","SCMCHLB",48,0)
PTP(PTPI) ;Patient Team Position Assignment (#404.43).
"RTN","SCMCHLB",49,0)
 ;Input: PTPI - Patient Team Position Assignment IEN
"RTN","SCMCHLB",50,0)
 ;
"RTN","SCMCHLB",51,0)
 ;To keep VISTA and NPCD in sync, for this PT TM POS ASSIGN send
"RTN","SCMCHLB",52,0)
 ;down a delete for all previous entries, and then send down data
"RTN","SCMCHLB",53,0)
 ;for current valid entries.
"RTN","SCMCHLB",54,0)
 ;
"RTN","SCMCHLB",55,0)
 NEW DFN,ERROR,ND,ZDATE,ZPTP
"RTN","SCMCHLB",56,0)
 ;djb/bp Added SCSEQ per Patch 210, replace above line with below line
"RTN","SCMCHLB",57,0)
 ;NEW DFN,ERROR,ND,SCSEQ,ZDATE,ZPTP
"RTN","SCMCHLB",58,0)
 ;
"RTN","SCMCHLB",59,0)
 ;Get data
"RTN","SCMCHLB",60,0)
 S ND=$G(^SCPT(404.43,PTPI,0))
"RTN","SCMCHLB",61,0)
 S DFN=$$DFN^SCMCHLB1(ND) Q:'DFN  ;..Patient
"RTN","SCMCHLB",62,0)
 D SEGMENTS^SCMCHLB1(DFN,PTPI)
"RTN","SCMCHLB",63,0)
 ;
"RTN","SCMCHLB",64,0)
 ;Generate deletes for all ID's starting with this PT TM POS ASSIGN.
"RTN","SCMCHLB",65,0)
 D PTPD^SCMCHLB2(PTPI)
"RTN","SCMCHLB",66,0)
 ;
"RTN","SCMCHLB",67,0)
 ;Get only valid entries for this PT TM POS ASSIGN. This call returns
"RTN","SCMCHLB",68,0)
 ;provider array for a patient team position assignment.
"RTN","SCMCHLB",69,0)
 ;Example: ZPTP(8944,"AP","8944-909-0-AP")=data
"RTN","SCMCHLB",70,0)
 ;         ZPTP(8944,"PCP","8944-911-157-PCP")=data
"RTN","SCMCHLB",71,0)
 KILL ZPTP
"RTN","SCMCHLB",72,0)
 D SETDATE ;Set date array
"RTN","SCMCHLB",73,0)
 S RESULT=$$PRPTTPC^SCAPMC(PTPI,"ZDATE","ZPTP","ERROR","",1)
"RTN","SCMCHLB",74,0)
 ;
"RTN","SCMCHLB",75,0)
 ;Build data type ZPC segments.
"RTN","SCMCHLB",76,0)
 Q:'$D(ZPTP)
"RTN","SCMCHLB",77,0)
 D ZPC^SCMCHLB1(.ZPTP)
"RTN","SCMCHLB",78,0)
 Q
"RTN","SCMCHLB",79,0)
 ;
"RTN","SCMCHLB",80,0)
POS ;Position Assign History (#404.52)
"RTN","SCMCHLB",81,0)
 ;
"RTN","SCMCHLB",82,0)
 ;To keep VISTA and NPCD in sync, for every primary care entry in Pt
"RTN","SCMCHLB",83,0)
 ;Tm Pos Assign for this TEAM POSITION, send down all valid entries.
"RTN","SCMCHLB",84,0)
 ;
"RTN","SCMCHLB",85,0)
 NEW TMPOS,TP
"RTN","SCMCHLB",86,0)
 ;
"RTN","SCMCHLB",87,0)
 ;Team Position pointer
"RTN","SCMCHLB",88,0)
 S TMPOS=$P($G(^SCTM(404.52,SCIEN,0)),U,1)
"RTN","SCMCHLB",89,0)
 Q:'TMPOS
"RTN","SCMCHLB",90,0)
 ;
"RTN","SCMCHLB",91,0)
 ;Get History entries for each PT TM POS ASSIGN
"RTN","SCMCHLB",92,0)
 D POS1(TMPOS)
"RTN","SCMCHLB",93,0)
 ;
"RTN","SCMCHLB",94,0)
 ;What if this TEAM POSITION is also a preceptor? Find every TEAM
"RTN","SCMCHLB",95,0)
 ;POSITION being precepted by this TEAM POSITION and for each, find
"RTN","SCMCHLB",96,0)
 ;every PT TM POS ASSIGN and send down all valid History entries.
"RTN","SCMCHLB",97,0)
 ;
"RTN","SCMCHLB",98,0)
 S TP=0
"RTN","SCMCHLB",99,0)
 F  S TP=$O(^SCTM(404.53,"AD",TMPOS,TP)) Q:'TP  D POS1(TP)
"RTN","SCMCHLB",100,0)
 Q
"RTN","SCMCHLB",101,0)
 ;
"RTN","SCMCHLB",102,0)
POS1(TMPOS) ;Find every primary care PT TM POS ASSIGN for this TEAM POSITION
"RTN","SCMCHLB",103,0)
 ;and get all valid History entries.
"RTN","SCMCHLB",104,0)
 ;Input:
"RTN","SCMCHLB",105,0)
 ;   TMPOS - TEAM POSITION pointer
"RTN","SCMCHLB",106,0)
 ;
"RTN","SCMCHLB",107,0)
 Q:'$G(TMPOS)
"RTN","SCMCHLB",108,0)
 NEW IFN,ND,TM
"RTN","SCMCHLB",109,0)
 ;
"RTN","SCMCHLB",110,0)
 S TM=0
"RTN","SCMCHLB",111,0)
 F  S TM=$O(^SCPT(404.43,"APTPA",TMPOS,TM)) Q:'TM  D  ;
"RTN","SCMCHLB",112,0)
 . S IFN=0
"RTN","SCMCHLB",113,0)
 . F  S IFN=$O(^SCPT(404.43,"APTPA",TMPOS,TM,IFN)) Q:'IFN  D  ;
"RTN","SCMCHLB",114,0)
 .. S ND=$G(^SCPT(404.43,IFN,0))
"RTN","SCMCHLB",115,0)
 .. Q:($P(ND,U,5)'=1)  ;..Must be Primary Care
"RTN","SCMCHLB",116,0)
 .. D PTP(IFN) ;..........Bld segments for this PT TM POS ASSIGN
"RTN","SCMCHLB",117,0)
 Q
"RTN","SCMCHLB",118,0)
 ;
"RTN","SCMCHLB",119,0)
PRE ;Preceptor Assign History (#404.53)
"RTN","SCMCHLB",120,0)
 ;
"RTN","SCMCHLB",121,0)
 ;Get TEAM POSITION pointer of preceptee. Find every primary care
"RTN","SCMCHLB",122,0)
 ;PT TM POS ASSIGN for this TEAM POSITION and send down all valid
"RTN","SCMCHLB",123,0)
 ;History entries.
"RTN","SCMCHLB",124,0)
 ;
"RTN","SCMCHLB",125,0)
 NEW TMPOS
"RTN","SCMCHLB",126,0)
 ;
"RTN","SCMCHLB",127,0)
 ;Preceptee TEAM POSITION pointer
"RTN","SCMCHLB",128,0)
 S TMPOS=$P($G(^SCTM(404.53,SCIEN,0)),U,1)
"RTN","SCMCHLB",129,0)
 Q:'TMPOS
"RTN","SCMCHLB",130,0)
 D POS1(TMPOS) ;Get History entries for each PT TM POS ASSIGN
"RTN","SCMCHLB",131,0)
 ;
"RTN","SCMCHLB",132,0)
 ;Preceptor TEAM POSITION pointer
"RTN","SCMCHLB",133,0)
 S TMPOS=$P($G(^SCTM(404.53,SCIEN,0)),U,6)
"RTN","SCMCHLB",134,0)
 Q:'TMPOS
"RTN","SCMCHLB",135,0)
 D POS1(TMPOS) ;Get History entries for each PT TM POS ASSIGN
"RTN","SCMCHLB",136,0)
 Q
"RTN","SCMCHLB",137,0)
 ;
"RTN","SCMCHLB",138,0)
SETDATE ;Set all encompassing date array
"RTN","SCMCHLB",139,0)
 S ZDATE("BEGIN")=2800101
"RTN","SCMCHLB",140,0)
 S ZDATE("END")=9991231
"RTN","SCMCHLB",141,0)
 S ZDATE("INCL")=0
"RTN","SCMCHLB",142,0)
 Q
"RTN","SCMCHLB2")
0^12^B13614527
"RTN","SCMCHLB2",1,0)
SCMCHLB2 ;BP/DJB - PCMM HL7 Bld Segment Array Deletes ; 1/12/00 10:24am
"RTN","SCMCHLB2",2,0)
 ;;5.3;Scheduling;**177,204**;May 01, 1999
"RTN","SCMCHLB2",3,0)
 ;
"RTN","SCMCHLB2",4,0)
PTP ;Entry has been deleted from file 404.43. Send deletes to NPCD.
"RTN","SCMCHLB2",5,0)
 ;
"RTN","SCMCHLB2",6,0)
 NEW DFN,TP
"RTN","SCMCHLB2",7,0)
 D GETEVENT Q:'DFN  ;..Get DFN & TP from PCMM HL7 EVENT file
"RTN","SCMCHLB2",8,0)
 D PTPD(SCIEN) ;.......Send delete
"RTN","SCMCHLB2",9,0)
 Q
"RTN","SCMCHLB2",10,0)
 ;
"RTN","SCMCHLB2",11,0)
PTPD(PTPI) ;From PCMM HL7 ID file, get all ID's whose 1st piece equals PTPI,
"RTN","SCMCHLB2",12,0)
 ;and send a delete segment.
"RTN","SCMCHLB2",13,0)
 ;Input: PTPI - 404.43 IEN (1st piece of ID)
"RTN","SCMCHLB2",14,0)
 ;
"RTN","SCMCHLB2",15,0)
 ;djb/bp Added SCSEQ per Patch 210[rel 204].
"RTN","SCMCHLB2",16,0)
 NEW DATA,ID,LINETAG,SCSEQ,VAFZPC
"RTN","SCMCHLB2",17,0)
 ;
"RTN","SCMCHLB2",18,0)
 S ID=PTPI_"-"
"RTN","SCMCHLB2",19,0)
 F  S ID=$O(^SCPT(404.49,"B",ID)) Q:ID=""!($P(ID,"-",1)'=PTPI)  D  ;
"RTN","SCMCHLB2",20,0)
 . S DATA="^^^" ;........A Delete type ZPC segment
"RTN","SCMCHLB2",21,0)
 . ;djb/bp Patch 210. Eliminate indirection[rel 204]
"RTN","SCMCHLB2",22,0)
 . ;New code begin
"RTN","SCMCHLB2",23,0)
 . D BLDZPC^SCMCHLS ;..Build segment (needs ID & DATA)
"RTN","SCMCHLB2",24,0)
 . D CPYZPC^SCMCHLS ;..Copy segment into array (needs ID & VAFZPC)
"RTN","SCMCHLB2",25,0)
 . ;New code end
"RTN","SCMCHLB2",26,0)
 . ;Old code begin
"RTN","SCMCHLB2",27,0)
 . ;S LINETAG="BLDZPC"
"RTN","SCMCHLB2",28,0)
 . ;D @LINETAG^SCMCHLS ;..Build segment (needs ID & DATA)
"RTN","SCMCHLB2",29,0)
 . ;S LINETAG="CPYZPC"
"RTN","SCMCHLB2",30,0)
 . ;D @LINETAG^SCMCHLS ;..Copy segment into array (needs ID & VAFZPC)
"RTN","SCMCHLB2",31,0)
 . ;Old code end
"RTN","SCMCHLB2",32,0)
 Q:'$D(@XMITARRY)
"RTN","SCMCHLB2",33,0)
 D SEGMENTS^SCMCHLB1(DFN,PTPI) ;Bld array of EVN,PID segments
"RTN","SCMCHLB2",34,0)
 Q
"RTN","SCMCHLB2",35,0)
 ;
"RTN","SCMCHLB2",36,0)
POS ;Entry has been deleted from file 404.52. Send deletes to NPCD.
"RTN","SCMCHLB2",37,0)
 ;
"RTN","SCMCHLB2",38,0)
 NEW DATA,DFN,ID,LINETAG,ND,POS,PTPI,VAFZPC
"RTN","SCMCHLB2",39,0)
 ;
"RTN","SCMCHLB2",40,0)
 ;From PCMM HL7 ID file, get all ID's whose 2nd piece equals SCIEN,
"RTN","SCMCHLB2",41,0)
 ;Build array sorted by:  DFN
"RTN","SCMCHLB2",42,0)
 ;                        404.43 IEN
"RTN","SCMCHLB2",43,0)
 ;                        ID
"RTN","SCMCHLB2",44,0)
 ;djb/bp Fix <STORE> errors for NOIS BIG-1199-71271.
"RTN","SCMCHLB2",45,0)
 ;       Replace local array POS() with global array.
"RTN","SCMCHLB2",46,0)
 S POS="^TMP(""PCMM"",""POS"","_$J_")"
"RTN","SCMCHLB2",47,0)
 KILL @POS
"RTN","SCMCHLB2",48,0)
 ;
"RTN","SCMCHLB2",49,0)
 S ID=""
"RTN","SCMCHLB2",50,0)
 F  S ID=$O(^SCPT(404.49,"B",ID)) Q:ID=""  D  ;
"RTN","SCMCHLB2",51,0)
 . Q:$P(ID,"-",2)'=SCIEN
"RTN","SCMCHLB2",52,0)
 . S PTPI=$P(ID,"-",1) ;...............404.43 IEN
"RTN","SCMCHLB2",53,0)
 . S ND=$G(^SCPT(404.43,PTPI,0))
"RTN","SCMCHLB2",54,0)
 . Q:($P(ND,U,5)'=1)  ;................Must be Primary Care
"RTN","SCMCHLB2",55,0)
 . S DFN=$$DFN^SCMCHLB1(ND) Q:'DFN  ;..Get patient
"RTN","SCMCHLB2",56,0)
 . ;
"RTN","SCMCHLB2",57,0)
 . ;S POS(DFN,PTPI,ID)=""
"RTN","SCMCHLB2",58,0)
 . S @POS@(DFN,PTPI,ID)="" ;djb/bp BIG-1199-71271
"RTN","SCMCHLB2",59,0)
 . ;
"RTN","SCMCHLB2",60,0)
 Q:'$D(@POS)
"RTN","SCMCHLB2",61,0)
 ;
"RTN","SCMCHLB2",62,0)
 ;Process array
"RTN","SCMCHLB2",63,0)
 S DFN=0
"RTN","SCMCHLB2",64,0)
 ;F  S DFN=$O(POS(DFN)) Q:'DFN  D  ;
"RTN","SCMCHLB2",65,0)
 F  S DFN=$O(@POS@(DFN)) Q:'DFN  D  ;djb/bp BIG-1199-71271
"RTN","SCMCHLB2",66,0)
 . S PTPI=0
"RTN","SCMCHLB2",67,0)
 . ;F  S PTPI=$O(POS(DFN,PTPI)) Q:'PTPI  D  ;
"RTN","SCMCHLB2",68,0)
 . F  S PTPI=$O(@POS@(DFN,PTPI)) Q:'PTPI  D  ;djb/bp BIG-1199-71271
"RTN","SCMCHLB2",69,0)
 .. NEW SCSEQ ;djb/bp Added per Patch 210.
"RTN","SCMCHLB2",70,0)
 .. D SEGMENTS^SCMCHLB1(DFN,PTPI) ;Bld array of EVN,PID segments
"RTN","SCMCHLB2",71,0)
 .. S ID=""
"RTN","SCMCHLB2",72,0)
 .. ;F  S ID=$O(POS(DFN,PTPI,ID)) Q:ID=""  D  ;
"RTN","SCMCHLB2",73,0)
 .. F  S ID=$O(@POS@(DFN,PTPI,ID)) Q:ID=""  D  ;djb/bp BIG-1199-71271
"RTN","SCMCHLB2",74,0)
 ... S DATA="^^^" ;........A Delete type ZPC segment
"RTN","SCMCHLB2",75,0)
 ... ;djb/bp Patch 210. Eliminate indirection[rel 204]
"RTN","SCMCHLB2",76,0)
 ... ;New code begin
"RTN","SCMCHLB2",77,0)
 ... D BLDZPC^SCMCHLS ;..Build segment (needs ID & DATA)
"RTN","SCMCHLB2",78,0)
 ... D CPYZPC^SCMCHLS ;..Copy segment into array (needs ID & VAFZPC)
"RTN","SCMCHLB2",79,0)
 ... ;New code end
"RTN","SCMCHLB2",80,0)
 ... ;Old code begin
"RTN","SCMCHLB2",81,0)
 ... ;S LINETAG="BLDZPC"
"RTN","SCMCHLB2",82,0)
 ... ;D @LINETAG^SCMCHLS ;..Build segment (needs ID & DATA)
"RTN","SCMCHLB2",83,0)
 ... ;S LINETAG="CPYZPC"
"RTN","SCMCHLB2",84,0)
 ... ;D @LINETAG^SCMCHLS ;..Copy segment into array (need ID & VAFZPC)
"RTN","SCMCHLB2",85,0)
 ... ;Old code end
"RTN","SCMCHLB2",86,0)
 ;
"RTN","SCMCHLB2",87,0)
 KILL @POS ;djb/bp BIG-1199-71271
"RTN","SCMCHLB2",88,0)
 Q
"RTN","SCMCHLB2",89,0)
 ;
"RTN","SCMCHLB2",90,0)
PRE ;Entry has been deleted from file 404.53. Send deletes to NPCD.
"RTN","SCMCHLB2",91,0)
 ;****
"RTN","SCMCHLB2",92,0)
 ;Currently, deletes to 404.53 are not allowed if there are
"RTN","SCMCHLB2",93,0)
 ;patients assigned.
"RTN","SCMCHLB2",94,0)
 ;****
"RTN","SCMCHLB2",95,0)
 Q
"RTN","SCMCHLB2",96,0)
 ;
"RTN","SCMCHLB2",97,0)
GETEVENT ;Get data from PCMM HL7 EVENT file
"RTN","SCMCHLB2",98,0)
 ;Return: DFN - Patient IEN
"RTN","SCMCHLB2",99,0)
 ;        TP  - Team Position
"RTN","SCMCHLB2",100,0)
 ;
"RTN","SCMCHLB2",101,0)
 NEW IEN,ND,PTR
"RTN","SCMCHLB2",102,0)
 ;
"RTN","SCMCHLB2",103,0)
 ;If in manual mode, get SCEVIEN (404.48 IEN).
"RTN","SCMCHLB2",104,0)
 I $G(SCMANUAL) D  ;
"RTN","SCMCHLB2",105,0)
 . S (IEN,SCEVIEN)=0
"RTN","SCMCHLB2",106,0)
 . F  S IEN=$O(^SCPT(404.48,IEN)) Q:'IEN!SCEVIEN  D  ;
"RTN","SCMCHLB2",107,0)
 .. S PTR=$P($G(^(IEN,0)),U,7) Q:PTR=""
"RTN","SCMCHLB2",108,0)
 .. Q:PTR'=VARPTR
"RTN","SCMCHLB2",109,0)
 .. S SCEVIEN=IEN
"RTN","SCMCHLB2",110,0)
 ;
"RTN","SCMCHLB2",111,0)
 S ND=$G(^SCPT(404.48,SCEVIEN,0))
"RTN","SCMCHLB2",112,0)
 S DFN=$P(ND,U,2) ;..Patient (DFN)
"RTN","SCMCHLB2",113,0)
 S TP=$P(ND,U,4) ;...Team Position
"RTN","SCMCHLB2",114,0)
 Q
"RTN","SCMCHLE")
0^14^B5993237
"RTN","SCMCHLE",1,0)
SCMCHLE ;BP/DJB - PCMM HL7 EVENT File Utils ; 12/16/99 8:59am
"RTN","SCMCHLE",2,0)
 ;;5.3;Scheduling;**177,204**;May 01, 1999
"RTN","SCMCHLE",3,0)
 ;
"RTN","SCMCHLE",4,0)
 ;Reference routine: ^SCDXFU01
"RTN","SCMCHLE",5,0)
ADD(EVDATE,EVPTR,DFN,TP) ;Add a new event to PCMM HL7 EVENT file (#404.48).
"RTN","SCMCHLE",6,0)
 ;
"RTN","SCMCHLE",7,0)
 ; Input: EVDATE - Date/time of PCMM event in FM format.
"RTN","SCMCHLE",8,0)
 ;                 Default="NOW"
"RTN","SCMCHLE",9,0)
 ;        EVPTR  - Variable pointer that records IEN and file where
"RTN","SCMCHLE",10,0)
 ;                 event occurred. Used to determine Table Designator
"RTN","SCMCHLE",11,0)
 ;                 and Table ID for the ZPC segment.
"RTN","SCMCHLE",12,0)
 ;        DFN    - Pointer to PATIENT file (#2).
"RTN","SCMCHLE",13,0)
 ;        TP     - Team Position (Used when processing deletes)
"RTN","SCMCHLE",14,0)
 ;                 In the case of changes to 404.53, this may be
"RTN","SCMCHLE",15,0)
 ;                 PrecepteeTP-PreceptorTP.
"RTN","SCMCHLE",16,0)
 ;Output: None
"RTN","SCMCHLE",17,0)
 ;
"RTN","SCMCHLE",18,0)
 NEW EVIEN
"RTN","SCMCHLE",19,0)
 Q:$G(SCMCOFF)  ;..djb/bp NOIS ISH-1299-40937. Turn off HL7 messaging.
"RTN","SCMCHLE",20,0)
 Q:'$G(EVPTR)  ;......................Event pointer
"RTN","SCMCHLE",21,0)
 S EVIEN=$$CREATE(.EVDATE) ;..........Create new entry
"RTN","SCMCHLE",22,0)
 Q:+EVIEN<0
"RTN","SCMCHLE",23,0)
 S DFN=$G(DFN)
"RTN","SCMCHLE",24,0)
 S TP=$G(TP)
"RTN","SCMCHLE",25,0)
 D STORE(EVIEN,EVPTR,DFN,$G(DUZ),TP) ;Store event info
"RTN","SCMCHLE",26,0)
 D TRANSMIT(EVIEN,1) ;................Mark entry for transmission
"RTN","SCMCHLE",27,0)
 Q
"RTN","SCMCHLE",28,0)
 ;
"RTN","SCMCHLE",29,0)
CREATE(EVDATE) ;Create entry in PCMM HL7 EVENT (#404.48)
"RTN","SCMCHLE",30,0)
 ;
"RTN","SCMCHLE",31,0)
 ; Input: EVDATE - Date/time of PCMM event, in Fileman format.
"RTN","SCMCHLE",32,0)
 ;                 Default="NOW".
"RTN","SCMCHLE",33,0)
 ;Output: Pointer to entry in PCMM HL7 EVENT (#404.48)
"RTN","SCMCHLE",34,0)
 ;        -1^Error - Unable to create entry
"RTN","SCMCHLE",35,0)
 ;
"RTN","SCMCHLE",36,0)
 NEW SCERR,SCFDA,SCIEN
"RTN","SCMCHLE",37,0)
 S:'$G(EVDATE) EVDATE="NOW"
"RTN","SCMCHLE",38,0)
 ;
"RTN","SCMCHLE",39,0)
 S SCFDA(404.48,"+1,",.01)=EVDATE
"RTN","SCMCHLE",40,0)
 D UPDATE^DIE("E","SCFDA","SCIEN","SCERR")
"RTN","SCMCHLE",41,0)
 ;
"RTN","SCMCHLE",42,0)
 I $D(SCERR) Q "-1^Unable to create entry in PCMM HL7 EVENT file"
"RTN","SCMCHLE",43,0)
 Q SCIEN(1)
"RTN","SCMCHLE",44,0)
 ;
"RTN","SCMCHLE",45,0)
STORE(EVIEN,EVPTR,DFN,EVDUZ,TP) ;Store data in PCMM HL7 EVENT file
"RTN","SCMCHLE",46,0)
 ;
"RTN","SCMCHLE",47,0)
 ; Input: EVIEN - Pointer to entry in PCMM HL7 EVENT file (#404.48)
"RTN","SCMCHLE",48,0)
 ;        EVPTR - Variable pointer that records IEN and file where
"RTN","SCMCHLE",49,0)
 ;                event occurred. Used to determine Table Designator
"RTN","SCMCHLE",50,0)
 ;                and Table ID for the ZPC segment.
"RTN","SCMCHLE",51,0)
 ;        DFN   - Pointer to PATIENT file (#2).
"RTN","SCMCHLE",52,0)
 ;        EVDUZ - Pointer to entry in NEW PERSON file (#200) that
"RTN","SCMCHLE",53,0)
 ;                caused event to occur (defaults to current DUZ).
"RTN","SCMCHLE",54,0)
 ;        TP    - Team Position (Used when processing deletes)
"RTN","SCMCHLE",55,0)
 ;                In the case of changes to 404.53, this may be
"RTN","SCMCHLE",56,0)
 ;Output: None
"RTN","SCMCHLE",57,0)
 ;Notes : If EVDUZ and current DUZ not valid, use POSTMASTER (.5)
"RTN","SCMCHLE",58,0)
 ;
"RTN","SCMCHLE",59,0)
 NEW SCERR,SCFDA,SCIENS
"RTN","SCMCHLE",60,0)
 ;
"RTN","SCMCHLE",61,0)
 ;Check input
"RTN","SCMCHLE",62,0)
 Q:'+$G(EVIEN)
"RTN","SCMCHLE",63,0)
 Q:'$D(^SCPT(404.48,EVIEN))
"RTN","SCMCHLE",64,0)
 Q:'$G(EVPTR)
"RTN","SCMCHLE",65,0)
 S:'+$G(EVDUZ) EVDUZ=$S($G(DUZ):DUZ,1:.5)
"RTN","SCMCHLE",66,0)
 I EVDUZ'=.5,'$D(^VA(200,EVDUZ)) S EVDUZ=.5
"RTN","SCMCHLE",67,0)
 ;
"RTN","SCMCHLE",68,0)
 S SCIENS=EVIEN_","
"RTN","SCMCHLE",69,0)
 S SCFDA(404.48,SCIENS,.02)=DFN ;....Patient
"RTN","SCMCHLE",70,0)
 S SCFDA(404.48,SCIENS,.04)=TP ;.....Team Position
"RTN","SCMCHLE",71,0)
 S SCFDA(404.48,SCIENS,.05)=EVDUZ ;..User
"RTN","SCMCHLE",72,0)
 S SCFDA(404.48,SCIENS,.07)=EVPTR ;..Variable event pointer
"RTN","SCMCHLE",73,0)
 D FILE^DIE(,"SCFDA","SCERR")
"RTN","SCMCHLE",74,0)
 Q
"RTN","SCMCHLE",75,0)
 ;
"RTN","SCMCHLE",76,0)
TRANSMIT(EVIEN,RESET) ;Set transmit flag in PCMM HL7 EVENT (#404.48)
"RTN","SCMCHLE",77,0)
 ;
"RTN","SCMCHLE",78,0)
 ;Input: EVIEN - Pointer to entry in PCMM HL7 EVENT file (#404.48)
"RTN","SCMCHLE",79,0)
 ;       RESET - Should TRANSMISSION REQUIRED fld be ON or OFF?
"RTN","SCMCHLE",80,0)
 ;                  0 = NO
"RTN","SCMCHLE",81,0)
 ;                  1 = YES (Default)
"RTN","SCMCHLE",82,0)
 ;Output: None
"RTN","SCMCHLE",83,0)
 ;Notes : Setting TRANSMISSION REQUIRED field to 'YES' flags entry
"RTN","SCMCHLE",84,0)
 ;        entry for transmission.
"RTN","SCMCHLE",85,0)
 ;
"RTN","SCMCHLE",86,0)
 NEW SCERR,SCFDA,SCIENS
"RTN","SCMCHLE",87,0)
 ;
"RTN","SCMCHLE",88,0)
 ;Check input
"RTN","SCMCHLE",89,0)
 Q:'+$G(EVIEN)
"RTN","SCMCHLE",90,0)
 Q:'$D(^SCPT(404.48,EVIEN))
"RTN","SCMCHLE",91,0)
 S RESET=$S($G(RESET)=0:"NO",1:"YES")
"RTN","SCMCHLE",92,0)
 ;
"RTN","SCMCHLE",93,0)
 S SCIENS=EVIEN_","
"RTN","SCMCHLE",94,0)
 S SCFDA(404.48,SCIENS,.03)=RESET
"RTN","SCMCHLE",95,0)
 D FILE^DIE("E","SCFDA","SCERR")
"RTN","SCMCHLE",96,0)
 Q
"RTN","SCMCLK")
0^1^B49799907
"RTN","SCMCLK",1,0)
SCMCLK ;bp/cmf - Preceptor History Functions ; Sep 1999
"RTN","SCMCLK",2,0)
 ;;5.3;Scheduling;**177,204**;AUG 13, 1993
"RTN","SCMCLK",3,0)
 ;
"RTN","SCMCLK",4,0)
 ; - $$OKPREC functions
"RTN","SCMCLK",5,0)
 ;        - input variables (required)
"RTN","SCMCLK",6,0)
 ;               scien    := pointer to 404.57 (precepted ien)
"RTN","SCMCLK",7,0)
 ;               scpien   := pointer to 404.57 (preceptor ien)
"RTN","SCMCLK",8,0)
 ;               sclnkdt  := date to test
"RTN","SCMCLK",9,0)
 ;        - output        
"RTN","SCMCLK",10,0)
 ;               $p1      := 1=assignment ok
"RTN","SCMCLK",11,0)
 ;                           0=not
"RTN","SCMCLK",12,0)
 ;               $p2      := if not, reason code
"RTN","SCMCLK",13,0)
 ;               $p3      := if not, reason
"RTN","SCMCLK",14,0)
 ; 
"RTN","SCMCLK",15,0)
OKPREC(SCIEN,SCPIEN,SCLNKDT) ;
"RTN","SCMCLK",16,0)
 ;
"RTN","SCMCLK",17,0)
 S SCIEN=+$G(SCIEN,0)
"RTN","SCMCLK",18,0)
 S SCPIEN=+$G(SCPIEN,0)
"RTN","SCMCLK",19,0)
 S SCLNKDT=+$G(SCLNKDT,0)
"RTN","SCMCLK",20,0)
 I (SCIEN<1)!(SCPIEN<1)!(SCLNKDT<1) Q $$S(8)
"RTN","SCMCLK",21,0)
 ; 
"RTN","SCMCLK",22,0)
 I SCIEN=SCPIEN Q $$S(1)
"RTN","SCMCLK",23,0)
 ;
"RTN","SCMCLK",24,0)
 N SCX,SCY,SCPAH,SCPAHA
"RTN","SCMCLK",25,0)
 I '$D(^SCTM(404.57,SCIEN,0)) Q $$S(8)
"RTN","SCMCLK",26,0)
 S SCX=$G(^SCTM(404.57,SCIEN,0))
"RTN","SCMCLK",27,0)
 I '$D(^SCTM(404.57,SCPIEN,0)) Q $$S(8)
"RTN","SCMCLK",28,0)
 S SCY=^SCTM(404.57,SCPIEN,0)
"RTN","SCMCLK",29,0)
 I $P(SCX,U,2)'=$P(SCY,U,2) Q $$S(2)
"RTN","SCMCLK",30,0)
 ;
"RTN","SCMCLK",31,0)
 D DTARY(0)
"RTN","SCMCLK",32,0)
 S SCPAH=$$VALHIST^SCAPMCU5(404.53,SCPIEN,"SCPAHA")
"RTN","SCMCLK",33,0)
 I $$ACTHIST^SCAPMCU5("SCPAHA","SCLNKDT") Q $$S(3)
"RTN","SCMCLK",34,0)
 ;I $$ACTHIST^SCAPMCU2(404.53,SCPIEN,"SCLNKDT") Q $$S(3)
"RTN","SCMCLK",35,0)
 ;
"RTN","SCMCLK",36,0)
 I '+$P(SCY,U,12) Q $$S(4)
"RTN","SCMCLK",37,0)
 ;
"RTN","SCMCLK",38,0)
 I +$P(SCX,U,4),'+$P(SCY,U,4) Q $$S(5)
"RTN","SCMCLK",39,0)
 ;
"RTN","SCMCLK",40,0)
 I $$ACTHIST^SCAPMCU2(404.59,SCPIEN,"SCLNKDT")<1 Q $$S(6)
"RTN","SCMCLK",41,0)
 ;
"RTN","SCMCLK",42,0)
 I $$CHKPRTP() Q $$S(9)
"RTN","SCMCLK",43,0)
 ;
"RTN","SCMCLK",44,0)
 Q 1
"RTN","SCMCLK",45,0)
 ;
"RTN","SCMCLK",46,0)
OKPREC1(SCPIEN,SCLNKDT) ;
"RTN","SCMCLK",47,0)
 ;               ; prevent preceptor assignment danglers
"RTN","SCMCLK",48,0)
 ;               ; should also return array of danglers, if any,
"RTN","SCMCLK",49,0)
 ;               ; for a cleanup function, but not asked for yet
"RTN","SCMCLK",50,0)
 ;
"RTN","SCMCLK",51,0)
 ;
"RTN","SCMCLK",52,0)
 S SCPIEN=+$G(SCPIEN,0)
"RTN","SCMCLK",53,0)
 S SCLNKDT=+$G(SCLNKDT,0)
"RTN","SCMCLK",54,0)
 I (SCPIEN<1)!(SCLNKDT<1) Q $$S(8)
"RTN","SCMCLK",55,0)
 I '$D(^SCTM(404.53,"AD",SCPIEN)) Q 1
"RTN","SCMCLK",56,0)
 ;
"RTN","SCMCLK",57,0)
 N SCX,SCN
"RTN","SCMCLK",58,0)
 D DTARY(1)
"RTN","SCMCLK",59,0)
 K ^TMP("SCPHIS",$J)
"RTN","SCMCLK",60,0)
 S SCX=$$PRECHIS(SCPIEN,"SCLNKDT","^TMP(""SCPHIS"",$J)")
"RTN","SCMCLK",61,0)
 K ^TMP("SCPHIS",$J)
"RTN","SCMCLK",62,0)
 ;
"RTN","SCMCLK",63,0)
 Q $S(SCX>0:$$S(7),1:1)
"RTN","SCMCLK",64,0)
 ;
"RTN","SCMCLK",65,0)
OKPREC2(SCIEN,SCLNKDT) ; return preceptor ien^name, if any
"RTN","SCMCLK",66,0)
 ;               ; used for computed field 306 of file 404.57
"RTN","SCMCLK",67,0)
 ;
"RTN","SCMCLK",68,0)
 ;
"RTN","SCMCLK",69,0)
 S SCIEN=+$G(SCIEN,0)
"RTN","SCMCLK",70,0)
 S SCLNKDT=+$G(SCLNKDT,0)
"RTN","SCMCLK",71,0)
 I (SCIEN<1)!(SCLNKDT<1) Q $$S(8)
"RTN","SCMCLK",72,0)
 N SCX,SCP2,SCP3,SCPIEN,SCLNKLI,SCLNKER,SCPAH,SCPAHA
"RTN","SCMCLK",73,0)
 D DTARY(0)
"RTN","SCMCLK",74,0)
 S SCPAH=$$VALHIST^SCAPMCU5(404.53,SCIEN,"SCPAHA")
"RTN","SCMCLK",75,0)
 S SCX=$$ACTHIST^SCAPMCU5("SCPAHA","SCLNKDT")
"RTN","SCMCLK",76,0)
 ;S SCX=$$ACTHIST^SCAPMCU2(404.53,SCIEN,"SCLNKDT")
"RTN","SCMCLK",77,0)
 I +SCX<1 Q ""
"RTN","SCMCLK",78,0)
 S SCP2=$P(SCX,U,2)
"RTN","SCMCLK",79,0)
 I +SCP2<1 Q ""
"RTN","SCMCLK",80,0)
 S SCP3=$P(SCX,U,3)
"RTN","SCMCLK",81,0)
 I '$D(^SCTM(404.53,SCP3,0)) Q $$S(8)
"RTN","SCMCLK",82,0)
 S SCPIEN=$P(^SCTM(404.53,SCP3,0),U,6)
"RTN","SCMCLK",83,0)
 Q $$GETPRTP^SCAPMCU2(SCPIEN,SCLNKDT)
"RTN","SCMCLK",84,0)
 ;
"RTN","SCMCLK",85,0)
OKPREC3(SCIEN,SCLNKDT) ; return preceptor position ien^name, if any
"RTN","SCMCLK",86,0)
 ;               ; used for computed field 305 of file 404.57
"RTN","SCMCLK",87,0)
 ;
"RTN","SCMCLK",88,0)
 ;
"RTN","SCMCLK",89,0)
 S SCIEN=+$G(SCIEN,0)
"RTN","SCMCLK",90,0)
 S SCLNKDT=+$G(SCLNKDT,0)
"RTN","SCMCLK",91,0)
 I (SCIEN<1)!(SCLNKDT<1) Q $$S(8)
"RTN","SCMCLK",92,0)
 N SCX,SCP2,SCP3,SCPIEN,SCLNKER,SCPAH,SCPAHA
"RTN","SCMCLK",93,0)
 D DTARY(0)
"RTN","SCMCLK",94,0)
 S SCPAH=$$VALHIST^SCAPMCU5(404.53,SCIEN,"SCPAHA")
"RTN","SCMCLK",95,0)
 S SCX=$$ACTHIST^SCAPMCU5("SCPAHA","SCLNKDT")
"RTN","SCMCLK",96,0)
 ;S SCX=$$ACTHIST^SCAPMCU2(404.53,SCIEN,"SCLNKDT")
"RTN","SCMCLK",97,0)
 I +SCX<1 Q ""
"RTN","SCMCLK",98,0)
 S SCP2=$P(SCX,U,2)
"RTN","SCMCLK",99,0)
 I +SCP2<1 Q ""
"RTN","SCMCLK",100,0)
 S SCP3=$P(SCX,U,3)
"RTN","SCMCLK",101,0)
 I '$D(^SCTM(404.53,SCP3,0)) Q $$S(8)
"RTN","SCMCLK",102,0)
 S SCPIEN=$P(^SCTM(404.53,SCP3,0),U,6)
"RTN","SCMCLK",103,0)
 Q SCPIEN_U_$$EXT^SCAPMCU2(404.53,SCPIEN)
"RTN","SCMCLK",104,0)
 ;
"RTN","SCMCLK",105,0)
OKPREC4(SCIEN) ; return if precepted position can be un-precepted
"RTN","SCMCLK",106,0)
 ;       ; if patient assign after 1st preceptment date, NO
"RTN","SCMCLK",107,0)
 ;       ; used by computed field #400 of file 404.57
"RTN","SCMCLK",108,0)
 S SCIEN=$G(SCIEN,0)
"RTN","SCMCLK",109,0)
 I (SCIEN<1)!('$D(^SCTM(404.57,SCIEN))) Q $$S(8)
"RTN","SCMCLK",110,0)
 I '$D(^SCTM(404.53,"B",SCIEN)) Q 1
"RTN","SCMCLK",111,0)
 ;
"RTN","SCMCLK",112,0)
 N SCVALHIS,SCDT,SCX
"RTN","SCMCLK",113,0)
 S SCDT=$P($$VALHIST^SCAPMCU5(404.53,SCIEN,"SCVALHIS"),U,2)
"RTN","SCMCLK",114,0)
 I SCDT=0 Q 1
"RTN","SCMCLK",115,0)
 S SCX=$$PCPOSCNT^SCAPMCU1(SCIEN,SCDT,0,1)
"RTN","SCMCLK",116,0)
 Q $S(SCX>0:$$S(10),1:1)
"RTN","SCMCLK",117,0)
 ;
"RTN","SCMCLK",118,0)
OKPREC5(SCIEN,SCLNKDT) ; if position has a preceptor,
"RTN","SCMCLK",119,0)
 ;               ; is preceptor link valid?
"RTN","SCMCLK",120,0)
 ;
"RTN","SCMCLK",121,0)
 S SCIEN=$G(SCIEN,0)
"RTN","SCMCLK",122,0)
 S SCLNKDT=$G(SCLNKDT,DT)
"RTN","SCMCLK",123,0)
 I (SCIEN<1)!(SCLNKDT<1) Q $$S(8)
"RTN","SCMCLK",124,0)
 N SCPIEN
"RTN","SCMCLK",125,0)
 S SCPIEN=+$$OKPREC3(SCIEN,SCLNKDT)
"RTN","SCMCLK",126,0)
 I SCPIEN<1 Q 1
"RTN","SCMCLK",127,0)
 Q $$OKPREC(SCIEN,SCPIEN,SCLNKDT)
"RTN","SCMCLK",128,0)
 ;
"RTN","SCMCLK",129,0)
PRECHIS(SCPIEN,SCDATES,SCLIST) ;return precepted positions for preceptor
"RTN","SCMCLK",130,0)
 ; input
"RTN","SCMCLK",131,0)
 ;    SCPIEN := preceptor pos ien (404.57) (required)
"RTN","SCMCLK",132,0)
 ;    SCDATES := standard PCMM date array  (required)
"RTN","SCMCLK",133,0)
 ;    SCDATES(begin) := start date [default = DT]
"RTN","SCMCLK",134,0)
 ;    SCDATES(end)   := end date   [default = DT]
"RTN","SCMCLK",135,0)
 ;    SCDATES(incl)  := always set to 0
"RTN","SCMCLK",136,0)
 ;    SCLIST := output array (required)
"RTN","SCMCLK",137,0)
 ;
"RTN","SCMCLK",138,0)
 ; output
"RTN","SCMCLK",139,0)
 ;    @SCLIST@(scn)
"RTN","SCMCLK",140,0)
 ;     format := 
"RTN","SCMCLK",141,0)
 ;      pieces 1-13:  same as SCLIST(scn,) node of $$prtp^scapmc8
"RTN","SCMCLK",142,0)
 ;      pieces 14-16: same as SCLIST(scn,'PR',) node of $$prtp^scapmc8
"RTN","SCMCLK",143,0)
 ;    @SCLIST@('SCPR',precepted team posn ien (404.57) +
"RTN","SCMCLK",144,0)
 ;                   ,preceptor start date +
"RTN","SCMCLK",145,0)
 ;                   ,preceptor asgn ien, +
"RTN","SCMCLK",146,0)
 ;                   ,precepted posn asgn ien,scn)
"RTN","SCMCLK",147,0)
 ;
"RTN","SCMCLK",148,0)
 S SCPIEN=+$G(SCPIEN,0)
"RTN","SCMCLK",149,0)
 S SCDATES=$G(SCDATES)
"RTN","SCMCLK",150,0)
 S SCLIST=$G(SCLIST)
"RTN","SCMCLK",151,0)
 I (SCPIEN<1)!(SCDATES']"")!(SCLIST']"") Q $$S(8)
"RTN","SCMCLK",152,0)
 ;
"RTN","SCMCLK",153,0)
 N SCN,SCPVAL,SCPN,SCIEN,SCX,SCXP,SCXPR,SCXARY,SCXDT
"RTN","SCMCLK",154,0)
 N SCPTP,SCPTPN,SCBEGIN,SCEND,SCESEQ,SCLSEQ
"RTN","SCMCLK",155,0)
 N SCP1P11,SCP12,SCP13,SCP14,SCP15,SCP16,SCR
"RTN","SCMCLK",156,0)
 ;
"RTN","SCMCLK",157,0)
 S (@SCDATES@("BEGIN"),SCBEGIN)=$G(@SCDATES@("BEGIN"),DT)
"RTN","SCMCLK",158,0)
 S (@SCDATES@("END"),SCEND)=$G(@SCDATES@("END"),DT)
"RTN","SCMCLK",159,0)
 S @SCDATES@("INCL")=0
"RTN","SCMCLK",160,0)
 ;
"RTN","SCMCLK",161,0)
 I '$D(^SCTM(404.53,"D",SCPIEN)) Q 0
"RTN","SCMCLK",162,0)
 I '$D(^SCTM(404.53,"AD",SCPIEN)) Q 0
"RTN","SCMCLK",163,0)
 S SCPN=0                              ; incrementor
"RTN","SCMCLK",164,0)
 S @SCLIST@(0)=0
"RTN","SCMCLK",165,0)
 S SCIEN=0
"RTN","SCMCLK",166,0)
 F  S SCIEN=$O(^SCTM(404.53,"AD",SCPIEN,SCIEN)) Q:'SCIEN  D
"RTN","SCMCLK",167,0)
 . ;K SCXPR
"RTN","SCMCLK",168,0)
 . ;S SCX=$$ACTHIST^SCAPMCU2(404.53,SCIEN,.SCDATES,"SCXER","SCXPR")
"RTN","SCMCLK",169,0)
 . ;Q:+SCX<1
"RTN","SCMCLK",170,0)
 . K SCPVAL(SCIEN)
"RTN","SCMCLK",171,0)
 . S SCX=$$VALHIST^SCAPMCU5(404.53,SCIEN,"SCPVAL("_SCIEN_")")
"RTN","SCMCLK",172,0)
 . Q:'$D(SCPVAL(SCIEN))
"RTN","SCMCLK",173,0)
 . S SCX=$$ACTHIST^SCAPMCU5("SCPVAL("_SCIEN_")",.SCDATES)
"RTN","SCMCLK",174,0)
 . Q:+SCX<1
"RTN","SCMCLK",175,0)
 . ;
"RTN","SCMCLK",176,0)
 . S SCX=0
"RTN","SCMCLK",177,0)
 . F  S SCX=$O(^SCTM(404.53,"AD",SCPIEN,SCIEN,1,SCX)) Q:'SCX  D
"RTN","SCMCLK",178,0)
 . . Q:'$D(SCPVAL(SCIEN,"I",SCX))
"RTN","SCMCLK",179,0)
 . . S SCXARY=$O(SCPVAL(SCIEN,"I",SCX,0))
"RTN","SCMCLK",180,0)
 . . S SCP14=$O(SCPVAL(SCIEN,SCXARY,0))              ;precept start dt
"RTN","SCMCLK",181,0)
 . . S SCP16=$O(SCPVAL(SCIEN,SCXARY,SCP14,0))        ;precept start ien
"RTN","SCMCLK",182,0)
 . . S SCP15=$P(SCPVAL(SCIEN,SCXARY,SCP14,SCP16),U)
"RTN","SCMCLK",183,0)
 . . S SCP15=$S(+SCP15>1:SCP15,1:9999999)            ;precept end dt
"RTN","SCMCLK",184,0)
 . . Q:'$$DTCHK^SCAPU1(SCBEGIN,SCEND,0,SCP14,SCP15)
"RTN","SCMCLK",185,0)
 . . K SCPTP
"RTN","SCMCLK",186,0)
 . . K SCXDT
"RTN","SCMCLK",187,0)
 . . S SCXDT("BEGIN")=SCP14
"RTN","SCMCLK",188,0)
 . . S SCXDT("END")=SCP15
"RTN","SCMCLK",189,0)
 . . S SCXDT("INCL")=0
"RTN","SCMCLK",190,0)
 . . S SCXP=$$PRTP^SCAPMC8(SCIEN,"SCXDT","SCPTP","SCPTPE")
"RTN","SCMCLK",191,0)
 . . Q:+$G(SCPTP(0))<1
"RTN","SCMCLK",192,0)
 . . F SCXP=1:1:SCPTP(0) D
"RTN","SCMCLK",193,0)
 . . . S SCPN=SCPN+1
"RTN","SCMCLK",194,0)
 . . . S SCP1P11=$P(SCPTP(SCXP),U,1,11)
"RTN","SCMCLK",195,0)
 . . . S SCP12=$P(SCPTP(SCXP),U,12)
"RTN","SCMCLK",196,0)
 . . . S SCP13=$P(SCPTP(SCXP),U,13)
"RTN","SCMCLK",197,0)
 . . . S SCR=SCP1P11_U_SCP12_U_SCP13_U_SCP14_U_SCP15_U_SCP16
"RTN","SCMCLK",198,0)
 . . . S @SCLIST@(0)=SCPN
"RTN","SCMCLK",199,0)
 . . . S @SCLIST@(SCPN)=SCR
"RTN","SCMCLK",200,0)
 . . . S @SCLIST@("SCPR",SCIEN,SCP14,SCP16,$P(SCR,U,11),SCPN)=""
"RTN","SCMCLK",201,0)
 . . . Q
"RTN","SCMCLK",202,0)
 . . Q
"RTN","SCMCLK",203,0)
 . K SCPVAL(SCIEN)
"RTN","SCMCLK",204,0)
 . Q
"RTN","SCMCLK",205,0)
 ;
"RTN","SCMCLK",206,0)
PRECQ Q @SCLIST@(0)>0
"RTN","SCMCLK",207,0)
 ;
"RTN","SCMCLK",208,0)
DTARY(SCX) ;
"RTN","SCMCLK",209,0)
 S SCLNKDT("BEGIN")=SCLNKDT
"RTN","SCMCLK",210,0)
 S SCLNKDT("END")=$S(SCX=1:9999999,1:SCLNKDT)
"RTN","SCMCLK",211,0)
 S SCLNKDT("INCL")=0
"RTN","SCMCLK",212,0)
 ;I $G(SCLIST)]"" S SCLNKDT("END")=$G(SCLNKDT0,9999999)
"RTN","SCMCLK",213,0)
 Q
"RTN","SCMCLK",214,0)
 ;
"RTN","SCMCLK",215,0)
CHKPRTP() ;
"RTN","SCMCLK",216,0)
 Q $$GETPRTP^SCAPMCU2(SCIEN,SCLNKDT)=$$GETPRTP^SCAPMCU2(SCPIEN,SCLNKDT)
"RTN","SCMCLK",217,0)
 ;
"RTN","SCMCLK",218,0)
S(SCX) Q 0_U_SCX_U_$P($T(T+SCX),";;",2)_"."
"RTN","SCMCLK",219,0)
 ;
"RTN","SCMCLK",220,0)
T ;;
"RTN","SCMCLK",221,0)
1 ;;Position can't precept itself;;
"RTN","SCMCLK",222,0)
2 ;;Preceptor and precepted must be on same team;;
"RTN","SCMCLK",223,0)
3 ;;Preceptor can't have a preceptor on assignment date;;
"RTN","SCMCLK",224,0)
4 ;;Preceptor must be able to act as a preceptor;;
"RTN","SCMCLK",225,0)
5 ;;Preceptor must be PC if precepted is PC;;
"RTN","SCMCLK",226,0)
6 ;;Preceptor must be active on assignment date;;
"RTN","SCMCLK",227,0)
7 ;;Active or future precepted position(s);;
"RTN","SCMCLK",228,0)
8 ;;Invalid Parameter
"RTN","SCMCLK",229,0)
9 ;;Preceptor/Precepted Staff can't be the same;;
"RTN","SCMCLK",230,0)
10 ;;Position has patient assignments after precepted date;;
"RTN","SCMCLK",231,0)
 ;
"RTN","SCMCTPU2")
0^13^B8191584
"RTN","SCMCTPU2",1,0)
SCMCTPU2 ;ALB/REW - Team Position Utilities ; 9 Jun 1995
"RTN","SCMCTPU2",2,0)
 ;;5.3;Scheduling;**41,148,204**;AUG 13, 1993
"RTN","SCMCTPU2",3,0)
 ;1
"RTN","SCMCTPU2",4,0)
YSPTTPPC(DFN,SCACT,SCROLE) ;is it ok to give patient a new pc position
"RTN","SCMCTPU2",5,0)
 ;  
"RTN","SCMCTPU2",6,0)
 ;  Return [OK:1,Not OK: 0^Message]
"RTN","SCMCTPU2",7,0)
 Q:"2^1"'[$G(SCROLE) "0^Bad PC Role"
"RTN","SCMCTPU2",8,0)
 N SCOK,SCX,SCTP,SCROLETX
"RTN","SCMCTPU2",9,0)
 S SCROLETX=$S(SCROLE=1:"Practitioner",(SCROLE=2):"Attending",1:"Error")
"RTN","SCMCTPU2",10,0)
 ;does pt have a current pc position?
"RTN","SCMCTPU2",11,0)
 S SCTP=$$GETPCTP^SCAPMCU2(DFN,DT,SCROLE)
"RTN","SCMCTPU2",12,0)
 IF SCTP>0 S SCOK="0^Pt has current PC "_SCROLETX_" Position Assignment"_U_SCTP G QTOKPC
"RTN","SCMCTPU2",13,0)
 ;does pt have a future pc position?
"RTN","SCMCTPU2",14,0)
 S SCX=$O(^SCPT(404.43,"APCPOS",DFN,SCROLE,SCACT))
"RTN","SCMCTPU2",15,0)
 IF SCX D  G QTOKPC
"RTN","SCMCTPU2",16,0)
 .S SCTP=$O(^SCPT(404.43,"APCPOS",DFN,SCROLE,+SCX,0))
"RTN","SCMCTPU2",17,0)
 .S SCOK="0^Patient has future PC Assignment to the "_$P($G(^SCTM(404.57,+SCTP,0)),U,1)_" position."_U_SCTP
"RTN","SCMCTPU2",18,0)
 S SCOK=1
"RTN","SCMCTPU2",19,0)
QTOKPC Q SCOK
"RTN","SCMCTPU2",20,0)
 ;
"RTN","SCMCTPU2",21,0)
OKACPTTP(DFN,SCTP,DATE,ACTIVE) ;is it ok to activate pt pos assignment?
"RTN","SCMCTPU2",22,0)
 N SCOK,SCDT,SCNODE,SCINACT
"RTN","SCMCTPU2",23,0)
 S SCOK=1
"RTN","SCMCTPU2",24,0)
 G:'$D(^SCPT(404.43,"ADFN",DFN)) ENDOK  ;quick check
"RTN","SCMCTPU2",25,0)
 ;is position active now(if checking)?
"RTN","SCMCTPU2",26,0)
 IF $G(ACTIVE) D  G:'SCOK ENDOK
"RTN","SCMCTPU2",27,0)
 . S SCOK=+$$ACTTP^SCMCTPU(SCTP,DATE)
"RTN","SCMCTPU2",28,0)
 ;is the patient assigned to this position either now or in future?
"RTN","SCMCTPU2",29,0)
 S SCDT=$O(^SCPT(404.43,"ADFN",DFN,SCTP,3990101),-1)
"RTN","SCMCTPU2",30,0)
 S SCPTTP=$O(^SCPT(404.43,"ADFN",DFN,SCTP,+SCDT,0))
"RTN","SCMCTPU2",31,0)
 IF SCPTTP D
"RTN","SCMCTPU2",32,0)
 .S SCNODE=$G(^SCPT(404.43,SCPTTP,0))
"RTN","SCMCTPU2",33,0)
 .S SCINACT=$P(SCNODE,U,4)
"RTN","SCMCTPU2",34,0)
 .IF ('SCINACT)!(SCINACT>DATE) D
"RTN","SCMCTPU2",35,0)
 ..S SCOK=0   ;no inactive date or inact after date
"RTN","SCMCTPU2",36,0)
ENDOK Q SCOK
"RTN","SCMCTPU2",37,0)
 ;
"RTN","SCMCTPU2",38,0)
PCRLPTTP(DFN,SCTP,DATE) ; can position be pc practitioner or pc attending
"RTN","SCMCTPU2",39,0)
 ; return yes pract^yes attend
"RTN","SCMCTPU2",40,0)
 Q $$CHKROLE(DFN,SCTP,DATE,1)_U_$$CHKROLE(DFN,SCTP,DATE,2)
"RTN","SCMCTPU2",41,0)
 ;
"RTN","SCMCTPU2",42,0)
CHKROLE(DFN,SCTP,DATE,ROLE) ;can position file role for patient?
"RTN","SCMCTPU2",43,0)
 ;this is not a stand-alone function
"RTN","SCMCTPU2",44,0)
 N SCCUR,SCDT,SCTPRL,SCPTTP,SCOK,SCNODE,SCINACT,SCACT
"RTN","SCMCTPU2",45,0)
 S SCOK=1
"RTN","SCMCTPU2",46,0)
 ;bp/cmf 204 change code begin
"RTN","SCMCTPU2",47,0)
 ;original code next line
"RTN","SCMCTPU2",48,0)
 ;IF $G(ROLE)&('$P($G(^SCTM(404.57,+$G(SCTP),0)),U,4)) S SCOK=0 G QTCHKRL
"RTN","SCMCTPU2",49,0)
 ;bp/cmf 204 new code begin
"RTN","SCMCTPU2",50,0)
 ;bp/cmf 204 new code end
"RTN","SCMCTPU2",51,0)
 I $G(ROLE) D  G:SCOK=0 QTCHKRL
"RTN","SCMCTPU2",52,0)
 . I '$P($G(^SCTM(404.57,+$G(SCTP),0)),U,4) S SCOK=0 Q
"RTN","SCMCTPU2",53,0)
 . N SCTM
"RTN","SCMCTPU2",54,0)
 . S SCTM=$P($G(^SCTM(404.57,SCTP,0)),U,2)
"RTN","SCMCTPU2",55,0)
 . I $P($G(^SCTM(404.51,SCTM,0)),U,5)'=1 S SCOK=0
"RTN","SCMCTPU2",56,0)
 . Q
"RTN","SCMCTPU2",57,0)
 ;bp/cmf 204 change code end
"RTN","SCMCTPU2",58,0)
 S SCDT=$O(^SCPT(404.43,"APCPOS",DFN,ROLE,3990101),-1)
"RTN","SCMCTPU2",59,0)
 S SCTPRL=$O(^SCPT(404.43,"APCPOS",DFN,ROLE,+SCDT,0))
"RTN","SCMCTPU2",60,0)
 S SCPTTP=$O(^SCPT(404.43,"APCPOS",DFN,ROLE,+SCDT,+SCTPRL,0))
"RTN","SCMCTPU2",61,0)
 ;check if active
"RTN","SCMCTPU2",62,0)
 IF SCPTTP D
"RTN","SCMCTPU2",63,0)
 .S SCNODE=$G(^SCPT(404.43,SCPTTP,0))
"RTN","SCMCTPU2",64,0)
 .S SCACT=$P(SCNODE,U,3)
"RTN","SCMCTPU2",65,0)
 .Q:(DATE=SCACT)&(SCTP=SCTPRL)  ;if this date & position (editing current
"RTN","SCMCTPU2",66,0)
 .S SCINACT=$P(SCNODE,U,4)
"RTN","SCMCTPU2",67,0)
 .IF SCINACT D
"RTN","SCMCTPU2",68,0)
 ..IF SCINACT>DATE D
"RTN","SCMCTPU2",69,0)
 ...S SCOK=0  ;no making pc role before currently defined
"RTN","SCMCTPU2",70,0)
 .ELSE  D
"RTN","SCMCTPU2",71,0)
 ..S SCOK=0   ;no making pc role without inactivating current
"RTN","SCMCTPU2",72,0)
QTCHKRL Q SCOK
"RTN","SCMCUT")
0^9^B23756077
"RTN","SCMCUT",1,0)
SCMCUT ;ALB/JLU;General utility routine;8/17/99@1515
"RTN","SCMCUT",2,0)
 ;;5.3;Scheduling;**177,205,204**;AUG 13, 1993
"RTN","SCMCUT",3,0)
 ;
"RTN","SCMCUT",4,0)
 ;This is a general utility routine for the PCMM application.  Any
"RTN","SCMCUT",5,0)
 ;general purpose utility should be placed in this routine.
"RTN","SCMCUT",6,0)
 ;
"RTN","SCMCUT",7,0)
 ;
"RTN","SCMCUT",8,0)
CLNLST(SER,ARY,ACT) ;
"RTN","SCMCUT",9,0)
 ;This API is a function that returns the list of clients that
"RTN","SCMCUT",10,0)
 ;can run with the server that is passed in.
"RTN","SCMCUT",11,0)
 ;
"RTN","SCMCUT",12,0)
 ;INPUTs:  SER --- This is the server to check for.  It needs to be in
"RTN","SCMCUT",13,0)
 ;                 a patch format Ex. SD*5.3*177
"RTN","SCMCUT",14,0)
 ;         ARY --- This is the array root the list will be returned in.
"RTN","SCMCUT",15,0)
 ;                 If nothing is passed in a default will be used.  This
"RTN","SCMCUT",16,0)
 ;                 array must be clean before it is passed to this API.
"RTN","SCMCUT",17,0)
 ;                 No kills will be issued.
"RTN","SCMCUT",18,0)
 ;                 Ex. ^TMP("PCMM CLIENT LIST",$J,"1.2.0.0")=effective dt
"RTN","SCMCUT",19,0)
 ;                     ^TMP("PCMM CLIENT LIST",$J,"1.3.0.0")=effective dt
"RTN","SCMCUT",20,0)
 ;         ACT --- This variable indicates whether to:
"RTN","SCMCUT",21,0)
 ;                 1 - return only active clients (default)
"RTN","SCMCUT",22,0)
 ;                 0 - return all clients
"RTN","SCMCUT",23,0)
 ;
"RTN","SCMCUT",24,0)
 ;OUTPUTS --- The output of this function call is the data in the array
"RTN","SCMCUT",25,0)
 ;            variable but also the function itself.  It will either be
"RTN","SCMCUT",26,0)
 ;            1 for a success or -1 with an error message.
"RTN","SCMCUT",27,0)
 ;            Ex. "-1^not a valid server name"
"RTN","SCMCUT",28,0)
 ;                "1"
"RTN","SCMCUT",29,0)
 ;
"RTN","SCMCUT",30,0)
 N RESULTS
"RTN","SCMCUT",31,0)
 ;
"RTN","SCMCUT",32,0)
 ;checking input parameters
"RTN","SCMCUT",33,0)
 S SER=$G(SER)
"RTN","SCMCUT",34,0)
 I SER']"" S RESULTS="-1^Server variable not defined." G CLNLSTQ
"RTN","SCMCUT",35,0)
 S ARY=$G(ARY)
"RTN","SCMCUT",36,0)
 I ARY']"" S ARY=$NA(^TMP("PCMM CLIENT LIST",$J))
"RTN","SCMCUT",37,0)
 S ACT=$G(ACT,1)
"RTN","SCMCUT",38,0)
 ;
"RTN","SCMCUT",39,0)
 ;checking existance of server in PCMM SERVER PATCH file.
"RTN","SCMCUT",40,0)
 I '$D(^SCTM(404.45,"B",SER)) S RESULTS="-1^This server is not in the PCMM SERVER PATCH file." G CLNLSTQ
"RTN","SCMCUT",41,0)
 ;
"RTN","SCMCUT",42,0)
 ;if ACT, checking if server is active
"RTN","SCMCUT",43,0)
 I ACT,'$$ACTSER(SER) S RESULTS="-1^This server is not active." G CLNLSTQ
"RTN","SCMCUT",44,0)
 ;
"RTN","SCMCUT",45,0)
 ;loop through the server patches and build the list of clients.
"RTN","SCMCUT",46,0)
 N CLT,SERIEN
"RTN","SCMCUT",47,0)
 S CLT="",RESULTS="-1^No clients found for this Server."
"RTN","SCMCUT",48,0)
 ;
"RTN","SCMCUT",49,0)
 F  S CLT=$O(^SCTM(404.45,"ASER",SER,CLT)) Q:CLT=""  S SERIEN=$O(^SCTM(404.45,"ASER",SER,CLT,"")) Q:SERIEN=""  DO
"RTN","SCMCUT",50,0)
 .N NOD5,NOD6
"RTN","SCMCUT",51,0)
 .S NOD5=$G(^SCTM(404.45,SERIEN,0))
"RTN","SCMCUT",52,0)
 .Q:NOD5=""
"RTN","SCMCUT",53,0)
 .S NOD6=$G(^SCTM(404.46,$P(NOD5,U,2),0))
"RTN","SCMCUT",54,0)
 .Q:NOD6=""
"RTN","SCMCUT",55,0)
 .I ACT,$P(NOD6,U,2),$D(^SCTM(404.45,"ACT",SER,SERIEN)) S @ARY@($P(NOD6,U,1))=$P(NOD6,U,2,3),RESULTS=1
"RTN","SCMCUT",56,0)
 .I 'ACT S @ARY@($P(NOD6,U,1))=$P(NOD6,U,2,3),RESULTS=1
"RTN","SCMCUT",57,0)
 .Q
"RTN","SCMCUT",58,0)
 ;
"RTN","SCMCUT",59,0)
CLNLSTQ Q RESULTS
"RTN","SCMCUT",60,0)
 ;
"RTN","SCMCUT",61,0)
 ;
"RTN","SCMCUT",62,0)
ACTCLT(CLT) ;Is this client active?
"RTN","SCMCUT",63,0)
 ;This function call returns whether the client passed in is active or
"RTN","SCMCUT",64,0)
 ;not .  It just tells the status of the client per its entry in PCMM 
"RTN","SCMCUT",65,0)
 ;CLIENT PATCH file.  It does not relate in anyway to the PCMM SERVER
"RTN","SCMCUT",66,0)
 ;PATCH file.
"RTN","SCMCUT",67,0)
 ;
"RTN","SCMCUT",68,0)
 ;INPUT:  CLT - This is the External Client version number
"RTN","SCMCUT",69,0)
 ;
"RTN","SCMCUT",70,0)
 ;OUTPUT: 1 - ACTIVE
"RTN","SCMCUT",71,0)
 ;        0 - NOT ACTIVE
"RTN","SCMCUT",72,0)
 ;       -1^ERROR DESCRIPTION
"RTN","SCMCUT",73,0)
 ;
"RTN","SCMCUT",74,0)
 N RESULTS
"RTN","SCMCUT",75,0)
 S CLT=$G(CLT)
"RTN","SCMCUT",76,0)
 I CLT']"" S RESULTS="-1^Client variable not defined." G ACTCLTQ
"RTN","SCMCUT",77,0)
 ;
"RTN","SCMCUT",78,0)
 N CLTIEN,ACT
"RTN","SCMCUT",79,0)
 S CLTIEN=$O(^SCTM(404.46,"B",CLT,0))
"RTN","SCMCUT",80,0)
 I CLTIEN="" S RESULTS="-1^Client not defined in PCMM CLIENT PATCH file." G ACTCLTQ
"RTN","SCMCUT",81,0)
 S ACT=$P(^SCTM(404.46,CLTIEN,0),U,2)
"RTN","SCMCUT",82,0)
 S RESULTS=$S(ACT:ACT,1:0) ;This was done so that a null would be zero
"RTN","SCMCUT",83,0)
 ;
"RTN","SCMCUT",84,0)
ACTCLTQ Q RESULTS
"RTN","SCMCUT",85,0)
 ;
"RTN","SCMCUT",86,0)
 ;
"RTN","SCMCUT",87,0)
ACTSER(SER,ARY) ; 
"RTN","SCMCUT",88,0)
 ; This function call is used to return the status of a server
"RTN","SCMCUT",89,0)
 ;  or a list of active servers at the sight.
"RTN","SCMCUT",90,0)
 ;  It does not return the IENs or multiples of 
"RTN","SCMCUT",91,0)
 ;  the same server value.
"RTN","SCMCUT",92,0)
 ;
"RTN","SCMCUT",93,0)
 ;INPUTS  SER - [optional]: Test for a specific server version
"RTN","SCMCUT",94,0)
 ;        ARY - [optional]: This is the array root that the list
"RTN","SCMCUT",95,0)
 ;               is to be stored in, if SER is undefined.
"RTN","SCMCUT",96,0)
 ;              If nothing is passed then the default will be used.
"RTN","SCMCUT",97,0)
 ;              ^TMP("PCMM ACTIVE SERVERS",$J,SERVER NUMBER)=EFFECTIVE DT
"RTN","SCMCUT",98,0)
 ;
"RTN","SCMCUT",99,0)
 ;OUTPUTS 1 - a success
"RTN","SCMCUT",100,0)
 ;        0 - none found.
"RTN","SCMCUT",101,0)
 ;
"RTN","SCMCUT",102,0)
 N RESULTS,LP,IEN
"RTN","SCMCUT",103,0)
 S SER=$G(SER,"")
"RTN","SCMCUT",104,0)
 I SER]"" S RESULTS=$D(^SCTM(404.45,"ACT",SER))>0 G ACTSERQ
"RTN","SCMCUT",105,0)
 S ARY=$G(ARY,"^TMP(""PCMM ACTIVE SERVERS"",$J)")
"RTN","SCMCUT",106,0)
 S RESULTS=0,LP=""
"RTN","SCMCUT",107,0)
 ;
"RTN","SCMCUT",108,0)
 I $O(^SCTM(404.45,"ACT",""))']"" G ACTSERQ
"RTN","SCMCUT",109,0)
 ;
"RTN","SCMCUT",110,0)
 F  S LP=$O(^SCTM(404.45,"ACT",LP)) Q:LP=""  S IEN=$O(^SCTM(404.45,"ACT",LP,"")) Q:IEN=""  DO
"RTN","SCMCUT",111,0)
 .S IEN=$G(^SCTM(404.45,IEN,0))
"RTN","SCMCUT",112,0)
 .Q:IEN=""
"RTN","SCMCUT",113,0)
 .S @ARY@(LP)=$P(IEN,U,3)
"RTN","SCMCUT",114,0)
 .S RESULTS=1
"RTN","SCMCUT",115,0)
 .Q
"RTN","SCMCUT",116,0)
 I SER]"" S RESULTS=$D(@ARY@(SER))
"RTN","SCMCUT",117,0)
 ; 
"RTN","SCMCUT",118,0)
ACTSERQ Q RESULTS
"RTN","SCMCUT",119,0)
 ;
"RTN","SCMCUT",120,0)
 ;
"RTN","SCMCUT",121,0)
DISCLNTS() ;This function call is used to determine if all clients should
"RTN","SCMCUT",122,0)
 ;be disabled.
"RTN","SCMCUT",123,0)
 ;
"RTN","SCMCUT",124,0)
 ;INPUTS  -- NONE
"RTN","SCMCUT",125,0)
 ;OUTPUTS -- 1 means YES disable all clients
"RTN","SCMCUT",126,0)
 ;           0 means NO
"RTN","SCMCUT",127,0)
 ;
"RTN","SCMCUT",128,0)
 N IEN,RESULTS
"RTN","SCMCUT",129,0)
 S RESULTS=0
"RTN","SCMCUT",130,0)
 ;
"RTN","SCMCUT",131,0)
 S IEN=+$O(^SCTM(404.44,0))
"RTN","SCMCUT",132,0)
 I 'IEN G DISQ
"RTN","SCMCUT",133,0)
 S IEN=$G(^SCTM(404.44,IEN,1))
"RTN","SCMCUT",134,0)
 S RESULTS=$S('$P(IEN,U,2):0,1:1)
"RTN","SCMCUT",135,0)
 ;
"RTN","SCMCUT",136,0)
DISQ Q RESULTS
"RTN","SCMCUT",137,0)
 ;
"RTN","SCMCUT",138,0)
UPCLNLST(SCX) ;update 404.46/404.45 with new client/server pair (if enabled)
"RTN","SCMCUT",139,0)
 ; input  := SCX p1[required] : ServerPatch
"RTN","SCMCUT",140,0)
 ;               p2[required] : ^ClientVersion
"RTN","SCMCUT",141,0)
 ;               p3[optional] : ^EnabledOverride(1=bypass,0=no[default])
"RTN","SCMCUT",142,0)
 ;               p4[optional] : ^ActiveServer(1=yes[default],0=no)
"RTN","SCMCUT",143,0)
 ;               p5[optional] : ^ActiveClient(1=yes[default],0=no)
"RTN","SCMCUT",144,0)
 ; output := SCRESULT : 1 = success
"RTN","SCMCUT",145,0)
 ;                    : 0 = failure/not allowed
"RTN","SCMCUT",146,0)
 ;
"RTN","SCMCUT",147,0)
 N SCRESULT,SCSER,SCCLI,SCASER,SCACLI,SCBYPASS,SCIEN
"RTN","SCMCUT",148,0)
 S SCRESULT=0
"RTN","SCMCUT",149,0)
 ;
"RTN","SCMCUT",150,0)
 ; parse
"RTN","SCMCUT",151,0)
 S SCSER=$P(SCX,U)
"RTN","SCMCUT",152,0)
 I SCSER']"" G UPCLNQ
"RTN","SCMCUT",153,0)
 S SCCLI=$P(SCX,U,2)
"RTN","SCMCUT",154,0)
 I SCCLI']"" G UPCLNQ
"RTN","SCMCUT",155,0)
 S SCBYPASS=$P(SCX,U,3)
"RTN","SCMCUT",156,0)
 S SCBYPASS=$S(SCBYPASS=1:1,1:0)
"RTN","SCMCUT",157,0)
 S SCIEN=+$O(^SCTM(404.44,0))
"RTN","SCMCUT",158,0)
 I 'SCIEN G UPCLNQ
"RTN","SCMCUT",159,0)
 I 'SCBYPASS,$P($G(^SCTM(404.44,SCIEN,1)),U,3)=1 G UPCLNQ
"RTN","SCMCUT",160,0)
 S SCASER=$P(SCX,U,4)
"RTN","SCMCUT",161,0)
 S SCASER=$S(SCASER=0:0,1:1)
"RTN","SCMCUT",162,0)
 S SCACLI=$P(SCX,U,5)
"RTN","SCMCUT",163,0)
 S SCACLI=$S(SCACLI=0:0,1:1)
"RTN","SCMCUT",164,0)
 ;
"RTN","SCMCUT",165,0)
 ;update client file
"RTN","SCMCUT",166,0)
 N SC1,SC1IEN,SC1ERR
"RTN","SCMCUT",167,0)
 S SC1(1,404.46,"?+1,",.01)=SCCLI       ;client version
"RTN","SCMCUT",168,0)
 S SC1(1,404.46,"?+1,",.02)=SCACLI      ;active?
"RTN","SCMCUT",169,0)
 S SC1(1,404.46,"?+1,",.03)=DT          ;today
"RTN","SCMCUT",170,0)
 D UPDATE^DIE("","SC1(1)","SC1IEN","SC1ERR")
"RTN","SCMCUT",171,0)
 I $D(SC1ERR)!(+$G(SC1IEN(1))<0) G UPCLNQ
"RTN","SCMCUT",172,0)
 ;
"RTN","SCMCUT",173,0)
 ;update server file
"RTN","SCMCUT",174,0)
 N SC2,SC2IEN,SC2ERR
"RTN","SCMCUT",175,0)
 S SC2(1,404.45,"?+1,",.01)=SCSER       ;server version
"RTN","SCMCUT",176,0)
 S SC2(1,404.45,"?+1,",.02)=SC1IEN(1)   ;ptr - client version
"RTN","SCMCUT",177,0)
 S SC2(1,404.45,"?+1,",.03)=DT          ;today
"RTN","SCMCUT",178,0)
 S SC2(1,404.45,"?+1,",.04)=SCASER      ;active?
"RTN","SCMCUT",179,0)
 D UPDATE^DIE("","SC2(1)","SC2IEN","SC2ERR")
"RTN","SCMCUT",180,0)
 I $D(SC2ERR)!(+$G(SC2IEN(1))<0) G UPCLNQ
"RTN","SCMCUT",181,0)
 S SCRESULT=1
"RTN","SCMCUT",182,0)
 ;
"RTN","SCMCUT",183,0)
UPCLNQ Q SCRESULT
"RTN","SCMCUT",184,0)
 ;
"RTN","SCMRBK")
0^15^B62054162
"RTN","SCMRBK",1,0)
SCMRBK  ;ALB/SCK - Broker Utilities for multiple patient reassignments; 4/8/96
"RTN","SCMRBK",2,0)
 ;;5.3;Scheduling;**148,157,204**;AUG 13, 1993
"RTN","SCMRBK",3,0)
 ;
"RTN","SCMRBK",4,0)
 Q
"RTN","SCMRBK",5,0)
 ;
"RTN","SCMRBK",6,0)
PTGET(SCDATA,SC)        ;  Return a block of patients to the client
"RTN","SCMRBK",7,0)
 ;     'SC GET PAT BLOCK'
"RTN","SCMRBK",8,0)
 ;
"RTN","SCMRBK",9,0)
 ;     SCJOB   = $J for the ^TMP global
"RTN","SCMRBK",10,0)
 ;     SCJOBID = The second subscript id for the ^TMP global
"RTN","SCMRBK",11,0)
 ;     SCSTART = Beginning entry number for the block retrieval in the ^TMP global
"RTN","SCMRBK",12,0)
 ;     SCEND   = The ending entry number for the block retrieval
"RTN","SCMRBK",13,0)
 ;     SCLAST  = The last entry number in the ^TMP global
"RTN","SCMRBK",14,0)
 ;
"RTN","SCMRBK",15,0)
 ; This RPC returns a list of patients from the temp global that was built by
"RTN","SCMRBK",16,0)
 ; by the call to either SCMC BLD POS PAT LIST or SCMC BLD TEAM PAT LIST
"RTN","SCMRBK",17,0)
 ;
"RTN","SCMRBK",18,0)
 N SCJOB,SCSTART,SCEND,I,SCLAST,SCJOBID
"RTN","SCMRBK",19,0)
 ;
"RTN","SCMRBK",20,0)
 D CHK^SCUTBK
"RTN","SCMRBK",21,0)
 D TMP^SCUTBK
"RTN","SCMRBK",22,0)
 ;
"RTN","SCMRBK",23,0)
 D PARSE^SCMCBK1(.SC)
"RTN","SCMRBK",24,0)
 ;
"RTN","SCMRBK",25,0)
 F I=SCSTART:1:SCEND Q:'$G(^TMP(SCJOB,SCJOBID,I),0)  D
"RTN","SCMRBK",26,0)
 . S SCDATA(I)=^TMP(SCJOB,SCJOBID,I)
"RTN","SCMRBK",27,0)
 I SCEND>SCLAST K ^TMP(SCJOB,SCJOBID)
"RTN","SCMRBK",28,0)
 ;
"RTN","SCMRBK",29,0)
 D CLRVAR^SCMCBK1
"RTN","SCMRBK",30,0)
 Q
"RTN","SCMRBK",31,0)
 ;
"RTN","SCMRBK",32,0)
 ; This is invoked after the Save button is clicked in Patient reasignment-both team and pos
"RTN","SCMRBK",33,0)
 ; RPC - SC BLD REASSIGN PAT LST
"RTN","SCMRBK",34,0)
PTLSTBLD(SCOK,SCVAL) ;  Build the list of patients to be assigned in the ^TMP($J,"SCPATIENT LIST",DFN) global
"RTN","SCMRBK",35,0)
 ;  'SC BLD PAT LIST'
"RTN","SCMRBK",36,0)
 ;
"RTN","SCMRBK",37,0)
 N SCJOB,SCDFN
"RTN","SCMRBK",38,0)
 ;
"RTN","SCMRBK",39,0)
 D CHK^SCUTBK
"RTN","SCMRBK",40,0)
 D TMP^SCUTBK
"RTN","SCMRBK",41,0)
 ;
"RTN","SCMRBK",42,0)
 S SCOK=0
"RTN","SCMRBK",43,0)
 I SCVAL["Start" D  G PTBLDQ
"RTN","SCMRBK",44,0)
 . S SCOK=$J
"RTN","SCMRBK",45,0)
 . K ^TMP(SCOK,"SC PATIENT LIST")
"RTN","SCMRBK",46,0)
 ; 
"RTN","SCMRBK",47,0)
 S SCJOB=$P(SCVAL,U,1)
"RTN","SCMRBK",48,0)
 S SCDFN=$P(SCVAL,U,2)
"RTN","SCMRBK",49,0)
 S ^TMP(SCJOB,"SC PATIENT LIST",SCDFN)=$P(SCVAL,U,3) ; equals assignment IEN (PDR)
"RTN","SCMRBK",50,0)
 S SCOK=1
"RTN","SCMRBK",51,0)
PTBLDQ  ;
"RTN","SCMRBK",52,0)
 Q
"RTN","SCMRBK",53,0)
 ;
"RTN","SCMRBK",54,0)
 ; This is invoked by RPC (SC FILE PAT TM REASGN) for team reasignment
"RTN","SCMRBK",55,0)
 ;
"RTN","SCMRBK",56,0)
PTFILE(SCOK,SC) ;  File the patient assignments in the ^TMP($J,"SC TEAM ASSIGN",SCDFN) global
"RTN","SCMRBK",57,0)
 ;    'SCMC FILE PAT TM REASGN'
"RTN","SCMRBK",58,0)
 ;
"RTN","SCMRBK",59,0)
 N SCADDFLD,SCTEAM,SCFILE,SCJOB,SCNEW,SCOLD,SCBAD,SCERMSG,SCX,SCDTVAR,SCOTH
"RTN","SCMRBK",60,0)
 N ZTPRI,ZTRTN,ZTDESC,ZTDTH,SCNOW
"RTN","SCMRBK",61,0)
 ;
"RTN","SCMRBK",62,0)
 D CHK^SCUTBK
"RTN","SCMRBK",63,0)
 D TMP^SCUTBK ; this sets up a DUZ=.5 and a DT of the current date
"RTN","SCMRBK",64,0)
 D NOW^%DTC
"RTN","SCMRBK",65,0)
 S SCNOW=% ; get actual FM date/time for enter/edit documentation
"RTN","SCMRBK",66,0)
 ;
"RTN","SCMRBK",67,0)
 D PARSE^SCMCBK1(.SC)
"RTN","SCMRBK",68,0)
 G:+$G(SCJOB)=0 FILEQ
"RTN","SCMRBK",69,0)
 ;
"RTN","SCMRBK",70,0)
 ; Additional fields for 404.42 PATIENT TEAM ASSIGNMENT FILE
"RTN","SCMRBK",71,0)
 S SCADDFLD(.08)=$G(SC("TYPE"),99)
"RTN","SCMRBK",72,0)
 S SCADDFLD(.1)=$G(SC("RESTRICT"),0)
"RTN","SCMRBK",73,0)
 ; note, the fields below are not appropriate if team is being activated or modified. Be sure
"RTN","SCMRBK",74,0)
 ; to kill as necessary before filing, and to add edit by and edit D/T where necessary - PDR
"RTN","SCMRBK",75,0)
 S SCADDFLD(.11)=DUZ ; user entering
"RTN","SCMRBK",76,0)
 S SCADDFLD(.12)=SCNOW ; entry date/time (changed from =DT - PDR)
"RTN","SCMRBK",77,0)
 ;
"RTN","SCMRBK",78,0)
 I $G(SC("BKG"))="1" D BKG(1) Q  ;Bail out to run in background
"RTN","SCMRBK",79,0)
 ; 
"RTN","SCMRBK",80,0)
BKGTM   ; Run Team Reassignment Filer in BKG
"RTN","SCMRBK",81,0)
 I $D(ZTQUEUED) S SCJOB=$J  ; want to use Task Manager assigned $J if BKG
"RTN","SCMRBK",82,0)
 S SCX=$$ACPTRATM^SCAPMR6("^TMP(SCJOB,""SC PATIENT LIST"")",SCTEAM,SCFRMTM,.SCOTH,"SCADDFLD",SCDTVAR,"SCERMSG","SCNEW","SCOLD","SCBAD")
"RTN","SCMRBK",83,0)
 I '$D(ZTQUEUED) D
"RTN","SCMRBK",84,0)
 . D BAD^SCMCBK1(.SCBAD,.SCOLD,.SCOK) ; this sets up RPC return var SCOK for error report dialog
"RTN","SCMRBK",85,0)
 . S SCOK(.1)=SCX_U_"FORE"
"RTN","SCMRBK",86,0)
 ;
"RTN","SCMRBK",87,0)
 K ^TMP(SCJOB,"SC PATIENT LIST")
"RTN","SCMRBK",88,0)
 D CLRVAR^SCMCBK1
"RTN","SCMRBK",89,0)
 ;
"RTN","SCMRBK",90,0)
FILEQ Q
"RTN","SCMRBK",91,0)
 ;
"RTN","SCMRBK",92,0)
 ; This is invoked by RPC ('SC FILE PAT POS REASGN') for position reasignment
"RTN","SCMRBK",93,0)
POSFILE(SCOK,SC)        ;  File the patient assignments in the ^TMP($J,"SC PATIENT LIST") global 
"RTN","SCMRBK",94,0)
 ;   ' SCMC FILE PAT POS REASGN '
"RTN","SCMRBK",95,0)
 ;
"RTN","SCMRBK",96,0)
 N SCADDFLD,SCTEAM,SCFILE,SCJOB,SCNEW,SCOLD,SCBAD,SCERMSG,SCX
"RTN","SCMRBK",97,0)
 N SCPOSTO,SCPOSFRM,SCDTVAR,SCMAFLD,SCADTM,SCNEW1,SCNOW
"RTN","SCMRBK",98,0)
 ;
"RTN","SCMRBK",99,0)
 D CHK^SCUTBK
"RTN","SCMRBK",100,0)
 D TMP^SCUTBK
"RTN","SCMRBK",101,0)
 S SCNOW=$$NOW^XLFDT
"RTN","SCMRBK",102,0)
 ;
"RTN","SCMRBK",103,0)
 D PARSE^SCMCBK1(.SC)
"RTN","SCMRBK",104,0)
 S SCPOSTO=SC("POSITION")
"RTN","SCMRBK",105,0)
 S SCPOSFRM=SC("FROMPOSITION")
"RTN","SCMRBK",106,0)
 G:+$G(SCJOB)=0 FILEQ
"RTN","SCMRBK",107,0)
 S SCADTM=1
"RTN","SCMRBK",108,0)
 ;
"RTN","SCMRBK",109,0)
 S SCADDFLD(.05)=$G(SC("TYPE"),0)
"RTN","SCMRBK",110,0)
 S SCADDFLD(.06)=DUZ
"RTN","SCMRBK",111,0)
 S SCADDFLD(.07)=SCNOW
"RTN","SCMRBK",112,0)
 ;
"RTN","SCMRBK",113,0)
 I $G(SC("BKG"))="1" D BKG(2) Q
"RTN","SCMRBK",114,0)
 ;
"RTN","SCMRBK",115,0)
BKGPOS  ;   BACKGROUND JOB ENTRY POINT
"RTN","SCMRBK",116,0)
 I $D(ZTQUEUED) S SCJOB=$J  ;  want to use Task Manager assigned $J if BKG
"RTN","SCMRBK",117,0)
 S SCX=$$ACPTATP^SCAPMR21("^TMP(SCJOB,""SC PATIENT LIST"")",SCPOSTO,SCPOSFRM,"SCADDFLD",SCDTVAR,"SCERMSG",SCADTM,"","SCNEW","SCNEW1","SCOLD","SCBAD")
"RTN","SCMRBK",118,0)
 ;
"RTN","SCMRBK",119,0)
 I '$D(ZTQUEUED) D
"RTN","SCMRBK",120,0)
 . D BAD2^SCMCBK1(.SCBAD,.SCOLD,.SCOK) ; this sets up RPC return var SCOK for error report dialog
"RTN","SCMRBK",121,0)
 . S SCOK(.1)=SCX_U_"FORE"
"RTN","SCMRBK",122,0)
 ;
"RTN","SCMRBK",123,0)
 K ^TMP(SCJOB,"SC PATIENT LIST")
"RTN","SCMRBK",124,0)
 D CLRVAR^SCMCBK1
"RTN","SCMRBK",125,0)
 Q
"RTN","SCMRBK",126,0)
 ;
"RTN","SCMRBK",127,0)
BLKPOS  ;
"RTN","SCMRBK",128,0)
 N SCX
"RTN","SCMRBK",129,0)
 S SCX=$G(SCDTRNG("END"))
"RTN","SCMRBK",130,0)
 S SCDTRNG("END")=3990101 ;check forever
"RTN","SCMRBK",131,0)
 S SCOK1=$$PTTP^SCAPMC(SCBLOCK,"SCDTRNG","^TMP(""SCMC"",$J,""EXCLUDE PT"")","SCER2")
"RTN","SCMRBK",132,0)
 S SCDTRNG("END")=SCX
"RTN","SCMRBK",133,0)
 Q
"RTN","SCMRBK",134,0)
 ;
"RTN","SCMRBK",135,0)
BLKTM   ;
"RTN","SCMRBK",136,0)
 N SCX
"RTN","SCMRBK",137,0)
 S SCX=$G(SCDTRNG("END"))
"RTN","SCMRBK",138,0)
 S SCDTRNG("END")=3990101 ;check forever
"RTN","SCMRBK",139,0)
 S SCOK1=$$PTTM^SCAPMC(SCBLOCK,"SCDTRNG","^TMP(""SCMC"",$J,""EXCLUDE PT"")","SCER2")
"RTN","SCMRBK",140,0)
 S SCDTRNG("END")=SCX
"RTN","SCMRBK",141,0)
 Q
"RTN","SCMRBK",142,0)
 ;
"RTN","SCMRBK",143,0)
 ; This is used to get the patient list to fill the list box after team and position selection
"RTN","SCMRBK",144,0)
 ;
"RTN","SCMRBK",145,0)
PTPOSLST(SCOK,SC)       ; Get a list of of patients for a team position
"RTN","SCMRBK",146,0)
 ;  RPC:'SCMC BLD POS PAT LIST'
"RTN","SCMRBK",147,0)
 ;
"RTN","SCMRBK",148,0)
 N PD,FD,TD,ASNST,FC
"RTN","SCMRBK",149,0)
 D NEWVAR^SCMCBK1
"RTN","SCMRBK",150,0)
 D CHK^SCUTBK
"RTN","SCMRBK",151,0)
 D TMP^SCUTBK
"RTN","SCMRBK",152,0)
 S FD=SC("FROMDATE")
"RTN","SCMRBK",153,0)
 S TD=SC("TODATE")
"RTN","SCMRBK",154,0)
 S ASNSTAT=SC("ASSIGNSTAT") ; 0=assigned only, 1=Discharged only, 2=both
"RTN","SCMRBK",155,0)
 ;
"RTN","SCMRBK",156,0)
 D PARSE^SCMCBK1(.SC)
"RTN","SCMRBK",157,0)
 ;
"RTN","SCMRBK",158,0)
 K ^TMP($J,"SCPOS")
"RTN","SCMRBK",159,0)
 ;
"RTN","SCMRBK",160,0)
 S SCOK=0
"RTN","SCMRBK",161,0)
 ; This date setting could be accomplished on GUI using the .MULT[] broker array, and
"RTN","SCMRBK",162,0)
 ; loaded into SCDTRNG via the call to parse. I've opted to set the array explicitly
"RTN","SCMRBK",163,0)
 ; here.
"RTN","SCMRBK",164,0)
 S SCDTRNG("BEGIN")=FD
"RTN","SCMRBK",165,0)
 S SCDTRNG("END")=TD
"RTN","SCMRBK",166,0)
 S SCDTRNG("INCL")=0
"RTN","SCMRBK",167,0)
 ; get list of pt active for time period specified
"RTN","SCMRBK",168,0)
 ; future discharges included
"RTN","SCMRBK",169,0)
 S SCOK=$$PTTP^SCAPMC11(SCFRMPOS,"SCDTRNG",.SCLOC,.SCERMSG)
"RTN","SCMRBK",170,0)
 K ^TMP("SCMC",$J,"EXCLUDE PT")
"RTN","SCMRBK",171,0)
 M ^TMP($J,"SC PCMM IN")=@SCLOC
"RTN","SCMRBK",172,0)
 ;
"RTN","SCMRBK",173,0)
 S I1=$G(^TMP($J,"SC PCMM IN",0))
"RTN","SCMRBK",174,0)
 S FC=0 ; initialize filtered count of patients
"RTN","SCMRBK",175,0)
 F I=1:1:I1 D
"RTN","SCMRBK",176,0)
 . S PD=$G(^TMP($J,"SC PCMM IN",I)) ; get the discharge date
"RTN","SCMRBK",177,0)
 . Q:$$FILTOUT(+$P(PD,U,5),+$P(PD,U,4))
"RTN","SCMRBK",178,0)
 . S ^TMP($J,"PCMM TMP",I)=$G(^TMP($J,"SC PCMM IN",I))
"RTN","SCMRBK",179,0)
 . S FC=FC+1
"RTN","SCMRBK",180,0)
 D ALPHA^SCAPMCU2("^TMP($J,""PCMM TMP"")","^TMP($J,""SCPOS"")")
"RTN","SCMRBK",181,0)
 S SCOK=$J_U_FC_U_SCOK
"RTN","SCMRBK",182,0)
 ;
"RTN","SCMRBK",183,0)
 D CLRVAR^SCMCBK1
"RTN","SCMRBK",184,0)
 Q
"RTN","SCMRBK",185,0)
 ;
"RTN","SCMRBK",186,0)
FILTOUT(DD,AD)  ; FILTER OUT CANDIDATE PATIENTS
"RTN","SCMRBK",187,0)
 ;bp/cmf 204t0 -- SCDTVAR(def = dt) replaces DT 
"RTN","SCMRBK",188,0)
 ; Want actives only
"RTN","SCMRBK",189,0)
 Q:ASNSTAT=0 ((DD)&(DD'>SCDTVAR))!(AD>SCDTVAR)
"RTN","SCMRBK",190,0)
 ; ; disch date before tomorrow, or assign date greater than today 
"RTN","SCMRBK",191,0)
 ;
"RTN","SCMRBK",192,0)
 ; Want discharges between dates only
"RTN","SCMRBK",193,0)
 Q:ASNSTAT=1 (DD>TD)!(DD<FD)
"RTN","SCMRBK",194,0)
 ; ; disch date is after TO date, or discharge date is before FROM date
"RTN","SCMRBK",195,0)
 ;
"RTN","SCMRBK",196,0)
 ; Want discharges and actives from date
"RTN","SCMRBK",197,0)
 Q:ASNSTAT=2 (DD&(DD<FD))!(AD>SCDTVAR)
"RTN","SCMRBK",198,0)
 ; ; disch date less than FROM date, or assign date > dtvar
"RTN","SCMRBK",199,0)
 Q 0
"RTN","SCMRBK",200,0)
 ;
"RTN","SCMRBK",201,0)
 ; 
"RTN","SCMRBK",202,0)
 ; used to get the patient list after a team selection
"RTN","SCMRBK",203,0)
 ;
"RTN","SCMRBK",204,0)
PTTMLST(SCOK,SC)        ; ; Get a list of of patients for a team - FILTER FOR ACTIVE
"RTN","SCMRBK",205,0)
 ;  RPC:'SCMC BLD TEAM PAT LIST' 
"RTN","SCMRBK",206,0)
 ;
"RTN","SCMRBK",207,0)
 ;bp/cmf 204t0 -- SCDTVAR(def = dt) replaces DT 
"RTN","SCMRBK",208,0)
 N TD,SCDD
"RTN","SCMRBK",209,0)
 D NEWVAR^SCMCBK1
"RTN","SCMRBK",210,0)
 D CHK^SCUTBK
"RTN","SCMRBK",211,0)
 D TMP^SCUTBK
"RTN","SCMRBK",212,0)
 ;
"RTN","SCMRBK",213,0)
 D PARSE^SCMCBK1(.SC)
"RTN","SCMRBK",214,0)
 K ^TMP($J,"SCTEAM")
"RTN","SCMRBK",215,0)
 ;
"RTN","SCMRBK",216,0)
 S SCOK=0
"RTN","SCMRBK",217,0)
 ; get list of patient team assignments ordered by q
"RTN","SCMRBK",218,0)
 S SCOK=$$PTTM^SCAPMC2(SCFRMTM,"SCDTRNG",.SCLOC,"SCERMSG")  ; SCLOC = ^TMP("SCTMP LIST",$J)
"RTN","SCMRBK",219,0)
 K ^TMP("SCMC",$J,"EXCLUDE PT")
"RTN","SCMRBK",220,0)
 M ^TMP($J,"SC PCMM IN")=@SCLOC
"RTN","SCMRBK",221,0)
 ;
"RTN","SCMRBK",222,0)
 S I=""
"RTN","SCMRBK",223,0)
 F  S I=$O(^TMP($J,"SC PCMM IN",I)) Q:'I  D
"RTN","SCMRBK",224,0)
 . S TD=^TMP($J,"SC PCMM IN",I)
"RTN","SCMRBK",225,0)
 . S SCDD=$P(TD,U,5)
"RTN","SCMRBK",226,0)
 . Q:(SCDD'="")&(SCDD'>SCDTVAR)  ; filter discharged assignments
"RTN","SCMRBK",227,0)
 . Q:$P(TD,U,4)>SCDTVAR  ; filter future assignments
"RTN","SCMRBK",228,0)
 . S ^TMP($J,"PCMM TMP",I)=^TMP($J,"SC PCMM IN",I)
"RTN","SCMRBK",229,0)
 ;
"RTN","SCMRBK",230,0)
 D ALPHA^SCAPMCU2("^TMP($J,""PCMM TMP"")","^TMP($J,""SCTEAM"")")
"RTN","SCMRBK",231,0)
 ;
"RTN","SCMRBK",232,0)
 S SCOK=$J_U_+$O(^TMP($J,"SCTEAM",""),-1)_U_SCOK
"RTN","SCMRBK",233,0)
 ;
"RTN","SCMRBK",234,0)
 D CLRVAR^SCMCBK1
"RTN","SCMRBK",235,0)
 Q
"RTN","SCMRBK",236,0)
 ;
"RTN","SCMRBK",237,0)
DISCHPOS(SCOK,SC)       ; DISCHARGE POSITIONS FOR A TEAM - RPC: PDR SC DIS TEAM POS
"RTN","SCMRBK",238,0)
 ; SC("DFN") = ptr to patient file
"RTN","SCMRBK",239,0)
 ; SC("TMASGN") = ptr to team assignment file 404.42
"RTN","SCMRBK",240,0)
 ; SC("DATE") = file date (date selected on client)
"RTN","SCMRBK",241,0)
 N SCBEGIN,SCEND,SCINCL,SCDATES,SCERR
"RTN","SCMRBK",242,0)
 D CHK^SCUTBK
"RTN","SCMRBK",243,0)
 D TMP^SCUTBK
"RTN","SCMRBK",244,0)
 S SCOK=1
"RTN","SCMRBK",245,0)
 S SCERR="SCERRMSG"
"RTN","SCMRBK",246,0)
 K @SCERR ;;bp/cmf 204 clean error array!!!!!!!!!!  [iow-0899-40854]
"RTN","SCMRBK",247,0)
 D DISCHPOS^SCRPMTA(SC("DFN"),SC("TMASGN"),SC("DATE"),SCERR)
"RTN","SCMRBK",248,0)
 S SCOK='$D(@SCERR)
"RTN","SCMRBK",249,0)
 Q
"RTN","SCMRBK",250,0)
 ;
"RTN","SCMRBK",251,0)
BKG(SCX) ;hand off to taskman
"RTN","SCMRBK",252,0)
 ;input SCX=toggle between team/position reassignment
"RTN","SCMRBK",253,0)
 ;
"RTN","SCMRBK",254,0)
 S ZTPRI=10
"RTN","SCMRBK",255,0)
 S ZTRTN=$P($$S(SCX),"::")
"RTN","SCMRBK",256,0)
 S ZTDESC=$P($$S(SCX),"::",2)
"RTN","SCMRBK",257,0)
 S ZTDTH=$H
"RTN","SCMRBK",258,0)
 S ZTSAVE("SC*")=""
"RTN","SCMRBK",259,0)
 S ZTSAVE("^TMP($J,")=""
"RTN","SCMRBK",260,0)
 I '$G(SC("NOP")) D ^%ZTLOAD ; define NOP on GUI side if don't want BKG
"RTN","SCMRBK",261,0)
 S SCOK(0)=1_U_"BKG"_$G(ZTSK)
"RTN","SCMRBK",262,0)
 S SCOK(.1)=$$PASSCNT^SCMCBK5($$S(3))_U_"BKG"_U_$G(SC("NOP"))
"RTN","SCMRBK",263,0)
 Q
"RTN","SCMRBK",264,0)
 ;
"RTN","SCMRBK",265,0)
S(SCX) Q $P($T(T+SCX),";;",2)
"RTN","SCMRBK",266,0)
 ;
"RTN","SCMRBK",267,0)
T ;;
"RTN","SCMRBK",268,0)
 ;;BKGTM^SCMRBK::PCMM TEAM REASSIGN BKG
"RTN","SCMRBK",269,0)
 ;;BKGPOS^SCMRBK::PCMM POSITION REASSIGN BKG
"RTN","SCMRBK",270,0)
 ;;^TMP($J,"SC PATIENT LIST")
"RTN","SCMRBK",271,0)
 ;
"RTN","SCUTBK3")
0^8^B13393151
"RTN","SCUTBK3",1,0)
SCUTBK3 ;MJK/ALB - RPC Broker Utilities ; SEP 99
"RTN","SCUTBK3",2,0)
 ;;5.3;Scheduling;**41,51,177,204**;AUG 13, 1993
"RTN","SCUTBK3",3,0)
 ;
"RTN","SCUTBK3",4,0)
GETUSER(SCDATA,SCDUZ) ; -- get user data
"RTN","SCUTBK3",5,0)
 ;
"RTN","SCUTBK3",6,0)
 ; input:                 SCDUZ -> user's id (DUZ)
"RTN","SCUTBK3",7,0)
 ;output: for success SCDATA(0) -> duz ^ name ^ default query id ^ default institution name
"RTN","SCUTBK3",8,0)
 ;        for failure SCDATA(0) -> 0 ^ <number of errors>
"RTN","SCUTBK3",9,0)
 ;                      (1...n) -> error text
"RTN","SCUTBK3",10,0)
 ;
"RTN","SCUTBK3",11,0)
 ; Related RPC: SCUT GET USER RECORD
"RTN","SCUTBK3",12,0)
 ;
"RTN","SCUTBK3",13,0)
 ;
"RTN","SCUTBK3",14,0)
 ;I $$VAPVER(XWBAPVER) D CLOSE^%ZISTCP Q  ;old clients off / future
"RTN","SCUTBK3",15,0)
 N X,DIERR,SCPARM
"RTN","SCUTBK3",16,0)
 IF SCDUZ="CURRENT USER" S SCDUZ=+$G(DUZ)
"RTN","SCUTBK3",17,0)
 S X=$G(^VA(200,+SCDUZ,0))
"RTN","SCUTBK3",18,0)
 IF X]"" D
"RTN","SCUTBK3",19,0)
 . N Y
"RTN","SCUTBK3",20,0)
 . S SCDATA(0)=+SCDUZ_U_$P(X,U)_U_$$DEFAULT(SCDUZ)
"RTN","SCUTBK3",21,0)
 . D GETENV^%ZOSV
"RTN","SCUTBK3",22,0)
 . S SCDATA(0)=SCDATA(0)_U_Y_U_$P($G(^DIC(4,DUZ(2),0)),U,1)
"RTN","SCUTBK3",23,0)
 ELSE  D
"RTN","SCUTBK3",24,0)
 . S SCPARM("USER ID")=SCDUZ
"RTN","SCUTBK3",25,0)
 . D BLD^DIALOG(4030005.001,.SCPARM,"","SCDATA","S")
"RTN","SCUTBK3",26,0)
 . D HDREC(.SCDATA,$G(DIERR),"Scheduling User Data Retrieval")
"RTN","SCUTBK3",27,0)
 Q
"RTN","SCUTBK3",28,0)
 ;
"RTN","SCUTBK3",29,0)
DEFAULT(SCDUZ) ; -- get default query for user
"RTN","SCUTBK3",30,0)
 N X
"RTN","SCUTBK3",31,0)
 S X=+$P($G(^SCRS(403.35,+SCDUZ,"PCMM")),U,15)
"RTN","SCUTBK3",32,0)
 IF 'X S X=+$O(^SD(404.95,"B","System Default",0))
"RTN","SCUTBK3",33,0)
 S X=X_U_$P($G(^SD(404.95,+X,0),"Unknown"),U)
"RTN","SCUTBK3",34,0)
 Q X
"RTN","SCUTBK3",35,0)
 ;
"RTN","SCUTBK3",36,0)
SETDEF(SCDATA,SCDUZ,SCQRY) ; -- set user's default query
"RTN","SCUTBK3",37,0)
 ; input:                 SCDUZ -> user's id (DUZ)
"RTN","SCUTBK3",38,0)
 ;                        SCQRY ->query ien
"RTN","SCUTBK3",39,0)
 ;output: for success SCDATA(0) -> 1
"RTN","SCUTBK3",40,0)
 ;        for failure SCDATA(0) -> 0 ^ <number of errors>
"RTN","SCUTBK3",41,0)
 ;                      (1...n) -> error text
"RTN","SCUTBK3",42,0)
 ;
"RTN","SCUTBK3",43,0)
 ;
"RTN","SCUTBK3",44,0)
 ; Related RPC: SCUT SET USER QUERY DEFAULT
"RTN","SCUTBK3",45,0)
 ;
"RTN","SCUTBK3",46,0)
 N SCVAL,SCFDA,SCIENS,SCERR,DIERR,SCPROC
"RTN","SCUTBK3",47,0)
 S SCPROC="Setting User Query Default"
"RTN","SCUTBK3",48,0)
 S SCFDA="SCFDA",SCIENS="SCIENS",SCERR="SCERR"
"RTN","SCUTBK3",49,0)
 ; -- make sure user has param rec
"RTN","SCUTBK3",50,0)
 IF '$D(^SCRS(403.35,+SCDUZ,0)) D  G:$O(SCDATA(0)) SETDEFQ
"RTN","SCUTBK3",51,0)
 . D FDA^DILF(403.35,"+1,",.01,"",+SCDUZ,SCFDA,SCERR)
"RTN","SCUTBK3",52,0)
 . S SCIENS(1)=+SCDUZ
"RTN","SCUTBK3",53,0)
 . D UPDATE^DIE("",SCFDA,SCIENS,SCERR)
"RTN","SCUTBK3",54,0)
 . D ERRCHK(.SCDATA,.SCERR,SCPROC)
"RTN","SCUTBK3",55,0)
 ;
"RTN","SCUTBK3",56,0)
 ; -- set default
"RTN","SCUTBK3",57,0)
 K SCFDA,SCIENS,SCERR,SCVAL
"RTN","SCUTBK3",58,0)
 S SCFDA="SCFDA",SCIENS="SCIENS",SCERR="SCERR"
"RTN","SCUTBK3",59,0)
 S SCVAL=$S(SCQRY:SCQRY,1:"@")
"RTN","SCUTBK3",60,0)
 D FDA^DILF(403.35,+SCDUZ_",",1.15,"",SCVAL,SCFDA,SCERR)
"RTN","SCUTBK3",61,0)
 D FILE^DIE("K",SCFDA,SCERR)
"RTN","SCUTBK3",62,0)
 D ERRCHK(.SCDATA,.SCERR,"Setting User Query Default")
"RTN","SCUTBK3",63,0)
SETDEFQ Q
"RTN","SCUTBK3",64,0)
 ;
"RTN","SCUTBK3",65,0)
VERPAT(SCRESULT,SCPATCH) ;
"RTN","SCUTBK3",66,0)
 ;       for rpc SCMC VERIFY C/S SYNC
"RTN","SCUTBK3",67,0)
 ;       input  := ServerPatch^ClientVersion
"RTN","SCUTBK3",68,0)
 ;       output := SCRESULT: 0 = Not Continue
"RTN","SCUTBK3",69,0)
 ;                           1 = Continue (pre SD*5.3*204)
"RTN","SCUTBK3",70,0)
 ;                           n = RpcTimeLimit (after SD*5.3*204)
"RTN","SCUTBK3",71,0)
 ;
"RTN","SCUTBK3",72,0)
 N SCX
"RTN","SCUTBK3",73,0)
 ;
"RTN","SCUTBK3",74,0)
 ; site turned off all clients?
"RTN","SCUTBK3",75,0)
 S SCRESULT=$$DISCLNTS^SCMCUT()'=1
"RTN","SCUTBK3",76,0)
 I SCRESULT=0 Q
"RTN","SCUTBK3",77,0)
 ;
"RTN","SCUTBK3",78,0)
 ; hook for complex RPCVersion checker
"RTN","SCUTBK3",79,0)
 S SCRESULT=$$VAPVER(XWBAPVER)
"RTN","SCUTBK3",80,0)
 ;
"RTN","SCUTBK3",81,0)
 ; if programmer, OK, quit
"RTN","SCUTBK3",82,0)
 I $$VPROGMR() Q
"RTN","SCUTBK3",83,0)
 ;
"RTN","SCUTBK3",84,0)
 ; hook for complex patch existence checker
"RTN","SCUTBK3",85,0)
 I $$VPATCH(SCPATCH)'=1 S SCRESULT=0 Q
"RTN","SCUTBK3",86,0)
 ;
"RTN","SCUTBK3",87,0)
 ; hook for complex executable version checker
"RTN","SCUTBK3",88,0)
 I $$VCLIENT(SCPATCH) S SCRESULT=0
"RTN","SCUTBK3",89,0)
 ;
"RTN","SCUTBK3",90,0)
 Q
"RTN","SCUTBK3",91,0)
 ;
"RTN","SCUTBK3",92,0)
VPROGMR() ; check if user is programmer
"RTN","SCUTBK3",93,0)
 N SCX
"RTN","SCUTBK3",94,0)
 D SECKEY^SCUTBK11(.SCX,"XUPROG")
"RTN","SCUTBK3",95,0)
 Q SCX=1
"RTN","SCUTBK3",96,0)
 ;
"RTN","SCUTBK3",97,0)
VAPVER(SCX) ; check client RPCVersion
"RTN","SCUTBK3",98,0)
 ;       ; input SCX := client RPCVersion(server XWBAPVER)
"RTN","SCUTBK3",99,0)
 ;       ; output    := RpcTimeLimit
"RTN","SCUTBK3",100,0)
 I +SCX<204 Q 1
"RTN","SCUTBK3",101,0)
 S SCX=+$O(^SCTM(404.44,0))
"RTN","SCUTBK3",102,0)
 I SCX<1 Q 0
"RTN","SCUTBK3",103,0)
 S SCX=+$P($G(^SCTM(404.44,SCX,1)),U,4)
"RTN","SCUTBK3",104,0)
 Q $S(SCX<30:30,SCX>300:300,1:SCX)
"RTN","SCUTBK3",105,0)
 ;
"RTN","SCUTBK3",106,0)
VCLIENT(SCX) ; check executable version/update if new
"RTN","SCUTBK3",107,0)
 ;       ; input SCX := server^client (versions)
"RTN","SCUTBK3",108,0)
 ;Q 0     ; hook for more complex checker
"RTN","SCUTBK3",109,0)
 N SCSER,SCCLI
"RTN","SCUTBK3",110,0)
 S SCSER=$P(SCX,U)
"RTN","SCUTBK3",111,0)
 I SCSER']"" Q 1
"RTN","SCUTBK3",112,0)
 S SCCLI=$P(SCX,U,2)
"RTN","SCUTBK3",113,0)
 I SCCLI']"" Q 1
"RTN","SCUTBK3",114,0)
 ;
"RTN","SCUTBK3",115,0)
 ;OK if on active list
"RTN","SCUTBK3",116,0)
 N SC1,SC1LIST
"RTN","SCUTBK3",117,0)
 S SC1=$$CLNLST^SCMCUT(SCSER,"SC1LIST",1)
"RTN","SCUTBK3",118,0)
 I SC1,$D(SC1LIST(SCCLI)) Q 0
"RTN","SCUTBK3",119,0)
 ;
"RTN","SCUTBK3",120,0)
 ;stop if on inactive list
"RTN","SCUTBK3",121,0)
 N SC2,SC2LIST
"RTN","SCUTBK3",122,0)
 S SC2=$$CLNLST^SCMCUT(SCSER,"SC2LIST",0)
"RTN","SCUTBK3",123,0)
 I SC2,$D(SC2LIST(SCCLI)) Q 1
"RTN","SCUTBK3",124,0)
 ;
"RTN","SCUTBK3",125,0)
 ;add client/server pair, OK if update
"RTN","SCUTBK3",126,0)
 Q '$$UPCLNLST^SCMCUT(SCX)
"RTN","SCUTBK3",127,0)
 ;
"RTN","SCUTBK3",128,0)
VPATCH(SCX) ; check server version
"RTN","SCUTBK3",129,0)
 ;       ; input SCX := server^client (versions)
"RTN","SCUTBK3",130,0)
 Q $$PATCH^XPDUTL($P(SCX,U))
"RTN","SCUTBK3",131,0)
 ;
"RTN","SCUTBK3",132,0)
 ; >>>> Error Processing Utilities <<<<
"RTN","SCUTBK3",133,0)
 ;
"RTN","SCUTBK3",134,0)
HDREC(SCDATA,SCER,SCPROC) ; -- build zeroth of SCDATA array
"RTN","SCUTBK3",135,0)
 IF SCER D
"RTN","SCUTBK3",136,0)
 . S SCDATA(0)=0_U_+SCER_U
"RTN","SCUTBK3",137,0)
 . D SETPROC(.SCDATA,.SCPROC)
"RTN","SCUTBK3",138,0)
 ELSE  D
"RTN","SCUTBK3",139,0)
 . S SCDATA(0)=1_U_U ; no errors
"RTN","SCUTBK3",140,0)
 Q
"RTN","SCUTBK3",141,0)
 ;
"RTN","SCUTBK3",142,0)
SETPROC(SCDATA,SCPROC) ; -- set process name for error list
"RTN","SCUTBK3",143,0)
 S $P(SCDATA(0),U,3)=SCPROC
"RTN","SCUTBK3",144,0)
 Q
"RTN","SCUTBK3",145,0)
 ;
"RTN","SCUTBK3",146,0)
ERRCHK(SCDATA,SCERR,SCPROC) ; -- process fileman dbs errors
"RTN","SCUTBK3",147,0)
 N SCERS
"RTN","SCUTBK3",148,0)
 S SCERS=$G(SCERR("DIERR"))
"RTN","SCUTBK3",149,0)
 IF SCERS D MSG^DIALOG("EA",.SCDATA,"","",SCERR)
"RTN","SCUTBK3",150,0)
 D HDREC(.SCDATA,SCERS,SCPROC)
"RTN","SCUTBK3",151,0)
 Q
"RTN","SCUTBK3",152,0)
 ;
"RTN","SD53A204")
0^3^B9244900
"RTN","SD53A204",1,0)
SD53A204 ;ALB/JAM;Part of post-install routine for patch 204;12/1/99@1105
"RTN","SD53A204",2,0)
 ;;5.3;Scheduling;**204**;DEC 01, 1999
"RTN","SD53A204",3,0)
 ;This post-install will check file 404.52 for invalid .03 field entries
"RTN","SD53A204",4,0)
 ;and save to a mail message.
"RTN","SD53A204",5,0)
 ;
"RTN","SD53A204",6,0)
POST ;Post-init
"RTN","SD53A204",7,0)
 N XSCSTOP
"RTN","SD53A204",8,0)
 S XSCSTOP=""
"RTN","SD53A204",9,0)
 D PROGCHK(.XSCSTOP)
"RTN","SD53A204",10,0)
 I XSCSTOP Q
"RTN","SD53A204",11,0)
 D MES^XPDUTL(" ")
"RTN","SD53A204",12,0)
 D MES^XPDUTL("This installation will generate an e-mail message with")
"RTN","SD53A204",13,0)
 D MES^XPDUTL("a list of invalid PRACTITIONER pointers (field #.03)")
"RTN","SD53A204",14,0)
 D MES^XPDUTL("from file POSITION ASSIGMENT HISTORY FILE (#404.52)")
"RTN","SD53A204",15,0)
 D MES^XPDUTL($$Q(DUZ))
"RTN","SD53A204",16,0)
 Q
"RTN","SD53A204",17,0)
        ;
"RTN","SD53A204",18,0)
PR40452 ;Process file 404.52 for invalid entries in field .03 and 
"RTN","SD53A204",19,0)
 ;create message text for mail message
"RTN","SD53A204",20,0)
 ;
"RTN","SD53A204",21,0)
 N XMY,XMDUZ,XMSUB,XMTEXT,FND
"RTN","SD53A204",22,0)
 K ^TMP("PCMM PRACTITIONER",$J),^TMP("SCMSG",$J)
"RTN","SD53A204",23,0)
 ;get list of invalid .03 field entries from file 404.52
"RTN","SD53A204",24,0)
 S FND=$$LST^SCMCCV5()
"RTN","SD53A204",25,0)
 D MAIL
"RTN","SD53A204",26,0)
 S XMDUZ=.5,XMY(XMDUZ)=""
"RTN","SD53A204",27,0)
 I $G(SCDUZ) S XMY(SCDUZ)=""
"RTN","SD53A204",28,0)
 S XMSUB="PCMM PRACTITIONER INCONSISTENCY REPORT"
"RTN","SD53A204",29,0)
 S XMTEXT="^TMP(""SCMSG"",$J,"
"RTN","SD53A204",30,0)
 D ^XMD
"RTN","SD53A204",31,0)
 K ^TMP("PCMM PRACTITIONER",$J),^TMP("SCMSG",$J)
"RTN","SD53A204",32,0)
 Q
"RTN","SD53A204",33,0)
 ;
"RTN","SD53A204",34,0)
MAIL ; Queue report as a MailMan Message.
"RTN","SD53A204",35,0)
 N NUM,TXT,I,SCDAT,SCDT,SCTP,SCSTA,SCPRAC,CNT,BL,X,Y
"RTN","SD53A204",36,0)
 S NUM=0,$P(BL," ",20)="",CNT=1
"RTN","SD53A204",37,0)
 D SET("This message was automatically generated by PCMM patch SD*5.3*204")
"RTN","SD53A204",38,0)
 D SET(" ")
"RTN","SD53A204",39,0)
 D SET("      INVALID PRACTITIONER POINTERS IN FILE 404.52 REPORT")
"RTN","SD53A204",40,0)
 D SET(" ")
"RTN","SD53A204",41,0)
 D SET(" ")
"RTN","SD53A204",42,0)
 I 'FND D SET("No inconsistencies found.") Q
"RTN","SD53A204",43,0)
 D SET("                              EFFECTIVE")
"RTN","SD53A204",44,0)
 D SET("IEN #   TEAM POSITION           DATE          PRACT.     STATUS")
"RTN","SD53A204",45,0)
 D SET("---------------------------------------------------------------")
"RTN","SD53A204",46,0)
 F I=1:1 S NUM=$O(^TMP("PCMM PRACTITIONER",$J,NUM)) Q:'NUM  D
"RTN","SD53A204",47,0)
 . S SCDAT=$G(^SCTM(404.52,NUM,0)),Y=$P(SCDAT,U,2) X ^DD("DD") S SCDT=Y
"RTN","SD53A204",48,0)
 . S X=$P(SCDAT,U),SCTP=$P($G(^SCTM(404.57,X,0)),U)
"RTN","SD53A204",49,0)
 . S SCSTA=$S($P(SCDAT,U,4):"Active",1:"Inactive"),SCPRAC=$P(SCDAT,U,3)
"RTN","SD53A204",50,0)
 . S TXT=$E(NUM_BL,1,7)_$E(SCTP_BL,1,21)_" "_$E(SCDT_BL,1,15)
"RTN","SD53A204",51,0)
 . S TXT=TXT_"  "_$E(SCPRAC_BL,1,9)_SCSTA
"RTN","SD53A204",52,0)
 . D SET(TXT)
"RTN","SD53A204",53,0)
 D SET(" ")
"RTN","SD53A204",54,0)
 D SET("Total entries found = "_(I-1))
"RTN","SD53A204",55,0)
 Q
"RTN","SD53A204",56,0)
 ;
"RTN","SD53A204",57,0)
SET(TXT) ;Build message array
"RTN","SD53A204",58,0)
 S ^TMP("SCMSG",$J,CNT)=TXT
"RTN","SD53A204",59,0)
 S CNT=CNT+1
"RTN","SD53A204",60,0)
 Q
"RTN","SD53A204",61,0)
 ;
"RTN","SD53A204",62,0)
PROGCHK(XSCSTOP) ;checks for necessary programmer variables
"RTN","SD53A204",63,0)
 ;
"RTN","SD53A204",64,0)
 I '$G(DUZ)!($G(DUZ(0))'="@")!('$G(DT))!($G(U)'="^") D
"RTN","SD53A204",65,0)
 . D BMES^XPDUTL("*****")
"RTN","SD53A204",66,0)
 . D MES^XPDUTL("Your programming variables are not set up properly.")
"RTN","SD53A204",67,0)
 . D MES^XPDUTL("Installation aborted.")
"RTN","SD53A204",68,0)
 . D MES^XPDUTL("*****")
"RTN","SD53A204",69,0)
 . S XSCSTOP=1
"RTN","SD53A204",70,0)
 Q
"RTN","SD53A204",71,0)
 ;
"RTN","SD53A204",72,0)
Q(SCDUZ) ; run job in background
"RTN","SD53A204",73,0)
 ; input  = user duz 
"RTN","SD53A204",74,0)
 ; output = task #, report via mailman
"RTN","SD53A204",75,0)
 N ZTRTN,ZTDESC,ZTDTH,ZTIO,ZTSAVE
"RTN","SD53A204",76,0)
 S ZTRTN="PR40452^SD53A204"
"RTN","SD53A204",77,0)
 S ZTDESC="PCMM PRACTITIONER INCONSISTENCY REPORT"
"RTN","SD53A204",78,0)
 S ZTDTH=$H
"RTN","SD53A204",79,0)
 S ZTIO=""
"RTN","SD53A204",80,0)
 S ZTSAVE("SCDUZ")=""
"RTN","SD53A204",81,0)
 D ^%ZTLOAD
"RTN","SD53A204",82,0)
 Q $S(+ZTSK:": Queued - Task# "_ZTSK,1:": Not Queued!")
"RTN","SD53A204",83,0)
 ;
"RTN","SD53B204")
0^4^B7144281
"RTN","SD53B204",1,0)
SD53B204 ;bp/cmf - Patch SD*5.3*204 post-init routine ; 12/06/99 
"RTN","SD53B204",2,0)
 ;;5.3;Scheduling;**204**;AUG 13, 1993
"RTN","SD53B204",3,0)
 ;
"RTN","SD53B204",4,0)
POST ;update c/s files
"RTN","SD53B204",5,0)
 ;
"RTN","SD53B204",6,0)
 ;initialize new pcmm parameter file fields
"RTN","SD53B204",7,0)
 ; add default value to RPC Time Limit field
"RTN","SD53B204",8,0)
 ; add default value to HL7 Transmit Limit field
"RTN","SD53B204",9,0)
 D BMESS("Updating PCMM files.")
"RTN","SD53B204",10,0)
 D MESS("Updating PCMM Parameter file.")
"RTN","SD53B204",11,0)
 N SCFDA,SC1ERR,SCX
"RTN","SD53B204",12,0)
 K SCFDA(1)
"RTN","SD53B204",13,0)
 S SCFDA(1,404.44,"1,",14)=30
"RTN","SD53B204",14,0)
 S SCFDA(1,404.44,"1,",15)=999999
"RTN","SD53B204",15,0)
 D FILE^DIE("","SCFDA(1)","SC1ERR")
"RTN","SD53B204",16,0)
 I $D(SC1ERR) D WMESS("PCMM Parameter file not updated properly.")
"RTN","SD53B204",17,0)
 ;
"RTN","SD53B204",18,0)
DSER ;disable old server entries (build active client list)
"RTN","SD53B204",19,0)
 D MESS("Disabling obsolete entries in Server Patch file.")
"RTN","SD53B204",20,0)
 N SC2LIST,SC2ERR,SCY,SC3LIST
"RTN","SD53B204",21,0)
 S SCX=$$ACTSER^SCMCUT("","SC2LIST")
"RTN","SD53B204",22,0)
 I 'SCX D MESS("No active Server Patch entries.") G P205
"RTN","SD53B204",23,0)
 S SCX=""
"RTN","SD53B204",24,0)
 F  S SCX=$O(SC2LIST(SCX)) Q:SCX']""  D
"RTN","SD53B204",25,0)
 . ;build active client list
"RTN","SD53B204",26,0)
 . S SCY=$$CLNLST^SCMCUT(SCX,"SC3LIST",1)
"RTN","SD53B204",27,0)
 . S SCY=0
"RTN","SD53B204",28,0)
 . F  S SCY=$O(^SCTM(404.45,"ACT",SCX,0)) Q:'SCY  D
"RTN","SD53B204",29,0)
 . . K SCFDA(2)
"RTN","SD53B204",30,0)
 . . S SCFDA(2,404.45,SCY_",",.04)=0
"RTN","SD53B204",31,0)
 . . D FILE^DIE("","SCFDA(2)","SC2ERR")
"RTN","SD53B204",32,0)
 . . Q
"RTN","SD53B204",33,0)
 . Q
"RTN","SD53B204",34,0)
 I $D(SC2ERR) D WMESS("Obsolete Server Patch entries not disabled.")
"RTN","SD53B204",35,0)
 ;
"RTN","SD53B204",36,0)
DCLI ;disable old client entries
"RTN","SD53B204",37,0)
 D MESS("Disabling obsolete entries in Client Patch file.")
"RTN","SD53B204",38,0)
 I '$D(SC3LIST) D MESS("No active Client Patch entries.") G P205
"RTN","SD53B204",39,0)
 N SC3ERR
"RTN","SD53B204",40,0)
 S SCX=""
"RTN","SD53B204",41,0)
 F  S SCX=$O(SC3LIST(SCX)) Q:SCX']""  D
"RTN","SD53B204",42,0)
 . K SCFDA(3)
"RTN","SD53B204",43,0)
 . S SCY=$O(^SCTM(404.46,"B",SCX,0))
"RTN","SD53B204",44,0)
 . S SCFDA(3,404.46,SCY_",",.02)=0
"RTN","SD53B204",45,0)
 . D FILE^DIE("","SCFDA(3)","SC3ERR")
"RTN","SD53B204",46,0)
 . Q
"RTN","SD53B204",47,0)
 I $D(SC3ERR) D WMESS("Obsolete Client Patch entries not disabled.")
"RTN","SD53B204",48,0)
 ;
"RTN","SD53B204",49,0)
P205 ;patch 205 record keeping
"RTN","SD53B204",50,0)
 D MESS("Updating SD*5.3*205 related entries.")
"RTN","SD53B204",51,0)
 S SCX=$$UPCLNLST^SCMCUT("SD*5.3*205^NullClient^1^0^0")
"RTN","SD53B204",52,0)
 I +SCX<1 D WMESS("SD*5.3*205 related entries not updated.")
"RTN","SD53B204",53,0)
 ;
"RTN","SD53B204",54,0)
P204 ;patch 204 record keeping
"RTN","SD53B204",55,0)
 D MESS("Updating SD*5.3*204 related entries.")
"RTN","SD53B204",56,0)
 S SCX=$$UPCLNLST^SCMCUT("SD*5.3*204^1.2.2.0^1^1^1")
"RTN","SD53B204",57,0)
 I +SCX<1 D WMESS("SD*5.3*204 related entries not updated.")
"RTN","SD53B204",58,0)
 ;
"RTN","SD53B204",59,0)
Q D MESS("")
"RTN","SD53B204",60,0)
 D MESS("PCMM files update finished.")
"RTN","SD53B204",61,0)
 Q
"RTN","SD53B204",62,0)
 ;
"RTN","SD53B204",63,0)
BMESS(SCX) ;
"RTN","SD53B204",64,0)
 D BMES^XPDUTL("******")
"RTN","SD53B204",65,0)
 D MESS(SCX)
"RTN","SD53B204",66,0)
 D MESS("")
"RTN","SD53B204",67,0)
 Q
"RTN","SD53B204",68,0)
 ;
"RTN","SD53B204",69,0)
WMESS(SCX) ;
"RTN","SD53B204",70,0)
 D MESS(" WARNING:")
"RTN","SD53B204",71,0)
 D MESS(" ."_SCX)
"RTN","SD53B204",72,0)
 Q
"RTN","SD53B204",73,0)
 ;
"RTN","SD53B204",74,0)
MESS(SCX) ;
"RTN","SD53B204",75,0)
 D MES^XPDUTL("."_SCX)
"RTN","SD53B204",76,0)
 Q
"RTN","SD53B204",77,0)
 ;
"RTN","SD53P204")
0^2^B2334712
"RTN","SD53P204",1,0)
SD53P204 ;bp/cmf - Patch SD*5.3*204 utility routine ; 12/06/99 
"RTN","SD53P204",2,0)
 ;;5.3;Scheduling;**204**;AUG 13, 1993
"RTN","SD53P204",3,0)
 ;
"RTN","SD53P204",4,0)
ENV ;environment check point.
"RTN","SD53P204",5,0)
 ;
"RTN","SD53P204",6,0)
 S XPDABORT=""
"RTN","SD53P204",7,0)
 D PROGCHK(.XPDABORT) ;checks programmer variables
"RTN","SD53P204",8,0)
 D PARMCHK(.XPDABORT) ;checks param file ien exists
"RTN","SD53P204",9,0)
 I XPDABORT="" K XPDABORT
"RTN","SD53P204",10,0)
 Q
"RTN","SD53P204",11,0)
 ;
"RTN","SD53P204",12,0)
PRE ;Pre-init
"RTN","SD53P204",13,0)
 Q
"RTN","SD53P204",14,0)
 ;
"RTN","SD53P204",15,0)
POST ;Post-init
"RTN","SD53P204",16,0)
 D POST^SD53A204 ;generate -1 practitioner message
"RTN","SD53P204",17,0)
 D POST^SD53B204 ;update c/s files
"RTN","SD53P204",18,0)
 Q
"RTN","SD53P204",19,0)
 ;
"RTN","SD53P204",20,0)
PROGCHK(XPDABORT) ;checks for necessary programmer variables
"RTN","SD53P204",21,0)
 ;
"RTN","SD53P204",22,0)
 I '$G(DUZ)!($G(DUZ(0))'="@")!('$G(DT))!($G(U)'="^") DO
"RTN","SD53P204",23,0)
 .D BMES^XPDUTL("*****")
"RTN","SD53P204",24,0)
 .D MES^XPDUTL("Your programming variables are not set up properly.")
"RTN","SD53P204",25,0)
 .D MES^XPDUTL("Installation aborted.")
"RTN","SD53P204",26,0)
 .D MES^XPDUTL("*****")
"RTN","SD53P204",27,0)
 .S XPDABORT=2
"RTN","SD53P204",28,0)
 .Q
"RTN","SD53P204",29,0)
 Q
"RTN","SD53P204",30,0)
 ;
"RTN","SD53P204",31,0)
PARMCHK(XPDABORT) ;checks for proper param file ien
"RTN","SD53P204",32,0)
 ;
"RTN","SD53P204",33,0)
 I '$D(^SCTM(404.44,1)) D
"RTN","SD53P204",34,0)
 .D BMES^XPDUTL("*****")
"RTN","SD53P204",35,0)
 .D MES^XPDUTL("Parameter file (#404.44) does not have proper IEN (1).")
"RTN","SD53P204",36,0)
 .D MES^XPDUTL("Installation aborted.")
"RTN","SD53P204",37,0)
 .D MES^XPDUTL("*****")
"RTN","SD53P204",38,0)
 .S XPDABORT=2
"RTN","SD53P204",39,0)
 .Q
"RTN","SD53P204",40,0)
 Q
"RTN","SD53P204",41,0)
 ;
"VER")
8.0^22.0
"^DD",404.44,404.44,14,0)
RPC TIME LIMIT^RNJ3,0^^1;4^K:+X'=X!(X>300)!(X<30)!(X?.E1"."1N.N) X
"^DD",404.44,404.44,14,3)
Type a Number between 30 and 300, 0 Decimal Digits
"^DD",404.44,404.44,14,21,0)
^^3^3^3000207^
"^DD",404.44,404.44,14,21,1,0)
This value represents the maximum number of seconds the client should
"^DD",404.44,404.44,14,21,2,0)
wait for a response from the server.  This value should be set as low
"^DD",404.44,404.44,14,21,3,0)
as possible consistent with allowing the client to avoid timeout errors.
"^DD",404.44,404.44,14,23,0)
^^3^3^3000207^^
"^DD",404.44,404.44,14,23,1,0)
The value retrieved from this field is returned to the client by the SCMC
"^DD",404.44,404.44,14,23,2,0)
VERIFY C/S SYNC remote procedure.  The client then uses this value to
"^DD",404.44,404.44,14,23,3,0)
update the run time property RPCTimelimit in all RPCBroker components.
"^DD",404.44,404.44,14,"DT")
2991206
"^DD",404.44,404.44,15,0)
HL7 TRANSMIT LIMIT^NJ6,0^^1;5^K:+X'=X!(X>999999)!(X<1)!(X?.E1"."1N.N) X
"^DD",404.44,404.44,15,3)
Type a Number between 1 and 999999, 0 Decimal Digits
"^DD",404.44,404.44,15,21,0)
^^5^5^3000207^
"^DD",404.44,404.44,15,21,1,0)
This value represents the maximum number of records which will be
"^DD",404.44,404.44,15,21,2,0)
transmitted during any given PCMM HL7 transmission session.  The default
"^DD",404.44,404.44,15,21,3,0)
value is 999999.  It is recommended this value be left AS IS, unless
"^DD",404.44,404.44,15,21,4,0)
the background HL7 messaging volume is adversely affecting system
"^DD",404.44,404.44,15,21,5,0)
performance.
"^DD",404.44,404.44,15,23,0)
^^3^3^3000207^
"^DD",404.44,404.44,15,23,1,0)
The value retrieved from this field is used by the 
"^DD",404.44,404.44,15,23,2,0)
SCMC PCMM HL7 TRANSMIT nightly background option to
"^DD",404.44,404.44,15,23,3,0)
regulate the maximum number of records to transmit.
"^DD",404.44,404.44,15,"DT")
2991206
"^DD",404.49,404.49,.02,0)
INTEGRATION ID^F^^0;2^K:$L(X)>25!($L(X)<5) X
"^DD",404.49,404.49,.02,1,0)
^.1
"^DD",404.49,404.49,.02,1,1,0)
404.49^C
"^DD",404.49,404.49,.02,1,1,1)
S ^SCPT(404.49,"C",$E(X,1,30),DA)=""
"^DD",404.49,404.49,.02,1,1,2)
K ^SCPT(404.49,"C",$E(X,1,30),DA)
"^DD",404.49,404.49,.02,1,1,"%D",0)
^^2^2^3000105^
"^DD",404.49,404.49,.02,1,1,"%D",1,0)
This xref is used to look-up an entry by it's legacy site ID.
"^DD",404.49,404.49,.02,1,1,"%D",2,0)
Used when processing HL7 rejects.
"^DD",404.49,404.49,.02,1,1,"DT")
3000105
"^DD",404.49,404.49,.02,3)
Enter legacy site ID (5-25 characters). ID is site number-PCMM HL7 ID IEN (Example: 604-34).
"^DD",404.49,404.49,.02,21,0)
^^4^4^3000105^
"^DD",404.49,404.49,.02,21,1,0)
When one site is integrated into another site, all entries in 404.43,
"^DD",404.49,404.49,.02,21,2,0)
404.52, and 404.53 that have been unassigned and that are moved to the
"^DD",404.49,404.49,.02,21,3,0)
primary site, need to be able to convert to the original ID if they are
"^DD",404.49,404.49,.02,21,4,0)
edited and an HL7 message is generated. This field preserves that old ID.
"^DD",404.49,404.49,.02,"DT")
3000105
**END**
**END**
