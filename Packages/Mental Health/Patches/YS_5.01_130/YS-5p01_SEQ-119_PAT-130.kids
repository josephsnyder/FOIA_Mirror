Released YS*5.01*130 SEQ #119
Extracted from mail message
**KIDS**:YS*5.01*130^

**INSTALL NAME**
YS*5.01*130
"BLD",10730,0)
YS*5.01*130^MENTAL HEALTH^0^3191217^y
"BLD",10730,1,0)
^^2^2^3191217^^^^
"BLD",10730,1,1,0)
Add assignment capablity to MHA and calls for MHA Web app that allows 
"BLD",10730,1,2,0)
patient entry.
"BLD",10730,4,0)
^9.64PA^601.97^3
"BLD",10730,4,601.71,0)
601.71
"BLD",10730,4,601.71,2,0)
^9.641^601.71101^2
"BLD",10730,4,601.71,2,601.71,0)
MH TESTS AND SURVEYS  (File-top level)
"BLD",10730,4,601.71,2,601.71,1,0)
^9.6411^94^1
"BLD",10730,4,601.71,2,601.71,1,94,0)
STAFF ENTRY ONLY
"BLD",10730,4,601.71,2,601.71101,0)
CATEGORY  (sub-file)
"BLD",10730,4,601.71,2,601.71101,1,0)
^9.6411^.01^1
"BLD",10730,4,601.71,2,601.71101,1,.01,0)
CATEGORY
"BLD",10730,4,601.71,222)
y^y^p^^^^n^^n
"BLD",10730,4,601.71,224)

"BLD",10730,4,601.96,0)
601.96
"BLD",10730,4,601.96,222)
y^y^f^^^^n
"BLD",10730,4,601.97,0)
601.97
"BLD",10730,4,601.97,222)
y^y^f^^n^^y^o^n
"BLD",10730,4,"APDD",601.71,601.71)

"BLD",10730,4,"APDD",601.71,601.71,94)

"BLD",10730,4,"APDD",601.71,601.71101)

"BLD",10730,4,"APDD",601.71,601.71101,.01)

"BLD",10730,4,"B",601.71,601.71)

"BLD",10730,4,"B",601.96,601.96)

"BLD",10730,4,"B",601.97,601.97)

"BLD",10730,6)
3^
"BLD",10730,6.3)
62
"BLD",10730,"ABPKG")
n
"BLD",10730,"INIT")
POST^YS130PST
"BLD",10730,"KRN",0)
^9.67PA^779.2^20
"BLD",10730,"KRN",.4,0)
.4
"BLD",10730,"KRN",.4,"NM",0)
^9.68A^^
"BLD",10730,"KRN",.401,0)
.401
"BLD",10730,"KRN",.402,0)
.402
"BLD",10730,"KRN",.403,0)
.403
"BLD",10730,"KRN",.5,0)
.5
"BLD",10730,"KRN",.84,0)
.84
"BLD",10730,"KRN",3.6,0)
3.6
"BLD",10730,"KRN",3.8,0)
3.8
"BLD",10730,"KRN",9.2,0)
9.2
"BLD",10730,"KRN",9.8,0)
9.8
"BLD",10730,"KRN",9.8,"NM",0)
^9.68A^30^23
"BLD",10730,"KRN",9.8,"NM",2,0)
YTQRQAD^^0^B17984488
"BLD",10730,"KRN",9.8,"NM",6,0)
YTQRUTL^^0^B67291165
"BLD",10730,"KRN",9.8,"NM",7,0)
YTWJSON^^0^B85561808
"BLD",10730,"KRN",9.8,"NM",8,0)
YTWJSONF^^0^B9425991
"BLD",10730,"KRN",9.8,"NM",9,0)
YTWJSONO^^0^B21552194
"BLD",10730,"KRN",9.8,"NM",10,0)
YTWJSONU^^0^B5383901
"BLD",10730,"KRN",9.8,"NM",11,0)
YTQRRPT^^0^B35953484
"BLD",10730,"KRN",9.8,"NM",12,0)
YS130PST^^0^B6726554
"BLD",10730,"KRN",9.8,"NM",13,0)
YTQRRPC^^0^B6690032
"BLD",10730,"KRN",9.8,"NM",14,0)
YTQRIS^^0^B89215067
"BLD",10730,"KRN",9.8,"NM",16,0)
YTQRQAD1^^0^B43113757
"BLD",10730,"KRN",9.8,"NM",17,0)
YTQRQAD2^^0^B33515515
"BLD",10730,"KRN",9.8,"NM",18,0)
YTQRQAD3^^0^B21425312
"BLD",10730,"KRN",9.8,"NM",21,0)
YTXCHG^^0^B70845213
"BLD",10730,"KRN",9.8,"NM",22,0)
YTXCHGT^^0^B23916651
"BLD",10730,"KRN",9.8,"NM",23,0)
YTQREST0^^0^B7041728
"BLD",10730,"KRN",9.8,"NM",24,0)
YTQAPI^^0^B17118160
"BLD",10730,"KRN",9.8,"NM",25,0)
YTQAPI2^^0^B34492962
"BLD",10730,"KRN",9.8,"NM",26,0)
YS130PS0^^0^B35085086
"BLD",10730,"KRN",9.8,"NM",27,0)
YTSBAMC^^0^B15807209
"BLD",10730,"KRN",9.8,"NM",28,0)
YTSBAMI^^0^B2972389
"BLD",10730,"KRN",9.8,"NM",29,0)
YTSBAMR^^0^B30507042
"BLD",10730,"KRN",9.8,"NM",30,0)
YTQROPT^^0^B3569685
"BLD",10730,"KRN",9.8,"NM","B","YS130PS0",26)

"BLD",10730,"KRN",9.8,"NM","B","YS130PST",12)

"BLD",10730,"KRN",9.8,"NM","B","YTQAPI",24)

"BLD",10730,"KRN",9.8,"NM","B","YTQAPI2",25)

"BLD",10730,"KRN",9.8,"NM","B","YTQREST0",23)

"BLD",10730,"KRN",9.8,"NM","B","YTQRIS",14)

"BLD",10730,"KRN",9.8,"NM","B","YTQROPT",30)

"BLD",10730,"KRN",9.8,"NM","B","YTQRQAD",2)

"BLD",10730,"KRN",9.8,"NM","B","YTQRQAD1",16)

"BLD",10730,"KRN",9.8,"NM","B","YTQRQAD2",17)

"BLD",10730,"KRN",9.8,"NM","B","YTQRQAD3",18)

"BLD",10730,"KRN",9.8,"NM","B","YTQRRPC",13)

"BLD",10730,"KRN",9.8,"NM","B","YTQRRPT",11)

"BLD",10730,"KRN",9.8,"NM","B","YTQRUTL",6)

"BLD",10730,"KRN",9.8,"NM","B","YTSBAMC",27)

"BLD",10730,"KRN",9.8,"NM","B","YTSBAMI",28)

"BLD",10730,"KRN",9.8,"NM","B","YTSBAMR",29)

"BLD",10730,"KRN",9.8,"NM","B","YTWJSON",7)

"BLD",10730,"KRN",9.8,"NM","B","YTWJSONF",8)

"BLD",10730,"KRN",9.8,"NM","B","YTWJSONO",9)

"BLD",10730,"KRN",9.8,"NM","B","YTWJSONU",10)

"BLD",10730,"KRN",9.8,"NM","B","YTXCHG",21)

"BLD",10730,"KRN",9.8,"NM","B","YTXCHGT",22)

"BLD",10730,"KRN",19,0)
19
"BLD",10730,"KRN",19,"NM",0)
^9.68A^4^3
"BLD",10730,"KRN",19,"NM",2,0)
YTQREST PATIENT ENTRY^^0
"BLD",10730,"KRN",19,"NM",3,0)
YS BROKER1^^0
"BLD",10730,"KRN",19,"NM",4,0)
YTQR ASSIGNMENT BY PATIENT^^0
"BLD",10730,"KRN",19,"NM","B","YS BROKER1",3)

"BLD",10730,"KRN",19,"NM","B","YTQR ASSIGNMENT BY PATIENT",4)

"BLD",10730,"KRN",19,"NM","B","YTQREST PATIENT ENTRY",2)

"BLD",10730,"KRN",19.1,0)
19.1
"BLD",10730,"KRN",101,0)
101
"BLD",10730,"KRN",409.61,0)
409.61
"BLD",10730,"KRN",771,0)
771
"BLD",10730,"KRN",779.2,0)
779.2
"BLD",10730,"KRN",870,0)
870
"BLD",10730,"KRN",8989.51,0)
8989.51
"BLD",10730,"KRN",8989.52,0)
8989.52
"BLD",10730,"KRN",8994,0)
8994
"BLD",10730,"KRN",8994,"NM",0)
^9.68A^4^3
"BLD",10730,"KRN",8994,"NM",2,0)
YTQREST QENTRY^^0
"BLD",10730,"KRN",8994,"NM",3,0)
YTQRRPC SELECT^^0
"BLD",10730,"KRN",8994,"NM",4,0)
YTQREST QSTAFF^^0
"BLD",10730,"KRN",8994,"NM","B","YTQREST QENTRY",2)

"BLD",10730,"KRN",8994,"NM","B","YTQREST QSTAFF",4)

"BLD",10730,"KRN",8994,"NM","B","YTQRRPC SELECT",3)

"BLD",10730,"KRN","B",.4,.4)

"BLD",10730,"KRN","B",.401,.401)

"BLD",10730,"KRN","B",.402,.402)

"BLD",10730,"KRN","B",.403,.403)

"BLD",10730,"KRN","B",.5,.5)

"BLD",10730,"KRN","B",.84,.84)

"BLD",10730,"KRN","B",3.6,3.6)

"BLD",10730,"KRN","B",3.8,3.8)

"BLD",10730,"KRN","B",9.2,9.2)

"BLD",10730,"KRN","B",9.8,9.8)

"BLD",10730,"KRN","B",19,19)

"BLD",10730,"KRN","B",19.1,19.1)

"BLD",10730,"KRN","B",101,101)

"BLD",10730,"KRN","B",409.61,409.61)

"BLD",10730,"KRN","B",771,771)

"BLD",10730,"KRN","B",779.2,779.2)

"BLD",10730,"KRN","B",870,870)

"BLD",10730,"KRN","B",8989.51,8989.51)

"BLD",10730,"KRN","B",8989.52,8989.52)

"BLD",10730,"KRN","B",8994,8994)

"BLD",10730,"QDEF")
^^^^NO^^^^NO^^NO
"BLD",10730,"QUES",0)
^9.62^^
"BLD",10730,"REQB",0)
^9.611^1^1
"BLD",10730,"REQB",1,0)
YS*5.01*123^1
"BLD",10730,"REQB","B","YS*5.01*123",1)

"DATA",601.97,1,0)
Cognitive
"DATA",601.97,2,0)
Anxiety/PTSD
"DATA",601.97,3,0)
Pain
"DATA",601.97,4,0)
Depression
"DATA",601.97,5,0)
Addiction-SUD
"DATA",601.97,6,0)
Suicide Prevention
"DATA",601.97,7,0)
Personality
"DATA",601.97,8,0)
Employment
"DATA",601.97,9,0)
ADL/Func Status
"DATA",601.97,10,0)
Sleep
"DATA",601.97,11,0)
Pain / Health
"DATA",601.97,12,0)
Psychosis
"DATA",601.97,13,0)
Quality of Life
"DATA",601.97,14,0)
Recovery
"DATA",601.97,15,0)
Life Satisfaction
"DATA",601.97,16,0)
Screening
"DATA",601.97,17,0)
Couples/Family Func
"DATA",601.97,18,0)
EBP
"DATA",601.97,19,0)
General Symptoms
"DATA",601.97,20,0)
Other 1
"DATA",601.97,21,0)
Other 2
"DATA",601.97,22,0)
Other 3
"DATA",601.97,23,0)
Addiction
"DATA",601.97,24,0)
Daily Living & Activity
"DATA",601.97,25,0)
Anxiety
"DATA",601.97,26,0)
Frequent MBCs
"FIA",601.71)
MH TESTS AND SURVEYS
"FIA",601.71,0)
^YTT(601.71,
"FIA",601.71,0,0)
601.71s
"FIA",601.71,0,1)
y^y^p^^^^n^^n
"FIA",601.71,0,10)

"FIA",601.71,0,11)

"FIA",601.71,0,"RLRO")

"FIA",601.71,0,"VR")
5.01^YS
"FIA",601.71,601.71)
1
"FIA",601.71,601.71,94)

"FIA",601.71,601.71,101)

"FIA",601.71,601.71101)
1
"FIA",601.71,601.71101,.01)

"FIA",601.96)
MH STAGED DOCUMENTS
"FIA",601.96,0)
^YTT(601.96,
"FIA",601.96,0,0)
601.96
"FIA",601.96,0,1)
y^y^f^^^^n
"FIA",601.96,0,10)

"FIA",601.96,0,11)

"FIA",601.96,0,"RLRO")

"FIA",601.96,0,"VR")
5.01^YS
"FIA",601.96,601.96)
0
"FIA",601.96,601.961)
0
"FIA",601.97)
MH INSTRUMENT CATEGORY
"FIA",601.97,0)
^YTT(601.97,
"FIA",601.97,0,0)
601.97
"FIA",601.97,0,1)
y^y^f^^n^^y^o^n
"FIA",601.97,0,10)

"FIA",601.97,0,11)

"FIA",601.97,0,"RLRO")

"FIA",601.97,0,"VR")
5.01^YS
"FIA",601.97,601.97)
0
"INIT")
POST^YS130PST
"KRN",19,12151,-1)
0^3
"KRN",19,12151,0)
YS BROKER1^YS BROKER1 version 1.0.3.75~1.0.5.6~1.0.3.80^^B^^^^^^^n^
"KRN",19,12151,1,0)
^19.06^1^1^3180821^^^^
"KRN",19,12151,1,1,0)
Allows user to call VISTA's remote procedures.
"KRN",19,12151,99.1)
65336,40886
"KRN",19,12151,"RPC",0)
^19.05P^170^170
"KRN",19,12151,"RPC",7,0)
YS GAF API
"KRN",19,12151,"RPC",20,0)
YTAPI NEW ASI
"KRN",19,12151,"RPC",35,0)
ORWU NEWPERS
"KRN",19,12151,"RPC",46,0)
YTRP INSTRUMENT REPORT
"KRN",19,12151,"RPC",47,0)
YSRP ASI ITEM
"KRN",19,12151,"RPC",48,0)
YSRP ASI NARRATIVE
"KRN",19,12151,"RPC",49,0)
YTAPI ASI PNOTE
"KRN",19,12151,"RPC",51,0)
YTAPI ASI SAVE DATA
"KRN",19,12151,"RPC",52,0)
YTAPI ASI SIGNER
"KRN",19,12151,"RPC",54,0)
YTAPI ASI FACTORS
"KRN",19,12151,"RPC",56,0)
YTAPI ASI LISTER
"KRN",19,12151,"RPC",57,0)
YTAPI GET ASI RESPONSES
"KRN",19,12151,"RPC",60,0)
YTAPI NEW GAF
"KRN",19,12151,"RPC",66,0)
ORWPT PTINQ
"KRN",19,12151,"RPC",78,0)
YTQ ADMINS BOTH
"KRN",19,12151,"RPC",79,0)
YTQ ALL ANSWERS
"KRN",19,12151,"RPC",80,0)
YTQ ALL CHOICES
"KRN",19,12151,"RPC",81,0)
YTQ ASI LISTER
"KRN",19,12151,"RPC",82,0)
YTQ ASI SIGNOK
"KRN",19,12151,"RPC",83,0)
YTQ BATTC
"KRN",19,12151,"RPC",84,0)
YTQ BATTDEL
"KRN",19,12151,"RPC",85,0)
YTQ CAPIE
"KRN",19,12151,"RPC",86,0)
YTQ CHOICE ADD
"KRN",19,12151,"RPC",87,0)
YTQ CHOICE ORPHAN DELETE
"KRN",19,12151,"RPC",88,0)
YTQ CHOICEIDENT
"KRN",19,12151,"RPC",89,0)
YTQ CHOICES
"KRN",19,12151,"RPC",90,0)
YTQ CHOICETYPE ADD
"KRN",19,12151,"RPC",91,0)
YTQ CHOICETYPE DELETE
"KRN",19,12151,"RPC",92,0)
YTQ CHOICETYPE DESCRIBE
"KRN",19,12151,"RPC",93,0)
YTQ CHOICETYPE ORPHAN DELETE
"KRN",19,12151,"RPC",94,0)
YTQ COPY TEST
"KRN",19,12151,"RPC",95,0)
YTQ DELETE SCALES AND GROUP
"KRN",19,12151,"RPC",96,0)
YTQ DELETE TEST
"KRN",19,12151,"RPC",97,0)
YTQ DISPLAY
"KRN",19,12151,"RPC",98,0)
YTQ EXPORT
"KRN",19,12151,"RPC",99,0)
YTQ EXPORTED MAIL
"KRN",19,12151,"RPC",100,0)
YTQ FIRST WP
"KRN",19,12151,"RPC",101,0)
YTQ GAF HX
"KRN",19,12151,"RPC",102,0)
YTQ GENERIC LISTER
"KRN",19,12151,"RPC",103,0)
YTQ GET ADMINISTRATIONS
"KRN",19,12151,"RPC",104,0)
YTQ GET REPORT
"KRN",19,12151,"RPC",105,0)
YTQ GET SCALES
"KRN",19,12151,"RPC",106,0)
YTQ GETANS
"KRN",19,12151,"RPC",107,0)
YTQ IMPORT
"KRN",19,12151,"RPC",108,0)
YTQ KEYS
"KRN",19,12151,"RPC",109,0)
YTQ LEGACY REPORT
"KRN",19,12151,"RPC",110,0)
YTQ PATIENT INFO
"KRN",19,12151,"RPC",111,0)
YTQ PATIENT LOOKUP
"KRN",19,12151,"RPC",112,0)
YTQ PN CREATE
"KRN",19,12151,"RPC",113,0)
YTQ PURGE
"KRN",19,12151,"RPC",114,0)
YTQ QUESTALL
"KRN",19,12151,"RPC",115,0)
YTQ RULEDEL
"KRN",19,12151,"RPC",116,0)
YTQ RULES
"KRN",19,12151,"RPC",117,0)
YTQ SAVE
"KRN",19,12151,"RPC",118,0)
YTQ SCALEGROUP
"KRN",19,12151,"RPC",119,0)
YTQ SCORE ADMIN
"KRN",19,12151,"RPC",120,0)
YTQ SCORE SAVE
"KRN",19,12151,"RPC",121,0)
YTQ SECTION
"KRN",19,12151,"RPC",122,0)
YTQ SET ANSWER
"KRN",19,12151,"RPC",123,0)
YTQ SET NATIONAL
"KRN",19,12151,"RPC",124,0)
YTQ SKIP
"KRN",19,12151,"RPC",125,0)
YTQ TEST ADD
"KRN",19,12151,"RPC",126,0)
YTQ TEST ORDER
"KRN",19,12151,"RPC",127,0)
YTQ TSLIST
"KRN",19,12151,"RPC",128,0)
YTQ TSLIST1
"KRN",19,12151,"RPC",129,0)
YTQ USERQ
"KRN",19,12151,"RPC",130,0)
YTQ VERSRV
"KRN",19,12151,"RPC",131,0)
YTQ WP ALL
"KRN",19,12151,"RPC",132,0)
YTQ WP FILER
"KRN",19,12151,"RPC",133,0)
YTQ HL7
"KRN",19,12151,"RPC",134,0)
YTQ LEGCR
"KRN",19,12151,"RPC",135,0)
YTAPI PREVIEW
"KRN",19,12151,"RPC",136,0)
YTQ ALLKEYS
"KRN",19,12151,"RPC",137,0)
YTQ GET SCRATCH
"KRN",19,12151,"RPC",138,0)
YTQ SET SCRATCH
"KRN",19,12151,"RPC",139,0)
YTQ KILL SCRATCH
"KRN",19,12151,"RPC",140,0)
YTQ SET ANSWER ALL
"KRN",19,12151,"RPC",141,0)
YTQ ADMIN DELETE
"KRN",19,12151,"RPC",142,0)
YTQ CONSULT CREATE
"KRN",19,12151,"RPC",143,0)
GMV LATEST VM
"KRN",19,12151,"RPC",144,0)
ORWCV VST
"KRN",19,12151,"RPC",145,0)
ORQQPL PROBLEM LIST
"KRN",19,12151,"RPC",147,0)
ORWU HOSPLOC
"KRN",19,12151,"RPC",148,0)
ORQQCN LIST
"KRN",19,12151,"RPC",149,0)
YTQ DELETE ENTRY
"KRN",19,12151,"RPC",159,0)
YTQ GET RESULTS
"KRN",19,12151,"RPC",160,0)
YTQ GET SCRATCH SCORES
"KRN",19,12151,"RPC",161,0)
YTQREST QSTAFF
"KRN",19,12151,"RPC",162,0)
YTQRRPC SELECT
"KRN",19,12151,"RPC",163,0)
DDR DELETE ENTRY
"KRN",19,12151,"RPC",164,0)
DDR FILER
"KRN",19,12151,"RPC",165,0)
DDR FIND1
"KRN",19,12151,"RPC",166,0)
DDR FINDER
"KRN",19,12151,"RPC",167,0)
DDR GET DD HELP
"KRN",19,12151,"RPC",168,0)
DDR GETS ENTRY DATA
"KRN",19,12151,"RPC",169,0)
DDR LISTER
"KRN",19,12151,"RPC",170,0)
DDR VALIDATOR
"KRN",19,12151,"U")
YS BROKER1 VERSION 1.0.3.75~1.
"KRN",19,14719,-1)
0^2
"KRN",19,14719,0)
YTQREST PATIENT ENTRY^MHA Patient Entry 1.0^^B^^^^^^^^
"KRN",19,14719,1,0)
^^1^1^3181005^
"KRN",19,14719,1,1,0)
Context option for MHA Patient Entry function.
"KRN",19,14719,10.1)
MHA Patient Entry Calls
"KRN",19,14719,99.1)
65289,56117
"KRN",19,14719,"RPC",0)
^19.05P^1^1
"KRN",19,14719,"RPC",1,0)
YTQREST QENTRY
"KRN",19,14719,"U")
MHA PATIENT ENTRY 1.0
"KRN",19,14724,-1)
0^4
"KRN",19,14724,0)
YTQR ASSIGNMENT BY PATIENT^MHA Assignments By Patient^^R^^^^^^^^
"KRN",19,14724,1,0)
^^1^1^3191008^
"KRN",19,14724,1,1,0)
List MHA instrument assignments with their respective PIN's for a patient.
"KRN",19,14724,10.1)
MHA Patient Assignments
"KRN",19,14724,25)
LSTBYPT^YTQROPT
"KRN",19,14724,99.1)
65332,44412
"KRN",19,14724,"U")
MHA ASSIGNMENTS BY PATIENT
"KRN",8994,4113,-1)
0^2
"KRN",8994,4113,0)
YTQREST QENTRY^QENTRY^YTQREST0^2^R^^^0^1^^1
"KRN",8994,4113,1,0)
^8994.01^2^2^3190607^^
"KRN",8994,4113,1,1,0)
Front controller for patient entered mental health instruments.
"KRN",8994,4113,1,2,0)
Limited REST calls, as this is intended for use with an application proxy.
"KRN",8994,4114,-1)
0^3
"KRN",8994,4114,0)
YTQRRPC SELECT^SELECT^YTQRRPC^2^R
"KRN",8994,4114,1,0)
^^1^1^3181106^
"KRN",8994,4114,1,1,0)
Calls for Instrument Selection (Delphi Version)
"KRN",8994,4115,-1)
0^4
"KRN",8994,4115,0)
YTQREST QSTAFF^QSTAFF^YTQREST0^2^R^^^0^1^^0
"KRN",8994,4115,1,0)
^8994.01^3^3^3190621^^
"KRN",8994,4115,1,1,0)
Front controller for creating instrument assignments.
"KRN",8994,4115,1,2,0)
This RPC is used by Delphi-based MHA and is a predecessor to full 
"KRN",8994,4115,1,3,0)
web-based MHA.
"MBREQ")
0
"ORD",16,8994)
8994;16;1;;;;RPCE1^XPDIA1;;;RPCDEL^XPDIA1
"ORD",16,8994,0)
REMOTE PROCEDURE
"ORD",18,19)
19;18;;;OPT^XPDTA;OPTF1^XPDIA;OPTE1^XPDIA;OPTF2^XPDIA;;OPTDEL^XPDIA
"ORD",18,19,0)
OPTION
"PKG",166,-1)
1^1
"PKG",166,0)
MENTAL HEALTH^YS^Version 5.01 of Mental Health
"PKG",166,22,0)
^9.49I^1^1
"PKG",166,22,1,0)
5.01^2941230^2950310
"PKG",166,22,1,"PAH",1,0)
130^3191217^1085
"PKG",166,22,1,"PAH",1,1,0)
^^2^2^3191217
"PKG",166,22,1,"PAH",1,1,1,0)
Add assignment capablity to MHA and calls for MHA Web app that allows 
"PKG",166,22,1,"PAH",1,1,2,0)
patient entry.
"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
NO
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
NO
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
NO
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
23
"RTN","YS130PS0")
0^26^B35085086^n/a
"RTN","YS130PS0",1,0)
YS130PS0 ;SLC/KCM - Patch 130 Post-Init Update Categories ; 1/25/2017
"RTN","YS130PS0",2,0)
 ;;5.01;MENTAL HEALTH;**130**;Dec 30, 1994;Build 62
"RTN","YS130PS0",3,0)
 ;
"RTN","YS130PS0",4,0)
 ; External Reference    ICR#
"RTN","YS130PS0",5,0)
 ; ------------------   -----
"RTN","YS130PS0",6,0)
 ; %ZOSV                10097
"RTN","YS130PS0",7,0)
 ; DIE                   2053
"RTN","YS130PS0",8,0)
 ; DIK                  10013
"RTN","YS130PS0",9,0)
 ; DILF                  2054
"RTN","YS130PS0",10,0)
 ; XPDUTL               10141
"RTN","YS130PS0",11,0)
 ;
"RTN","YS130PS0",12,0)
 Q
"RTN","YS130PS0",13,0)
SHOCATS ; List out categories for inclusion in routine 
"RTN","YS130PS0",14,0)
 N TEST,X,CAT,IEN,LIST
"RTN","YS130PS0",15,0)
 S TEST=0 F  S TEST=$O(^YTT(601.71,TEST)) Q:'TEST  D
"RTN","YS130PS0",16,0)
 . I $P($G(^YTT(601.71,TEST,2)),U,2)'="Y" QUIT  ; active instrument?
"RTN","YS130PS0",17,0)
 . S X="",CAT=0 F  S CAT=$O(^YTT(601.71,TEST,10,CAT)) Q:'CAT  D
"RTN","YS130PS0",18,0)
 . . S IEN=+^YTT(601.71,TEST,10,CAT,0)
"RTN","YS130PS0",19,0)
 . . S X=X_$S($L(X):U,1:"")_$P(^YTT(601.97,IEN,0),U)
"RTN","YS130PS0",20,0)
 . I $L(X) S LIST($P(^YTT(601.71,TEST,0),U))=X
"RTN","YS130PS0",21,0)
 S X="" F  S X=$O(LIST(X)) Q:'$L(X)  W !," ;;"_X_U_LIST(X)
"RTN","YS130PS0",22,0)
 Q
"RTN","YS130PS0",23,0)
SETCATS ; Set categories from CATLST into 601.71
"RTN","YS130PS0",24,0)
 ; Don't run this install in the dev environment
"RTN","YS130PS0",25,0)
 N Y D GETENV^%ZOSV I $P(Y,U,4)="SPPNXT:VISTA" Q
"RTN","YS130PS0",26,0)
 ;
"RTN","YS130PS0",27,0)
 N YSI,YSJ,YSX,YSNM,YSIEN,YSCATS,YSCAT,YSCNT
"RTN","YS130PS0",28,0)
 S YSCNT=0
"RTN","YS130PS0",29,0)
 F YSI=1:1 S YSX=$P($T(CATLST+YSI),";;",2,99) Q:YSX="zzzzz"  D
"RTN","YS130PS0",30,0)
 . S YSNM=$P(YSX,U,1),YSCATS=$P(YSX,U,2,99)
"RTN","YS130PS0",31,0)
 . S YSIEN=$O(^YTT(601.71,"B",YSNM,0)) Q:'YSIEN
"RTN","YS130PS0",32,0)
 . D DELCATS(YSIEN)
"RTN","YS130PS0",33,0)
 . N FDA,FDAIEN,DIERR
"RTN","YS130PS0",34,0)
 . F YSJ=1:1:$L(YSCATS,U) D
"RTN","YS130PS0",35,0)
 . . S YSCAT=$P(YSCATS,U,YSJ) Q:'$L(YSCAT)
"RTN","YS130PS0",36,0)
 . . S YSCNT=YSCNT+1
"RTN","YS130PS0",37,0)
 . . S FDA(601.71101,"+"_YSJ_","_YSIEN_",",.01)=YSCAT
"RTN","YS130PS0",38,0)
 . Q:$D(FDA)<10
"RTN","YS130PS0",39,0)
 . D UPDATE^DIE("E","FDA","FDAIEN")
"RTN","YS130PS0",40,0)
 . I $D(DIERR) D MES^XPDUTL(YSNM_": "_$G(^TMP("DIERR",$J,1,"TEXT",1)))
"RTN","YS130PS0",41,0)
 . D CLEAN^DILF
"RTN","YS130PS0",42,0)
 D MES^XPDUTL("Instrument categories updated: "_YSCNT)
"RTN","YS130PS0",43,0)
 Q
"RTN","YS130PS0",44,0)
DELCATS(YSIEN) ; Delete the categories for instrument YSIEN
"RTN","YS130PS0",45,0)
 I '$O(^YTT(601.71,YSIEN,10,0)) Q  ; no child nodes
"RTN","YS130PS0",46,0)
 N DA,DIK
"RTN","YS130PS0",47,0)
 S DA=0,DA(1)=YSIEN,DIK="^YTT(601.71,"_DA(1)_",10,"
"RTN","YS130PS0",48,0)
 F  S DA=$O(^YTT(601.71,YSIEN,10,DA)) Q:'DA  D ^DIK
"RTN","YS130PS0",49,0)
 Q
"RTN","YS130PS0",50,0)
CATLST ; Instrument Categories
"RTN","YS130PS0",51,0)
 ;;AAQ-2^EBP
"RTN","YS130PS0",52,0)
 ;;ACE^
"RTN","YS130PS0",53,0)
 ;;AD8^Pain^Cognitive
"RTN","YS130PS0",54,0)
 ;;AIMS^Psychosis
"RTN","YS130PS0",55,0)
 ;;ASSIST-NIDA^Screening
"RTN","YS130PS0",56,0)
 ;;ASSIST-WHOV3^Screening
"RTN","YS130PS0",57,0)
 ;;ATQ^Depression^EBP
"RTN","YS130PS0",58,0)
 ;;AUDC^Screening^Addiction-SUD
"RTN","YS130PS0",59,0)
 ;;AUDIT^Addiction-SUD
"RTN","YS130PS0",60,0)
 ;;BAI^Anxiety/PTSD
"RTN","YS130PS0",61,0)
 ;;BAM-C^Addiction-SUD
"RTN","YS130PS0",62,0)
 ;;BAM-IOP^Addiction-SUD
"RTN","YS130PS0",63,0)
 ;;BAM-R^Addiction-SUD
"RTN","YS130PS0",64,0)
 ;;BARTHEL INDEX^ADL/Func Status
"RTN","YS130PS0",65,0)
 ;;BASIS-24^General Symptoms^Frequent MBCs
"RTN","YS130PS0",66,0)
 ;;BASIS-24 PSYCHOSIS^Psychosis
"RTN","YS130PS0",67,0)
 ;;BBHI-2^Pain / Health
"RTN","YS130PS0",68,0)
 ;;BDI2^Depression
"RTN","YS130PS0",69,0)
 ;;BHS^Suicide Prevention
"RTN","YS130PS0",70,0)
 ;;BOMC^Cognitive
"RTN","YS130PS0",71,0)
 ;;BPRS^Psychosis
"RTN","YS130PS0",72,0)
 ;;BPRS-A^Psychosis
"RTN","YS130PS0",73,0)
 ;;BRADEN SCALE^Screening
"RTN","YS130PS0",74,0)
 ;;BRS^Recovery
"RTN","YS130PS0",75,0)
 ;;BSI18^Suicide Prevention
"RTN","YS130PS0",76,0)
 ;;BSS^
"RTN","YS130PS0",77,0)
 ;;BUSS^General Symptoms
"RTN","YS130PS0",78,0)
 ;;C-SSRS^Suicide Prevention^Screening
"RTN","YS130PS0",79,0)
 ;;CAGE^Addiction-SUD^Screening
"RTN","YS130PS0",80,0)
 ;;CCSA-DSM5^General Symptoms
"RTN","YS130PS0",81,0)
 ;;CDR^Cognitive
"RTN","YS130PS0",82,0)
 ;;CEMI^EBP
"RTN","YS130PS0",83,0)
 ;;CES^Anxiety/PTSD
"RTN","YS130PS0",84,0)
 ;;CESD^Depression
"RTN","YS130PS0",85,0)
 ;;CIWA-AR-^Addiction-SUD
"RTN","YS130PS0",86,0)
 ;;CMQ^
"RTN","YS130PS0",87,0)
 ;;COPD^Pain / Health
"RTN","YS130PS0",88,0)
 ;;COWS^Addiction-SUD
"RTN","YS130PS0",89,0)
 ;;CSDD-RS^Depression
"RTN","YS130PS0",90,0)
 ;;CSI^Couples/Family Func
"RTN","YS130PS0",91,0)
 ;;CSI PARTNER VERSION^Couples/Family Func
"RTN","YS130PS0",92,0)
 ;;CSI-4^Couples/Family Func
"RTN","YS130PS0",93,0)
 ;;CSI-4 PARTNER VERSION^Couples/Family Func
"RTN","YS130PS0",94,0)
 ;;D.BAS^Sleep
"RTN","YS130PS0",95,0)
 ;;D.ERS^Anxiety/PTSD
"RTN","YS130PS0",96,0)
 ;;EAT-26^
"RTN","YS130PS0",97,0)
 ;;EPDS^Depression
"RTN","YS130PS0",98,0)
 ;;ERS^
"RTN","YS130PS0",99,0)
 ;;FAST^ADL/Func Status
"RTN","YS130PS0",100,0)
 ;;FFMQ^EBP
"RTN","YS130PS0",101,0)
 ;;FOCI^
"RTN","YS130PS0",102,0)
 ;;FTND^Pain / Health
"RTN","YS130PS0",103,0)
 ;;GAD-7^Anxiety/PTSD
"RTN","YS130PS0",104,0)
 ;;GAI^Anxiety/PTSD
"RTN","YS130PS0",105,0)
 ;;GDS^Depression
"RTN","YS130PS0",106,0)
 ;;GDS DEMENTIA^Cognitive
"RTN","YS130PS0",107,0)
 ;;GPCOG^Cognitive
"RTN","YS130PS0",108,0)
 ;;HSI^Pain / Health
"RTN","YS130PS0",109,0)
 ;;I9+C-SSRS^Suicide Prevention^Screening
"RTN","YS130PS0",110,0)
 ;;IADL^ADL/Func Status
"RTN","YS130PS0",111,0)
 ;;IJSS^Employment
"RTN","YS130PS0",112,0)
 ;;IMRS^Recovery
"RTN","YS130PS0",113,0)
 ;;ISI^Sleep
"RTN","YS130PS0",114,0)
 ;;ISMI^Recovery
"RTN","YS130PS0",115,0)
 ;;ISS-2^Frequent MBCs^Depression
"RTN","YS130PS0",116,0)
 ;;KATZ-ADL-18PT^
"RTN","YS130PS0",117,0)
 ;;KATZ-ADL-6PT^ADL/Func Status
"RTN","YS130PS0",118,0)
 ;;MBMD^Personality
"RTN","YS130PS0",119,0)
 ;;MCMI3^Personality
"RTN","YS130PS0",120,0)
 ;;MCMI4^Personality
"RTN","YS130PS0",121,0)
 ;;MHLA^Pain / Health
"RTN","YS130PS0",122,0)
 ;;MHLB^Pain / Health
"RTN","YS130PS0",123,0)
 ;;MHLC-C^Pain / Health
"RTN","YS130PS0",124,0)
 ;;MHRM^Recovery
"RTN","YS130PS0",125,0)
 ;;MHRM-10^
"RTN","YS130PS0",126,0)
 ;;MINICOG^Cognitive
"RTN","YS130PS0",127,0)
 ;;MISS^Anxiety/PTSD
"RTN","YS130PS0",128,0)
 ;;MMPI-2-RF^Personality
"RTN","YS130PS0",129,0)
 ;;MMPI2^Personality
"RTN","YS130PS0",130,0)
 ;;MOCA^Cognitive
"RTN","YS130PS0",131,0)
 ;;MOCA ALT 1^Cognitive
"RTN","YS130PS0",132,0)
 ;;MOCA ALT 2^Cognitive
"RTN","YS130PS0",133,0)
 ;;MORSE FALL SCALE^Screening
"RTN","YS130PS0",134,0)
 ;;MPI-PAIN-INTRF^Pain / Health
"RTN","YS130PS0",135,0)
 ;;NEO-PI-3^Personality
"RTN","YS130PS0",136,0)
 ;;PAI^Personality
"RTN","YS130PS0",137,0)
 ;;PC PTSD^Anxiety/PTSD
"RTN","YS130PS0",138,0)
 ;;PC-PTSD-5^Anxiety/PTSD^Screening
"RTN","YS130PS0",139,0)
 ;;PC-PTSD-5+I9^Anxiety/PTSD^Screening
"RTN","YS130PS0",140,0)
 ;;PCL-5^Anxiety/PTSD
"RTN","YS130PS0",141,0)
 ;;PCL-5 WEEKLY^Anxiety/PTSD^Frequent MBCs
"RTN","YS130PS0",142,0)
 ;;PHQ-15^Pain / Health
"RTN","YS130PS0",143,0)
 ;;PHQ-2^Depression^Screening
"RTN","YS130PS0",144,0)
 ;;PHQ-2+I9^Suicide Prevention^Screening
"RTN","YS130PS0",145,0)
 ;;PHQ9^Depression^Frequent MBCs
"RTN","YS130PS0",146,0)
 ;;POQ^Pain / Health
"RTN","YS130PS0",147,0)
 ;;PROMIS29^Frequent MBCs
"RTN","YS130PS0",148,0)
 ;;PSOCQ^Pain / Health
"RTN","YS130PS0",149,0)
 ;;PSS^Anxiety/PTSD
"RTN","YS130PS0",150,0)
 ;;PSS-3^Suicide Prevention^Screening
"RTN","YS130PS0",151,0)
 ;;PSS-3 2ND^Suicide Prevention^Screening
"RTN","YS130PS0",152,0)
 ;;Q-LES-Q-SF^Quality of Life
"RTN","YS130PS0",153,0)
 ;;QOLI^Quality of Life
"RTN","YS130PS0",154,0)
 ;;RLS^Sleep
"RTN","YS130PS0",155,0)
 ;;SBR^Suicide Prevention
"RTN","YS130PS0",156,0)
 ;;SCL9R^
"RTN","YS130PS0",157,0)
 ;;SF36^Pain / Health
"RTN","YS130PS0",158,0)
 ;;SLUMS^Cognitive
"RTN","YS130PS0",159,0)
 ;;SMEQ^Sleep
"RTN","YS130PS0",160,0)
 ;;SNQ^Sleep
"RTN","YS130PS0",161,0)
 ;;SSF^Suicide Prevention
"RTN","YS130PS0",162,0)
 ;;STAI^Anxiety/PTSD
"RTN","YS130PS0",163,0)
 ;;STMS^Cognitive
"RTN","YS130PS0",164,0)
 ;;STOP^Sleep
"RTN","YS130PS0",165,0)
 ;;SWEMWBS^Quality of Life
"RTN","YS130PS0",166,0)
 ;;VR-12^Pain / Health
"RTN","YS130PS0",167,0)
 ;;VRA^Recovery
"RTN","YS130PS0",168,0)
 ;;WAI-SR^Recovery^Frequent MBCs
"RTN","YS130PS0",169,0)
 ;;WEMWBS^Quality of Life
"RTN","YS130PS0",170,0)
 ;;WHODAS 2^ADL/Func Status
"RTN","YS130PS0",171,0)
 ;;WHODAS2.0-12^ADL/Func Status
"RTN","YS130PS0",172,0)
 ;;WHOQOL BREF^Quality of Life
"RTN","YS130PS0",173,0)
 ;;WHYMPI^Pain / Health
"RTN","YS130PS0",174,0)
 ;;ZBI SCREEN^Couples/Family Func
"RTN","YS130PS0",175,0)
 ;;ZBI SHORT^Couples/Family Func
"RTN","YS130PS0",176,0)
 ;;ZUNG^Depression
"RTN","YS130PS0",177,0)
 ;;zzzzz
"RTN","YS130PS0",178,0)
 ;
"RTN","YS130PST")
0^12^B6726554^n/a
"RTN","YS130PST",1,0)
YS130PST ;SLC/KCM - Patch 130 Post-Init ; 1/25/2017
"RTN","YS130PST",2,0)
 ;;5.01;MENTAL HEALTH;**130**;Dec 30, 1994;Build 62
"RTN","YS130PST",3,0)
 ;
"RTN","YS130PST",4,0)
 ; External Reference    ICR#
"RTN","YS130PST",5,0)
 ; ------------------   -----
"RTN","YS130PST",6,0)
 ; ^VA(200)             10060
"RTN","YS130PST",7,0)
 ; XPDUTL               10141
"RTN","YS130PST",8,0)
 ; XUSAP                 4677 
"RTN","YS130PST",9,0)
 ;
"RTN","YS130PST",10,0)
 Q
"RTN","YS130PST",11,0)
EDTDATE ; date used to update 601.71:18
"RTN","YS130PST",12,0)
 ;;3190315.1855
"RTN","YS130PST",13,0)
 Q
"RTN","YS130PST",14,0)
POST ; Post-init for YS*5.01*130
"RTN","YS130PST",15,0)
 D FIXANS("WHODAS2.0-12")
"RTN","YS130PST",16,0)
 D FIXANS("PSS-3 2ND")
"RTN","YS130PST",17,0)
 D SAVE96^YTWJSONF   ; set up all instruments as JSON files in 601.96
"RTN","YS130PST",18,0)
 D PROXY             ; set up application proxy for patient-entered
"RTN","YS130PST",19,0)
 D LPSTAFF           ; mark instruments that should be staff-entered
"RTN","YS130PST",20,0)
 D SETCATS^YS130PS0  ; set up instrument categories
"RTN","YS130PST",21,0)
 Q
"RTN","YS130PST",22,0)
PROXY ; Create proxy user
"RTN","YS130PST",23,0)
 I $$FIND1^DIC(200,"","BQX","YTQR,PATIENTENTRY PROXY")>0 D  QUIT
"RTN","YS130PST",24,0)
 . D MES^XPDUTL("YTQR Proxy Found")
"RTN","YS130PST",25,0)
 I $$CREATE^XUSAP("YTQR,PATIENTENTRY PROXY","","YTQREST PATIENT ENTRY") D
"RTN","YS130PST",26,0)
 . D MES^XPDUTL("YTQR Proxy Created")
"RTN","YS130PST",27,0)
 Q
"RTN","YS130PST",28,0)
LPSTAFF ; Loop through instruments to set staff entry only
"RTN","YS130PST",29,0)
 N I,X
"RTN","YS130PST",30,0)
 F I=1:1 S X=$P($P($T(STAFF+I),";;",2),U) Q:X="zzzzz"  D UPDSTAFF(X,"Y")
"RTN","YS130PST",31,0)
 Q
"RTN","YS130PST",32,0)
UPDSTAFF(NAME,VALUE) ; Update STAFF ENTRY ONLY field
"RTN","YS130PST",33,0)
 N IEN,REC
"RTN","YS130PST",34,0)
 S IEN=$O(^YTT(601.71,"B",NAME,0)) Q:'IEN
"RTN","YS130PST",35,0)
 S REC(94)=VALUE
"RTN","YS130PST",36,0)
 S REC(18)=$P($T(EDTDATE+1),";;",2)
"RTN","YS130PST",37,0)
 D FMUPD^YTXCHGU(601.71,.REC,IEN)
"RTN","YS130PST",38,0)
 Q
"RTN","YS130PST",39,0)
FIXANS(TESTNM) ; Fix the case of the answer tags for 
"RTN","YS130PST",40,0)
 N SWAP,RPT,TEST,I,X
"RTN","YS130PST",41,0)
 S SWAP("<*ANSWER_7771*>")="<*Answer_7771*>"
"RTN","YS130PST",42,0)
 S SWAP("<*ANSWER_7778*>")="<*Answer_7778*>"
"RTN","YS130PST",43,0)
 N RPT,TEST,I
"RTN","YS130PST",44,0)
 S TEST=$O(^YTT(601.71,"B",TESTNM,0)) Q:'TEST
"RTN","YS130PST",45,0)
 S RPT=$O(^YTT(601.93,"C",TEST,0)) Q:'RPT
"RTN","YS130PST",46,0)
 S I=0 F  S I=$O(^YTT(601.93,RPT,1,I)) Q:'I  D
"RTN","YS130PST",47,0)
 . S X=^YTT(601.93,RPT,1,I,0)
"RTN","YS130PST",48,0)
 . I X["<*ANSWER_" D
"RTN","YS130PST",49,0)
 . . S X=$$REPLACE^XLFSTR(X,.SWAP)
"RTN","YS130PST",50,0)
 . . S ^YTT(601.93,RPT,1,I,0)=X
"RTN","YS130PST",51,0)
 Q
"RTN","YS130PST",52,0)
STAFF ; Staff Entry Only Instruments
"RTN","YS130PST",53,0)
 ;;AIMS^
"RTN","YS130PST",54,0)
 ;;BBHI-2^
"RTN","YS130PST",55,0)
 ;;BOMC^
"RTN","YS130PST",56,0)
 ;;BPRS^
"RTN","YS130PST",57,0)
 ;;BPRS-A^
"RTN","YS130PST",58,0)
 ;;BRADEN SCALE^
"RTN","YS130PST",59,0)
 ;;CDR^
"RTN","YS130PST",60,0)
 ;;CIWA-AR-^
"RTN","YS130PST",61,0)
 ;;COPD^
"RTN","YS130PST",62,0)
 ;;COWS^
"RTN","YS130PST",63,0)
 ;;CSDD-RS^
"RTN","YS130PST",64,0)
 ;;CSI^
"RTN","YS130PST",65,0)
 ;;CSI PARTNER VERSION^
"RTN","YS130PST",66,0)
 ;;D.BAS^
"RTN","YS130PST",67,0)
 ;;FAST^
"RTN","YS130PST",68,0)
 ;;GDS DEMENTIA^
"RTN","YS130PST",69,0)
 ;;GPCOG^
"RTN","YS130PST",70,0)
 ;;IADL^
"RTN","YS130PST",71,0)
 ;;ISS-2^
"RTN","YS130PST",72,0)
 ;;I9+C-SSRS^
"RTN","YS130PST",73,0)
 ;;KATZ-ADL-18PT^
"RTN","YS130PST",74,0)
 ;;KATZ-ADL-6PT^
"RTN","YS130PST",75,0)
 ;;MINICOG^
"RTN","YS130PST",76,0)
 ;;MOCA^
"RTN","YS130PST",77,0)
 ;;MOCA ALT 1^
"RTN","YS130PST",78,0)
 ;;MOCA ALT 2^
"RTN","YS130PST",79,0)
 ;;MORSE FALL SCALE^
"RTN","YS130PST",80,0)
 ;;MPI-PAIN-INTRF^
"RTN","YS130PST",81,0)
 ;;PC-PTSD-5+I9^
"RTN","YS130PST",82,0)
 ;;PHQ-2+I9^
"RTN","YS130PST",83,0)
 ;;POQ^
"RTN","YS130PST",84,0)
 ;;PROMIS29^
"RTN","YS130PST",85,0)
 ;;PSS-3^
"RTN","YS130PST",86,0)
 ;;RAID^
"RTN","YS130PST",87,0)
 ;;SBR^
"RTN","YS130PST",88,0)
 ;;SLUMS^
"RTN","YS130PST",89,0)
 ;;SSF^
"RTN","YS130PST",90,0)
 ;;STMS^
"RTN","YS130PST",91,0)
 ;;WHYMPI^
"RTN","YS130PST",92,0)
 ;;zzzzz
"RTN","YS130PST",93,0)
 ;
"RTN","YTQAPI")
0^24^B17118160^B15475641
"RTN","YTQAPI",1,0)
YTQAPI ;ASF/ALB - MHQ REMOTE PROCEEDURES ; 4/3/07 10:36am
"RTN","YTQAPI",2,0)
 ;;5.01;MENTAL HEALTH;**85,130**;Dec 30, 1994;Build 62
"RTN","YTQAPI",3,0)
 ;
"RTN","YTQAPI",4,0)
 ; External Reference    ICR#
"RTN","YTQAPI",5,0)
 ; ------------------   -----
"RTN","YTQAPI",6,0)
 ; DID                   2052
"RTN","YTQAPI",7,0)
 ; DIQ                   2056
"RTN","YTQAPI",8,0)
 ;
"RTN","YTQAPI",9,0)
 Q
"RTN","YTQAPI",10,0)
TSLIST(YSDATA) ;list tests and surveys
"RTN","YTQAPI",11,0)
 ;Input: none
"RTN","YTQAPI",12,0)
 ;Output: TEST NAME = LAST EDIT DATE^OPERATIONAL^REQUIRES LISCENCE^LISCENCE CURRENT^IS LEGACY^IEN^R PRIVILEGE^IS NATIONAL^HAS BEEN OPERATIONAL
"RTN","YTQAPI",13,0)
 N YSTESTN,YSTEST,N,G,G1,G2,G3,G4,G5,G6,G7
"RTN","YTQAPI",14,0)
 K ^TMP($J,"YSTL")
"RTN","YTQAPI",15,0)
 S YSDATA=$NA(^TMP($J,"YSTL"))
"RTN","YTQAPI",16,0)
 S N=1,^TMP($J,"YSTL",N)="[DATA]"
"RTN","YTQAPI",17,0)
 S YSTEST="" F  S YSTEST=$O(^YTT(601.71,"B",YSTEST)) Q:YSTEST=""  D
"RTN","YTQAPI",18,0)
 . S YSTESTN=$O(^YTT(601.71,"B",YSTEST,0))
"RTN","YTQAPI",19,0)
 . S N=N+1
"RTN","YTQAPI",20,0)
 . S G=$$GET1^DIQ(601.71,YSTESTN_",",18,"I")
"RTN","YTQAPI",21,0)
 . S G1=$$GET1^DIQ(601.71,YSTESTN_",",10,"E")
"RTN","YTQAPI",22,0)
 . S G2=$$GET1^DIQ(601.71,YSTESTN_",",11,"E")
"RTN","YTQAPI",23,0)
 . S G3=$$GET1^DIQ(601.71,YSTESTN_",",20,"E")
"RTN","YTQAPI",24,0)
 . S G4=$$GET1^DIQ(601.71,YSTESTN_",",23,"E")
"RTN","YTQAPI",25,0)
 . S G5=$$GET1^DIQ(601.71,YSTESTN_",",9,"E")
"RTN","YTQAPI",26,0)
 . S G6=$$GET1^DIQ(601.71,YSTESTN_",",19,"E")
"RTN","YTQAPI",27,0)
 . S G7=$$GET1^DIQ(601.71,YSTESTN_",",10.5,"E")
"RTN","YTQAPI",28,0)
 . S ^TMP($J,"YSTL",N)=YSTEST_"="_G_U_G1_U_G2_U_G3_U_G4_U_YSTESTN_U_G5_U_G6_U_G7
"RTN","YTQAPI",29,0)
 Q
"RTN","YTQAPI",30,0)
TSLIST1(YSDATA,YS) ;list questions for a single test
"RTN","YTQAPI",31,0)
 ;input: CODE as test name
"RTN","YTQAPI",32,0)
 ;output: Field^Value
"RTN","YTQAPI",33,0)
 N YSTESTN,YSTEST,YSF,YSV,N,I,YSEI
"RTN","YTQAPI",34,0)
 S YSTEST=$G(YS("CODE"))
"RTN","YTQAPI",35,0)
 I YSTEST="" S YSDATA(1)="[ERROR]",YSDATA(2)="NO code" Q  ;-->out
"RTN","YTQAPI",36,0)
 S YSTESTN=$O(^YTT(601.71,"B",YSTEST,0))
"RTN","YTQAPI",37,0)
 I YSTESTN'>0 S YSDATA(1)="[ERROR]",YSDATA(2)="bad code" Q  ;-->out
"RTN","YTQAPI",38,0)
 S N=2,YSDATA(1)="[DATA]",YSDATA(2)="IEN="_YSTESTN
"RTN","YTQAPI",39,0)
 F I=.01,2,3,4,5,7,7.5,8,9,10,10.5,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,100.01,100.02,100.03,100.04 D
"RTN","YTQAPI",40,0)
 . S N=N+1
"RTN","YTQAPI",41,0)
 . S YSEI=$S(I=18:"I",1:"E")
"RTN","YTQAPI",42,0)
 . D FIELD^DID(601.71,I,"","LABEL","YSF")
"RTN","YTQAPI",43,0)
 . S YSV=$$GET1^DIQ(601.71,YSTESTN_",",I,YSEI)
"RTN","YTQAPI",44,0)
 . S YSDATA(N)=YSF("LABEL")_"="_YSV
"RTN","YTQAPI",45,0)
 Q
"RTN","YTQAPI",46,0)
CHOICES(YSDATA,YS) ;list choices for a question
"RTN","YTQAPI",47,0)
 ;input: CODE as test name
"RTN","YTQAPI",48,0)
 ;output: 601.75(1) CHOICETYPE ID^SEQUENCE^CHOICE IFN^CHOICE TEXT^LEGACY VALUE
"RTN","YTQAPI",49,0)
 N YSCDA,YSIC,YSQN,YSN,YSN1,YSTESTN,YSTEST,YSF,YSV,N,G,YSCTYP,YSCTYPID,G,G1,X
"RTN","YTQAPI",50,0)
 S YSTEST=$G(YS("CODE"))
"RTN","YTQAPI",51,0)
 S YSTESTN=$O(^YTT(601.71,"B",YSTEST,0))
"RTN","YTQAPI",52,0)
 I YSTESTN'>0 S YSDATA(1)="[ERROR]",YSDATA(2)="bad code" Q  ;-->out
"RTN","YTQAPI",53,0)
 S N=1,YSDATA(1)="[DATA]"
"RTN","YTQAPI",54,0)
 ;
"RTN","YTQAPI",55,0)
 S YSIC=0
"RTN","YTQAPI",56,0)
 F  S YSIC=$O(^YTT(601.76,"AC",YSTESTN,YSIC)) Q:YSIC'>0  S YSQN=$P(^YTT(601.76,YSIC,0),U,4) D
"RTN","YTQAPI",57,0)
 . S YSCTYP=$P($G(^YTT(601.72,YSQN,2)),U,3)
"RTN","YTQAPI",58,0)
 . S:YSCTYP'="" YSCTYPID(YSCTYP)=""
"RTN","YTQAPI",59,0)
C2 ;
"RTN","YTQAPI",60,0)
 S YSN=0
"RTN","YTQAPI",61,0)
 F  S YSN=$O(YSCTYPID(YSN)) Q:YSN'>0  D
"RTN","YTQAPI",62,0)
 . S YSN1=0 F  S YSN1=$O(^YTT(601.751,"AC",YSN,YSN1)) Q:YSN1'>0  D
"RTN","YTQAPI",63,0)
 .. S YSCDA=0 F  S YSCDA=$O(^YTT(601.751,"AC",YSN,YSN1,YSCDA)) Q:YSCDA'>0  D
"RTN","YTQAPI",64,0)
 ... S N=N+1
"RTN","YTQAPI",65,0)
 ... S YSDATA(N)=YSN_U_YSN1_U_YSCDA_U_$G(^YTT(601.75,YSCDA,1))_U_$P($G(^YTT(601.75,YSCDA,0)),U,2)
"RTN","YTQAPI",66,0)
 Q
"RTN","YTQAPI",67,0)
SKIPPED(YSDATA,YS) ; skipped questions for an instrument
"RTN","YTQAPI",68,0)
 ;input: CODE as test name
"RTN","YTQAPI",69,0)
 ;output: QUESTIONID^SKIPQUESTIONID
"RTN","YTQAPI",70,0)
 ; for single test in question,skipped order
"RTN","YTQAPI",71,0)
 N YSTESTN,YSTEST,N,N1,N2,YSQ,YSK,G
"RTN","YTQAPI",72,0)
 S YSTEST=$G(YS("CODE"))
"RTN","YTQAPI",73,0)
 S YSTESTN=$O(^YTT(601.71,"B",YSTEST,0))
"RTN","YTQAPI",74,0)
 I YSTESTN'>0 S YSDATA(1)="[ERROR]",YSDATA(2)="bad code" Q  ;-->out
"RTN","YTQAPI",75,0)
 I '$D(^YTT(601.79,"AC",YSTESTN)) S YSDATA(1)="[ERROR]",YSDATA(2)="no entries for this code" Q  ;--> out
"RTN","YTQAPI",76,0)
 S N=1,YSDATA(1)="[DATA]"
"RTN","YTQAPI",77,0)
 ;
"RTN","YTQAPI",78,0)
 S N1=0 F  S N1=$O(^YTT(601.79,"AC",YSTESTN,N1)) Q:N1'>0  D
"RTN","YTQAPI",79,0)
 . S G=^YTT(601.79,N1,0),YSQ=$P(G,U,3),YSK=$P(G,U,4)
"RTN","YTQAPI",80,0)
 . S:(YSQ?1N.N)&(YSK?1N.N) G(YSQ,YSK)=""
"RTN","YTQAPI",81,0)
 S N1=0 F  S N1=$O(G(N1)) Q:N1'>0  S N2=0 F  S N2=$O(G(N1,N2)) Q:N2'>0  S N=N+1,YSDATA(N)=N1_U_N2
"RTN","YTQAPI",82,0)
 Q
"RTN","YTQAPI",83,0)
SECTION(YSDATA,YS) ;section captions
"RTN","YTQAPI",84,0)
 ;input: CODE as test name
"RTN","YTQAPI",85,0)
 ;output: FIRSTQUESTIONID^TABCAPTION^SECTIONCAPTION^DISPLAYID
"RTN","YTQAPI",86,0)
 ; for single test in questionID order
"RTN","YTQAPI",87,0)
 N YSTESTN,YSTEST,N,N1,G,YSQ
"RTN","YTQAPI",88,0)
 S YSTEST=$G(YS("CODE"))
"RTN","YTQAPI",89,0)
 S YSTESTN=$O(^YTT(601.71,"B",YSTEST,0))
"RTN","YTQAPI",90,0)
 I YSTESTN'>0 S YSDATA(1)="[ERROR]",YSDATA(2)="bad code" Q  ;-->out
"RTN","YTQAPI",91,0)
 I '$D(^YTT(601.81,"AC",YSTESTN)) S YSDATA(1)="[DATA]" Q  ;-->out no entries for this code
"RTN","YTQAPI",92,0)
 S N=1,YSDATA(1)="[DATA]"
"RTN","YTQAPI",93,0)
 ;
"RTN","YTQAPI",94,0)
 S N1=0 F  S N1=$O(^YTT(601.81,"AC",YSTESTN,N1)) Q:N1'>0  D
"RTN","YTQAPI",95,0)
 . S G=^YTT(601.81,N1,0),YSQ=$P(G,U,3)
"RTN","YTQAPI",96,0)
 . S:(YSQ?1N.N) G(YSQ)=$P(G,U,3,6)
"RTN","YTQAPI",97,0)
 S N1=0 F  S N1=$O(G(N1)) Q:N1'>0  D
"RTN","YTQAPI",98,0)
  . S N=N+1,YSDATA(N)=G(N1)
"RTN","YTQAPI",99,0)
 . S N=N+1,YSDATA(N)="DISPLAY=" S:$P(G(N1),U,4)?1N.N YSDATA(N)=YSDATA(N)_$$DISPEXT^YTQAPI5($P(G(N1),U,4))
"RTN","YTQAPI",100,0)
 Q
"RTN","YTQAPI",101,0)
 ;
"RTN","YTQAPI2")
0^25^B34492962^B31600888
"RTN","YTQAPI2",1,0)
YTQAPI2 ;ASF/ALB - MHAX REMOTE PROCEDURES cont ;10/17/16  13:37
"RTN","YTQAPI2",2,0)
 ;;5.01;MENTAL HEALTH;**85,96,119,121,123,130**;Dec 30, 1994;Build 62
"RTN","YTQAPI2",3,0)
 ;
"RTN","YTQAPI2",4,0)
 ; External Reference    ICR#
"RTN","YTQAPI2",5,0)
 ; ------------------   -----
"RTN","YTQAPI2",6,0)
 ; ^DPT                 10035
"RTN","YTQAPI2",7,0)
 ; DIC                   2051
"RTN","YTQAPI2",8,0)
 ; DILFD                 2055
"RTN","YTQAPI2",9,0)
 ; DIQ                   2056
"RTN","YTQAPI2",10,0)
 ;
"RTN","YTQAPI2",11,0)
 Q
"RTN","YTQAPI2",12,0)
LISTER(YSDATA,YS) ;list entries
"RTN","YTQAPI2",13,0)
 ;entry point for YTQ GENERIC LISTER rpc
"RTN","YTQAPI2",14,0)
 ;input: CODE as test name
"RTN","YTQAPI2",15,0)
 ;output: Field^Value
"RTN","YTQAPI2",16,0)
 N YSFIELD,YSFILEN,N,C,YSNUMBER,YSFLAG,YSFROM,YSINDEX,YTTLKUP
"RTN","YTQAPI2",17,0)
 S YTTLKUP=1  ; suppress filter on 601.71
"RTN","YTQAPI2",18,0)
 S YSFILEN=$G(YS("FILEN"),0) S X=$$VFILE^DILFD(YSFILEN) I X=0 S YSDATA(1)="[ERROR]",YSDATA(2)="BAD FILE N" Q  ;--->out
"RTN","YTQAPI2",19,0)
 S YSFIELD=$G(YS("FIELD"),0) S X=$$VFIELD^DILFD(YSFILEN,YSFIELD) I X=0 S YSDATA(1)="[ERROR]",YSDATA(2)="BAD FIELD N" Q  ;--->out
"RTN","YTQAPI2",20,0)
 S YSFLAG=$G(YS("FLAG"))
"RTN","YTQAPI2",21,0)
 S YSNUMBER=$G(YS("NUMBER"),500)
"RTN","YTQAPI2",22,0)
 S YSFROM("IEN")=$G(YS("FROM"))
"RTN","YTQAPI2",23,0)
 S YSINDEX=$G(YS("INDEX"))
"RTN","YTQAPI2",24,0)
 D LIST^DIC(YSFILEN,,YSFIELD,YSFLAG,YSNUMBER,.YSFROM,,YSINDEX)
"RTN","YTQAPI2",25,0)
 I $D(^TMP("DIERR",$J)) S YSDATA(1)="[ERROR]",YSDATA(2)=$G(^TMP("DIERR",$J,1,"TEXT",1)) Q  ;--> out
"RTN","YTQAPI2",26,0)
 S YSDATA(1)="[DATA]"
"RTN","YTQAPI2",27,0)
 S YSDATA(2)=^TMP("DILIST",$J,0)
"RTN","YTQAPI2",28,0)
 S C=2,N=0
"RTN","YTQAPI2",29,0)
 F  S N=$O(^TMP("DILIST",$J,2,N)) Q:N'>0  D
"RTN","YTQAPI2",30,0)
 . S C=C+1
"RTN","YTQAPI2",31,0)
 . S YSDATA(C)=^TMP("DILIST",$J,2,N)_U_$G(^TMP("DILIST",$J,"ID",N,YSFIELD))
"RTN","YTQAPI2",32,0)
 K ^TMP("DILIST",$J)
"RTN","YTQAPI2",33,0)
 Q
"RTN","YTQAPI2",34,0)
ALLANS(YSDATA,YS) ;get all answers
"RTN","YTQAPI2",35,0)
 ;entry point for YTQ ALL ANSWERS rpc
"RTN","YTQAPI2",36,0)
 ;input:AD = ADMINISTRATION #
"RTN","YTQAPI2",37,0)
 ;output: [DATA]
"RTN","YTQAPI2",38,0)
 ; ADMIN ID^DFN^INSTRUMENT^DATE GIVEN^IS COMPLETE
"RTN","YTQAPI2",39,0)
 ;QUESTION #^seq^ANSWER
"RTN","YTQAPI2",40,0)
 N G,G1,N,YSAD,YSQN,YSTSTN,YSEQ,YSICON
"RTN","YTQAPI2",41,0)
 N IEN71,YSRTN,YSRTN71 ; llh patch 123
"RTN","YTQAPI2",42,0)
 S YSAD=$G(YS("AD"))
"RTN","YTQAPI2",43,0)
 I YSAD'?1N.N S YSDATA(1)="[ERROR]",YSDATA(2)="bad ad num" Q  ;-->out
"RTN","YTQAPI2",44,0)
 I '$D(^YTT(601.85,"AC",YSAD)) S YSDATA(1)="[ERROR]",YSDATA(2)="no such reference" Q  ;-->out
"RTN","YTQAPI2",45,0)
 S YSTSTN=$P(^YTT(601.84,YSAD,0),U,3)
"RTN","YTQAPI2",46,0)
 S YSDATA(1)="[DATA]"
"RTN","YTQAPI2",47,0)
 S YSDATA(2)=YSAD_U_$$GET1^DIQ(601.84,YSAD_",",1,"I")_U_$$GET1^DIQ(601.84,YSAD_",",2,"E")_U_$$GET1^DIQ(601.84,YSAD_",",3,"I")_U_$$GET1^DIQ(601.84,YSAD_",",8,"I")
"RTN","YTQAPI2",48,0)
 S YSQN=0,N=2
"RTN","YTQAPI2",49,0)
 F  S YSQN=$O(^YTT(601.85,"AC",YSAD,YSQN)) Q:YSQN'>0  S G=0 D
"RTN","YTQAPI2",50,0)
 .S G=$O(^YTT(601.85,"AC",YSAD,YSQN,G)) Q:G'>0  S G1=0 D
"RTN","YTQAPI2",51,0)
 ..S YSICON=$O(^YTT(601.76,"AF",YSTSTN,YSQN,0))
"RTN","YTQAPI2",52,0)
 ..S YSEQ=1
"RTN","YTQAPI2",53,0)
 ..I YSICON?1N.N S YSEQ=$P(^YTT(601.76,YSICON,0),U,3)
"RTN","YTQAPI2",54,0)
 ..S:$P(^YTT(601.85,G,0),U,4)?1N.N N=N+1,YSDATA(N)=YSQN_U_YSEQ_U_$P(^YTT(601.85,G,0),U,4)
"RTN","YTQAPI2",55,0)
 ..F  S G1=$O(^YTT(601.85,G,1,G1)) Q:G1'>0  S N=N+1,YSDATA(N)=YSQN_U_YSEQ_";"_G1_U_$G(^YTT(601.85,G,1,G1,0))
"RTN","YTQAPI2",56,0)
 I $P(^YTT(601.84,YSAD,0),U,9)'="Y" QUIT  ; chk special proc only if complete
"RTN","YTQAPI2",57,0)
 ;llh patch 123, check for special processing of complex instruments
"RTN","YTQAPI2",58,0)
 S IEN71=$O(^YTT(601.71,"B",$P(YSDATA(2),U,3),0))
"RTN","YTQAPI2",59,0)
 S YSRTN71=$$GET1^DIQ(601.71,IEN71_",",92)
"RTN","YTQAPI2",60,0)
 I (YSRTN71'=""),(YSRTN71'="YTSCORE") D
"RTN","YTQAPI2",61,0)
 .N RPRIV S RPRIV=$P($G(^YTT(601.71,IEN71,2)),U) ; wrap for note
"RTN","YTQAPI2",62,0)
 .S YSRTN="DLLSTR^"_YSRTN71_"(.YSDATA,.YS,2)"
"RTN","YTQAPI2",63,0)
 .I $L($T(@("DLLSTR^"_YSRTN71))) D @YSRTN D:'$L(RPRIV) WRAP(80)
"RTN","YTQAPI2",64,0)
 D SPECIAL^YTQAPI2A(.YSDATA,N,YSAD,YSTSTN)
"RTN","YTQAPI2",65,0)
 Q
"RTN","YTQAPI2",66,0)
SETANS(YSDATA,YS) ;save an answer
"RTN","YTQAPI2",67,0)
 ;entry point for YTQ SET ANSWER rpc
"RTN","YTQAPI2",68,0)
 ;input: AD = ADMINISTRATION #
"RTN","YTQAPI2",69,0)
 ;input: QN= QUESTION #
"RTN","YTQAPI2",70,0)
 ;input: CHOICE= Choice ID [optional]
"RTN","YTQAPI2",71,0)
 ;input: YS(1) thru YS(N) WP entries
"RTN","YTQAPI2",72,0)
 ;output: [DATA] vs [ERROR]
"RTN","YTQAPI2",73,0)
 N N,N1,YSIENS,YSAD,YSQN,YSCI,YSCODE,YSOP
"RTN","YTQAPI2",74,0)
 S YSDATA(1)="[ERROR]"
"RTN","YTQAPI2",75,0)
 S YSAD=$G(YS("AD"))
"RTN","YTQAPI2",76,0)
 S YSQN=$G(YS("QN"))
"RTN","YTQAPI2",77,0)
 S YSCI=$G(YS("CHOICE"))
"RTN","YTQAPI2",78,0)
 I YSAD'?1N.N S YSDATA(2)="bad ad num" Q  ;-->out
"RTN","YTQAPI2",79,0)
 I YSQN'?1N.N S YSDATA(2)="bad quest num" Q  ;-->out
"RTN","YTQAPI2",80,0)
 I $D(^YTT(601.85,"AC",YSAD,YSQN)) S YSIENS=$O(^YTT(601.85,"AC",YSAD,YSQN,0))
"RTN","YTQAPI2",81,0)
 I '$D(^YTT(601.85,"AC",YSAD,YSQN)) D  ; set new entry
"RTN","YTQAPI2",82,0)
 . S YSIENS=""
"RTN","YTQAPI2",83,0)
 . S YSIENS=$$NEW^YTQLIB(601.85)
"RTN","YTQAPI2",84,0)
 . Q:YSIENS'?1N.N
"RTN","YTQAPI2",85,0)
 . L +^YTT(601.85,YSIENS):DILOCKTM
"RTN","YTQAPI2",86,0)
 . I '$T S YSDATA(2)="time out" Q
"RTN","YTQAPI2",87,0)
 . S ^YTT(601.85,YSIENS,0)=YSIENS_U_YSAD_U_YSQN
"RTN","YTQAPI2",88,0)
 . L -^YTT(601.85,YSIENS)
"RTN","YTQAPI2",89,0)
 . S ^YTT(601.85,0)="MH ANSWERS^601.85^"_YSIENS_U_($P(^YTT(601.85,0),U,4)+1)
"RTN","YTQAPI2",90,0)
 . S ^YTT(601.85,"B",YSIENS,YSIENS)=""
"RTN","YTQAPI2",91,0)
 . S ^YTT(601.85,"AC",YSAD,YSQN,YSIENS)=""
"RTN","YTQAPI2",92,0)
 . S ^YTT(601.85,"AD",YSAD,YSIENS)=""
"RTN","YTQAPI2",93,0)
 Q:$D(YSDATA(2))
"RTN","YTQAPI2",94,0)
 ;enter or delete Answers
"RTN","YTQAPI2",95,0)
 S $P(^YTT(601.85,YSIENS,0),U,4)=YSCI
"RTN","YTQAPI2",96,0)
 K ^YTT(601.85,YSIENS,1)
"RTN","YTQAPI2",97,0)
 S N=0,N1=0
"RTN","YTQAPI2",98,0)
 F  S N=$O(YS(N)) Q:N'>0  S N1=N1+1,^YTT(601.85,YSIENS,1,N1,0)=YS(N)
"RTN","YTQAPI2",99,0)
 S:N1 ^YTT(601.85,YSIENS,1,0)=U_U_N1_U_N1_U_DT_U
"RTN","YTQAPI2",100,0)
 S YSDATA(1)="[DATA]",YSDATA(2)="OK"
"RTN","YTQAPI2",101,0)
 ;set has been operational
"RTN","YTQAPI2",102,0)
 S YSCODE=$P(^YTT(601.84,YSAD,0),U,3)
"RTN","YTQAPI2",103,0)
 S YSOP=$P($G(^YTT(601.71,YSCODE,2)),U,2)
"RTN","YTQAPI2",104,0)
 S:YSOP="Y" $P(^YTT(601.71,YSCODE,2),U,5)="Y"
"RTN","YTQAPI2",105,0)
 Q
"RTN","YTQAPI2",106,0)
ADMINS(YSDATA,YS) ;administration retrieval
"RTN","YTQAPI2",107,0)
 ;entry point for YTQ GET ADMINISTRATIONS rpc
"RTN","YTQAPI2",108,0)
 ;input : DFN
"RTN","YTQAPI2",109,0)
 ;output:AdministrationID=InstrumentName^DateGiven^DateSaved^OrderedBy^AdministeredBy^Signed^IsComplete^NumberOfQuestionsAnswered
"RTN","YTQAPI2",110,0)
 N N,G,DFN,YSIENS
"RTN","YTQAPI2",111,0)
 S DFN=$G(YS("DFN"))
"RTN","YTQAPI2",112,0)
 I DFN'?1N.NP S YSDATA(1)="[ERROR]",YSDATA(2)="bad DFN" Q  ;-->out asf 2/22/08
"RTN","YTQAPI2",113,0)
 I '$D(^DPT(DFN,0)) S YSDATA(1)="[ERROR]",YSDATA(2)="no pt" Q  ;-->out
"RTN","YTQAPI2",114,0)
 S YSIENS=0,N=2
"RTN","YTQAPI2",115,0)
 S YSDATA(1)="[DATA]"
"RTN","YTQAPI2",116,0)
 F  S YSIENS=$O(^YTT(601.84,"C",DFN,YSIENS)) Q:YSIENS'>0  D
"RTN","YTQAPI2",117,0)
 . S N=N+1
"RTN","YTQAPI2",118,0)
 . S G=$G(^YTT(601.84,YSIENS,0))
"RTN","YTQAPI2",119,0)
 . I G="" S YSDATA(1)="[ERROR]",YSDATA(2)=YSIENS_" bad ien in 84" Q  ;-->out
"RTN","YTQAPI2",120,0)
 . S YSDATA(N)=YSIENS_"="_$$GET1^DIQ(601.84,YSIENS_",",2)_U_$P(G,U,4)_U_$P(G,U,5)
"RTN","YTQAPI2",121,0)
 . S YSDATA(N)=YSDATA(N)_U_$$GET1^DIQ(601.84,YSIENS_",",5,"I")_U_$$GET1^DIQ(601.84,YSIENS_",",6,"I")
"RTN","YTQAPI2",122,0)
 . S YSDATA(N)=YSDATA(N)_U_$$GET1^DIQ(601.84,YSIENS_",",7)_U_$$GET1^DIQ(601.84,YSIENS_",",8)_U_$$GET1^DIQ(601.84,YSIENS_",",9)
"RTN","YTQAPI2",123,0)
 S:YSDATA(1)="[DATA]" YSDATA(2)=(N-2)_" administrations"
"RTN","YTQAPI2",124,0)
 Q
"RTN","YTQAPI2",125,0)
CCALL(YSDATA) ;all choices returned
"RTN","YTQAPI2",126,0)
 ;entry point for YTQ ALL CHOICES rpc
"RTN","YTQAPI2",127,0)
 ;output: 601.75(1) CHOICETYPE ID^SEQUENCE^CHOICE IFN^CHOICE TEXT
"RTN","YTQAPI2",128,0)
 N N,YSCDA,YSN,YSN1
"RTN","YTQAPI2",129,0)
 S YSN=0,N=1
"RTN","YTQAPI2",130,0)
 S YSDATA(1)="[DATA]"
"RTN","YTQAPI2",131,0)
 F  S YSN=$O(^YTT(601.751,YSN)) Q:YSN'>0  D
"RTN","YTQAPI2",132,0)
 . S YSN1=0 F  S YSN1=$O(^YTT(601.751,"AC",YSN,YSN1)) Q:YSN1'>0  D
"RTN","YTQAPI2",133,0)
 .. S YSCDA=0 F  S YSCDA=$O(^YTT(601.751,"AC",YSN,YSN1,YSCDA)) Q:YSCDA'>0  D
"RTN","YTQAPI2",134,0)
 ... S N=N+1
"RTN","YTQAPI2",135,0)
 ... S YSDATA(N)=YSN_U_YSN1_U_YSCDA_U_$G(^YTT(601.75,YSCDA,1))
"RTN","YTQAPI2",136,0)
 Q
"RTN","YTQAPI2",137,0)
WRAP(MAX) ; Make sure DLLStr is wrapped by adding | chars
"RTN","YTQAPI2",138,0)
 ; expects YSDATA
"RTN","YTQAPI2",139,0)
 N LN,TX,OUT,I,J,X,Y,YNEW
"RTN","YTQAPI2",140,0)
 S LN=$O(YSDATA(9999999999),-1)
"RTN","YTQAPI2",141,0)
 S TX=$P(YSDATA(LN),U,3,99)
"RTN","YTQAPI2",142,0)
 F I=1:1:$L(TX,"|") S X=$P(TX,"|",I) D
"RTN","YTQAPI2",143,0)
 . I $L(X)'>MAX D ADDOUT(X) QUIT
"RTN","YTQAPI2",144,0)
 . S Y=""
"RTN","YTQAPI2",145,0)
 . F J=1:1:$L(X," ") D
"RTN","YTQAPI2",146,0)
 . . S YNEW=Y_$S(J=1:"",1:" ")_$P(X," ",J)
"RTN","YTQAPI2",147,0)
 . . I $L(YNEW)>MAX D ADDOUT(Y) S Y=$P(X," ",J) I 1
"RTN","YTQAPI2",148,0)
 . . E  S Y=YNEW
"RTN","YTQAPI2",149,0)
 . D ADDOUT(Y) ; add any remaining
"RTN","YTQAPI2",150,0)
 S X="",I=0 F  S I=$O(OUT(I)) Q:'I  S X=X_$S(I=1:"",1:"|")_OUT(I)
"RTN","YTQAPI2",151,0)
 S $P(YSDATA(LN),U,3)=X
"RTN","YTQAPI2",152,0)
 Q
"RTN","YTQAPI2",153,0)
ADDOUT(S) ; add string to out array (expects OUT)
"RTN","YTQAPI2",154,0)
 S OUT=+$G(OUT)+1,OUT(OUT)=S
"RTN","YTQAPI2",155,0)
 Q
"RTN","YTQREST0")
0^23^B7041728^n/a
"RTN","YTQREST0",1,0)
YTQREST0 ;SLC/KCM - RESTful API front controller v0 ; 1/25/2017
"RTN","YTQREST0",2,0)
 ;;5.01;MENTAL HEALTH;**130**;Dec 30, 1994;Build 62
"RTN","YTQREST0",3,0)
 ;
"RTN","YTQREST0",4,0)
 ; .HTTPREQ: HTTP-formatted request and JSON body (if present)
"RTN","YTQREST0",5,0)
 ; .HTTPRSP: HTTP-formatted response and JSON body (if present)
"RTN","YTQREST0",6,0)
 ;
"RTN","YTQREST0",7,0)
QSTAFF(HTTPRSP,HTTPREQ) ; questionnaire administration resources
"RTN","YTQREST0",8,0)
 ;;POST /api/mha/assignment NEWASMT^YTQRQAD1
"RTN","YTQREST0",9,0)
 ;;
"RTN","YTQREST0",10,0)
 D HANDLE^YTQRUTL("QSTAFF^YTQREST0",.HTTPREQ,.HTTPRSP)
"RTN","YTQREST0",11,0)
 Q
"RTN","YTQREST0",12,0)
 ;
"RTN","YTQREST0",13,0)
 ; -- for use when using embedded browser
"RTN","YTQREST0",14,0)
 ;
"RTN","YTQREST0",15,0)
 ;;GET /api/mha/patient/:dfn/identifiers PID^YTQRQAD
"RTN","YTQREST0",16,0)
 ;;GET /api/mha/persons/:match PERSONS^YTQRQAD
"RTN","YTQREST0",17,0)
 ;;GET /api/mha/users/:match USERS^YTQRQAD
"RTN","YTQREST0",18,0)
 ;;GET /api/mha/instruments/active LSTALL^YTQRQAD
"RTN","YTQREST0",19,0)
 ;;GET /api/mha/instruments/cprs LSTCPRS^YTQRQAD
"RTN","YTQREST0",20,0)
 ;;GET /api/mha/instrument/:instrumentName GETSPEC^YTQRQAD
"RTN","YTQREST0",21,0)
 ;;GET /api/mha/assignment/:assignmentId?1.N ASMTBYID^YTQRQAD1
"RTN","YTQREST0",22,0)
 ;;GET /api/mha/assignment/:assignmentId?1.N/:division ASMTBYID^YTQRQAD1
"RTN","YTQREST0",23,0)
 ;;DELETE /api/mha/assignment/:assignmentId DELASMT^YTQRQAD1
"RTN","YTQREST0",24,0)
 ;;DELETE /api/mha/assignment/:assignmentId/:instrument DELTEST^YTQRQAD1
"RTN","YTQREST0",25,0)
 ;;POST /api/mha/instrument/admin SAVEADM^YTQRQAD2
"RTN","YTQREST0",26,0)
 ;;GET /api/mha/instrument/admin/:adminId?1.N GETADM^YTQRQAD2
"RTN","YTQREST0",27,0)
 ;;GET /api/mha/instrument/report/:adminId?1.N REPORT^YTQRQAD3
"RTN","YTQREST0",28,0)
 ;;GET /api/mha/instrument/note/:adminId?1.N GETNOTE^YTQRQAD3
"RTN","YTQREST0",29,0)
 ;;POST /api/mha/instrument/note SETNOTE^YTQRQAD3
"RTN","YTQREST0",30,0)
 ;;GET /api/mha/permission/cosign/:adminId/:userId ALWCSGN^YTQRQAD3
"RTN","YTQREST0",31,0)
 ;;GET /api/mha/division/current/ TMPDIV^YTQRQAD
"RTN","YTQREST0",32,0)
 ;;POST /api/wrapper/close WRCLOSE^YTQRQAD
"RTN","YTQREST0",33,0)
 ;;
"RTN","YTQREST0",34,0)
QENTRY(HTTPRSP,HTTPREQ) ; questionnaire entry for patient
"RTN","YTQREST0",35,0)
 ;;GET /api/mha/patient/:dfn/identifiers PID^YTQRQAD
"RTN","YTQREST0",36,0)
 ;;GET /api/mha/instrument/:instrumentName GETSPEC^YTQRQAD
"RTN","YTQREST0",37,0)
 ;;GET /api/mha/assignment/:assignmentId?1.N ASMTBYID^YTQRQAD1
"RTN","YTQREST0",38,0)
 ;;GET /api/mha/checks/:instrumentName GETCHKS^YTQRQAD2
"RTN","YTQREST0",39,0)
 ;;GET /api/mha/instrument/admin/:adminId?1.N GETADM^YTQRQAD2
"RTN","YTQREST0",40,0)
 ;;POST /api/mha/instrument/admin SAVEADM^YTQRQAD2
"RTN","YTQREST0",41,0)
 ;;
"RTN","YTQREST0",42,0)
 D HANDLE^YTQRUTL("QENTRY^YTQREST0",.HTTPREQ,.HTTPRSP)
"RTN","YTQREST0",43,0)
 Q
"RTN","YTQRIS")
0^14^B89215067^n/a
"RTN","YTQRIS",1,0)
YTQRIS ;SLC/KCM - Instrument Selection RPC's ; 1/25/2017
"RTN","YTQRIS",2,0)
 ;;5.01;MENTAL HEALTH;**130**;Dec 30, 1994;Build 62
"RTN","YTQRIS",3,0)
 ;
"RTN","YTQRIS",4,0)
 ; External Reference    ICR#
"RTN","YTQRIS",5,0)
 ; ------------------   -----
"RTN","YTQRIS",6,0)
 ; ^VA(200)              1234
"RTN","YTQRIS",7,0)
 ; ^XUSEC               10076
"RTN","YTQRIS",8,0)
 ; DIK                  10013
"RTN","YTQRIS",9,0)
 ; DIQ                   2056
"RTN","YTQRIS",10,0)
 ; VADPT                10061
"RTN","YTQRIS",11,0)
 ; XLFDT                10103
"RTN","YTQRIS",12,0)
 ; XPDKEY                1367
"RTN","YTQRIS",13,0)
 ; XPDMENU               1157
"RTN","YTQRIS",14,0)
 ; XQCHK                10078
"RTN","YTQRIS",15,0)
 ; XUAF4                 2171
"RTN","YTQRIS",16,0)
 ; XUSER                 2343
"RTN","YTQRIS",17,0)
 ;
"RTN","YTQRIS",18,0)
NXT() ; return next RSP index
"RTN","YTQRIS",19,0)
 S YSIDX=$G(YSIDX)+1
"RTN","YTQRIS",20,0)
 Q YSIDX
"RTN","YTQRIS",21,0)
 ;
"RTN","YTQRIS",22,0)
AVAIL(RSP,DFN,ORDBY) ; return list available instruments/assignments/etc.
"RTN","YTQRIS",23,0)
 ; return type^displayText^identifier^instrumentList...
"RTN","YTQRIS",24,0)
 ;         1        2           3         4..n
"RTN","YTQRIS",25,0)
 N YSIDX
"RTN","YTQRIS",26,0)
 D INCPLT(DFN,ORDBY)  ; add incomplete instruments
"RTN","YTQRIS",27,0)
 D ASSIGN(DFN,ORDBY)  ; get active assignments
"RTN","YTQRIS",28,0)
 D BATTERY            ; add batteries
"RTN","YTQRIS",29,0)
 D REGULAR            ; add regular instruments
"RTN","YTQRIS",30,0)
 Q
"RTN","YTQRIS",31,0)
ACTIVE(RSP,DFN,ORDBY) ; return list of active assignments
"RTN","YTQRIS",32,0)
 ; return displayText^pin^name|adminId^name|adminId^...
"RTN","YTQRIS",33,0)
 ;              1      2        3            4       n...
"RTN","YTQRIS",34,0)
 N PTADMIN
"RTN","YTQRIS",35,0)
 D ASSIGN2(DFN,ORDBY) ; this has to be first to build PTADMIN
"RTN","YTQRIS",36,0)
 D INCPLT2(DFN,ORDBY)
"RTN","YTQRIS",37,0)
 Q
"RTN","YTQRIS",38,0)
INCPLT(DFN,ORDBY) ; add list of incomplete instruments for DFN and ORDBY
"RTN","YTQRIS",39,0)
 ; expects RSP,YSIDX
"RTN","YTQRIS",40,0)
 Q:'ORDBY  Q:'DFN
"RTN","YTQRIS",41,0)
 N I,X,YS,YSDATA,YSNOW,YSDOW,OFFSET,YSDTSAV,YSRSTRT
"RTN","YTQRIS",42,0)
 S YSNOW=$$NOW^XLFDT
"RTN","YTQRIS",43,0)
 S YSDOW=$$DOW^XLFDT(YSNOW)
"RTN","YTQRIS",44,0)
 S OFFSET=$S(YSDOW=5:2,YSDOW=6:1,1:0)
"RTN","YTQRIS",45,0)
 S YS("DFN")=DFN,YS("COMPLETE")="N"
"RTN","YTQRIS",46,0)
 D ADMINS^YTQAPI5(.YSDATA,.YS)
"RTN","YTQRIS",47,0)
 S I=2 F  S I=$O(YSDATA(I)) Q:'I  D
"RTN","YTQRIS",48,0)
 . I $P(YSDATA(I),U,5)'=ORDBY QUIT                    ; not same orderedBy
"RTN","YTQRIS",49,0)
 . S YSDTSAV=$P(YSDATA(I),U,4) I 'YSDTSAV QUIT        ; no date, bad entry
"RTN","YTQRIS",50,0)
 . S YSRSTRT=$P(YSDATA(I),U,15) S:'YSRSTRT YSRSTRT=2  ; account for weekends
"RTN","YTQRIS",51,0)
 . ; always restartable is -1, comparing full 24 hour periods so use seconds
"RTN","YTQRIS",52,0)
 . I (YSRSTRT'=-1),$$FMDIFF^XLFDT(YSNOW,YSDTSAV,2)>((YSRSTRT+OFFSET)*86400) Q
"RTN","YTQRIS",53,0)
 . S X="I"                                            ; incomplete
"RTN","YTQRIS",54,0)
 . S $P(X,U,2)=$P(YSDATA(I),U,2)_" ("_$$FMTE^XLFDT(YSDTSAV,"2Z")_")"
"RTN","YTQRIS",55,0)
 . S $P(X,U,3)=$P(YSDATA(I),U)                        ; adminId
"RTN","YTQRIS",56,0)
 . S $P(X,U,4)=$P(YSDATA(I),U,2)                      ; instrumentName
"RTN","YTQRIS",57,0)
 . S RSP($$NXT)=X
"RTN","YTQRIS",58,0)
 Q
"RTN","YTQRIS",59,0)
INCPLT2(DFN,ORDBY) ; add list of incomplete instruments for DFN and ORDBY
"RTN","YTQRIS",60,0)
 ; expects RSP,YSIDX,PTADMIN
"RTN","YTQRIS",61,0)
 Q:'ORDBY  Q:'DFN
"RTN","YTQRIS",62,0)
 N I,X,YS,YSDATA,YSNOW,YSDOW,OFFSET,YSDTSAV,YSRSTRT
"RTN","YTQRIS",63,0)
 S YSNOW=$$NOW^XLFDT
"RTN","YTQRIS",64,0)
 S YSDOW=$$DOW^XLFDT(YSNOW)
"RTN","YTQRIS",65,0)
 S OFFSET=$S(YSDOW=5:2,YSDOW=6:1,1:0)
"RTN","YTQRIS",66,0)
 S YS("DFN")=DFN,YS("COMPLETE")="N"
"RTN","YTQRIS",67,0)
 D ADMINS^YTQAPI5(.YSDATA,.YS)
"RTN","YTQRIS",68,0)
 S I=2 F  S I=$O(YSDATA(I)) Q:'I  D
"RTN","YTQRIS",69,0)
 . I $D(PTADMIN(+YSDATA(I))) QUIT                     ; skip pt assigned
"RTN","YTQRIS",70,0)
 . I $P(YSDATA(I),U,5)'=ORDBY QUIT                    ; not same orderedBy
"RTN","YTQRIS",71,0)
 . S YSDTSAV=$P(YSDATA(I),U,4) I 'YSDTSAV QUIT        ; no date, bad entry
"RTN","YTQRIS",72,0)
 . S YSRSTRT=$P(YSDATA(I),U,15) S:'YSRSTRT YSRSTRT=2  ; account for weekends
"RTN","YTQRIS",73,0)
 . ; always restartable is -1, comparing full 24 hour periods so use seconds
"RTN","YTQRIS",74,0)
 . I (YSRSTRT'=-1),$$FMDIFF^XLFDT(YSNOW,YSDTSAV,2)>((YSRSTRT+OFFSET)*86400) Q
"RTN","YTQRIS",75,0)
 . S X=$P(YSDATA(I),U,2)_" ("_$$FMTE^XLFDT(YSDTSAV,"2Z")_")" ; test (date)
"RTN","YTQRIS",76,0)
 . S $P(X,U,2)=0                                      ; staff entry -- no PIN
"RTN","YTQRIS",77,0)
 . S $P(X,U,3)=$P(YSDATA(I),U,2)_"|"_$P(YSDATA(I),U)  ; instrumentName|adminId
"RTN","YTQRIS",78,0)
 . S RSP($$NXT)=X
"RTN","YTQRIS",79,0)
 Q
"RTN","YTQRIS",80,0)
BATTERY ; add batteries
"RTN","YTQRIS",81,0)
 ; expects RSP,YSIDX
"RTN","YTQRIS",82,0)
 N I,X,YSDATA,LIST,NM
"RTN","YTQRIS",83,0)
 D BATTC^YTQAPI3(.YSDATA)
"RTN","YTQRIS",84,0)
 S I=1 F  S I=$O(YSDATA(I)) Q:'I  D
"RTN","YTQRIS",85,0)
 . S LIST($P(YSDATA(I),U,2),$P(YSDATA(I),U,3))=$P(YSDATA(I),U,5)
"RTN","YTQRIS",86,0)
 S NM="" F  S NM=$O(LIST(NM)) Q:'$L(NM)  D
"RTN","YTQRIS",87,0)
 . S X="B^"_NM
"RTN","YTQRIS",88,0)
 . S I=0 F  S I=$O(LIST(NM,I)) Q:'I  S $P(X,U,I+3)=LIST(NM,I)
"RTN","YTQRIS",89,0)
 . S RSP($$NXT)=X
"RTN","YTQRIS",90,0)
 Q
"RTN","YTQRIS",91,0)
REGULAR ; add list of regular instruments
"RTN","YTQRIS",92,0)
 ; expects RSP,YSIDX
"RTN","YTQRIS",93,0)
 N I,X,NM
"RTN","YTQRIS",94,0)
 S X="" F  S X=$O(^YTT(601.71,"B",X)) Q:'$L(X)  D
"RTN","YTQRIS",95,0)
 . S I=$O(^YTT(601.71,"B",X,0))
"RTN","YTQRIS",96,0)
 . I $P($G(^YTT(601.71,I,2)),U,2)'="Y" QUIT
"RTN","YTQRIS",97,0)
 . S NM=$P(^YTT(601.71,I,0),U)
"RTN","YTQRIS",98,0)
 . S RSP($$NXT)="R"_U_NM_U_I_U_NM
"RTN","YTQRIS",99,0)
 Q
"RTN","YTQRIS",100,0)
ASSIGN(DFN,ORDBY) ; return available list of instruments
"RTN","YTQRIS",101,0)
 ; expects RSP,YSIDX
"RTN","YTQRIS",102,0)
 Q:'ORDBY  Q:'DFN
"RTN","YTQRIS",103,0)
 N ASMT
"RTN","YTQRIS",104,0)
 S ASMT=0 F  S ASMT=$O(^XTMP("YTQASMT-INDEX","AD",DFN,ORDBY,ASMT)) Q:'ASMT  D
"RTN","YTQRIS",105,0)
 . N DATA,NAMES,X,I,J
"RTN","YTQRIS",106,0)
 . I '$D(^XTMP("YTQASMT-SET-"_ASMT,0)) D  Q  ; assignment must have expired
"RTN","YTQRIS",107,0)
 . . N OK S OK=$$DELIDX^YTQRQAD1(ASMT,DFN,ORDBY)
"RTN","YTQRIS",108,0)
 . M DATA=^XTMP("YTQASMT-SET-"_ASMT,1)
"RTN","YTQRIS",109,0)
 . I DATA("entryMode")="staff" Q  ; only show patient entered
"RTN","YTQRIS",110,0)
 . S NAMES="",X="A^",J=3 ; J is piece offset for test name
"RTN","YTQRIS",111,0)
 . S I=0 F  S I=$O(DATA("instruments",I)) Q:'I  D
"RTN","YTQRIS",112,0)
 . . I $L(NAMES) S NAMES=NAMES_","
"RTN","YTQRIS",113,0)
 . . S NAMES=NAMES_DATA("instruments",I,"name")
"RTN","YTQRIS",114,0)
 . . S J=J+1,$P(X,U,J)=DATA("instruments",I,"name")
"RTN","YTQRIS",115,0)
 . S $P(X,U,2)=NAMES
"RTN","YTQRIS",116,0)
 . S $P(X,U,3)=ASMT
"RTN","YTQRIS",117,0)
 . S RSP($$NXT)=X
"RTN","YTQRIS",118,0)
 Q
"RTN","YTQRIS",119,0)
ASSIGN2(DFN,ORDBY) ; return available list of instruments
"RTN","YTQRIS",120,0)
 ; expects RSP,YSIDX,PTADMIN
"RTN","YTQRIS",121,0)
 Q:'DFN  ;Q:'ORDBY
"RTN","YTQRIS",122,0)
 N ASMT,PRV
"RTN","YTQRIS",123,0)
 S PRV=0 F  S PRV=$O(^XTMP("YTQASMT-INDEX","AD",DFN,PRV)) Q:'PRV  D
"RTN","YTQRIS",124,0)
 . S ASMT=0 F  S ASMT=$O(^XTMP("YTQASMT-INDEX","AD",DFN,PRV,ASMT)) Q:'ASMT  D
"RTN","YTQRIS",125,0)
 . . N DATA,NAMES,TEST,ADMIN,X,I,J
"RTN","YTQRIS",126,0)
 . . I '$D(^XTMP("YTQASMT-SET-"_ASMT,0)) D  Q  ; assignment must have expired
"RTN","YTQRIS",127,0)
 . . . N OK S OK=$$DELIDX^YTQRQAD1(ASMT,DFN,PRV)
"RTN","YTQRIS",128,0)
 . . M DATA=^XTMP("YTQASMT-SET-"_ASMT,1)
"RTN","YTQRIS",129,0)
 . . I DATA("entryMode")="staff" Q             ; only show patient entered
"RTN","YTQRIS",130,0)
 . . S (X,NAMES)="",J=2                        ; J is piece offset for test name
"RTN","YTQRIS",131,0)
 . . S I=0 F  S I=$O(DATA("instruments",I)) Q:'I  D
"RTN","YTQRIS",132,0)
 . . . I $L(NAMES) S NAMES=NAMES_","
"RTN","YTQRIS",133,0)
 . . . S NAMES=NAMES_DATA("instruments",I,"name")
"RTN","YTQRIS",134,0)
 . . . S TEST=DATA("instruments",I,"name")
"RTN","YTQRIS",135,0)
 . . . S ADMIN=+$G(DATA("instruments",I,"adminId"))
"RTN","YTQRIS",136,0)
 . . . S TEST=TEST_"|"_ADMIN
"RTN","YTQRIS",137,0)
 . . . I ADMIN S PTADMIN(ADMIN)=""             ; avoid including with staff
"RTN","YTQRIS",138,0)
 . . . S J=J+1,$P(X,U,J)=TEST
"RTN","YTQRIS",139,0)
 . . S $P(X,U,1)=NAMES
"RTN","YTQRIS",140,0)
 . . S $P(X,U,2)=ASMT
"RTN","YTQRIS",141,0)
 . . S RSP($$NXT)=X
"RTN","YTQRIS",142,0)
 Q
"RTN","YTQRIS",143,0)
PTINFO(RSP,DFN) ; return display info for patient
"RTN","YTQRIS",144,0)
 N VA,VADM,VAERR
"RTN","YTQRIS",145,0)
 D DEM^VADPT
"RTN","YTQRIS",146,0)
 I VAERR S RSP(1)="Error Encountered" QUIT
"RTN","YTQRIS",147,0)
 S RSP(1)=VADM(1)_U_"xxx-xx-"_VA("BID")
"RTN","YTQRIS",148,0)
 Q
"RTN","YTQRIS",149,0)
USERINFO(RSP) ; return user info
"RTN","YTQRIS",150,0)
 S RSP(1)=DUZ_U_$$NAME^XUSER(DUZ,"F")_U_$$STA^XUAF4(DUZ(2))
"RTN","YTQRIS",151,0)
 Q
"RTN","YTQRIS",152,0)
DESCRIBE(RSP,PIN,ADMINS) ; describe an assignment
"RTN","YTQRIS",153,0)
 ; expects RSP,YSIDX
"RTN","YTQRIS",154,0)
 S RSP(1)="descriptive text will go here"
"RTN","YTQRIS",155,0)
 N YSIDX,DATA,EXPDT,I,IEN,X0
"RTN","YTQRIS",156,0)
 S YSIDX=0
"RTN","YTQRIS",157,0)
 I +PIN D
"RTN","YTQRIS",158,0)
 . M DATA=^XTMP("YTQASMT-SET-"_PIN,1)
"RTN","YTQRIS",159,0)
 . S EXPDT=$P($G(^XTMP("YTQASMT-SET-"_PIN,0)),U)
"RTN","YTQRIS",160,0)
 . S:EXPDT EXPDT=$$FMTE^XLFDT(EXPDT,"2Z")
"RTN","YTQRIS",161,0)
 . S RSP($$NXT)="PIN: "_PIN_"  (expires "_EXPDT_")"
"RTN","YTQRIS",162,0)
 . S RSP($$NXT)="Ordered By: "_$$GET1^DIQ(200,+$G(DATA("orderedBy"))_",",.01)
"RTN","YTQRIS",163,0)
 I YSIDX>0 S RSP($$NXT)=" "
"RTN","YTQRIS",164,0)
 F I=1:1:$L(ADMINS,",") D
"RTN","YTQRIS",165,0)
 . S IEN=+$P(ADMINS,",",I) Q:'IEN  Q:'$D(^YTT(601.84,IEN,0))
"RTN","YTQRIS",166,0)
 . S X0=^YTT(601.84,IEN,0)
"RTN","YTQRIS",167,0)
 . S RSP($$NXT)=$P($G(^YTT(601.71,+$P(X0,U,3),0)),U)
"RTN","YTQRIS",168,0)
 . I 'PIN S RSP($$NXT)="  Ordered By: "_$$GET1^DIQ(200,+$P(X0,U,6)_",",.01)
"RTN","YTQRIS",169,0)
 . S RSP($$NXT)="  Date/Time Begun: "_$$FMTE^XLFDT($P(X0,U,4),"2PZ")
"RTN","YTQRIS",170,0)
 . S RSP($$NXT)="  Date/Time Last Saved: "_$$FMTE^XLFDT($P(X0,U,5),"2PZ")
"RTN","YTQRIS",171,0)
 . S RSP($$NXT)="  Number of Questions Answered: "_$P(X0,U,10)
"RTN","YTQRIS",172,0)
 . I +PIN S RSP($$NXT)="  Completed: "_$S($P(X0,U,9)="Y":"Yes",1:"No")
"RTN","YTQRIS",173,0)
 Q
"RTN","YTQRIS",174,0)
VALTSTS(RSP,MODE,ORDBY,TESTS) ; validate a set of instruments
"RTN","YTQRIS",175,0)
 N MSG,I,IEN,TEST,APRV
"RTN","YTQRIS",176,0)
 S MSG=""
"RTN","YTQRIS",177,0)
 F I=1:1:$L(TESTS,",") S TEST=$P(TESTS,",",I) I $L(TEST) D  Q:$L(MSG)
"RTN","YTQRIS",178,0)
 . S IEN=$O(^YTT(601.71,"B",TEST,0)) I 'IEN D  Q
"RTN","YTQRIS",179,0)
 . . S MSG=TEST_" is not found on the server."
"RTN","YTQRIS",180,0)
 . S APRV=$P($G(^YTT(601.71,IEN,1)),U,6) S:+APRV APRV=$$LKUP^XPDKEY(APRV)
"RTN","YTQRIS",181,0)
 . I $L(APRV),'$D(^XUSEC(APRV,ORDBY)) D  Q
"RTN","YTQRIS",182,0)
 . . S MSG="Insufficient privilege to administer "_TEST
"RTN","YTQRIS",183,0)
 . I MODE="patient",$P($G(^YTT(601.71,IEN,9)),U,4)="Y" D  Q
"RTN","YTQRIS",184,0)
 . . S MSG=TEST_"is identified as 'staff-entry only'"
"RTN","YTQRIS",185,0)
 S RSP(0)=$S($L(MSG):MSG,1:"OK")
"RTN","YTQRIS",186,0)
 Q
"RTN","YTQRIS",187,0)
DELASMT(RSP,ATYP,ANID) ; delete an assignment or incomplete admin
"RTN","YTQRIS",188,0)
 I ATYP="A" D  QUIT
"RTN","YTQRIS",189,0)
 . N YTQRERRS
"RTN","YTQRIS",190,0)
 . K ^TMP("YTQRERRS",$J)
"RTN","YTQRIS",191,0)
 . D DELASMT1^YTQRQAD1(ANID)
"RTN","YTQRIS",192,0)
 . S RSP(1)="ok" I $G(YTQRERRS) S RSP(1)=$$ERRTXT^YTQRUTL
"RTN","YTQRIS",193,0)
 . K ^TMP("YTQRERRS",$J)
"RTN","YTQRIS",194,0)
 I ATYP="I" D  QUIT
"RTN","YTQRIS",195,0)
 . S RSP(1)="Deletion of instruments that have been started is not allowed."
"RTN","YTQRIS",196,0)
 S RSP(1)="Unrecognized Item Type"
"RTN","YTQRIS",197,0)
 Q
"RTN","YTQRIS",198,0)
DELASMT2(RSP,PIN,ADMINS) ; delete an assignment or incomplete admin
"RTN","YTQRIS",199,0)
 N I,X0,IEN,MGR,ERRMSG
"RTN","YTQRIS",200,0)
 S MGR=$$ISMGR,ERRMSG=""
"RTN","YTQRIS",201,0)
 ;
"RTN","YTQRIS",202,0)
 ; delete the individual admin entries first
"RTN","YTQRIS",203,0)
 F I=1:1:$L(ADMINS,",") D  Q:$L(ERRMSG)
"RTN","YTQRIS",204,0)
 . S IEN=+$P(ADMINS,",",I) Q:'IEN  Q:'$D(^YTT(601.84,IEN,0))
"RTN","YTQRIS",205,0)
 . S X0=^YTT(601.84,IEN,0)
"RTN","YTQRIS",206,0)
 . I $P(X0,U,8)="Y" D  Q
"RTN","YTQRIS",207,0)
 . . S ERRMSG="Deletion not allowed:  status is 'completed'"
"RTN","YTQRIS",208,0)
 . I MGR!(DUZ=$P(X0,U,6))!(DUZ=$P(X0,U,7)) D DELADMIN(IEN) I 1
"RTN","YTQRIS",209,0)
 . E  S ERRMSG="Deletion not allowed:  insufficient privilege"
"RTN","YTQRIS",210,0)
 I $L(ERRMSG) S RSP(1)=ERRMSG Q
"RTN","YTQRIS",211,0)
 S RSP(1)="ok"
"RTN","YTQRIS",212,0)
 ;
"RTN","YTQRIS",213,0)
 ; now delete the assignment
"RTN","YTQRIS",214,0)
 I 'PIN QUIT
"RTN","YTQRIS",215,0)
 N YTQRERRS
"RTN","YTQRIS",216,0)
 K ^TMP("YTQRERRS",$J)
"RTN","YTQRIS",217,0)
 D DELASMT1^YTQRQAD1(PIN)
"RTN","YTQRIS",218,0)
 I $G(YTQRERRS) S RSP(1)=$$ERRTXT^YTQRUTL
"RTN","YTQRIS",219,0)
 K ^TMP("YTQRERRS",$J)
"RTN","YTQRIS",220,0)
 Q
"RTN","YTQRIS",221,0)
ISMGR() ; return 1 if admin access to admins
"RTN","YTQRIS",222,0)
 N YSMENU,YSPRIV
"RTN","YTQRIS",223,0)
 S YSMENU=$$LKOPT^XPDMENU("YSMANAGER") Q:'YSMENU 0
"RTN","YTQRIS",224,0)
 S YSPRIV=$$ACCESS^XQCHK(DUZ,YSMENU)
"RTN","YTQRIS",225,0)
 Q +YSPRIV>0
"RTN","YTQRIS",226,0)
 ;
"RTN","YTQRIS",227,0)
DELADMIN(YSADM) ; delete an admin & associated records
"RTN","YTQRIS",228,0)
 N DIK,DA,YSANS,YSRSLT
"RTN","YTQRIS",229,0)
 ; delete the admin record
"RTN","YTQRIS",230,0)
 S DIK="^YTT(601.84,",DA=YSADM D ^DIK
"RTN","YTQRIS",231,0)
 ; delete the answer records
"RTN","YTQRIS",232,0)
 S YSANS=0 F  S YSANS=$O(^YTT(601.85,"AD",YSADM,YSANS)) Q:YSANS'>0  D
"RTN","YTQRIS",233,0)
 . I $P(^YTT(601.85,YSANS,0),U,2)'=YSADM Q  ; admin doesn't match
"RTN","YTQRIS",234,0)
 . S DIK="^YTT(601.85,",DA=YSANS D ^DIK
"RTN","YTQRIS",235,0)
 ; delete the result records
"RTN","YTQRIS",236,0)
 S YSRSLT=0 F  S YSRSLT=$O(^YTT(601.92,"AC",YSADM,YSRSLT)) Q:YSRSLT'>0  D
"RTN","YTQRIS",237,0)
 . I $P(^YTT(601.92,YSRSLT,0),U,2)'=YSADM Q  ; result doesn't match
"RTN","YTQRIS",238,0)
 . S DIK="^YTT(601.92,",DA=YSRSLT D ^DIK
"RTN","YTQRIS",239,0)
 Q
"RTN","YTQRIS",240,0)
ACTCAT(RSP) ; return a list of active categories
"RTN","YTQRIS",241,0)
 N TEST,CAT,X0,NM,SORTED
"RTN","YTQRIS",242,0)
 S TEST=0 F  S TEST=$O(^YTT(601.71,TEST)) Q:'TEST  D
"RTN","YTQRIS",243,0)
 . I $P($G(^YTT(601.71,TEST,2)),U,2)'="Y" QUIT  ; not active
"RTN","YTQRIS",244,0)
 . S CAT=0 F  S CAT=$O(^YTT(601.71,TEST,10,CAT)) Q:'CAT  D
"RTN","YTQRIS",245,0)
 . . S X0=^YTT(601.71,TEST,10,CAT,0)
"RTN","YTQRIS",246,0)
 . . S NM=^YTT(601.97,+X0,0)
"RTN","YTQRIS",247,0)
 . . S SORTED(NM)=""
"RTN","YTQRIS",248,0)
 S NM="" F  S NM=$O(SORTED(NM)) Q:'$L(NM)  S RSP($$NXT)=NM
"RTN","YTQRIS",249,0)
 Q
"RTN","YTQRIS",250,0)
INBYCAT(RSP,NM) ; return a list of instruments by category
"RTN","YTQRIS",251,0)
 N TEST,CAT,SORTED
"RTN","YTQRIS",252,0)
 S CAT=$O(^YTT(601.97,"B",NM,0)) Q:'CAT
"RTN","YTQRIS",253,0)
 S TEST=0 F  S TEST=$O(^YTT(601.71,TEST)) Q:'TEST  D
"RTN","YTQRIS",254,0)
 . I $P($G(^YTT(601.71,TEST,2)),U,2)'="Y" QUIT  ; not active
"RTN","YTQRIS",255,0)
 . I '$D(^YTT(601.71,TEST,10,"B",CAT)) QUIT     ; not in category
"RTN","YTQRIS",256,0)
 . S SORTED($P(^YTT(601.71,TEST,0),U))=""
"RTN","YTQRIS",257,0)
 S RSP(1)="Root="
"RTN","YTQRIS",258,0)
 S NM="" F  S NM=$O(SORTED(NM)) Q:'$L(NM)  S RSP(1)=RSP(1)_NM_U
"RTN","YTQRIS",259,0)
 Q
"RTN","YTQROPT")
0^30^B3569685^n/a
"RTN","YTQROPT",1,0)
YTQROPT ;SLC/KCM - MHA Assignment Options ; 1/25/2017
"RTN","YTQROPT",2,0)
 ;;5.01;MENTAL HEALTH;**130**;Dec 30, 1994;Build 62
"RTN","YTQROPT",3,0)
 ;
"RTN","YTQROPT",4,0)
 ; External Reference    ICR#
"RTN","YTQROPT",5,0)
 ; ------------------   -----
"RTN","YTQROPT",6,0)
 ; ^DPT                 10035
"RTN","YTQROPT",7,0)
 ; DIC                  10006
"RTN","YTQROPT",8,0)
 ; DIQ                   2056
"RTN","YTQROPT",9,0)
 ; XLFDT                10103
"RTN","YTQROPT",10,0)
 ;
"RTN","YTQROPT",11,0)
LSTBYPT ; List assignments by patient
"RTN","YTQROPT",12,0)
 N X,Y,DIC,DUOUT,DTOUT,YSDFN,OUT
"RTN","YTQROPT",13,0)
 S DIC="^DPT(",DIC(0)="AEMQ" D ^DIC I Y'>0 QUIT
"RTN","YTQROPT",14,0)
 D BLD4PT(+Y,.OUT)
"RTN","YTQROPT",15,0)
 I '$D(OUT) W !,?5,"No assignments found for this patient",! QUIT
"RTN","YTQROPT",16,0)
 W ! D SHO4PT(.OUT) W !
"RTN","YTQROPT",17,0)
 Q
"RTN","YTQROPT",18,0)
 ;
"RTN","YTQROPT",19,0)
BLD4PT(YSDFN,OUT) ; List assignments for patient in OUT
"RTN","YTQROPT",20,0)
 ; ^XTMP("YTQASMT-INDEX","AD",DFN,ORDBY,SETID)=EXPIRE
"RTN","YTQROPT",21,0)
 N PRV,PRVNM,SET,EXPIRE K OUT
"RTN","YTQROPT",22,0)
 S PRV=0 F  S PRV=$O(^XTMP("YTQASMT-INDEX","AD",YSDFN,PRV)) Q:'PRV  D
"RTN","YTQROPT",23,0)
 . S SET=0 F  S SET=$O(^XTMP("YTQASMT-INDEX","AD",YSDFN,PRV,SET)) Q:'SET  D
"RTN","YTQROPT",24,0)
 . . I $G(^XTMP("YTQASMT-SET-"_SET,1,"entryMode"))'="patient" QUIT
"RTN","YTQROPT",25,0)
 . . S PRVNM=$$GET1^DIQ(200,PRV_",",.01)
"RTN","YTQROPT",26,0)
 . . S EXPIRE=^XTMP("YTQASMT-INDEX","AD",YSDFN,PRV,SET)
"RTN","YTQROPT",27,0)
 . . S OUT(PRVNM,SET)=$$FMTE^XLFDT(EXPIRE)
"RTN","YTQROPT",28,0)
 Q
"RTN","YTQROPT",29,0)
SHO4PT(OUT) ; Display assignment information
"RTN","YTQROPT",30,0)
 N PRVNM,SET
"RTN","YTQROPT",31,0)
 W !,?5,"Provider",?34,"PIN",?40,"Expires"
"RTN","YTQROPT",32,0)
 W !,?5,"--------",?34,"---",?40,"-------"
"RTN","YTQROPT",33,0)
 S PRVNM="" F  S PRVNM=$O(OUT(PRVNM)) Q:'$L(PRVNM)  D
"RTN","YTQROPT",34,0)
 . S SET=0 F  S SET=$O(OUT(PRVNM,SET)) Q:'SET  D
"RTN","YTQROPT",35,0)
 . . W !,?5,PRVNM,?32,$J(SET,6),?40,OUT(PRVNM,SET)
"RTN","YTQROPT",36,0)
 Q
"RTN","YTQROPT",37,0)
LSTALL ; List all active assignments
"RTN","YTQROPT",38,0)
 N YSDFN,PTNM,OUT
"RTN","YTQROPT",39,0)
 S YSDFN=0 F  S YSDFN=$O(^XTMP("YTQASMT-INDEX","AD",YSDFN)) Q:'YSDFN  D
"RTN","YTQROPT",40,0)
 . D BLD4PT(YSDFN,.OUT) Q:'$D(OUT)
"RTN","YTQROPT",41,0)
 . S PTNM=$$GET1^DIQ(2,YSDFN_",",.01)
"RTN","YTQROPT",42,0)
 . W !!,?10,"---- ",PTNM," ----"
"RTN","YTQROPT",43,0)
 . D SHO4PT(.OUT)
"RTN","YTQROPT",44,0)
 Q
"RTN","YTQRQAD")
0^2^B17984488^n/a
"RTN","YTQRQAD",1,0)
YTQRQAD ;SLC/KCM - RESTful Calls for Instrument Admin ; 1/25/2017
"RTN","YTQRQAD",2,0)
 ;;5.01;MENTAL HEALTH;**130**;Dec 30, 1994;Build 62
"RTN","YTQRQAD",3,0)
 ;
"RTN","YTQRQAD",4,0)
 ; External Reference    ICR#
"RTN","YTQRQAD",5,0)
 ; ------------------   -----
"RTN","YTQRQAD",6,0)
 ; ^DIC(3.1)             1234
"RTN","YTQRQAD",7,0)
 ; ^DIC(49)             10093
"RTN","YTQRQAD",8,0)
 ; ^DPT                 10035
"RTN","YTQRQAD",9,0)
 ; ^VA(200)             10060
"RTN","YTQRQAD",10,0)
 ; ^VA(200,"AUSER")      4868
"RTN","YTQRQAD",11,0)
 ; DIQ                   2056
"RTN","YTQRQAD",12,0)
 ; XLFNAME               3065
"RTN","YTQRQAD",13,0)
 ; XLFSTR               10104
"RTN","YTQRQAD",14,0)
 ;
"RTN","YTQRQAD",15,0)
 ;
"RTN","YTQRQAD",16,0)
 ;; -- GETs  all return M object that is transformed to JSON
"RTN","YTQRQAD",17,0)
 ;; -- POSTs all return a path to the created/updated object
"RTN","YTQRQAD",18,0)
 ;;
"RTN","YTQRQAD",19,0)
PID(ARGS,RESULTS) ; get patient identifiers
"RTN","YTQRQAD",20,0)
 N DFN S DFN=+$G(ARGS("dfn"))
"RTN","YTQRQAD",21,0)
 I '$D(^DPT(DFN,0)) D SETERROR^YTQRUTL(404,"Not Found: "_DFN) QUIT
"RTN","YTQRQAD",22,0)
 S RESULTS("dfn")=DFN
"RTN","YTQRQAD",23,0)
 S RESULTS("name")=$P($G(^DPT(DFN,0)),U)
"RTN","YTQRQAD",24,0)
 S RESULTS("pid")="xxx-xx-"_$E($P($G(^DPT(DFN,0)),U,9),6,10)
"RTN","YTQRQAD",25,0)
 S RESULTS("ssn")=RESULTS("pid") ; TEMPORARY until a switch to PID
"RTN","YTQRQAD",26,0)
 Q
"RTN","YTQRQAD",27,0)
LSTALL(ARGS,RESULTS) ; get a list of all instruments
"RTN","YTQRQAD",28,0)
 D GETDOC("YTL ACTIVE",.RESULTS)
"RTN","YTQRQAD",29,0)
 Q
"RTN","YTQRQAD",30,0)
LSTCPRS(ARGS,RESULTS) ; get a list of all instruments
"RTN","YTQRQAD",31,0)
 D GETDOC("YTL CPRS",.RESULTS)
"RTN","YTQRQAD",32,0)
 Q
"RTN","YTQRQAD",33,0)
GETSPEC(ARGS,RESULTS) ; get an instrument specification
"RTN","YTQRQAD",34,0)
 D GETDOC("YTT "_$G(ARGS("instrumentName"),"MISSING NAME"),.RESULTS)
"RTN","YTQRQAD",35,0)
 Q
"RTN","YTQRQAD",36,0)
GETDOC(DOCNAME,RESULTS) ; set ^TMP with contents of the document named
"RTN","YTQRQAD",37,0)
 K ^TMP("YTQ-JSON",$J)
"RTN","YTQRQAD",38,0)
 N IEN S IEN=$O(^YTT(601.96,"B",DOCNAME,0))
"RTN","YTQRQAD",39,0)
 I 'IEN S IEN=$O(^YTT(601.96,"B",$TR(DOCNAME,"_"," "),0)) ; temporary
"RTN","YTQRQAD",40,0)
 I 'IEN D SETERROR^YTQRUTL(404,"Not Found: "_DOCNAME) QUIT
"RTN","YTQRQAD",41,0)
 M ^TMP("YTQ-JSON",$J)=^YTT(601.96,IEN,1)
"RTN","YTQRQAD",42,0)
 K ^TMP("YTQ-JSON",$J,0) ; remove 0 node (wp meta-data)
"RTN","YTQRQAD",43,0)
 S RESULTS=$NA(^TMP("YTQ-JSON",$J))
"RTN","YTQRQAD",44,0)
 Q
"RTN","YTQRQAD",45,0)
WRCLOSE(ARGS,DATA) ; noop call for closing Delphi wrapper
"RTN","YTQRQAD",46,0)
 Q "/api/wrapper/close/ok"
"RTN","YTQRQAD",47,0)
 ;
"RTN","YTQRQAD",48,0)
PERSONS(ARGS,RESULTS) ; GET /api/mha/persons/:match
"RTN","YTQRQAD",49,0)
 N ROOT,LROOT,NM,IEN,SEQ,PREVNM,QUAL
"RTN","YTQRQAD",50,0)
 S ROOT=$$UP^XLFSTR($G(ARGS("match"))),LROOT=$L(ROOT),SEQ=0,PREVNM=""
"RTN","YTQRQAD",51,0)
 S NM=ROOT F  S NM=$O(^VA(200,"AUSER",NM)) Q:NM=""  Q:$E(NM,1,LROOT)'=ROOT  D
"RTN","YTQRQAD",52,0)
 . S IEN=0 F  S IEN=$O(^VA(200,"AUSER",NM,IEN)) Q:'IEN  D
"RTN","YTQRQAD",53,0)
 . . S SEQ=SEQ+1
"RTN","YTQRQAD",54,0)
 . . S RESULTS("persons",SEQ,"userId")=IEN
"RTN","YTQRQAD",55,0)
 . . S RESULTS("persons",SEQ,"name")=$$NAMEFMT^XLFNAME(NM,"F","DcMPC")
"RTN","YTQRQAD",56,0)
 . . S RESULTS("persons",SEQ,"title")=""
"RTN","YTQRQAD",57,0)
 . . I $P(NM," ")=$P(PREVNM," ") D
"RTN","YTQRQAD",58,0)
 . . . S QUAL=$$GET1^DIQ(200,IEN_",",8)  ; try title first
"RTN","YTQRQAD",59,0)
 . . . I $L(QUAL) S RESULTS("persons",SEQ,"title")=QUAL Q
"RTN","YTQRQAD",60,0)
 . . . S QUAL=$$GET1^DIQ(200,IEN,",",29) ; then try service/section
"RTN","YTQRQAD",61,0)
 . . . S RESULTS("persons",SEQ,"title")=QUAL
"RTN","YTQRQAD",62,0)
 . . S PREVNM=NM
"RTN","YTQRQAD",63,0)
 I '$D(RESULTS) D  ; return empty array in ^TMP so handler knows it is JSON
"RTN","YTQRQAD",64,0)
 . K ^TMP("YTQ-JSON",$J)
"RTN","YTQRQAD",65,0)
 . S ^TMP("YTQ-JSON",$J,1,0)="{""persons"":[]}"
"RTN","YTQRQAD",66,0)
 . S RESULTS=$NA(^TMP("YTQ-JSON",$J))
"RTN","YTQRQAD",67,0)
 Q
"RTN","YTQRQAD",68,0)
USERS(ARGS,RESULTS) ; GET /api/mha/users/:match
"RTN","YTQRQAD",69,0)
 N ROOT,LROOT,NM,IEN,SEQ,PREVNM,PREVLBL,LABEL,QUAL,I
"RTN","YTQRQAD",70,0)
 S ROOT=$$UP^XLFSTR($G(ARGS("match"))),LROOT=$L(ROOT),SEQ=0,PREVNM="",PREVLBL=""
"RTN","YTQRQAD",71,0)
 S NM=ROOT F  S NM=$O(^VA(200,"AUSER",NM)) Q:NM=""  Q:$E(NM,1,LROOT)'=ROOT  D
"RTN","YTQRQAD",72,0)
 . S IEN=0 F  S IEN=$O(^VA(200,"AUSER",NM,IEN)) Q:'IEN  D
"RTN","YTQRQAD",73,0)
 . . S SEQ=SEQ+1
"RTN","YTQRQAD",74,0)
 . . S LABEL=$$NAMEFMT^XLFNAME(NM,"F","DcMPC"),QUAL=""
"RTN","YTQRQAD",75,0)
 . . I $P(NM," ")=$P(PREVNM," ") D
"RTN","YTQRQAD",76,0)
 . . . ; try TITLE as qualifier first
"RTN","YTQRQAD",77,0)
 . . . S $P(QUAL,U)=$$GET1^DIQ(200,IEN_",",8)
"RTN","YTQRQAD",78,0)
 . . . I $P((LABEL_QUAL),U)'=$P(PREVLBL,U) QUIT
"RTN","YTQRQAD",79,0)
 . . . ; try SERVICE/SECTION as qualifier next
"RTN","YTQRQAD",80,0)
 . . . S $P(QUAL,U,2)=$$GET1^DIQ(200,IEN,",",29)
"RTN","YTQRQAD",81,0)
 . . . I $P(LABEL_QUAL,U,1,2)'=$P(PREVLBL,U,1,2) QUIT
"RTN","YTQRQAD",82,0)
 . . . ; try nickname
"RTN","YTQRQAD",83,0)
 . . . S $P(QUAL,U,3)=$$GET1^DIQ(200,IEN_",",13)
"RTN","YTQRQAD",84,0)
 . . S PREVNM=NM,PREVLBL=LABEL_QUAL
"RTN","YTQRQAD",85,0)
 . . I $L(QUAL) D
"RTN","YTQRQAD",86,0)
 . . . N X,I S X=""
"RTN","YTQRQAD",87,0)
 . . . F I=1:1:3 I $L($P(QUAL,U,I)) S X=X_$S($L(X):", ",1:"")_$P(QUAL,U,I)
"RTN","YTQRQAD",88,0)
 . . . S LABEL=LABEL_" ("_X_")"
"RTN","YTQRQAD",89,0)
 . . S RESULTS("persons",SEQ,"id")=IEN
"RTN","YTQRQAD",90,0)
 . . S RESULTS("persons",SEQ,"label")=LABEL
"RTN","YTQRQAD",91,0)
 I '$D(RESULTS) D  ; return empty array in ^TMP so handler knows it is JSON
"RTN","YTQRQAD",92,0)
 . K ^TMP("YTQ-JSON",$J)
"RTN","YTQRQAD",93,0)
 . S ^TMP("YTQ-JSON",$J,1,0)="{""persons"":[]}"
"RTN","YTQRQAD",94,0)
 . S RESULTS=$NA(^TMP("YTQ-JSON",$J))
"RTN","YTQRQAD",95,0)
 Q
"RTN","YTQRQAD",96,0)
RESET ; clear the ^XTMP("YTQASMT") nodes
"RTN","YTQRQAD",97,0)
 ; WARNING -- calling this (at RESET+3) will erase all current assignments
"RTN","YTQRQAD",98,0)
 Q
"RTN","YTQRQAD",99,0)
 N NM
"RTN","YTQRQAD",100,0)
 S NM="YTQASMT" F  S NM=$O(^XTMP(NM)) Q:$E(NM,1,7)'="YTQASMT"  D
"RTN","YTQRQAD",101,0)
 . W !,NM
"RTN","YTQRQAD",102,0)
 . K ^XTMP(NM)
"RTN","YTQRQAD",103,0)
 Q
"RTN","YTQRQAD1")
0^16^B43113757^n/a
"RTN","YTQRQAD1",1,0)
YTQRQAD1 ;SLC/KCM - RESTful Calls to handle MHA assignments ; 1/25/2017
"RTN","YTQRQAD1",2,0)
 ;;5.01;MENTAL HEALTH;**130**;Dec 30, 1994;Build 62
"RTN","YTQRQAD1",3,0)
 ;
"RTN","YTQRQAD1",4,0)
 ; External Reference    ICR#
"RTN","YTQRQAD1",5,0)
 ; ------------------   -----
"RTN","YTQRQAD1",6,0)
 ; VADPT                10061
"RTN","YTQRQAD1",7,0)
 ; XLFDT                10103
"RTN","YTQRQAD1",8,0)
 ; XLFSTR               10104
"RTN","YTQRQAD1",9,0)
 ;
"RTN","YTQRQAD1",10,0)
ASMTBYID(ARGS,RESULTS) ; get assignment identified by assignmentId
"RTN","YTQRQAD1",11,0)
 N ASMT,ADMIN,TEST,I
"RTN","YTQRQAD1",12,0)
 S ASMT="YTQASMT-SET-"_$G(ARGS("assignmentId"))
"RTN","YTQRQAD1",13,0)
 I '$D(^XTMP(ASMT)) D SETERROR^YTQRUTL(404,"Not Found: "_ARGS("assignmentId")) QUIT
"RTN","YTQRQAD1",14,0)
 S I=0 F  S I=$O(^XTMP(ASMT,1,"instruments",I)) Q:'I  D  ; calc progress
"RTN","YTQRQAD1",15,0)
 . S ADMIN=+$G(^XTMP(ASMT,1,"instruments",I,"adminId"))
"RTN","YTQRQAD1",16,0)
 . S TEST=+$G(^XTMP(ASMT,1,"instruments",I,"id"))
"RTN","YTQRQAD1",17,0)
 . S ^XTMP(ASMT,1,"instruments",I,"progress")=$$PROGRESS(ADMIN,TEST)
"RTN","YTQRQAD1",18,0)
 M RESULTS=^XTMP(ASMT,1)                                 ; load assignment
"RTN","YTQRQAD1",19,0)
 Q
"RTN","YTQRQAD1",20,0)
ASMTBYNM(ARGS,RESULTS) ; get assignment identified by lastName and last4
"RTN","YTQRQAD1",21,0)
 N ASMT,PID,PTNAME,LAST
"RTN","YTQRQAD1",22,0)
 S PID=ARGS("last4")
"RTN","YTQRQAD1",23,0)
 S PTNAME=$$UP^XLFSTR(ARGS("lastName"))
"RTN","YTQRQAD1",24,0)
 I 'PID!'$L(PTNAME) D SETERROR^YTQRUTL(400,"Missing Identifiers") QUIT
"RTN","YTQRQAD1",25,0)
 S LAST=$O(^XTMP("YTQASMT-INDEX","AC",PID,PTNAME,0))
"RTN","YTQRQAD1",26,0)
 S ASMT=$G(^XTMP("YTQASMT-INDEX","AC",PID,PTNAME,LAST))
"RTN","YTQRQAD1",27,0)
 I 'ASMT D SETERROR^YTQRUTL(404,"Not Found: Assignment for Patient") QUIT
"RTN","YTQRQAD1",28,0)
 S ARGS("assignmentId")=ASMT
"RTN","YTQRQAD1",29,0)
 D ASMTBYID(.ARGS,.RESULTS)
"RTN","YTQRQAD1",30,0)
 Q
"RTN","YTQRQAD1",31,0)
PROGRESS(ADMIN,TEST) ; return the progress for an administration
"RTN","YTQRQAD1",32,0)
 Q:'ADMIN 0
"RTN","YTQRQAD1",33,0)
 N I,QANS,QTOT
"RTN","YTQRQAD1",34,0)
 S QANS=$P(^YTT(601.84,ADMIN,0),U,10)
"RTN","YTQRQAD1",35,0)
 S (I,QTOT)=0 F  S I=$O(^YTT(601.76,"AC",TEST,I)) Q:'I  S QTOT=QTOT+1
"RTN","YTQRQAD1",36,0)
 Q $S(QTOT>0:$P(((QANS/QTOT)*100)+.5,"."),1:0)
"RTN","YTQRQAD1",37,0)
 ;
"RTN","YTQRQAD1",38,0)
NEWASMT(ARGS,DATA) ; save assignment, return /api/mha/assignment/{assignmentId}
"RTN","YTQRQAD1",39,0)
 N I,DFN,ORDBY,VA,VADM,VAERR,I,PREFIX,SETID,FOUND,PID,PTNAME,EXPIRE
"RTN","YTQRQAD1",40,0)
 S DFN=+$G(DATA("patient","dfn"))
"RTN","YTQRQAD1",41,0)
 S ORDBY=+$G(DATA("orderedBy"))
"RTN","YTQRQAD1",42,0)
 I 'DFN!'ORDBY D SETERROR^YTQRUTL(400,"Missing Reqd Fields") QUIT ""
"RTN","YTQRQAD1",43,0)
 D DEM^VADPT I $G(VAERR) D SETERROR^YTQRUTL(400,"Missing Pt Info") QUIT ""
"RTN","YTQRQAD1",44,0)
 S PID=VA("BID"),PTNAME=VADM(1)
"RTN","YTQRQAD1",45,0)
 ; set these "patient" nodes up in case called with just DFN
"RTN","YTQRQAD1",46,0)
 S DATA("patient","name")=PTNAME
"RTN","YTQRQAD1",47,0)
 S DATA("patient","pid")="xxx-xx-"_PID
"RTN","YTQRQAD1",48,0)
 S DATA("patient","ssn")=DATA("patient","pid")
"RTN","YTQRQAD1",49,0)
 ; look up IEN for each instrument in the assignment
"RTN","YTQRQAD1",50,0)
 S I=0 F  S I=$O(DATA("instruments",I)) Q:'I  D
"RTN","YTQRQAD1",51,0)
 . N TSTNM,TSTID,TSTFN
"RTN","YTQRQAD1",52,0)
 . S TSTNM=$G(DATA("instruments",I,"name")) Q:'$L(TSTNM)
"RTN","YTQRQAD1",53,0)
 . S TSTID=$O(^YTT(601.71,"B",TSTNM,0)) Q:'TSTID
"RTN","YTQRQAD1",54,0)
 . S TSTFN=$P(^YTT(601.71,TSTID,0),U,3)
"RTN","YTQRQAD1",55,0)
 . S DATA("instruments",I,"id")=TSTID
"RTN","YTQRQAD1",56,0)
 . S DATA("instruments",I,"printTitle")=TSTFN
"RTN","YTQRQAD1",57,0)
 . I +$G(DATA("instruments",I,"replace")) D    ; creating from old asmt
"RTN","YTQRQAD1",58,0)
 . . D RMVTEST(DATA("instruments",I,"replace"),DATA("instruments",I,"name"))
"RTN","YTQRQAD1",59,0)
 . . K DATA("instruments",I,"replace")
"RTN","YTQRQAD1",60,0)
 ; randomly generate an instrument-set id and check for already used
"RTN","YTQRQAD1",61,0)
 S PREFIX="YTQASMT-SET-",FOUND=0,EXPIRE=$$FMADD^XLFDT(DT,7)
"RTN","YTQRQAD1",62,0)
 F I=1:1:500 S SETID=$R(100000) D  Q:FOUND     ; give up after 500 tries
"RTN","YTQRQAD1",63,0)
 . I $D(^XTMP(PREFIX_SETID)) QUIT              ; already occupied
"RTN","YTQRQAD1",64,0)
 . L +^XTMP(PREFIX_SETID,0):DILOCKTM E  QUIT   ; didn't get lock in time
"RTN","YTQRQAD1",65,0)
 . S ^XTMP(PREFIX_SETID,0)=EXPIRE_U_DT_U_"MH Assignment"
"RTN","YTQRQAD1",66,0)
 . S ^XTMP("YTQASMT-INDEX",0)=^XTMP(PREFIX_SETID,0)_" Index"
"RTN","YTQRQAD1",67,0)
 . L -^XTMP(PREFIX_SETID,0)
"RTN","YTQRQAD1",68,0)
 . M ^XTMP(PREFIX_SETID,1)=DATA                ; save assignment object
"RTN","YTQRQAD1",69,0)
 . S ^XTMP(PREFIX_SETID,1,"id")=SETID
"RTN","YTQRQAD1",70,0)
 . S ^XTMP("YTQASMT-INDEX","AC",PID,$P(PTNAME,","),9999999-$$NOW^XLFDT)=SETID
"RTN","YTQRQAD1",71,0)
 . S ^XTMP("YTQASMT-INDEX","AD",DFN,ORDBY,SETID)=EXPIRE
"RTN","YTQRQAD1",72,0)
 . S FOUND=1
"RTN","YTQRQAD1",73,0)
 I 'FOUND D SETERROR^YTQRUTL(500,"Assignment not found") Q ""
"RTN","YTQRQAD1",74,0)
 Q "/api/mha/assignment/"_SETID
"RTN","YTQRQAD1",75,0)
 ;
"RTN","YTQRQAD1",76,0)
DELASMT(ARGS) ; delete the assignment identified in ARGS("assignmentId")
"RTN","YTQRQAD1",77,0)
 D DELASMT1(ARGS("assignmentId"))
"RTN","YTQRQAD1",78,0)
 Q
"RTN","YTQRQAD1",79,0)
DELASMT1(ASMT) ; delete the assignment given the assignment number
"RTN","YTQRQAD1",80,0)
 N DATA,DFN,ORDBY
"RTN","YTQRQAD1",81,0)
 M DATA=^XTMP("YTQASMT-SET-"_ASMT,1)
"RTN","YTQRQAD1",82,0)
 I $D(DATA)<10 D SETERROR^YTQRUTL(404,"Assignment not found") QUIT
"RTN","YTQRQAD1",83,0)
 S DFN=+$G(DATA("patient","dfn"))
"RTN","YTQRQAD1",84,0)
 S ORDBY=+$G(DATA("orderedBy"))
"RTN","YTQRQAD1",85,0)
 I '$$DELIDX(ASMT,DFN,ORDBY) QUIT  ; missing pt info
"RTN","YTQRQAD1",86,0)
 K ^XTMP("YTQASMT-SET-"_ASMT)
"RTN","YTQRQAD1",87,0)
 Q
"RTN","YTQRQAD1",88,0)
DELIDX(ASMT,DFN,ORDBY) ; return true if able to remove "AC", "AD" indexes
"RTN","YTQRQAD1",89,0)
 N VA,VADM,VAERR,PID,LNAME,INVDT
"RTN","YTQRQAD1",90,0)
 D DEM^VADPT I $G(VAERR) D SETERROR^YTQRUTL(400,"Missing Pt Info") QUIT 0
"RTN","YTQRQAD1",91,0)
 S PID=VA("BID"),LNAME=$P(VADM(1),",")
"RTN","YTQRQAD1",92,0)
 K ^XTMP("YTQASMT-INDEX","AD",DFN,ORDBY,ASMT)
"RTN","YTQRQAD1",93,0)
 S INVDT=0 F  S INVDT=$O(^XTMP("YTQASMT-INDEX","AC",PID,LNAME,INVDT)) Q:'INVDT  D
"RTN","YTQRQAD1",94,0)
 . I ^XTMP("YTQASMT-INDEX","AC",PID,LNAME,INVDT)=ASMT D
"RTN","YTQRQAD1",95,0)
 . . K ^XTMP("YTQASMT-INDEX","AC",PID,LNAME,INVDT)
"RTN","YTQRQAD1",96,0)
 Q 1
"RTN","YTQRQAD1",97,0)
 ;
"RTN","YTQRQAD1",98,0)
DELTEST(ARGS) ; remove an instrument from an assignment
"RTN","YTQRQAD1",99,0)
 N ASMT,TEST
"RTN","YTQRQAD1",100,0)
 S TEST=$G(ARGS("instrument")),ASMT=$G(ARGS("assignmentId"))
"RTN","YTQRQAD1",101,0)
 I +TEST=TEST S TEST=$P($G(^YTT(601.71,TEST,0)),U) ; use instrument name
"RTN","YTQRQAD1",102,0)
 I '$L(TEST) D SETERROR^YTQRUTL(404,"Instrument not found") QUIT
"RTN","YTQRQAD1",103,0)
 I $D(^XTMP("YTQASMT-SET-"_ASMT))<10 D SETERROR^YTQRUTL("Assignment not found") QUIT
"RTN","YTQRQAD1",104,0)
 D RMVTEST(ASMT,TEST)
"RTN","YTQRQAD1",105,0)
 Q
"RTN","YTQRQAD1",106,0)
RMVTEST(ASMT,TEST) ; remove test from assignment, delete assignment if empty
"RTN","YTQRQAD1",107,0)
 N I,NODE
"RTN","YTQRQAD1",108,0)
 S NODE="YTQASMT-SET-"_ASMT
"RTN","YTQRQAD1",109,0)
 S I=0 F  S I=$O(^XTMP(NODE,1,"instruments",I)) Q:'I  D
"RTN","YTQRQAD1",110,0)
 . I ^XTMP(NODE,1,"instruments",I,"name")=TEST D
"RTN","YTQRQAD1",111,0)
 . . K ^XTMP(NODE,1,"instruments",I)
"RTN","YTQRQAD1",112,0)
 I $D(^XTMP(NODE,1,"instruments"))<10 D DELASMT1(ASMT)
"RTN","YTQRQAD1",113,0)
 Q
"RTN","YTQRQAD1",114,0)
 ;
"RTN","YTQRQAD1",115,0)
UPDIDX ; Update AC and AD indexes to synch with expired assignments
"RTN","YTQRQAD1",116,0)
 N PID,LNAME,INVDT,ASMT,DFN,ORDBY,CURTM,ORIGTM
"RTN","YTQRQAD1",117,0)
 S CURTM=$$NOW^XLFDT
"RTN","YTQRQAD1",118,0)
 S PID="" F  S PID=$O(^XTMP("YTQASMT-INDEX","AC",PID)) Q:'$L(PID)  D
"RTN","YTQRQAD1",119,0)
 . S LNAME="" F  S LNAME=$O(^XTMP("YTQASMT-INDEX","AC",PID,LNAME)) Q:'$L(LNAME)  D
"RTN","YTQRQAD1",120,0)
 . . S INVDT=0 F  S INVDT=$O(^XTMP("YTQASMT-INDEX","AC",PID,LNAME,INVDT)) Q:'INVDT  D
"RTN","YTQRQAD1",121,0)
 . . . S ASMT=^XTMP("YTQASMT-INDEX","AC",PID,LNAME,INVDT)
"RTN","YTQRQAD1",122,0)
 . . . I '$D(^XTMP("YTQASMT-SET-"_ASMT,0)) D
"RTN","YTQRQAD1",123,0)
 . . . . K ^XTMP("YTQASMT-INDEX","AC",PID,LNAME,INVDT)
"RTN","YTQRQAD1",124,0)
 . . . . S ORIGTM=9999999-INVDT
"RTN","YTQRQAD1",125,0)
 . . . . W !,"removed AC:  "_ASMT,?20,PID_"  "_LNAME,?40,$$FMDIFF^XLFDT(CURTM,ORIGTM,1)_" days"
"RTN","YTQRQAD1",126,0)
 S DFN=0 F  S DFN=$O(^XTMP("YTQASMT-INDEX","AD",DFN)) Q:'DFN  D
"RTN","YTQRQAD1",127,0)
 . S ORDBY=0 F  S ORDBY=$O(^XTMP("YTQASMT-INDEX","AD",DFN,ORDBY)) Q:'ORDBY  D
"RTN","YTQRQAD1",128,0)
 . . S ASMT=0 F  S ASMT=$O(^XTMP("YTQASMT-INDEX","AD",DFN,ORDBY,ASMT)) Q:'ASMT  D
"RTN","YTQRQAD1",129,0)
 . . . I '$D(^XTMP("YTQASMT-SET-"_ASMT,0)) D
"RTN","YTQRQAD1",130,0)
 . . . . S ORIGTM=^XTMP("YTQASMT-INDEX","AD",DFN,ORDBY,ASMT)
"RTN","YTQRQAD1",131,0)
 . . . . K ^XTMP("YTQASMT-INDEX","AD",DFN,ORDBY,ASMT)
"RTN","YTQRQAD1",132,0)
 . . . . W !,"removed AD:  "_ASMT,?20,DFN_"  "_ORDBY,?40,$$FMDIFF^XLFDT(CURTM,ORIGTM,1)_" days"
"RTN","YTQRQAD1",133,0)
 Q
"RTN","YTQRQAD1",134,0)
CHKIDX ; Check assignments to make sure the indexes are present
"RTN","YTQRQAD1",135,0)
 N SET,ASMT,DFN,ORDBY,VA,VADM,VAERR,PID,LNAME,INVDT,FOUND
"RTN","YTQRQAD1",136,0)
 S SET="YTQASMT-SET-" F  S SET=$O(^XTMP(SET)) Q:$E(SET,1,12)'="YTQASMT-SET-"  D
"RTN","YTQRQAD1",137,0)
 . S ASMT=$P(SET,"-",3)
"RTN","YTQRQAD1",138,0)
 . S DFN=^XTMP(SET,1,"patient","dfn")
"RTN","YTQRQAD1",139,0)
 . S ORDBY=^XTMP(SET,1,"orderedBy")
"RTN","YTQRQAD1",140,0)
 . I '$D(^XTMP("YTQASMT-INDEX","AD",DFN,ORDBY,ASMT)) D
"RTN","YTQRQAD1",141,0)
 . . W !,"Assignment "_ASMT_" missing AD index."
"RTN","YTQRQAD1",142,0)
 . D DEM^VADPT I $G(VAERR) Q
"RTN","YTQRQAD1",143,0)
 . S PID=VA("BID"),LNAME=$P(VADM(1),","),FOUND=0
"RTN","YTQRQAD1",144,0)
 . S INVDT=0 F  S INVDT=$O(^XTMP("YTQASMT-INDEX","AC",PID,LNAME,INVDT)) Q:'INVDT  D  Q:FOUND
"RTN","YTQRQAD1",145,0)
 . . I ^XTMP("YTQASMT-INDEX","AC",PID,LNAME,INVDT)=ASMT S FOUND=1
"RTN","YTQRQAD1",146,0)
 . I 'FOUND W !,"Assignment "_ASMT_" missing AC index."
"RTN","YTQRQAD1",147,0)
 Q
"RTN","YTQRQAD2")
0^17^B33515515^n/a
"RTN","YTQRQAD2",1,0)
YTQRQAD2 ;SLC/KCM - RESTful Calls to set/get MHA administrations ; 1/25/2017
"RTN","YTQRQAD2",2,0)
 ;;5.01;MENTAL HEALTH;**130**;Dec 30, 1994;Build 62
"RTN","YTQRQAD2",3,0)
 ;
"RTN","YTQRQAD2",4,0)
SAVEADM(ARGS,DATA) ; save answers and return /ys/mha/admin/{adminId}
"RTN","YTQRQAD2",5,0)
 ; loop through DATA to create ANS array, then YSDATA array
"RTN","YTQRQAD2",6,0)
 ; ANS(#)=questionId^choiceId    <-- radio group question
"RTN","YTQRQAD2",7,0)
 ; ANS(#,#)=wp value             <-- all others
"RTN","YTQRQAD2",8,0)
 N I,QNUM,QANS,QID,VAL,ASMT,TEST,ADMIN,CPLT,ANS,PTENT,RT1
"RTN","YTQRQAD2",9,0)
 S QNUM=0,QANS=0
"RTN","YTQRQAD2",10,0)
 S I=0 F  S I=$O(DATA("answers",I)) Q:'I  D
"RTN","YTQRQAD2",11,0)
 . S QID=DATA("answers",I,"id")
"RTN","YTQRQAD2",12,0)
 . S VAL=DATA("answers",I,"value")
"RTN","YTQRQAD2",13,0)
 . QUIT:$E(QID)'="q"   ; skip intros, sections
"RTN","YTQRQAD2",14,0)
 . S QNUM=QNUM+1       ; QNUM is sequence w/o intros
"RTN","YTQRQAD2",15,0)
 . S QID=$E(QID,2,999) ; remove the "q"
"RTN","YTQRQAD2",16,0)
 . I VAL="null" S ANS(QNUM)=QID_U_"NOT ASKED" QUIT
"RTN","YTQRQAD2",17,0)
 . ; QANS is number answered, don't include skipped (1155 or 1157)
"RTN","YTQRQAD2",18,0)
 . I '((VAL="c1155")!(VAL="c1157")) S QANS=QANS+1
"RTN","YTQRQAD2",19,0)
 . S RT1=0             ; response type 1 is choice question
"RTN","YTQRQAD2",20,0)
 . I VAL="c1155"!(VAL="c1156")!(VAL="c1157") S RT1=1
"RTN","YTQRQAD2",21,0)
 . I $P($G(^YTT(601.72,QID,2)),U,2)=1 S RT1=1
"RTN","YTQRQAD2",22,0)
 . I RT1 S ANS(QNUM)=QID_U_$E(VAL,2,999) QUIT
"RTN","YTQRQAD2",23,0)
 . S ANS(QNUM)=QID D TXT2ANS(I,QNUM) ; handle longer WP values
"RTN","YTQRQAD2",24,0)
 ; save admin itself
"RTN","YTQRQAD2",25,0)
 S ASMT=DATA("assignmentId")
"RTN","YTQRQAD2",26,0)
 S TEST=DATA("instrumentId")
"RTN","YTQRQAD2",27,0)
 S CPLT=$S(DATA("complete")="true":"Y",1:"N")
"RTN","YTQRQAD2",28,0)
 S ADMIN=$$SETADM(ASMT,TEST,QANS,CPLT,+$G(DATA("adminId")))
"RTN","YTQRQAD2",29,0)
 Q:'ADMIN ""
"RTN","YTQRQAD2",30,0)
 ; save the answers
"RTN","YTQRQAD2",31,0)
 N YSDATA
"RTN","YTQRQAD2",32,0)
 S ANS("AD")=ADMIN
"RTN","YTQRQAD2",33,0)
 D SAVEALL^YTQAPI17(.YSDATA,.ANS)
"RTN","YTQRQAD2",34,0)
 I YSDATA(1)'="[DATA]" D SETERROR^YTQRUTL(500,"Answers not saved") Q ""
"RTN","YTQRQAD2",35,0)
 ; create a note if this was patient-entered
"RTN","YTQRQAD2",36,0)
 S PTENT=($G(^XTMP("YTQASMT-SET-"_ASMT,1,"entryMode"))="patient")
"RTN","YTQRQAD2",37,0)
 I (CPLT="Y"),PTENT D NOTE4PT^YTQRQAD3(ADMIN)
"RTN","YTQRQAD2",38,0)
 ; update the assignment with adminId, remove completed admins/assignments
"RTN","YTQRQAD2",39,0)
 N NODE,REMAIN
"RTN","YTQRQAD2",40,0)
 S NODE="YTQASMT-SET-"_ASMT,REMAIN=0
"RTN","YTQRQAD2",41,0)
 S I=0 F  S I=$O(^XTMP(NODE,1,"instruments",I)) Q:'I  D
"RTN","YTQRQAD2",42,0)
 . I ^XTMP(NODE,1,"instruments",I,"id")=TEST D  QUIT
"RTN","YTQRQAD2",43,0)
 . . ; remove instrument if complete and staff-entered
"RTN","YTQRQAD2",44,0)
 . . I 'PTENT,(CPLT="Y") K ^XTMP(NODE,1,"instruments",I) QUIT
"RTN","YTQRQAD2",45,0)
 . . ;I CPLT="Y" K ^XTMP(NODE,1,"instruments",I) QUIT  ; patient-entered (may need to keep)
"RTN","YTQRQAD2",46,0)
 . . S ^XTMP(NODE,1,"instruments",I,"adminId")=ADMIN
"RTN","YTQRQAD2",47,0)
 . . S ^XTMP(NODE,1,"instruments",I,"complete")=DATA("complete")
"RTN","YTQRQAD2",48,0)
 . . I CPLT'="Y" S REMAIN=1
"RTN","YTQRQAD2",49,0)
 . I $G(^XTMP(NODE,1,"instruments",I,"complete"))'="true" S REMAIN=1
"RTN","YTQRQAD2",50,0)
 I 'REMAIN D DELASMT1^YTQRQAD1(ASMT)
"RTN","YTQRQAD2",51,0)
 Q "/ys/mha/admin/"_ADMIN
"RTN","YTQRQAD2",52,0)
 ;
"RTN","YTQRQAD2",53,0)
SETADM(ASMT,TEST,NUM,CPLT,ADMIN) ; return the id for new/updated admin
"RTN","YTQRQAD2",54,0)
 N YSDATA,YS,NODE
"RTN","YTQRQAD2",55,0)
 S NODE="YTQASMT-SET-"_ASMT
"RTN","YTQRQAD2",56,0)
 S YS("FILEN")=601.84
"RTN","YTQRQAD2",57,0)
 I ADMIN S YS("IEN")=ADMIN I 1
"RTN","YTQRQAD2",58,0)
 E  S YS(1)=".01^NEW^1"
"RTN","YTQRQAD2",59,0)
 S YS(2)="1^`"_$G(^XTMP(NODE,1,"patient","dfn"))
"RTN","YTQRQAD2",60,0)
 S YS(3)="2^`"_TEST
"RTN","YTQRQAD2",61,0)
 S YS(4)="3^"_$G(^XTMP(NODE,1,"date"))
"RTN","YTQRQAD2",62,0)
 S YS(5)="4^NOW"
"RTN","YTQRQAD2",63,0)
 S YS(6)="5^`"_$G(^XTMP(NODE,1,"orderedBy"))
"RTN","YTQRQAD2",64,0)
 S YS(7)="6^`"_$G(^XTMP(NODE,1,"interview"))
"RTN","YTQRQAD2",65,0)
 S YS(8)="7^N"
"RTN","YTQRQAD2",66,0)
 S YS(9)="8^"_CPLT
"RTN","YTQRQAD2",67,0)
 S YS(10)="9^"_NUM
"RTN","YTQRQAD2",68,0)
 S YS(11)="13^`"_$G(^XTMP(NODE,1,"location"))
"RTN","YTQRQAD2",69,0)
 ; TODO: add new field to admin file to hold consult
"RTN","YTQRQAD2",70,0)
 ; I $G(^XTMP(NODE,1,"consult")) S YS(12)="15^`"_^XTMP(NODE,1,"consult")
"RTN","YTQRQAD2",71,0)
 D EDAD^YTQAPI1(.YSDATA,.YS)
"RTN","YTQRQAD2",72,0)
 I YSDATA(1)'="[DATA]" D SETERROR^YTQRUTL(500,"Unable to create admin") Q 0
"RTN","YTQRQAD2",73,0)
 Q:'ADMIN $P(YSDATA(2),U,2) ; only non-null if new admin
"RTN","YTQRQAD2",74,0)
 Q ADMIN
"RTN","YTQRQAD2",75,0)
 ;
"RTN","YTQRQAD2",76,0)
GETADM(ARGS,RESULTS) ; get answers for administration identified by ARGS("adminId")
"RTN","YTQRQAD2",77,0)
 I '$G(ARGS("adminId")) D SETERROR^YTQRUTL(404,"Missing admin parameter") Q
"RTN","YTQRQAD2",78,0)
 I $D(^YTT(601.84,ARGS("adminId")))<10 D  Q
"RTN","YTQRQAD2",79,0)
 . D SETERROR^YTQRUTL(404,"Admin not found: "_ARGS("adminId"))
"RTN","YTQRQAD2",80,0)
 ;
"RTN","YTQRQAD2",81,0)
 N ADMIN,X0,TST,QID,ANS,CTNT,SEQ,TYP,VAL,TOT,NA,TMP,I,J,N,L
"RTN","YTQRQAD2",82,0)
 S ADMIN=ARGS("adminId"),X0=^YTT(601.84,ADMIN,0),TST=$P(X0,U,3)
"RTN","YTQRQAD2",83,0)
 S RESULTS("adminId")=ADMIN
"RTN","YTQRQAD2",84,0)
 S RESULTS("complete")=$S($P(X0,U,9)="Y":"true",1:"false")
"RTN","YTQRQAD2",85,0)
 S RESULTS("instrumentId")=TST
"RTN","YTQRQAD2",86,0)
 ; iterate through answers to get values and sort by sequence
"RTN","YTQRQAD2",87,0)
 S (TOT,NA)=0  ; total questions & not answered count
"RTN","YTQRQAD2",88,0)
 S QID=0 F  S QID=$O(^YTT(601.85,"AC",ADMIN,QID)) Q:'QID  D
"RTN","YTQRQAD2",89,0)
 . S CTNT=$O(^YTT(601.76,"AF",TST,QID,0))
"RTN","YTQRQAD2",90,0)
 . S SEQ=$P($G(^YTT(601.76,+CTNT,0)),U,3) S:'SEQ SEQ=1
"RTN","YTQRQAD2",91,0)
 . S TYP=+$P($G(^YTT(601.72,QID,2)),U,2)
"RTN","YTQRQAD2",92,0)
 . S ANS=0 F  S ANS=$O(^YTT(601.85,"AC",ADMIN,QID,ANS)) Q:'ANS  D
"RTN","YTQRQAD2",93,0)
 . . S VAL=$P(^YTT(601.85,ANS,0),U,4),TOT=TOT+1
"RTN","YTQRQAD2",94,0)
 . . I VAL="NOT ASKED"!(VAL=1155)!(VAL=1157) S NA=NA+1  ; skipped=not answered
"RTN","YTQRQAD2",95,0)
 . . I VAL="NOT ASKED" S TMP(+SEQ)=QID_U_"null" QUIT    ; not asked
"RTN","YTQRQAD2",96,0)
 . . I VAL=1155!(VAL=1156)!(VAL=1157) S TYP=1           ; skipped values
"RTN","YTQRQAD2",97,0)
 . . I TYP=1 S TMP(+SEQ)=QID_U_"c"_VAL QUIT             ; mult choice
"RTN","YTQRQAD2",98,0)
 . . S VAL=$G(^YTT(601.85,ANS,1,1,0))                   ; integer, etc.
"RTN","YTQRQAD2",99,0)
 . . I TYP'=5 S TMP(+SEQ)=QID_U_VAL QUIT
"RTN","YTQRQAD2",100,0)
 . . S (N,L)=0 F  S N=$O(^YTT(601.85,ANS,1,N)) Q:'N  D  ; memo fields
"RTN","YTQRQAD2",101,0)
 . . . S VAL=$G(^YTT(601.85,ANS,1,N,0))
"RTN","YTQRQAD2",102,0)
 . . . I '$D(TMP(+SEQ)) S TMP(+SEQ)=QID_U_$TR(VAL,"|",$C(10)) I 1
"RTN","YTQRQAD2",103,0)
 . . . E  S L=L+1,TMP(+SEQ,L)=$TR(VAL,"|",$C(10))
"RTN","YTQRQAD2",104,0)
 S RESULTS("progress")=$S(TOT>0:$P((((TOT-NA)/TOT)*100)+.5,"."),1:0)
"RTN","YTQRQAD2",105,0)
 ; now move sorted responses from TMP into "answers" nodes
"RTN","YTQRQAD2",106,0)
 S I="",N=0 F  S I=$O(TMP(I)) Q:'$L(I)  S N=N+1 D
"RTN","YTQRQAD2",107,0)
 . S RESULTS("answers",N,"id")="q"_$P(TMP(I),U)
"RTN","YTQRQAD2",108,0)
 . S RESULTS("answers",N,"value")=$P(TMP(I),U,2,999)
"RTN","YTQRQAD2",109,0)
 . I $D(TMP(I))>9 S J="",L=0 F  S J=$O(TMP(I,J)) Q:'$L(J)  S L=L+1 D
"RTN","YTQRQAD2",110,0)
 . . S RESULTS("answers",N,"value","\",L)=TMP(I,J)
"RTN","YTQRQAD2",111,0)
 Q
"RTN","YTQRQAD2",112,0)
TXT2ANS(IDX,QNUM) ; Convert web to ANS format for DATA(IDX)
"RTN","YTQRQAD2",113,0)
 ; expects DATA,ANS
"RTN","YTQRQAD2",114,0)
 N LEN,LN,NODE,J
"RTN","YTQRQAD2",115,0)
 S LEN=240,LN=0
"RTN","YTQRQAD2",116,0)
 S NODE=DATA("answers",IDX,"value")
"RTN","YTQRQAD2",117,0)
 D ADDSEGS(NODE)
"RTN","YTQRQAD2",118,0)
 I $D(DATA("answers",IDX,"value","\")) D
"RTN","YTQRQAD2",119,0)
 . F J=1:1 Q:'$D(DATA("answers",IDX,"value","\",J))  D
"RTN","YTQRQAD2",120,0)
 . . S NODE=DATA("answers",IDX,"value","\",J)
"RTN","YTQRQAD2",121,0)
 . . D ADDSEGS(NODE)
"RTN","YTQRQAD2",122,0)
 Q
"RTN","YTQRQAD2",123,0)
ADDSEGS(NODE) ; split text in node into LEN segments with "|" for newlines
"RTN","YTQRQAD2",124,0)
 ; expects DATA,ANS,LEN,LN
"RTN","YTQRQAD2",125,0)
 N I,X,END,FIRST,LAST
"RTN","YTQRQAD2",126,0)
 S END=$L(NODE),LAST=0 F I=0:1 D  Q:LAST>END   ; iterate thru each segment
"RTN","YTQRQAD2",127,0)
 . S FIRST=(I*LEN)+1,LAST=(I*LEN)+LEN,LN=LN+1  ; set first&last char positions
"RTN","YTQRQAD2",128,0)
 . S X=$TR($E(NODE,FIRST,LAST),$C(10),"|")     ; set segment, chg newline to |
"RTN","YTQRQAD2",129,0)
 . S ANS(QNUM,LN)=X
"RTN","YTQRQAD2",130,0)
 Q
"RTN","YTQRQAD2",131,0)
GETCHKS(ARGS,RESULTS) ; verify answer string & return check messages if needed
"RTN","YTQRQAD2",132,0)
 ;ARGS("q6440")="c2420"      -- may be choice id
"RTN","YTQRQAD2",133,0)
 ;ARGS("q6439")="08/07/2019" -- or literal
"RTN","YTQRQAD2",134,0)
 S RESULTS("count")=0
"RTN","YTQRQAD2",135,0)
 I ARGS("instrumentName")="BAM-C" D VERIFY^YTSBAMC(.ARGS,.RESULTS)
"RTN","YTQRQAD2",136,0)
 I ARGS("instrumentName")="BAM-R" D VERIFY^YTSBAMR(.ARGS,.RESULTS)
"RTN","YTQRQAD2",137,0)
 I ARGS("instrumentName")="BAM-IOP" D VERIFY^YTSBAMI(.ARGS,.RESULTS)
"RTN","YTQRQAD2",138,0)
 Q
"RTN","YTQRQAD3")
0^18^B21425312^n/a
"RTN","YTQRQAD3",1,0)
YTQRQAD3 ;SLC/KCM - RESTful Calls to set/get MHA administrations ; 1/25/2017
"RTN","YTQRQAD3",2,0)
 ;;5.01;MENTAL HEALTH;**130**;Dec 30, 1994;Build 62
"RTN","YTQRQAD3",3,0)
 ;
"RTN","YTQRQAD3",4,0)
 ; External Reference    ICR#
"RTN","YTQRQAD3",5,0)
 ; ------------------   -----
"RTN","YTQRQAD3",6,0)
 ; ^VA(200)             10060
"RTN","YTQRQAD3",7,0)
 ; DIQ                   2056
"RTN","YTQRQAD3",8,0)
 ; TIUCNSLT              5546
"RTN","YTQRQAD3",9,0)
 ; TIUPUTU               3351
"RTN","YTQRQAD3",10,0)
 ; TIUSRVA               5541
"RTN","YTQRQAD3",11,0)
 ;
"RTN","YTQRQAD3",12,0)
REPORT(ARGS,RESULTS) ; build report object identifed by ARGS("adminId")
"RTN","YTQRQAD3",13,0)
 N ADMIN S ADMIN=+$G(ARGS("adminId"))
"RTN","YTQRQAD3",14,0)
 I '$D(^YTT(601.84,ADMIN,0)) D SETERROR^YTQRUTL(404,"Admin not found: "_ADMIN) QUIT
"RTN","YTQRQAD3",15,0)
 S RESULTS("adminId")=ADMIN
"RTN","YTQRQAD3",16,0)
 D REPORT1(ADMIN,.RESULTS)
"RTN","YTQRQAD3",17,0)
 Q
"RTN","YTQRQAD3",18,0)
REPORT1(ADMIN,REPORT) ; fill in the report text for ADMIN
"RTN","YTQRQAD3",19,0)
 N I,REPORT
"RTN","YTQRQAD3",20,0)
 D BLDRPT^YTQRRPT(.REPORT,ADMIN)
"RTN","YTQRQAD3",21,0)
 S RESULTS("text")=$G(REPORT(1))_$C(13,10)
"RTN","YTQRQAD3",22,0)
 S I=1 F  S I=$O(REPORT(I)) Q:'I  S RESULTS("text","\",I-1)=REPORT(I)_$C(13,10)
"RTN","YTQRQAD3",23,0)
 Q
"RTN","YTQRQAD3",24,0)
GETNOTE(ARGS,RESULTS) ; build note object based on ARGS("adminId")
"RTN","YTQRQAD3",25,0)
 N ADMIN S ADMIN=$G(ARGS("adminId"))
"RTN","YTQRQAD3",26,0)
 I '$D(^YTT(601.84,ADMIN,0)) D SETERROR^YTQRUTL(404,"Admin not found: "_ADMIN) QUIT
"RTN","YTQRQAD3",27,0)
 N CONSULT S CONSULT=$P(^YTT(601.84,ADMIN,0),U,13)
"RTN","YTQRQAD3",28,0)
 S RESULTS("adminId")=ADMIN
"RTN","YTQRQAD3",29,0)
 S RESULTS("consultId")=$S(+CONSULT:CONSULT,1:"null")
"RTN","YTQRQAD3",30,0)
 S RESULTS("allowNote")=$$ALWNOTE(ADMIN)
"RTN","YTQRQAD3",31,0)
 S RESULTS("requireCosigner")=$$REQCSGN(ADMIN)
"RTN","YTQRQAD3",32,0)
 S RESULTS("cosigner")="null"
"RTN","YTQRQAD3",33,0)
 I RESULTS("allowNote")="true" D REPORT1(ADMIN,.RESULTS) I 1
"RTN","YTQRQAD3",34,0)
 E  S RESULTS("text")="null"
"RTN","YTQRQAD3",35,0)
 Q
"RTN","YTQRQAD3",36,0)
SETNOTE(ARGS,DATA) ; save note in DATA("text") using ARGS("adminId")
"RTN","YTQRQAD3",37,0)
 N YS,YSDATA,ADMIN,CONSULT
"RTN","YTQRQAD3",38,0)
 S ADMIN=$G(DATA("adminId"))
"RTN","YTQRQAD3",39,0)
 S CONSULT=$P(^YTT(601.84,ADMIN,0),U,13)
"RTN","YTQRQAD3",40,0)
 I '$D(^YTT(601.84,ADMIN,0)) D SETERROR^YTQRUTL(404,"Admin not found: "_ADMIN) QUIT ""
"RTN","YTQRQAD3",41,0)
 D TXT2LN(.DATA,.YS) ; parse by CRLF and set YS(#) to note text
"RTN","YTQRQAD3",42,0)
 S YS("AD")=ADMIN
"RTN","YTQRQAD3",43,0)
 I +$G(DATA("cosigner")) D  I $G(YTQRERRS) QUIT ""
"RTN","YTQRQAD3",44,0)
 . N YSCSGN S YSCSGN=DATA("cosigner")
"RTN","YTQRQAD3",45,0)
 . S YS("COSIGNER")=YSCSGN
"RTN","YTQRQAD3",46,0)
 . I $$REQCSGN(ADMIN,YSCSGN)="true" D  ; cosigner can't require cosigner
"RTN","YTQRQAD3",47,0)
 . . S YSCSGN=$$GET1^DIQ(200,YSCSGN_",",.01)
"RTN","YTQRQAD3",48,0)
 . . D SETERROR^YTQRUTL(500,YSCSGN_" not allowed to cosign.")
"RTN","YTQRQAD3",49,0)
 I CONSULT S YS("CON")=CONSULT D CCREATE^YTQCONS(.YSDATA,.YS) I 1
"RTN","YTQRQAD3",50,0)
 E  D PCREATE^YTQTIU(.YSDATA,.YS)
"RTN","YTQRQAD3",51,0)
 I YSDATA(1)'="[DATA]" D SETERROR^YTQRUTL(500,"Note not saved") Q ""
"RTN","YTQRQAD3",52,0)
 Q "/api/mha/instrument/note/"_$G(YSDATA(2))
"RTN","YTQRQAD3",53,0)
 ;
"RTN","YTQRQAD3",54,0)
ALWNOTE(ADMIN) ; return "true" if note could/should be saved
"RTN","YTQRQAD3",55,0)
 N TEST,TITLE,CONSULT,Y,YSISC,YSTITLE
"RTN","YTQRQAD3",56,0)
 S TEST=$P(^YTT(601.84,ADMIN,0),U,3) Q:'TEST "false" ; missing test
"RTN","YTQRQAD3",57,0)
 I $L($P($G(^YTT(601.71,TEST,2)),U)) Q "false"       ; R PRIVILEGE
"RTN","YTQRQAD3",58,0)
 I $P($G(^YTT(601.71,TEST,8)),U,8)'="Y" Q "false"    ; gen note
"RTN","YTQRQAD3",59,0)
 S CONSULT=$P(^YTT(601.84,ADMIN,0),U,13)
"RTN","YTQRQAD3",60,0)
 I CONSULT D  I 1
"RTN","YTQRQAD3",61,0)
 . S YSTITLE=$$GET1^DIQ(601.71,TEST_",",30,"E")
"RTN","YTQRQAD3",62,0)
 . S Y=$$WHATITLE^TIUPUTU(YSTITLE)
"RTN","YTQRQAD3",63,0)
 . D ISCNSLT^TIUCNSLT(.YSISC,+Y)
"RTN","YTQRQAD3",64,0)
 . I 'YSISC S YSTITLE="MHA CONSULT"
"RTN","YTQRQAD3",65,0)
 E  S YSTITLE=$$GET1^DIQ(601.71,TEST_",",29,"E")
"RTN","YTQRQAD3",66,0)
 I $$WHATITLE^TIUPUTU(YSTITLE)'>0 Q "false"          ; bad note title
"RTN","YTQRQAD3",67,0)
 Q "true"
"RTN","YTQRQAD3",68,0)
 ;
"RTN","YTQRQAD3",69,0)
NOTE4PT(ADMIN) ; create a progress note for a patient-entered admin
"RTN","YTQRQAD3",70,0)
 N CONSULT,YS,YSDATA
"RTN","YTQRQAD3",71,0)
 I $$ALWNOTE(ADMIN)'="true" QUIT
"RTN","YTQRQAD3",72,0)
 D BLDRPT^YTQRRPT(.YS,ADMIN,79)
"RTN","YTQRQAD3",73,0)
 S CONSULT=$P(^YTT(601.84,ADMIN,0),U,13)
"RTN","YTQRQAD3",74,0)
 S YS("AD")=ADMIN
"RTN","YTQRQAD3",75,0)
 I CONSULT S YS("CON")=CONSULT D CCREATE^YTQCONS(.YSDATA,.YS) I 1
"RTN","YTQRQAD3",76,0)
 E  D PCREATE^YTQTIU(.YSDATA,.YS)
"RTN","YTQRQAD3",77,0)
 I YSDATA(1)'="[DATA]" D SETERROR^YTQRUTL(500,"Note not saved") Q
"RTN","YTQRQAD3",78,0)
 Q
"RTN","YTQRQAD3",79,0)
ALWCSGN(ARGS,RESULTS) ; GET /api/mha/permission/cosign/:adminId/:userId
"RTN","YTQRQAD3",80,0)
 N ADMIN,COSIGNER,NEEDCSGN
"RTN","YTQRQAD3",81,0)
 S ADMIN=$G(ARGS("adminId"))
"RTN","YTQRQAD3",82,0)
 S COSIGNER=$G(ARGS("userId"))
"RTN","YTQRQAD3",83,0)
 S NEEDCSGN=$$REQCSGN(ADMIN,COSIGNER)
"RTN","YTQRQAD3",84,0)
 S RESULTS("userId")=COSIGNER
"RTN","YTQRQAD3",85,0)
 S RESULTS("allowedToCosign")=$S(NEEDCSGN="true":"false",1:"true")
"RTN","YTQRQAD3",86,0)
 Q
"RTN","YTQRQAD3",87,0)
REQCSGN(ADMIN,COSIGNER) ; return "true" if this user requires a cosigner
"RTN","YTQRQAD3",88,0)
 ; if cosigner is passed in, use that instead of orderedBy
"RTN","YTQRQAD3",89,0)
 N TEST,YSCREQ,YSTITLE,YSPERSON,X0
"RTN","YTQRQAD3",90,0)
 S X0=$G(^YTT(601.84,ADMIN,0))
"RTN","YTQRQAD3",91,0)
 S YSPERSON=$G(COSIGNER,$P(X0,U,6)) ; either cosigner or orderedBy
"RTN","YTQRQAD3",92,0)
 S TEST=$P(X0,U,3),CONSULT=$P(X0,U,13)
"RTN","YTQRQAD3",93,0)
 ; TODO:  account for the MHA CONSULT title
"RTN","YTQRQAD3",94,0)
 S YSTITLE=$S(CONSULT:$P($G(^YTT(601.71,TEST,8)),U,10),1:$P($G(^YTT(601.71,TEST,8)),U,9))
"RTN","YTQRQAD3",95,0)
 D REQCOS^TIUSRVA(.YSCREQ,YSTITLE,"",YSPERSON,"")
"RTN","YTQRQAD3",96,0)
 Q $S(YSCREQ:"true",1:"false")
"RTN","YTQRQAD3",97,0)
 ;
"RTN","YTQRQAD3",98,0)
TXT2LN(SRC,DEST) ; Move CRLF delimited text from .SRC into WP lines in .DEST
"RTN","YTQRQAD3",99,0)
 N IDEST,CRLF,REMAIN
"RTN","YTQRQAD3",100,0)
 S IDEST=0,CRLF=$C(13,10)
"RTN","YTQRQAD3",101,0)
 S REMAIN=$$PARSLN(SRC("text"))
"RTN","YTQRQAD3",102,0)
 I '$D(SRC("text","\",1)),$L(REMAIN) D  QUIT  ; done since no continue nodes
"RTN","YTQRQAD3",103,0)
 . S IDEST=IDEST+1,DEST(IDEST)=REMAIN
"RTN","YTQRQAD3",104,0)
 N J                                          ; handle continue nodes
"RTN","YTQRQAD3",105,0)
 S J=0 F  S J=$O(SRC("text","\",J)) Q:'J  D
"RTN","YTQRQAD3",106,0)
 . S REMAIN=$$PARSLN(REMAIN_SRC("text","\",J))
"RTN","YTQRQAD3",107,0)
 I $L(REMAIN) S IDEST=IDEST+1,DEST(IDEST)=REMAIN
"RTN","YTQRQAD3",108,0)
 Q
"RTN","YTQRQAD3",109,0)
PARSLN(TXT) ; Return remainder after parsing text into lines
"RTN","YTQRQAD3",110,0)
 ; expects: CRLF, DEST, IDEST
"RTN","YTQRQAD3",111,0)
 N X S X=TXT
"RTN","YTQRQAD3",112,0)
 I '$L(X) Q ""
"RTN","YTQRQAD3",113,0)
 F  S IDEST=IDEST+1,DEST(IDEST)=$P(X,CRLF),X=$P(X,CRLF,2,99999) Q:X'[CRLF
"RTN","YTQRQAD3",114,0)
 Q X
"RTN","YTQRQAD3",115,0)
 ;
"RTN","YTQRRPC")
0^13^B6690032^n/a
"RTN","YTQRRPC",1,0)
YTQRRPC ;SLC/KCM - Other RPC Calls for MHA ; 1/25/2017
"RTN","YTQRRPC",2,0)
 ;;5.01;MENTAL HEALTH;**130**;Dec 30, 1994;Build 62
"RTN","YTQRRPC",3,0)
 ;
"RTN","YTQRRPC",4,0)
 ; External Reference    ICR#
"RTN","YTQRRPC",5,0)
 ; ------------------   -----
"RTN","YTQRRPC",6,0)
 ; HOSPLOC^ORWU          1816
"RTN","YTQRRPC",7,0)
 ; NEWPERS^ORWU          1836
"RTN","YTQRRPC",8,0)
 ;
"RTN","YTQRRPC",9,0)
SELECT(YTQRRSP,REQ) ; Controller for patient select screen
"RTN","YTQRRPC",10,0)
 N I,CMD,PARAMS
"RTN","YTQRRPC",11,0)
 S CMD=$G(REQ(1))
"RTN","YTQRRPC",12,0)
 S I=1 F  S I=$O(REQ(I)) Q:'I  S PARAMS($P(REQ(I),"="))=$P(REQ(I),"=",2,99)
"RTN","YTQRRPC",13,0)
 ;
"RTN","YTQRRPC",14,0)
 ; switch on CMD
"RTN","YTQRRPC",15,0)
 ; ---------------------------------
"RTN","YTQRRPC",16,0)
 ; getCurrentUser ==> duz^username
"RTN","YTQRRPC",17,0)
 I CMD="getCurrentUser" D  G OUT
"RTN","YTQRRPC",18,0)
 . D USERINFO^YTQRIS(.YTQRRSP)
"RTN","YTQRRPC",19,0)
 ; ---------------------------------
"RTN","YTQRRPC",20,0)
 ; getPatientInfo ==> lastname,firstname^PID
"RTN","YTQRRPC",21,0)
 I CMD="getPatientInfo" D  G OUT
"RTN","YTQRRPC",22,0)
 . D PTINFO^YTQRIS(.YTQRRSP,$$VAL("patientId"))
"RTN","YTQRRPC",23,0)
 ; ---------------------------------
"RTN","YTQRRPC",24,0)
 ; subsetOfPersons ==> [ien^name^- organization] 
"RTN","YTQRRPC",25,0)
 I CMD="subsetOfPersons" D  G OUT
"RTN","YTQRRPC",26,0)
 . D NEWPERS^ORWU(.YTQRRSP,$$VAL("startFrom"),$$VAL("direction"))
"RTN","YTQRRPC",27,0)
 ; ---------------------------------
"RTN","YTQRRPC",28,0)
 ; subsetOfLocations ==> [ien^locationName] 
"RTN","YTQRRPC",29,0)
 I CMD="subsetOfLocations" D  G OUT
"RTN","YTQRRPC",30,0)
 . D HOSPLOC^ORWU(.YTQRRSP,$$VAL("startFrom"),$$VAL("direction"))
"RTN","YTQRRPC",31,0)
 ; ---------------------------------
"RTN","YTQRRPC",32,0)
 ; listAvailable(patientId,userId) ==> [type^displayText^identifier]
"RTN","YTQRRPC",33,0)
 I CMD="listAvailable" D  G OUT
"RTN","YTQRRPC",34,0)
 . D AVAIL^YTQRIS(.YTQRRSP,$$VAL("patientId"),$$VAL("userId"))
"RTN","YTQRRPC",35,0)
 ; --------------------------------- 
"RTN","YTQRRPC",36,0)
 ; deleteAssignment(itemType,identifier) ==> ok or errorMsg
"RTN","YTQRRPC",37,0)
 I CMD="deleteAssignment" D  G OUT
"RTN","YTQRRPC",38,0)
 . D DELASMT^YTQRIS(.YTQRRSP,$$VAL("itemType"),$$VAL("identifier"))
"RTN","YTQRRPC",39,0)
 ; ---------------------------------
"RTN","YTQRRPC",40,0)
 ; listAssignments(patientId,userId) ==> [displayText^pin^test|adminId^...]
"RTN","YTQRRPC",41,0)
 I CMD="listActiveAssignments" D  G OUT
"RTN","YTQRRPC",42,0)
 . D ACTIVE^YTQRIS(.YTQRRSP,$$VAL("patientId"),$$VAL("userId"))
"RTN","YTQRRPC",43,0)
 ; ---------------------------------
"RTN","YTQRRPC",44,0)
 ; deleteAssignment2(pin,admins) ==> ok or errorMsg
"RTN","YTQRRPC",45,0)
 I CMD="deleteAssignment2" D  G OUT
"RTN","YTQRRPC",46,0)
 . D DELASMT2^YTQRIS(.YTQRRSP,$$VAL("pin"),$$VAL("admins"))
"RTN","YTQRRPC",47,0)
 ; --------------------------------- 
"RTN","YTQRRPC",48,0)
 ; describeAssignment(pin,admins) ==> [text]
"RTN","YTQRRPC",49,0)
 I CMD="describeAssignment" D  G OUT
"RTN","YTQRRPC",50,0)
 . D DESCRIBE^YTQRIS(.YTQRRSP,$$VAL("pin"),$$VAL("admins"))
"RTN","YTQRRPC",51,0)
 ; --------------------------------- 
"RTN","YTQRRPC",52,0)
 ; validateInstruments(mode,orderedBy,tests) ==> ok or errorMsg
"RTN","YTQRRPC",53,0)
 I CMD="validateInstruments" D  G OUT
"RTN","YTQRRPC",54,0)
 . D VALTSTS^YTQRIS(.YTQRRSP,$$VAL("mode"),$$VAL("orderedBy"),$$VAL("tests"))
"RTN","YTQRRPC",55,0)
 ; ---------------------------------
"RTN","YTQRRPC",56,0)
 ; listCategories ==> [categoryName]
"RTN","YTQRRPC",57,0)
 I CMD="listCategories" D  G OUT
"RTN","YTQRRPC",58,0)
 . D ACTCAT^YTQRIS(.YTQRRSP)
"RTN","YTQRRPC",59,0)
 ; ---------------------------------
"RTN","YTQRRPC",60,0)
 ; listByCategory(category) ==> root=TEST1^TEST2^...
"RTN","YTQRRPC",61,0)
 I CMD="listByCategory" D  G OUT
"RTN","YTQRRPC",62,0)
 . D INBYCAT^YTQRIS(.YTQRRSP,$$VAL("category"))
"RTN","YTQRRPC",63,0)
 ; ---------------------------------
"RTN","YTQRRPC",64,0)
 ; else
"RTN","YTQRRPC",65,0)
 S YTQRRSP(1)="Error: command not found"
"RTN","YTQRRPC",66,0)
 ;
"RTN","YTQRRPC",67,0)
OUT ; end of switch statement 
"RTN","YTQRRPC",68,0)
 Q
"RTN","YTQRRPC",69,0)
 ;
"RTN","YTQRRPC",70,0)
VAL(X) ; return value from request
"RTN","YTQRRPC",71,0)
 ; expects PARAMS
"RTN","YTQRRPC",72,0)
 Q $G(PARAMS(X))
"RTN","YTQRRPC",73,0)
 ;
"RTN","YTQRRPC",74,0)
TEST ;
"RTN","YTQRRPC",75,0)
 N REQ,RSP
"RTN","YTQRRPC",76,0)
 S REQ(1)="listActiveAssignments"
"RTN","YTQRRPC",77,0)
 S REQ(2)="patientId=100662"
"RTN","YTQRRPC",78,0)
 S REQ(3)="userId=1085"
"RTN","YTQRRPC",79,0)
 ;S REQ(1)="getCurrentUser"
"RTN","YTQRRPC",80,0)
 D SELECT(.RSP,.REQ)
"RTN","YTQRRPC",81,0)
 ;W ! ZW RSP
"RTN","YTQRRPC",82,0)
 Q
"RTN","YTQRRPT")
0^11^B35953484^n/a
"RTN","YTQRRPT",1,0)
YTQRRPT ;SLC/LLH - Report Builder ; 08/13/2018
"RTN","YTQRRPT",2,0)
 ;;5.01;MENTAL HEALTH;**130**;Dec 30, 1994;Build 62
"RTN","YTQRRPT",3,0)
 ;
"RTN","YTQRRPT",4,0)
 ; External Reference    ICR#
"RTN","YTQRRPT",5,0)
 ; ------------------   -----
"RTN","YTQRRPT",6,0)
 ; DIQ                   2056
"RTN","YTQRRPT",7,0)
 ; XLFDT                10103
"RTN","YTQRRPT",8,0)
 ; XLFNAME               3065
"RTN","YTQRRPT",9,0)
 ; XLFSTR               10104
"RTN","YTQRRPT",10,0)
 ;
"RTN","YTQRRPT",11,0)
BLDRPT(RESULTS,ADMIN,MAXWIDTH) ;
"RTN","YTQRRPT",12,0)
 N ADATA,ANS,INST,LP,PDATA,RPT,RSTR,SCL,SWAP,YSDATA,YS
"RTN","YTQRRPT",13,0)
 I '$D(^YTT(601.84,ADMIN,0)) D SETERROR^YTQRUTL(404,"Not Found: "_ADMIN) Q
"RTN","YTQRRPT",14,0)
 S INST=$P(^YTT(601.84,ADMIN,0),U,3)
"RTN","YTQRRPT",15,0)
 I $P($G(^YTT(601.71,INST,8)),U,3)="Y" D  QUIT  ; call legacy report
"RTN","YTQRRPT",16,0)
 . N I,J
"RTN","YTQRRPT",17,0)
 . S YS("AD")=ADMIN
"RTN","YTQRRPT",18,0)
 . D LEGACY^YTQAPI8(.YSDATA,.YS)
"RTN","YTQRRPT",19,0)
 . ; only have 1 empty line at the top
"RTN","YTQRRPT",20,0)
 . S I=0 F  S I=$O(^TMP("YSDATA",$J,1,I)) Q:'I  Q:$L(^TMP("YSDATA",$J,1,I))
"RTN","YTQRRPT",21,0)
 . S I=I-2,J=0 F  S I=$O(^TMP("YSDATA",$J,1,I)) Q:'I  S J=J+1,RESULTS(J)=^(I)
"RTN","YTQRRPT",22,0)
 ; continue here if not legacy report
"RTN","YTQRRPT",23,0)
 I '$D(^YTT(601.93,"C",INST)) D SETERROR^YTQRUTL(404,"Not Found: "_INST) Q
"RTN","YTQRRPT",24,0)
 S RPT=$O(^YTT(601.93,"C",INST,"")) I '$G(RPT) D SETERROR^YTQRUTL(404,"Not Found: "_INST) Q 
"RTN","YTQRRPT",25,0)
 S YS("AD")=ADMIN
"RTN","YTQRRPT",26,0)
 K ^TMP($J)
"RTN","YTQRRPT",27,0)
 D ADMINFO(.ADATA,ADMIN)          ;get Administration information
"RTN","YTQRRPT",28,0)
 D PATINFO(.PDATA,ADATA("DFN"))   ;get Patient demographic information
"RTN","YTQRRPT",29,0)
 D SWAPIT                         ;load report variables with data
"RTN","YTQRRPT",30,0)
 D GETSCORE^YTQAPI8(.YSDATA,.YS)  ;get scale scores
"RTN","YTQRRPT",31,0)
 D SETSCL                         ;put in array to swap values
"RTN","YTQRRPT",32,0)
 D ALLANS^YTQAPI2(.YSDATA,.YS)    ;get answers
"RTN","YTQRRPT",33,0)
 D SWAPANS                        ;load report answer vars with data
"RTN","YTQRRPT",34,0)
 D LOADTLT(.RSTR,RPT)             ;load the report template
"RTN","YTQRRPT",35,0)
 I '$D(RSTR) D SETERROR^YTQRUTL(404,"Not Found: "_RPT) Q
"RTN","YTQRRPT",36,0)
 I $G(MAXWIDTH)>1 D WRAPTLT(.RSTR,MAXWIDTH) ; wrap for progress notes
"RTN","YTQRRPT",37,0)
 D GETDATA                        ;insert the data from the answer vars
"RTN","YTQRRPT",38,0)
 ;Loop back through completed array to replace "|" (line feeds) with a blank line with a space
"RTN","YTQRRPT",39,0)
 D FIXP(.RSTR,.RESULTS)
"RTN","YTQRRPT",40,0)
 Q
"RTN","YTQRRPT",41,0)
LOADTLT(TLT,RPT) ; Load template for RPT into .TLT split by "|" chars
"RTN","YTQRRPT",42,0)
 N LP,LN,FRAG,X,START,END
"RTN","YTQRRPT",43,0)
 S LN=0,FRAG=""
"RTN","YTQRRPT",44,0)
 S LP=0 F  S LP=$O(^YTT(601.93,RPT,1,LP)) Q:'LP  D
"RTN","YTQRRPT",45,0)
 . S X=^YTT(601.93,RPT,1,LP,0)
"RTN","YTQRRPT",46,0)
 . I LP=1,($E(X)="|") S X=$E(X,2,$L(X)) ; drop initial line feed
"RTN","YTQRRPT",47,0)
 . I X["$~" S X=$P(X,"$~"),LP=9999999   ; $~ marks end of report
"RTN","YTQRRPT",48,0)
 . S START=0 F  S END=$F(X,"|",START) D  Q:'START
"RTN","YTQRRPT",49,0)
 . . I END D  Q
"RTN","YTQRRPT",50,0)
 . . . S LN=LN+1
"RTN","YTQRRPT",51,0)
 . . . S TLT(LN)=FRAG_$E(X,START,END-2)
"RTN","YTQRRPT",52,0)
 . . . I TLT(LN)="." S TLT(LN)=" "
"RTN","YTQRRPT",53,0)
 . . . S TLT(LN)=TLT(LN)_"|"
"RTN","YTQRRPT",54,0)
 . . . S FRAG="",START=END
"RTN","YTQRRPT",55,0)
 . . E  D
"RTN","YTQRRPT",56,0)
 . . . S FRAG=FRAG_$E(X,START,$L(X))
"RTN","YTQRRPT",57,0)
 . . . S START=0
"RTN","YTQRRPT",58,0)
 I $L(FRAG) S LN=LN+1,TLT(LN)=FRAG_"|"
"RTN","YTQRRPT",59,0)
 Q
"RTN","YTQRRPT",60,0)
WRAPTLT(TLT,MAX) ; Wrap lines in TLT that are >WIDTH by adding "|" chars
"RTN","YTQRRPT",61,0)
 N I
"RTN","YTQRRPT",62,0)
 S I=0 F  S I=$O(TLT(I)) Q:'I  I $L(TLT(I))'<MAX S TLT(I)=$$WRAP(TLT(I),MAX)
"RTN","YTQRRPT",63,0)
 Q
"RTN","YTQRRPT",64,0)
FIXP(RSTR,RESULTS) ;
"RTN","YTQRRPT",65,0)
 N LP,LN,FRAG,START,END
"RTN","YTQRRPT",66,0)
 S LN=0,FRAG=""
"RTN","YTQRRPT",67,0)
 S LP=0 F  S LP=$O(RSTR(LP)) Q:'LP  D
"RTN","YTQRRPT",68,0)
 . S START=0 F  S END=$F(RSTR(LP),"|",START) D  Q:'START
"RTN","YTQRRPT",69,0)
 . . I END D  Q
"RTN","YTQRRPT",70,0)
 . . . S LN=LN+1
"RTN","YTQRRPT",71,0)
 . . . S RESULTS(LN)=FRAG_$E(RSTR(LP),START,END-2)
"RTN","YTQRRPT",72,0)
 . . . I RESULTS(LN)="." S RESULTS(LN)=" "
"RTN","YTQRRPT",73,0)
 . . . S FRAG="",START=END
"RTN","YTQRRPT",74,0)
 . . E  D
"RTN","YTQRRPT",75,0)
 . . . S FRAG=FRAG_$E(RSTR(LP),START,$L(RSTR(LP)))
"RTN","YTQRRPT",76,0)
 . . . S START=0
"RTN","YTQRRPT",77,0)
 Q
"RTN","YTQRRPT",78,0)
GETDATA ;
"RTN","YTQRRPT",79,0)
 N LP
"RTN","YTQRRPT",80,0)
 S LP=0 F  S LP=$O(RSTR(LP)) Q:'LP  S RSTR(LP)=$$REPLACE^XLFSTR(RSTR(LP),.SWAP)
"RTN","YTQRRPT",81,0)
 Q
"RTN","YTQRRPT",82,0)
ADMINFO(ADATA,ADMIN) ;
"RTN","YTQRRPT",83,0)
 N CLIN,DATA,MYNAME
"RTN","YTQRRPT",84,0)
 S DATA=^YTT(601.84,ADMIN,0)
"RTN","YTQRRPT",85,0)
 S CLIN=$$GET1^DIQ(601.84,ADMIN_",",5,"I")
"RTN","YTQRRPT",86,0)
 S MYNAME("FILE")=200
"RTN","YTQRRPT",87,0)
 S MYNAME("FIELD")=.01
"RTN","YTQRRPT",88,0)
 S MYNAME("IENS")=CLIN_","
"RTN","YTQRRPT",89,0)
 S ADATA("DFN")=$P($G(^YTT(601.84,ADMIN,0)),U,2)
"RTN","YTQRRPT",90,0)
 S ADATA("DATE")=$$FMTE^XLFDT($P($P($G(^YTT(601.84,ADMIN,0)),U,4),"."),1)  ; Date Given
"RTN","YTQRRPT",91,0)
 S ADATA("ORDERED")=$$NAMEFMT^XLFNAME(.MYNAME,"F","MCXc")         ;Ordered by
"RTN","YTQRRPT",92,0)
 S ADATA("LOC")=$$TITLE^XLFSTR($$GET1^DIQ(601.84,ADMIN_",",13))   ;Location
"RTN","YTQRRPT",93,0)
 Q
"RTN","YTQRRPT",94,0)
PATINFO(PDATA,DFN) ;
"RTN","YTQRRPT",95,0)
 N YS,YSDATA,MYNAME
"RTN","YTQRRPT",96,0)
 I '$G(DFN) Q
"RTN","YTQRRPT",97,0)
 S YS("DFN")=DFN
"RTN","YTQRRPT",98,0)
 S MYNAME("FILE")=2
"RTN","YTQRRPT",99,0)
 S MYNAME("FIELD")=.01
"RTN","YTQRRPT",100,0)
 S MYNAME("IENS")=DFN_","
"RTN","YTQRRPT",101,0)
 D PATSEL^YTQAPI9(.YSDATA,.YS)
"RTN","YTQRRPT",102,0)
 S PDATA("NM")=$$NAMEFMT^XLFNAME(.MYNAME,"F","MCXc")
"RTN","YTQRRPT",103,0)
 S PDATA("SSN")="xxx-xx-"_$P($P(YSDATA(3),U,2),"-",3)
"RTN","YTQRRPT",104,0)
 S PDATA("DOB")=$P(YSDATA(4),U,2)
"RTN","YTQRRPT",105,0)
 S PDATA("AGE")=$P(YSDATA(5),U)
"RTN","YTQRRPT",106,0)
 S PDATA("GENDER")=$$SENTENCE^XLFSTR($P(YSDATA(6),U,2))
"RTN","YTQRRPT",107,0)
 K VA
"RTN","YTQRRPT",108,0)
 Q
"RTN","YTQRRPT",109,0)
SWAPIT ;
"RTN","YTQRRPT",110,0)
 N LP,TXT
"RTN","YTQRRPT",111,0)
 F LP=1:1 S TXT=$T(SWAP+LP) Q:TXT["zzzzz"  S SWAP($P(TXT,";;",2))=@($P(TXT,";;",3))
"RTN","YTQRRPT",112,0)
 S SWAP("<.DLL_String.>")="Complex Instrument"
"RTN","YTQRRPT",113,0)
 Q 
"RTN","YTQRRPT",114,0)
SWAP ;
"RTN","YTQRRPT",115,0)
 ;;<.Date_Given.>;;ADATA("DATE")
"RTN","YTQRRPT",116,0)
 ;;<.Staff_Ordered_By.>;;ADATA("ORDERED")
"RTN","YTQRRPT",117,0)
 ;;<.Location.>;;ADATA("LOC")
"RTN","YTQRRPT",118,0)
 ;;<.Patient_Name_Last_First.>;;PDATA("NM")
"RTN","YTQRRPT",119,0)
 ;;<.Patient_SSN.>;;PDATA("SSN")
"RTN","YTQRRPT",120,0)
 ;;<.Patient_Date_Of_Birth.>;;PDATA("DOB")
"RTN","YTQRRPT",121,0)
 ;;<.Patient_Age.>;;PDATA("AGE")
"RTN","YTQRRPT",122,0)
 ;;<.Patient_Gender.>;;PDATA("GENDER")
"RTN","YTQRRPT",123,0)
 ;;zzzzz
"RTN","YTQRRPT",124,0)
 Q
"RTN","YTQRRPT",125,0)
SWAPANS ;
"RTN","YTQRRPT",126,0)
 N ANS,LP,STR
"RTN","YTQRRPT",127,0)
 F ANS=7771:1:7787 S SWAP("<*Answer_"_ANS_"*>")=""  ; default for computed
"RTN","YTQRRPT",128,0)
 I '$D(YSDATA)!($G(YSDATA(1))'="[DATA]") Q
"RTN","YTQRRPT",129,0)
 S LP=2 F  S LP=$O(YSDATA(LP)) Q:'LP  D
"RTN","YTQRRPT",130,0)
 .S STR=YSDATA(LP)
"RTN","YTQRRPT",131,0)
 .S ANS=$P(STR,U)
"RTN","YTQRRPT",132,0)
 .I ANS=999999999999 S SWAP("<*Answer_"_ANS_"*>")=$P(STR,U,3) Q
"RTN","YTQRRPT",133,0)
 .I $P(STR,U,2)[";" S SWAP("<*Answer_"_ANS_"*>")=$G(SWAP("<*Answer_"_ANS_"*>"))_$P(STR,U,3) Q
"RTN","YTQRRPT",134,0)
 .S SWAP("<*Answer_"_ANS_"*>")=$$GET1^DIQ(601.75,$P(STR,U,3)_",",3)
"RTN","YTQRRPT",135,0)
 ; loop thru SWAP array & make sure all responses wrapped to 80 chars
"RTN","YTQRRPT",136,0)
 S ANS="" F  S ANS=$O(SWAP(ANS)) Q:'$L(ANS)  D
"RTN","YTQRRPT",137,0)
 . I $L(SWAP(ANS))'>80 Q              ; already under 80 chars
"RTN","YTQRRPT",138,0)
 . I ANS="<*Answer_999999999999*>" Q  ; DLLStr already wrapped
"RTN","YTQRRPT",139,0)
 . S SWAP(ANS)=$$WRAP(SWAP(ANS),80)   ; wrap by adding | chars
"RTN","YTQRRPT",140,0)
 Q
"RTN","YTQRRPT",141,0)
SETSCL ;
"RTN","YTQRRPT",142,0)
 N LP,STR
"RTN","YTQRRPT",143,0)
 I '$D(^TMP($J,"YSCOR")) Q
"RTN","YTQRRPT",144,0)
 F LP=2:1 Q:('$D(^TMP($J,"YSCOR",LP)))!($G(^TMP($J,"YSCOR",1))="[ERROR]")  D
"RTN","YTQRRPT",145,0)
 .S STR=$G(^TMP($J,"YSCOR",LP))
"RTN","YTQRRPT",146,0)
 .S SWAP("<-"_$P(STR,"=")_"->")=$P($P(STR,"=",2),U) ; use raw score
"RTN","YTQRRPT",147,0)
 Q
"RTN","YTQRRPT",148,0)
WRAP(TX,MAX) ; If length of TX > MAX, wrap by adding | chars
"RTN","YTQRRPT",149,0)
 N OUT,I,J,X,Y,YNEW
"RTN","YTQRRPT",150,0)
 F I=1:1:$L(TX,"|") S X=$P(TX,"|",I) D
"RTN","YTQRRPT",151,0)
 . I $L(X)'>MAX D ADDOUT(X) QUIT
"RTN","YTQRRPT",152,0)
 . S Y=""
"RTN","YTQRRPT",153,0)
 . F J=1:1:$L(X," ") D
"RTN","YTQRRPT",154,0)
 . . S YNEW=Y_$S(J=1:"",1:" ")_$P(X," ",J)
"RTN","YTQRRPT",155,0)
 . . I $L(YNEW)>MAX D ADDOUT(Y) S Y=$P(X," ",J) I 1
"RTN","YTQRRPT",156,0)
 . . E  S Y=YNEW
"RTN","YTQRRPT",157,0)
 . D ADDOUT(Y) ; add any remaining
"RTN","YTQRRPT",158,0)
 S X="",I=0 F  S I=$O(OUT(I)) Q:'I  S X=X_$S(I=1:"",1:"|")_OUT(I)
"RTN","YTQRRPT",159,0)
 Q X
"RTN","YTQRRPT",160,0)
 ;
"RTN","YTQRRPT",161,0)
ADDOUT(S) ; add string to out array (expects OUT)
"RTN","YTQRRPT",162,0)
 S OUT=+$G(OUT)+1,OUT(OUT)=S
"RTN","YTQRRPT",163,0)
 Q
"RTN","YTQRUTL")
0^6^B67291165^n/a
"RTN","YTQRUTL",1,0)
YTQRUTL ;SLC/KCM - RESTful API Utilities ; 1/25/2017
"RTN","YTQRUTL",2,0)
 ;;5.01;MENTAL HEALTH;**130**;Dec 30, 1994;Build 62
"RTN","YTQRUTL",3,0)
 ;
"RTN","YTQRUTL",4,0)
 ; External Reference    ICR#
"RTN","YTQRUTL",5,0)
 ; ------------------   -----
"RTN","YTQRUTL",6,0)
 ; VPRJSON               6411
"RTN","YTQRUTL",7,0)
 ; XLFSTR               10104
"RTN","YTQRUTL",8,0)
 ; XLFUTL                2622
"RTN","YTQRUTL",9,0)
 ; XWBLIB                2238
"RTN","YTQRUTL",10,0)
 ;
"RTN","YTQRUTL",11,0)
 ;
"RTN","YTQRUTL",12,0)
 ; ^TMP("YTQRERRS",$J)  place to list errors
"RTN","YTQRUTL",13,0)
 ;
"RTN","YTQRUTL",14,0)
 ; -- the HTTP request comes in the original RPC call
"RTN","YTQRUTL",15,0)
 ; HTTPREQ(1)="GET /path/goes/here?queryparam=avalue"
"RTN","YTQRUTL",16,0)
 ; HTTPREQ(2)="content-type=application/json"
"RTN","YTQRUTL",17,0)
 ; HTTPREQ(3)=""
"RTN","YTQRUTL",18,0)
 ; HTTPREQ(n)={json stuff...}
"RTN","YTQRUTL",19,0)
 ; 
"RTN","YTQRUTL",20,0)
 ; -- HTTPREQ is parsed into these variables
"RTN","YTQRUTL",21,0)
 ; YTQRREQT("method")="GET"
"RTN","YTQRUTL",22,0)
 ; YTQRREQT("path")="path/goes/here"
"RTN","YTQRUTL",23,0)
 ; YTQRREQT("query")="queryparam=avalue"
"RTN","YTQRUTL",24,0)
 ; YTQRARGS(name)=value          (names from path variables and query params)
"RTN","YTQRUTL",25,0)
 ; YTQRTREE(subscripts)=values   (M-tree from JSON passed as request body)
"RTN","YTQRUTL",26,0)
 ;
"RTN","YTQRUTL",27,0)
 ; -- these are how the REST methods are invoked in matched routine
"RTN","YTQRUTL",28,0)
 ;    GET:  getCall(.YTQRARGS,.YTQRRSLT)              returns .YTQRRSLT
"RTN","YTQRUTL",29,0)
 ;   POST:  locationURL=postCall(.YTQRARGS,.YTQRTREE) returns LOCATION header
"RTN","YTQRUTL",30,0)
 ; DELETE: delCall(.YTQRARGS)                         returns OK or error
"RTN","YTQRUTL",31,0)
 ;
"RTN","YTQRUTL",32,0)
 ; -- this array is built based on the return from the matched routine
"RTN","YTQRUTL",33,0)
 ;    for  GET:  convert .YTQRTREE results into JSON
"RTN","YTQRUTL",34,0)
 ;    for POST:  set Location header based on return value of function
"RTN","YTQRUTL",35,0)
 ; HTTPRSP(.1)="HTTP/1.1 200 OK"
"RTN","YTQRUTL",36,0)
 ; HTTPRSP(.2)="Date: ..."  (GMT date)
"RTN","YTQRUTL",37,0)
 ; HTTPRSP(.3)="Location: /path/to/resource"
"RTN","YTQRUTL",38,0)
 ; HTTPRSP(.4)="Content-Type: application/json"
"RTN","YTQRUTL",39,0)
 ; HTTPRSP(.5)="Content-Length: 42"
"RTN","YTQRUTL",40,0)
 ; HTTPRSP(.9)=""
"RTN","YTQRUTL",41,0)
 ; HTTPRSP(1..n)=JSON content
"RTN","YTQRUTL",42,0)
 ;
"RTN","YTQRUTL",43,0)
HANDLE(URLTAG,HTTPREQ,HTTPRSP) ; route REST request based on URL pattern
"RTN","YTQRUTL",44,0)
 ;   URLTAG: tag^routine that begins mapping of path patterns to routines
"RTN","YTQRUTL",45,0)
 ; .HTTPREQ: GET/PUT/POST/DELETE request in HTTP form
"RTN","YTQRUTL",46,0)
 ; .HTTPRSP: response to caller in HTTP form
"RTN","YTQRUTL",47,0)
 N YTQRREQT,YTQRERRS,YTQRARGS,YTQRTREE,YTQRRSLT,JSONBODY,CALL,LOCATION
"RTN","YTQRUTL",48,0)
 K ^TMP("YTQRERRS",$J),^TMP("YTQ-JSON",$J)
"RTN","YTQRUTL",49,0)
 D PARSHTTP(.HTTPREQ,.YTQRREQT,.JSONBODY) G:$G(YTQRERRS) RESPONSE
"RTN","YTQRUTL",50,0)
 I $D(JSONBODY) D PARSJSON(.JSONBODY,.YTQRTREE) G:$G(YTQRERRS) RESPONSE
"RTN","YTQRUTL",51,0)
 D MATCH(URLTAG,.CALL,.YTQRARGS) G:$G(YTQRERRS) RESPONSE
"RTN","YTQRUTL",52,0)
 D QSPLIT(.YTQRARGS)
"RTN","YTQRUTL",53,0)
 ; treat PUT and POST the same for now
"RTN","YTQRUTL",54,0)
 I "PUT,POST"[YTQRREQT("method") X "S LOCATION=$$"_CALL_"(.YTQRARGS,.YTQRTREE)" I 1
"RTN","YTQRUTL",55,0)
 I YTQRREQT("method")="GET" D @(CALL_"(.YTQRARGS,.YTQRRSLT)")
"RTN","YTQRUTL",56,0)
 I YTQRREQT("method")="DELETE" D @(CALL_"(.YTQRARGS)")
"RTN","YTQRUTL",57,0)
 D RESPONSE(.YTQRRSLT,.LOCATION)
"RTN","YTQRUTL",58,0)
 Q
"RTN","YTQRUTL",59,0)
PARSHTTP(HTTPREQ,YTQRREQT,JSONBODY) ; parse out header and body of HTTP HTTPREQ
"RTN","YTQRUTL",60,0)
 N I,J,X
"RTN","YTQRUTL",61,0)
 S YTQRREQT("method")=$P(HTTPREQ(1)," ")
"RTN","YTQRUTL",62,0)
 S YTQRREQT("path")=$P($P(HTTPREQ(1)," ",2),"?")
"RTN","YTQRUTL",63,0)
 S YTQRREQT("query")=$P($P(HTTPREQ(1)," ",2),"?",2,99)
"RTN","YTQRUTL",64,0)
 F I=2:1 Q:'$L($G(HTTPREQ(I)))  S X=HTTPREQ(I),YTQRREQT("header",$P(X,"="))=$P(X,"=",2,99)
"RTN","YTQRUTL",65,0)
 F J=1:1 S I=$O(HTTPREQ(I)) Q:'I  S JSONBODY(J)=HTTPREQ(I)
"RTN","YTQRUTL",66,0)
 I '$D(YTQRREQT("method")) D SETERROR(400,"Missing HTTP method")
"RTN","YTQRUTL",67,0)
 I '$D(YTQRREQT("path")) D SETERROR(400,"Missing URL path")
"RTN","YTQRUTL",68,0)
 Q 
"RTN","YTQRUTL",69,0)
PARSJSON(JSONBODY,YTQRTREE) ; parse JSON request into M tree structure
"RTN","YTQRUTL",70,0)
 N ERRORS
"RTN","YTQRUTL",71,0)
 D DECODE^VPRJSON("JSONBODY","YTQRTREE","ERRORS")
"RTN","YTQRUTL",72,0)
 I $D(ERRORS)>0 D SETERROR(400,$G(ERRORS(1)))
"RTN","YTQRUTL",73,0)
 Q
"RTN","YTQRUTL",74,0)
MATCH(TAG,CALL,ARGS) ; evaluate paths listed in TAG until match found (else 404)
"RTN","YTQRUTL",75,0)
 ; expects YTQRREQT to contain "path" and "method" nodes
"RTN","YTQRUTL",76,0)
 ;  TAG     contains the beginning tag where the paths are listed
"RTN","YTQRUTL",77,0)
 ; .ROUTINE contains TAG^ROUTINE, which will be called as TAG(.RESULTS,.ARGS)
"RTN","YTQRUTL",78,0)
 ; .ARGS    will contain an array of any resolved path arguments
"RTN","YTQRUTL",79,0)
 ;
"RTN","YTQRUTL",80,0)
 N I,J,X,PATH,PATHFND,RTN,PATTERN,SEGSOK,SEGPATH,SEGPTRN,ARGUMENT,TEST
"RTN","YTQRUTL",81,0)
 S PATH=YTQRREQT("path"),PATHFND=0
"RTN","YTQRUTL",82,0)
 S RTN=$P(TAG,"^",2),TAG=$P(TAG,"^") S:$L(RTN) RTN="^"_RTN
"RTN","YTQRUTL",83,0)
 I $E(PATH)'="/" S PATH="/"_PATH  ; ensure leading / for consistency
"RTN","YTQRUTL",84,0)
 F I=1:1 S X=$P($T(@(TAG_"+"_I_RTN)),";;",2,99) Q:'$L(X)  D  Q:PATHFND
"RTN","YTQRUTL",85,0)
 . K ARGS S PATTERN=$P(X," ",2)
"RTN","YTQRUTL",86,0)
 . I $P(X," ")'=YTQRREQT("method") Q               ; '=method -- continue
"RTN","YTQRUTL",87,0)
 . I $L(PATTERN,"/")'=$L(PATH,"/") Q             ; '=segCount -- continue
"RTN","YTQRUTL",88,0)
 . S SEGSOK=1 F J=1:1:$L(PATH,"/") D  Q:'SEGSOK  ; check each path segment
"RTN","YTQRUTL",89,0)
 . . S SEGPATH=$$URLDEC($P(PATH,"/",J),1)
"RTN","YTQRUTL",90,0)
 . . S SEGPTRN=$$URLDEC($P(PATTERN,"/",J),1)
"RTN","YTQRUTL",91,0)
 . . I $E(SEGPTRN)'=":" S SEGSOK=($$LOW^XLFSTR(SEGPTRN)=$$LOW^XLFSTR(SEGPATH)) Q
"RTN","YTQRUTL",92,0)
 . . ; extract the :argument with optional pattern test
"RTN","YTQRUTL",93,0)
 . . S SEGPTRN=$E(SEGPTRN,2,$L(SEGPTRN))               ; remove colon
"RTN","YTQRUTL",94,0)
 . . S ARGUMENT=$P(SEGPTRN,"?"),TEST=$P(SEGPTRN,"?",2) ; get arg and test
"RTN","YTQRUTL",95,0)
 . . I $L(TEST) S SEGSOK=(SEGPATH?@TEST) Q:'SEGSOK     ; test pattern match
"RTN","YTQRUTL",96,0)
 . . S ARGS(ARGUMENT)=SEGPATH                          ; ARGS(argName)=value
"RTN","YTQRUTL",97,0)
 . I SEGSOK S PATHFND=1,CALL=$P(X," ",3)
"RTN","YTQRUTL",98,0)
 I 'PATHFND D SETERROR(404,"No match to path found.")
"RTN","YTQRUTL",99,0)
 Q
"RTN","YTQRUTL",100,0)
QSPLIT(ARGS) ; parses and decodes query fragments into ARGS
"RTN","YTQRUTL",101,0)
 N I,X,NAME,VALUE
"RTN","YTQRUTL",102,0)
 F I=1:1:$L(YTQRREQT("query"),"&") D
"RTN","YTQRUTL",103,0)
 . S X=$$URLDEC($P(YTQRREQT("query"),"&",I))
"RTN","YTQRUTL",104,0)
 . S NAME=$P(X,"="),VALUE=$P(X,"=",2,999)
"RTN","YTQRUTL",105,0)
 . I $L(NAME) S ARGS($$LOW^XLFSTR(NAME))=VALUE
"RTN","YTQRUTL",106,0)
 Q
"RTN","YTQRUTL",107,0)
RESPONSE(YTQRRSLT,LOCATION) ; build HTTPRSP based results or error
"RTN","YTQRUTL",108,0)
 ; from HANDLE, expects YTQRERRS (only defined if there were errors)
"RTN","YTQRUTL",109,0)
 ; YTQRERRS: positive number if there are errors to return
"RTN","YTQRUTL",110,0)
 ; YTQRRSLT: return value of the GET call
"RTN","YTQRUTL",111,0)
 ; LOCATION: return path of the POST call
"RTN","YTQRUTL",112,0)
 K HTTPRSP
"RTN","YTQRUTL",113,0)
 I $G(YTQRERRS) D BLDERRS(.HTTPRSP) QUIT
"RTN","YTQRUTL",114,0)
 I $D(YTQRRSLT) D     ; call is returning data (i.e., was a GET)
"RTN","YTQRUTL",115,0)
 . I $E($G(YTQRRSLT),1,16)="^TMP(""YTQ-JSON""," D
"RTN","YTQRUTL",116,0)
 . . ; contents of ^TMP("YTQ-JSON",$J) already in JSON format
"RTN","YTQRUTL",117,0)
 . . S HTTPRSP=$NA(^TMP("YTQ-JSON",$J))
"RTN","YTQRUTL",118,0)
 . . D ADDHDR(HTTPRSP,$$GVSIZE(HTTPRSP))
"RTN","YTQRUTL",119,0)
 . . I '$$RTRNFMT^XWBLIB(4,1) D SETERROR(400,"Unable to return global array")
"RTN","YTQRUTL",120,0)
 . E  D
"RTN","YTQRUTL",121,0)
 . . ; contents of YTQRRSLT need to be converted from nodes to JSON
"RTN","YTQRUTL",122,0)
 . . D JSONRSP("YTQRRSLT",.HTTPRSP)
"RTN","YTQRUTL",123,0)
 . . D ADDHDR("HTTPRSP",$$LVSIZE(.HTTPRSP))
"RTN","YTQRUTL",124,0)
 E  D                 ; call is returning location only (i.e., was a POST)
"RTN","YTQRUTL",125,0)
 . I YTQRREQT("method")="DELETE" D ADDHDR("HTTPRSP",0) QUIT
"RTN","YTQRUTL",126,0)
 . I '$L($G(LOCATION)) D SETERROR(400,"Location missing after POST") QUIT
"RTN","YTQRUTL",127,0)
 . D ADDHDR("HTTPRSP",0,LOCATION)
"RTN","YTQRUTL",128,0)
 I $G(YTQRERRS) D BLDERRS(.HTTPRSP) ; rebuild return value if we have errors
"RTN","YTQRUTL",129,0)
 Q
"RTN","YTQRUTL",130,0)
JSONRSP(ROOT,HTTPRSP) ; encode response tree or error info as JSON
"RTN","YTQRUTL",131,0)
 N ERRORS
"RTN","YTQRUTL",132,0)
 K HTTPRSP
"RTN","YTQRUTL",133,0)
 D ENCODE^VPRJSON(ROOT,"HTTPRSP","ERRORS")
"RTN","YTQRUTL",134,0)
 I $D(ERRORS)>0 D SETERROR(400,"Unable to encode HTTPRSP: "_$G(ERRORS(1)))
"RTN","YTQRUTL",135,0)
 Q
"RTN","YTQRUTL",136,0)
ADDHDR(DEST,SIZE,LOCATION) ; add header values to response
"RTN","YTQRUTL",137,0)
 ; S HTTPRSP(.2)="Date: "_$$GMT
"RTN","YTQRUTL",138,0)
 I $L($G(LOCATION)) D
"RTN","YTQRUTL",139,0)
 . S @DEST@(.3)="Location: "_$$URLENC(LOCATION)
"RTN","YTQRUTL",140,0)
 I $G(SIZE)>0 D
"RTN","YTQRUTL",141,0)
 . S @DEST@(.4)="Content-Type: application/json"
"RTN","YTQRUTL",142,0)
 . S @DEST@(.5)="Content-Length: "_SIZE
"RTN","YTQRUTL",143,0)
 S @DEST@(.1)="HTTP/1.1 "_$S($G(YTQRERRS):$$ERRHDR,1:"200 OK")
"RTN","YTQRUTL",144,0)
 S @DEST@(.9)=""
"RTN","YTQRUTL",145,0)
 Q
"RTN","YTQRUTL",146,0)
BLDERRS(HTTPRSP) ; Build response with error information
"RTN","YTQRUTL",147,0)
 K HTTPRSP
"RTN","YTQRUTL",148,0)
 D JSONRSP($NA(^TMP("YTQRERRS",$J,1)),.HTTPRSP)
"RTN","YTQRUTL",149,0)
 D ADDHDR("HTTPRSP",$$LVSIZE(.HTTPRSP))
"RTN","YTQRUTL",150,0)
 Q
"RTN","YTQRUTL",151,0)
 ;
"RTN","YTQRUTL",152,0)
URLDEC(X,PATH) ; Decode a URL-encoded string
"RTN","YTQRUTL",153,0)
 ; Q $ZCONVERT(X,"I","URL")  ; uncomment for fastest performance on Cache
"RTN","YTQRUTL",154,0)
 ;
"RTN","YTQRUTL",155,0)
 N I,OUT,FRAG,ASC
"RTN","YTQRUTL",156,0)
 S:'$G(PATH) X=$TR(X,"+"," ") ; don't convert '+' in path fragment
"RTN","YTQRUTL",157,0)
 F I=1:1:$L(X,"%") D
"RTN","YTQRUTL",158,0)
 . I I=1 S OUT=$P(X,"%") Q
"RTN","YTQRUTL",159,0)
 . S FRAG=$P(X,"%",I),ASC=$E(FRAG,1,2),FRAG=$E(FRAG,3,$L(FRAG))
"RTN","YTQRUTL",160,0)
 . I $L(ASC) S OUT=OUT_$C($$BASE^XLFUTL(ASC,16,10)) ; hex to dec
"RTN","YTQRUTL",161,0)
 . S OUT=OUT_FRAG
"RTN","YTQRUTL",162,0)
 Q OUT
"RTN","YTQRUTL",163,0)
 ;
"RTN","YTQRUTL",164,0)
URLENC(X) ; Encode a string for use in a URL
"RTN","YTQRUTL",165,0)
 ; Q $ZCONVERT(X,"O","URL")  ; uncomment for fastest performance on Cache
"RTN","YTQRUTL",166,0)
 ; =, &, %, +, non-printable
"RTN","YTQRUTL",167,0)
 ; {, } added JC 7-24-2012
"RTN","YTQRUTL",168,0)
 N I,Y,Z,LAST
"RTN","YTQRUTL",169,0)
 S Y=$P(X,"%") F I=2:1:$L(X,"%") S Y=Y_"%25"_$P(X,"%",I)
"RTN","YTQRUTL",170,0)
 S X=Y,Y=$P(X,"&") F I=2:1:$L(X,"&") S Y=Y_"%26"_$P(X,"&",I)
"RTN","YTQRUTL",171,0)
 S X=Y,Y=$P(X,"=") F I=2:1:$L(X,"=") S Y=Y_"%3D"_$P(X,"=",I)
"RTN","YTQRUTL",172,0)
 S X=Y,Y=$P(X,"+") F I=2:1:$L(X,"+") S Y=Y_"%2B"_$P(X,"+",I)
"RTN","YTQRUTL",173,0)
 S X=Y,Y=$P(X,"{") F I=2:1:$L(X,"{") S Y=Y_"%7B"_$P(X,"{",I)
"RTN","YTQRUTL",174,0)
 S X=Y,Y=$P(X,"}") F I=2:1:$L(X,"}") S Y=Y_"%7D"_$P(X,"}",I)
"RTN","YTQRUTL",175,0)
 S Y=$TR(Y," ","+")
"RTN","YTQRUTL",176,0)
 S Z="",LAST=1
"RTN","YTQRUTL",177,0)
 F I=1:1:$L(Y) I $A(Y,I)<32 D
"RTN","YTQRUTL",178,0)
 . S CODE=$$BASE^XLFUTL($A(Y,I),10,16),CODE=$TR($J(CODE,2)," ","0")
"RTN","YTQRUTL",179,0)
 . S Z=Z_$E(Y,LAST,I-1)_"%"_CODE,LAST=I+1
"RTN","YTQRUTL",180,0)
 S Z=Z_$E(Y,LAST,$L(Y))
"RTN","YTQRUTL",181,0)
 Q Z
"RTN","YTQRUTL",182,0)
 ;
"RTN","YTQRUTL",183,0)
LVSIZE(V) ; return the size of a local variable
"RTN","YTQRUTL",184,0)
 Q:'$D(V) 0
"RTN","YTQRUTL",185,0)
 N SIZE,I
"RTN","YTQRUTL",186,0)
 S SIZE=0
"RTN","YTQRUTL",187,0)
 I $D(V)#2 S SIZE=$L(V)
"RTN","YTQRUTL",188,0)
 I $D(V)>1 S I="" F  S I=$O(V(I)) Q:'I  S SIZE=SIZE+$L(V(I))
"RTN","YTQRUTL",189,0)
 Q SIZE
"RTN","YTQRUTL",190,0)
 ;
"RTN","YTQRUTL",191,0)
GVSIZE(ROOT) ; return the size of a global variable (assumes WP format)
"RTN","YTQRUTL",192,0)
 Q:'$D(ROOT) 0 Q:'$L(ROOT) 0
"RTN","YTQRUTL",193,0)
 N SIZE,I
"RTN","YTQRUTL",194,0)
 S SIZE=0
"RTN","YTQRUTL",195,0)
 I $D(@ROOT)#2 S SIZE=$L(@ROOT)
"RTN","YTQRUTL",196,0)
 I $D(@ROOT)>1 S I=0 F  S I=$O(@ROOT@(I)) Q:'I  S SIZE=SIZE+$L(@ROOT@(I,0))
"RTN","YTQRUTL",197,0)
 Q SIZE
"RTN","YTQRUTL",198,0)
 ;
"RTN","YTQRUTL",199,0)
SETERROR(CODE,MSG) ; set up error object
"RTN","YTQRUTL",200,0)
 S ^TMP("YTQRERRS",$J,0)=$G(^(0))+1
"RTN","YTQRUTL",201,0)
 S ^TMP("YTQRERRS",$J,1,"apiVersion")="1.0"
"RTN","YTQRUTL",202,0)
 S ^TMP("YTQRERRS",$J,1,"error","code")=CODE
"RTN","YTQRUTL",203,0)
 S ^TMP("YTQRERRS",$J,1,"error","message")=$$HTTPMSG(CODE)
"RTN","YTQRUTL",204,0)
 S ^TMP("YTQRERRS",$J,1,"error","request")=$G(YTQRREQT("method"))_" "_$G(YTQRREQT("path"))_" "_$G(YTQRREQT("query"))
"RTN","YTQRUTL",205,0)
 S ^TMP("YTQRERRS",$J,1,"error","errors",^TMP("YTQRERRS",$J,0),"message")=MSG
"RTN","YTQRUTL",206,0)
 S YTQRERRS=1 ; Global indicator of errors
"RTN","YTQRUTL",207,0)
 Q
"RTN","YTQRUTL",208,0)
HTTPMSG(CODE) ; return message for error code
"RTN","YTQRUTL",209,0)
 I CODE=200 Q "OK"
"RTN","YTQRUTL",210,0)
 I CODE=201 Q "CREATED"
"RTN","YTQRUTL",211,0)
 I CODE=400 Q "BAD REQUEST"
"RTN","YTQRUTL",212,0)
 I CODE=404 Q "NOT FOUND"
"RTN","YTQRUTL",213,0)
 I CODE=500 Q "INTERNAL SERVER ERROR"
"RTN","YTQRUTL",214,0)
 Q "UNKNOWN"
"RTN","YTQRUTL",215,0)
 ;
"RTN","YTQRUTL",216,0)
ERRTXT() ; return error message for non-HTTP RPC calls
"RTN","YTQRUTL",217,0)
 N I,X
"RTN","YTQRUTL",218,0)
 S X=""
"RTN","YTQRUTL",219,0)
 S I=0 F  S I=$O(^TMP("YTQRERRS",$J,1,"error","errors",I)) Q:'I  D
"RTN","YTQRUTL",220,0)
 . S X=X_$S($L(X):$C(13,10),1:"")
"RTN","YTQRUTL",221,0)
 . S X=X_^TMP("YTQRERRS",$J,1,"error","errors",I,"message")
"RTN","YTQRUTL",222,0)
 Q X
"RTN","YTQRUTL",223,0)
 ;
"RTN","YTQRUTL",224,0)
ERRHDR() ; return error header
"RTN","YTQRUTL",225,0)
 N X
"RTN","YTQRUTL",226,0)
 S X=$G(^TMP("YTQRERRS",$J,1,"error","code"))
"RTN","YTQRUTL",227,0)
 S X=X_" "_$G(^TMP("YTQRERRS",$J,1,"error","message"))
"RTN","YTQRUTL",228,0)
 I X'?3N1" "1.E S X="500 INTERNAL SERVER ERROR"
"RTN","YTQRUTL",229,0)
 Q X
"RTN","YTQRUTL",230,0)
 ;
"RTN","YTQRUTL",231,0)
TR2WP(SRC,DEST,DELIM) ; Convert tree representation to FM WP
"RTN","YTQRUTL",232,0)
 ;  SRC: glvn of source array (JSON node with wp text)
"RTN","YTQRUTL",233,0)
 ; DEST: glvn of destination array (will add [line,0] nodes)
"RTN","YTQRUTL",234,0)
 ;DELIM: string that represents line break -- defaults to $C(13,10)
"RTN","YTQRUTL",235,0)
 N I,J,X,LN
"RTN","YTQRUTL",236,0)
 S LN=0,X=$G(@SRC),DELIM=$G(DELIM,$C(13,10))
"RTN","YTQRUTL",237,0)
 F J=1:1:$L(X,DELIM) S LN=LN+1,@DEST@(LN,0)=$P(X,$C(13,10),J)
"RTN","YTQRUTL",238,0)
 S I=0 F  S I=$O(@SRC@("\",I)) Q:'I  D
"RTN","YTQRUTL",239,0)
 . S X=@SRC@("\",I)
"RTN","YTQRUTL",240,0)
 . F J=1:1:$L(X,DELIM) D
"RTN","YTQRUTL",241,0)
 . . I J=1 S @DEST@(LN,0)=@DEST@(LN,0)_$P(X,DELIM,1) I 1
"RTN","YTQRUTL",242,0)
 . . E  S LN=LN+1,@DEST@(LN,0)=$P(X,DELIM,J)
"RTN","YTQRUTL",243,0)
 Q
"RTN","YTSBAMC")
0^27^B15807209^B2786313
"RTN","YTSBAMC",1,0)
YTSBAMC ;SLC/PIJ - Score BAMC ; 01/08/2016
"RTN","YTSBAMC",2,0)
 ;;5.01;MENTAL HEALTH;**123,130**;DEC 30,1994;Build 62
"RTN","YTSBAMC",3,0)
 ;
"RTN","YTSBAMC",4,0)
 ;Public, Supported ICRs
"RTN","YTSBAMC",5,0)
 ; #2056 - Fileman API - $$GET1^DIQ
"RTN","YTSBAMC",6,0)
 ;
"RTN","YTSBAMC",7,0)
 Q
"RTN","YTSBAMC",8,0)
 ;
"RTN","YTSBAMC",9,0)
DATA1 ; display scores for administration
"RTN","YTSBAMC",10,0)
 N ANS
"RTN","YTSBAMC",11,0)
 S YSINSNAM=$P($G(YSDATA(2)),U,3)
"RTN","YTSBAMC",12,0)
 I $G(YSINSNAM)="" S YSINSNAM=$G(YS("CODE"),"NO NAME PASSED")
"RTN","YTSBAMC",13,0)
 S NODE=2 F  S NODE=$O(YSDATA(NODE)) Q:NODE=""  D  ; Start at YSDATA(3)
"RTN","YTSBAMC",14,0)
 .S DATA=YSDATA(NODE)
"RTN","YTSBAMC",15,0)
 .S YSQN=$P(DATA,U,1)
"RTN","YTSBAMC",16,0)
 .S ANS=$P(DATA,U,3),ANS=$S(ANS=1155:0,ANS=1156:0,1:ANS)
"RTN","YTSBAMC",17,0)
 .I YSQN=6464 S ALCO=ANS
"RTN","YTSBAMC",18,0)
 .I YSQN=6465 S HALCO=ANS
"RTN","YTSBAMC",19,0)
 .I YSQN=6466 S DRUG=ANS
"RTN","YTSBAMC",20,0)
 Q
"RTN","YTSBAMC",21,0)
 ;
"RTN","YTSBAMC",22,0)
SCORESV ;
"RTN","YTSBAMC",23,0)
 I $D(^TMP($J,"YSG",1)),^TMP($J,"YSG",1)="[ERROR]" D  Q  ;-->out
"RTN","YTSBAMC",24,0)
 .K ^TMP($J,"YSCOR")
"RTN","YTSBAMC",25,0)
 .S ^TMP($J,"YSCOR",1)="[ERROR]"
"RTN","YTSBAMC",26,0)
 .S ^TMP($J,"YSCOR",2)=YSINSNAM_" Scale not found"
"RTN","YTSBAMC",27,0)
 ;
"RTN","YTSBAMC",28,0)
 K ^TMP($J,"YSCOR")
"RTN","YTSBAMC",29,0)
 S ^TMP($J,"YSCOR",1)="[DATA]"
"RTN","YTSBAMC",30,0)
 S ^TMP($J,"YSCOR",2)=$$GET1^DIQ(601.87,778_",",3,"I")_"="_ALCO
"RTN","YTSBAMC",31,0)
 S ^TMP($J,"YSCOR",3)=$$GET1^DIQ(601.87,838_",",3,"I")_"="_HALCO
"RTN","YTSBAMC",32,0)
 S ^TMP($J,"YSCOR",4)=$$GET1^DIQ(601.87,839_",",3,"I")_"="_DRUG
"RTN","YTSBAMC",33,0)
 Q
"RTN","YTSBAMC",34,0)
 ; 
"RTN","YTSBAMC",35,0)
DLLSTR(YSDATA,YS,YSTRNG) ;
"RTN","YTSBAMC",36,0)
 ;  YSTRNG = 1 Score Instrument
"RTN","YTSBAMC",37,0)
 ;  YSTRNG = 2 get Report Answers and Text
"RTN","YTSBAMC",38,0)
 ;
"RTN","YTSBAMC",39,0)
 N ALCO,DATA,DRUG,HALCO,NODE,YSQN,YSINSNAM
"RTN","YTSBAMC",40,0)
 ;
"RTN","YTSBAMC",41,0)
 I YSTRNG=2 Q  ; no special processing or text
"RTN","YTSBAMC",42,0)
 ;
"RTN","YTSBAMC",43,0)
 D DATA1
"RTN","YTSBAMC",44,0)
 D SCORESV
"RTN","YTSBAMC",45,0)
 Q
"RTN","YTSBAMC",46,0)
 ;
"RTN","YTSBAMC",47,0)
VERIFY(ARGS,RESULTS) ; Add inconsistency messages based on set of answers in ARGS
"RTN","YTSBAMC",48,0)
 N MSGCNT S MSGCNT=0
"RTN","YTSBAMC",49,0)
 I $$NV("q6464") D NVMSG("1")
"RTN","YTSBAMC",50,0)
 I $$NV("q6465") D NVMSG("2")
"RTN","YTSBAMC",51,0)
 I $$LT("q6464","q6465") D MSG("more","1","2")
"RTN","YTSBAMC",52,0)
 I $$NV("q6466") D NVMSG("3")
"RTN","YTSBAMC",53,0)
 I $$NV("q6467") D NVMSG("4A")
"RTN","YTSBAMC",54,0)
 I $$LT("q6466","q6467") D MSG("less","4A","3")
"RTN","YTSBAMC",55,0)
 I $$NV("q6468") D NVMSG("4B")
"RTN","YTSBAMC",56,0)
 I $$LT("q6466","q6468") D MSG("less","4B","3")
"RTN","YTSBAMC",57,0)
 I $$NV("q6469") D NVMSG("4C")
"RTN","YTSBAMC",58,0)
 I $$LT("q6466","q6469") D MSG("less","4C","3")
"RTN","YTSBAMC",59,0)
 I $$NV("q6470") D NVMSG("4D")
"RTN","YTSBAMC",60,0)
 I $$LT("q6466","q6470") D MSG("less","4D","3")
"RTN","YTSBAMC",61,0)
 I $$NV("q6471") D NVMSG("4E")
"RTN","YTSBAMC",62,0)
 I $$LT("q6466","q6471") D MSG("less","4E","3")
"RTN","YTSBAMC",63,0)
 I $$NV("q6472") D NVMSG("4F")
"RTN","YTSBAMC",64,0)
 I $$LT("q6466","q6472") D MSG("less","4F","3")
"RTN","YTSBAMC",65,0)
 I $$NV("q6473") D NVMSG("4G")
"RTN","YTSBAMC",66,0)
 I $$LT("q6466","q6473") D MSG("less","4G","3")
"RTN","YTSBAMC",67,0)
 D ALLSUB
"RTN","YTSBAMC",68,0)
 S RESULTS("count")=MSGCNT
"RTN","YTSBAMC",69,0)
 Q
"RTN","YTSBAMC",70,0)
LT(ID1,ID2) ; returns 1 if ID1 is less than ID2
"RTN","YTSBAMC",71,0)
 ; expects ARGS from VERIFY
"RTN","YTSBAMC",72,0)
 N VAL1,VAL2        ; 1155=not answered, 1156=skipped by rule
"RTN","YTSBAMC",73,0)
 S VAL1=$G(ARGS(ID1)) S:(VAL1="c1156")!(VAL1="c1155") VAL1=0
"RTN","YTSBAMC",74,0)
 S VAL2=$G(ARGS(ID2)) S:(VAL2="c1156")!(VAL2="c1155") VAL2=0
"RTN","YTSBAMC",75,0)
 I +VAL1<+VAL2 Q 1
"RTN","YTSBAMC",76,0)
 Q 0
"RTN","YTSBAMC",77,0)
 ;
"RTN","YTSBAMC",78,0)
NV(ID) ; returns 1 if ID had no value (has been skipped)
"RTN","YTSBAMC",79,0)
 ; expects ARGS from VERIFY
"RTN","YTSBAMC",80,0)
 N VAL              ; 1155=not answered
"RTN","YTSBAMC",81,0)
 S VAL=$G(ARGS(ID)) I VAL="c1155" Q 1
"RTN","YTSBAMC",82,0)
 Q 0
"RTN","YTSBAMC",83,0)
 ;
"RTN","YTSBAMC",84,0)
MSG(REL,Q1,Q2) ; Add text of message to RESULTS
"RTN","YTSBAMC",85,0)
 ; expects MSGCNT, RESULTS from VERIFY
"RTN","YTSBAMC",86,0)
 N X
"RTN","YTSBAMC",87,0)
 S X="There is an inconsistency: The number of days entered in Question "_Q1
"RTN","YTSBAMC",88,0)
 S X=X_" should be equal to, or "_REL_" than,"
"RTN","YTSBAMC",89,0)
 S X=X_" the number of days in Question "_Q2_"."
"RTN","YTSBAMC",90,0)
 S MSGCNT=MSGCNT+1,RESULTS("messages",MSGCNT)=X
"RTN","YTSBAMC",91,0)
 Q
"RTN","YTSBAMC",92,0)
NVMSG(Q1) ; Add message for no value present
"RTN","YTSBAMC",93,0)
 ; expects MSGCNT, RESULTS from VERIFY
"RTN","YTSBAMC",94,0)
 N X
"RTN","YTSBAMC",95,0)
 S X="There is an inconsistency: The number of days entered in Question "_Q1
"RTN","YTSBAMC",96,0)
 S X=X_" should not be blank."
"RTN","YTSBAMC",97,0)
 S MSGCNT=MSGCNT+1,RESULTS("messages",MSGCNT)=X
"RTN","YTSBAMC",98,0)
 Q
"RTN","YTSBAMC",99,0)
ALLSUB ; compare total of all substances with any substance number
"RTN","YTSBAMC",100,0)
 ; expects ARGS, RESULT from VERIFY
"RTN","YTSBAMC",101,0)
 N SUM,ID,X
"RTN","YTSBAMC",102,0)
 S SUM=0
"RTN","YTSBAMC",103,0)
 F ID="q6467","q6468","q6469","q6470","q6471","q6472","q6473" S SUM=SUM+$G(ARGS(ID))
"RTN","YTSBAMC",104,0)
 I SUM<+$G(ARGS("q6466")) D
"RTN","YTSBAMC",105,0)
 . S X="There is an inconsistency: The addition of all the itemized substances"
"RTN","YTSBAMC",106,0)
 . S X=X_" in questions 4A through 4G should be equal to, or greater than, the"
"RTN","YTSBAMC",107,0)
 . S X=X_" number of days in Question 3."
"RTN","YTSBAMC",108,0)
 . S MSGCNT=MSGCNT+1,RESULTS("messages",MSGCNT)=X
"RTN","YTSBAMC",109,0)
 Q
"RTN","YTSBAMI")
0^28^B2972389^n/a
"RTN","YTSBAMI",1,0)
YTSBAMI ;SLC/KCM - Verify for BAM-IOP ; 01/08/2016
"RTN","YTSBAMI",2,0)
 ;;5.01;MENTAL HEALTH;**130**;DEC 30,1994;Build 62
"RTN","YTSBAMI",3,0)
 ;
"RTN","YTSBAMI",4,0)
 Q
"RTN","YTSBAMI",5,0)
 ;
"RTN","YTSBAMI",6,0)
VERIFY(ARGS,RESULTS) ; Add inconsistency messages based on set of answers in ARGS
"RTN","YTSBAMI",7,0)
 N MSGCNT S MSGCNT=0
"RTN","YTSBAMI",8,0)
 I $$LT("q6444","q6445") D MSG("more","4","5")
"RTN","YTSBAMI",9,0)
 I $$LT("q6446","q6447") D MSG("less","7A","6")
"RTN","YTSBAMI",10,0)
 I $$LT("q6446","q6448") D MSG("less","7B","6")
"RTN","YTSBAMI",11,0)
 I $$LT("q6446","q6449") D MSG("less","7C","6")
"RTN","YTSBAMI",12,0)
 I $$LT("q6446","q6450") D MSG("less","7D","6")
"RTN","YTSBAMI",13,0)
 I $$LT("q6446","q6451") D MSG("less","7E","6")
"RTN","YTSBAMI",14,0)
 I $$LT("q6446","q6452") D MSG("less","7F","6")
"RTN","YTSBAMI",15,0)
 I $$LT("q6446","q6453") D MSG("less","7G","6")
"RTN","YTSBAMI",16,0)
 S RESULTS("count")=MSGCNT
"RTN","YTSBAMI",17,0)
 Q
"RTN","YTSBAMI",18,0)
LT(ID1,ID2) ; returns 1 if ID1 is less than ID2
"RTN","YTSBAMI",19,0)
 ; expects ARGS from VERIFY
"RTN","YTSBAMI",20,0)
 N VAL1,VAL2
"RTN","YTSBAMI",21,0)
 S VAL1=$E($G(ARGS(ID1)),2,9) S:VAL1=1156 VAL1=0  ; 1156 = skipped by rule
"RTN","YTSBAMI",22,0)
 I VAL1 S VAL1=+$P($G(^YTT(601.75,VAL1,0)),U,2)   ; legacy value for compare
"RTN","YTSBAMI",23,0)
 S VAL2=$E($G(ARGS(ID2)),2,9) S:VAL2=1156 VAL2=0
"RTN","YTSBAMI",24,0)
 I VAL2 S VAL2=+$P($G(^YTT(601.75,VAL2,0)),U,2)
"RTN","YTSBAMI",25,0)
 I +VAL1<+VAL2 Q 1
"RTN","YTSBAMI",26,0)
 Q 0
"RTN","YTSBAMI",27,0)
 ;
"RTN","YTSBAMI",28,0)
MSG(REL,Q1,Q2) ; Add text of message to RESULTS
"RTN","YTSBAMI",29,0)
 ; expects MSGCNT, RESULTS from VERIFY
"RTN","YTSBAMI",30,0)
 N X
"RTN","YTSBAMI",31,0)
 S X="There is an inconsistency:  The number of days entered in Question "_Q1
"RTN","YTSBAMI",32,0)
 S X=X_" should be equal to, or "_REL_" than,"
"RTN","YTSBAMI",33,0)
 S X=X_" the number of days in Question "_Q2_"."
"RTN","YTSBAMI",34,0)
 S MSGCNT=MSGCNT+1,RESULTS("messages",MSGCNT)=X
"RTN","YTSBAMI",35,0)
 Q
"RTN","YTSBAMR")
0^29^B30507042^B21293411
"RTN","YTSBAMR",1,0)
YTSBAMR ;SLC/PIJ - Score BAM-Revision ; 01/08/2016
"RTN","YTSBAMR",2,0)
 ;;5.01;MENTAL HEALTH;**123,130**;DEC 30,1994;Build 62
"RTN","YTSBAMR",3,0)
 ;
"RTN","YTSBAMR",4,0)
 ;Public, Supported ICRs
"RTN","YTSBAMR",5,0)
 ; #2056 - Fileman API - $$GET1^DIQ
"RTN","YTSBAMR",6,0)
 ;
"RTN","YTSBAMR",7,0)
 Q
"RTN","YTSBAMR",8,0)
 ;
"RTN","YTSBAMR",9,0)
DATA1 ; display scores for administration
"RTN","YTSBAMR",10,0)
 N ANS,LEG,NODE,YSCDA,YSSEQ,YS
"RTN","YTSBAMR",11,0)
 N DATA,DES,SCORE,YSANS,YSQN,CID
"RTN","YTSBAMR",12,0)
 S SCORE=0
"RTN","YTSBAMR",13,0)
 S YSINSNAM=$P($G(YSDATA(2)),U,3)
"RTN","YTSBAMR",14,0)
 I $G(YSINSNAM)="" S YSINSNAM=$G(YS("CODE"),"NO NAME PASSED")
"RTN","YTSBAMR",15,0)
 S NODE=2 F  S NODE=$O(YSDATA(NODE)) Q:NODE=""  D  ; Start at YSDATA(3)
"RTN","YTSBAMR",16,0)
 .S DATA=YSDATA(NODE)
"RTN","YTSBAMR",17,0)
 .S YSQN=$P(DATA,U,1)
"RTN","YTSBAMR",18,0)
 .S YSSEQ=$P($P(DATA,U,2),";",1) ; Sequence Number
"RTN","YTSBAMR",19,0)
 .;if $P(YSSEQ,";",2)'"" then no Choice ID, piece 3 is data 
"RTN","YTSBAMR",20,0)
 .S YSANS=$P($P(DATA,U,2),";",2)
"RTN","YTSBAMR",21,0)
 .S ANS=$P(DATA,U,3),ANS=$S(ANS=1155:0,ANS=1156:0,1:ANS)
"RTN","YTSBAMR",22,0)
 .D DESGNTR^YTSCORE(YSQN,.DES)
"RTN","YTSBAMR",23,0)
 .S YSCDA=$P($G(DATA),U,3) ; Choice ID 
"RTN","YTSBAMR",24,0)
 .I $G(YSANS) S LEG=YSCDA
"RTN","YTSBAMR",25,0)
 .; legacy values are not correct for numerous CHOICE ID's, therefore set value from ID
"RTN","YTSBAMR",26,0)
 .I '$G(YSANS) S CID=YSCDA D
"RTN","YTSBAMR",27,0)
 ..S LEG=$S(CID=212:0,CID=1059:0,CID=1060:1,CID=1061:2,CID=1062:3,CID=1063:4,CID=717:1,CID=685:2,CID=2312:3,CID=687:4,CID=241:"Y",1:"")
"RTN","YTSBAMR",28,0)
 .I (DES="A")!(DES="B") Q
"RTN","YTSBAMR",29,0)
 .D SCORE
"RTN","YTSBAMR",30,0)
 Q
"RTN","YTSBAMR",31,0)
 ;
"RTN","YTSBAMR",32,0)
SCORE ;
"RTN","YTSBAMR",33,0)
 I DES=1 D
"RTN","YTSBAMR",34,0)
 .S HEALTH=HEALTH+LEG
"RTN","YTSBAMR",35,0)
 .S RISK=RISK+$$SCORADJ(LEG)
"RTN","YTSBAMR",36,0)
 I DES=2 D
"RTN","YTSBAMR",37,0)
 .S SLEEP=LEG
"RTN","YTSBAMR",38,0)
 .S RISK=RISK+LEG
"RTN","YTSBAMR",39,0)
 I DES=3 D
"RTN","YTSBAMR",40,0)
 .S DISTR=LEG
"RTN","YTSBAMR",41,0)
 .S RISK=RISK+LEG
"RTN","YTSBAMR",42,0)
 I DES=4 D
"RTN","YTSBAMR",43,0)
 .S DAYSAU=LEG
"RTN","YTSBAMR",44,0)
 .S USE=USE+LEG
"RTN","YTSBAMR",45,0)
 I DES=5 D
"RTN","YTSBAMR",46,0)
 .S DAYSHA=LEG
"RTN","YTSBAMR",47,0)
 .S USE=USE+LEG
"RTN","YTSBAMR",48,0)
 I DES=6 D
"RTN","YTSBAMR",49,0)
 .S DAYSDRUG=LEG
"RTN","YTSBAMR",50,0)
 .S USE=USE+LEG
"RTN","YTSBAMR",51,0)
 I DES=8 D
"RTN","YTSBAMR",52,0)
 .S URGE=LEG
"RTN","YTSBAMR",53,0)
 .S RISK=RISK+$$SCORADJ(LEG)
"RTN","YTSBAMR",54,0)
 I DES=9 D
"RTN","YTSBAMR",55,0)
 .S CONFID=LEG
"RTN","YTSBAMR",56,0)
 .S PROTECT=PROTECT+$$SCORADJ(LEG)
"RTN","YTSBAMR",57,0)
 I DES=10 D
"RTN","YTSBAMR",58,0)
 .S SELF=LEG
"RTN","YTSBAMR",59,0)
 .S PROTECT=PROTECT+LEG
"RTN","YTSBAMR",60,0)
 I DES=11 D
"RTN","YTSBAMR",61,0)
 .S RISKY=LEG
"RTN","YTSBAMR",62,0)
 .S RISK=RISK+LEG
"RTN","YTSBAMR",63,0)
 I DES=12 D
"RTN","YTSBAMR",64,0)
 .S SPIRIT=LEG
"RTN","YTSBAMR",65,0)
 .S PROTECT=PROTECT+$$SCORADJ(LEG)
"RTN","YTSBAMR",66,0)
 I DES=13 D
"RTN","YTSBAMR",67,0)
 .S WORK=LEG
"RTN","YTSBAMR",68,0)
 .S PROTECT=PROTECT+LEG
"RTN","YTSBAMR",69,0)
 I DES=14 D
"RTN","YTSBAMR",70,0)
 .I LEG="Y" S INCME=4,PROTECT=PROTECT+30
"RTN","YTSBAMR",71,0)
 I DES=15 D
"RTN","YTSBAMR",72,0)
 .S RELAT=LEG
"RTN","YTSBAMR",73,0)
 .S RISK=RISK+$$SCORADJ(LEG)
"RTN","YTSBAMR",74,0)
 I DES=16 D
"RTN","YTSBAMR",75,0)
 .S SUPT=LEG
"RTN","YTSBAMR",76,0)
 .S PROTECT=PROTECT+LEG
"RTN","YTSBAMR",77,0)
 Q
"RTN","YTSBAMR",78,0)
 ;
"RTN","YTSBAMR",79,0)
SCORADJ(SCOR) ;
"RTN","YTSBAMR",80,0)
 S ANS=0
"RTN","YTSBAMR",81,0)
 I SCOR=1 S ANS=8
"RTN","YTSBAMR",82,0)
 I SCOR=2 S ANS=15
"RTN","YTSBAMR",83,0)
 I SCOR=3 S ANS=22
"RTN","YTSBAMR",84,0)
 I SCOR=4 S ANS=30
"RTN","YTSBAMR",85,0)
 Q ANS
"RTN","YTSBAMR",86,0)
 ; 
"RTN","YTSBAMR",87,0)
SCORESV ;
"RTN","YTSBAMR",88,0)
 I $D(^TMP($J,"YSG",1)),^TMP($J,"YSG",1)="[ERROR]" D  Q  ;-->out
"RTN","YTSBAMR",89,0)
 .K ^TMP($J,"YSCOR")
"RTN","YTSBAMR",90,0)
 .S ^TMP($J,"YSCOR",1)="[ERROR]"
"RTN","YTSBAMR",91,0)
 .S ^TMP($J,"YSCOR",2)="BAMR Scale not found"
"RTN","YTSBAMR",92,0)
 ;
"RTN","YTSBAMR",93,0)
 K ^TMP($J,"YSCOR")
"RTN","YTSBAMR",94,0)
 S ^TMP($J,"YSCOR",1)="[DATA]"
"RTN","YTSBAMR",95,0)
 S ^TMP($J,"YSCOR",2)=$$GET1^DIQ(601.87,861_",",3,"I")_"="_USE
"RTN","YTSBAMR",96,0)
 S ^TMP($J,"YSCOR",3)=$$GET1^DIQ(601.87,863_",",3,"I")_"="_RISK
"RTN","YTSBAMR",97,0)
 S ^TMP($J,"YSCOR",4)=$$GET1^DIQ(601.87,864_",",3,"I")_"="_PROTECT
"RTN","YTSBAMR",98,0)
 S ^TMP($J,"YSCOR",5)=$$GET1^DIQ(601.87,865_",",3,"I")_"="_DAYSAU
"RTN","YTSBAMR",99,0)
 S ^TMP($J,"YSCOR",6)=$$GET1^DIQ(601.87,866_",",3,"I")_"="_DAYSHA
"RTN","YTSBAMR",100,0)
 S ^TMP($J,"YSCOR",7)=$$GET1^DIQ(601.87,867_",",3,"I")_"="_DAYSDRUG
"RTN","YTSBAMR",101,0)
 S ^TMP($J,"YSCOR",8)=$$GET1^DIQ(601.87,868_",",3,"I")_"="_HEALTH
"RTN","YTSBAMR",102,0)
 S ^TMP($J,"YSCOR",9)=$$GET1^DIQ(601.87,869_",",3,"I")_"="_SLEEP
"RTN","YTSBAMR",103,0)
 S ^TMP($J,"YSCOR",10)=$$GET1^DIQ(601.87,870_",",3,"I")_"="_DISTR
"RTN","YTSBAMR",104,0)
 S ^TMP($J,"YSCOR",11)=$$GET1^DIQ(601.87,871_",",3,"I")_"="_URGE
"RTN","YTSBAMR",105,0)
 S ^TMP($J,"YSCOR",12)=$$GET1^DIQ(601.87,872_",",3,"I")_"="_RISKY
"RTN","YTSBAMR",106,0)
 S ^TMP($J,"YSCOR",13)=$$GET1^DIQ(601.87,873_",",3,"I")_"="_RELAT
"RTN","YTSBAMR",107,0)
 S ^TMP($J,"YSCOR",14)=$$GET1^DIQ(601.87,874_",",3,"I")_"="_CONFID
"RTN","YTSBAMR",108,0)
 S ^TMP($J,"YSCOR",15)=$$GET1^DIQ(601.87,875_",",3,"I")_"="_SELF
"RTN","YTSBAMR",109,0)
 S ^TMP($J,"YSCOR",16)=$$GET1^DIQ(601.87,876_",",3,"I")_"="_SPIRIT
"RTN","YTSBAMR",110,0)
 S ^TMP($J,"YSCOR",17)=$$GET1^DIQ(601.87,877_",",3,"I")_"="_WORK
"RTN","YTSBAMR",111,0)
 S ^TMP($J,"YSCOR",18)=$$GET1^DIQ(601.87,878_",",3,"I")_"="_INCME
"RTN","YTSBAMR",112,0)
 S ^TMP($J,"YSCOR",19)=$$GET1^DIQ(601.87,879_",",3,"I")_"="_SUPT
"RTN","YTSBAMR",113,0)
 ;
"RTN","YTSBAMR",114,0)
 Q
"RTN","YTSBAMR",115,0)
DLLSTR(YSDATA,YS,YSTRNG) ;
"RTN","YTSBAMR",116,0)
 ;  YSTRNG = 1 Score Instrument
"RTN","YTSBAMR",117,0)
 ;  YSTRNG = 2 get Report Answers and Text
"RTN","YTSBAMR",118,0)
 N YSINSNAM
"RTN","YTSBAMR",119,0)
 N USE,RISK,PROTECT,DAYSAU,DAYSHA,DAYSDRUG,HEALTH,SLEEP
"RTN","YTSBAMR",120,0)
 N DISTR,URGE,RISKY,RELAT,CONFID,SELF,SPIRIT,WORK,INCME,SUPT
"RTN","YTSBAMR",121,0)
 ;
"RTN","YTSBAMR",122,0)
 S (USE,RISK,PROTECT,DAYSAU,DAYSHA,DAYSDRUG,HEALTH,SLEEP)=0
"RTN","YTSBAMR",123,0)
 S (DISTR,URGE,RISKY,RELAT,CONFID,SELF,SPIRIT,WORK,INCME,SUPT)=0
"RTN","YTSBAMR",124,0)
 ;
"RTN","YTSBAMR",125,0)
 I YSTRNG=2 Q  ; No special text, computations in the report. 
"RTN","YTSBAMR",126,0)
 ;
"RTN","YTSBAMR",127,0)
 D DATA1
"RTN","YTSBAMR",128,0)
 D SCORESV
"RTN","YTSBAMR",129,0)
 Q
"RTN","YTSBAMR",130,0)
 ;
"RTN","YTSBAMR",131,0)
VERIFY(ARGS,RESULTS) ; Add inconsistency messages based on set of answers in ARGS
"RTN","YTSBAMR",132,0)
 N MSGCNT S MSGCNT=0
"RTN","YTSBAMR",133,0)
 I $$LT("q6501","q6502") D MSG("more","4","5")
"RTN","YTSBAMR",134,0)
 I $$LT("q6503","q6504") D MSG("less","7A","6")
"RTN","YTSBAMR",135,0)
 I $$LT("q6503","q6505") D MSG("less","7B","6")
"RTN","YTSBAMR",136,0)
 I $$LT("q6503","q6506") D MSG("less","7C","6")
"RTN","YTSBAMR",137,0)
 I $$LT("q6503","q6507") D MSG("less","7D","6")
"RTN","YTSBAMR",138,0)
 I $$LT("q6503","q6508") D MSG("less","7E","6")
"RTN","YTSBAMR",139,0)
 I $$LT("q6503","q6509") D MSG("less","7F","6")
"RTN","YTSBAMR",140,0)
 I $$LT("q6503","q6510") D MSG("less","7G","6")
"RTN","YTSBAMR",141,0)
 S RESULTS("count")=MSGCNT
"RTN","YTSBAMR",142,0)
 Q
"RTN","YTSBAMR",143,0)
LT(ID1,ID2) ; returns 1 if ID1 is less than ID2
"RTN","YTSBAMR",144,0)
 ; expects ARGS from VERIFY
"RTN","YTSBAMR",145,0)
 N VAL1,VAL2
"RTN","YTSBAMR",146,0)
 S VAL1=$G(ARGS(ID1)) S:VAL1="c1156" VAL1=0  ; 1156 = skipped by rule
"RTN","YTSBAMR",147,0)
 S VAL2=$G(ARGS(ID2)) S:VAL2="c1156" VAL2=0
"RTN","YTSBAMR",148,0)
 I +VAL1<+VAL2 Q 1
"RTN","YTSBAMR",149,0)
 Q 0
"RTN","YTSBAMR",150,0)
 ;
"RTN","YTSBAMR",151,0)
MSG(REL,Q1,Q2) ; Add text of message to RESULTS
"RTN","YTSBAMR",152,0)
 ; expects MSGCNT, RESULTS from VERIFY
"RTN","YTSBAMR",153,0)
 N X
"RTN","YTSBAMR",154,0)
 S X="There is an inconsistency:  The number of days entered in Question "_Q1
"RTN","YTSBAMR",155,0)
 S X=X_" should be equal to, or "_REL_" than,"
"RTN","YTSBAMR",156,0)
 S X=X_" the number of days in Question "_Q2_"."
"RTN","YTSBAMR",157,0)
 S MSGCNT=MSGCNT+1,RESULTS("messages",MSGCNT)=X
"RTN","YTSBAMR",158,0)
 Q
"RTN","YTWJSON")
0^7^B85561808^n/a
"RTN","YTWJSON",1,0)
YTWJSON ;SLC/KCM - Generate JSON Instrument Spec ; 7/20/2018
"RTN","YTWJSON",2,0)
 ;;5.01;MENTAL HEALTH;**130**;Dec 30, 1994;Build 62
"RTN","YTWJSON",3,0)
 ;
"RTN","YTWJSON",4,0)
 ; External Reference    ICR#
"RTN","YTWJSON",5,0)
 ; ------------------   -----
"RTN","YTWJSON",6,0)
 ; %ZOSV                10097
"RTN","YTWJSON",7,0)
 ; %ZTER                 1621
"RTN","YTWJSON",8,0)
 ;
"RTN","YTWJSON",9,0)
GETSPEC(JSON,TEST) ; Get the JSON admin spec for instrument TEST
"RTN","YTWJSON",10,0)
 I TEST'=+TEST S TEST=$O(^YTT(601.71,"B",TEST,0)) Q:'TEST
"RTN","YTWJSON",11,0)
 ;
"RTN","YTWJSON",12,0)
 N $ES,$ET S $ET="D ERRHND^YTWJSON"   ; quit from ERRHND if error
"RTN","YTWJSON",13,0)
 N TREE,ERR
"RTN","YTWJSON",14,0)
 D CONTENT(TEST,.TREE)
"RTN","YTWJSON",15,0)
 D RULES(TEST,.TREE)
"RTN","YTWJSON",16,0)
 D FMTJSON^YTWJSONO(.TREE,.JSON) ;D ENCODE^VPRJSON("TREE","JSON","ERR")
"RTN","YTWJSON",17,0)
 Q
"RTN","YTWJSON",18,0)
ERRHND ; Handle errors & clear stack
"RTN","YTWJSON",19,0)
 N ERROR S ERROR=$$EC^%ZOSV           ; grab the error code
"RTN","YTWJSON",20,0)
 I ERROR["ZTER" D UNWIND^%ZTER        ; ignore errors clearing stack
"RTN","YTWJSON",21,0)
 N $ET S $ET="D ^%ZTER,UNWIND^%ZTER"  ; avoid looping on add'l error
"RTN","YTWJSON",22,0)
 D ^%ZTER                             ; record failure in error trap
"RTN","YTWJSON",23,0)
 K JSON                               ; delete the return value
"RTN","YTWJSON",24,0)
 D UNWIND^%ZTER                       ; clear the call stack
"RTN","YTWJSON",25,0)
 Q
"RTN","YTWJSON",26,0)
CONTENT(TEST,TREE) ; build TEST spec as TREE for JSON conversion
"RTN","YTWJSON",27,0)
 S TREE("name")=$P(^YTT(601.71,TEST,0),U)
"RTN","YTWJSON",28,0)
 ; TODO: replace Copyright (c) with \u00A9 ??
"RTN","YTWJSON",29,0)
 S TREE("copyright")=$$HTMLESC^YTWJSONU($G(^YTT(601.71,TEST,7)))
"RTN","YTWJSON",30,0)
 S TREE("restartDays")=$P($G(^YTT(601.71,TEST,8)),U,7)
"RTN","YTWJSON",31,0)
 I TREE("restartDays")="" S TREE("restartDays")=2
"RTN","YTWJSON",32,0)
 ;
"RTN","YTWJSON",33,0)
 N SECTIONS D SECTIONS(TEST,.SECTIONS)  ; build SECTIONS(questionId)
"RTN","YTWJSON",34,0)
 N CTNTIDX S CTNTIDX=0                  ; content index - global scope
"RTN","YTWJSON",35,0)
 N LSTINTRO S LSTINTRO=0                ; last intro used
"RTN","YTWJSON",36,0)
 ;
"RTN","YTWJSON",37,0)
 ; loop thru content by sequence, then choices by sequence
"RTN","YTWJSON",38,0)
 N SEQ,CTNT,X0,X2,QSTN,DISP,RTYP,CTYP
"RTN","YTWJSON",39,0)
 S SEQ=0 F  S SEQ=$O(^YTT(601.76,"AD",TEST,SEQ)) Q:'SEQ  D
"RTN","YTWJSON",40,0)
 . S CTNT=0 F  S CTNT=$O(^YTT(601.76,"AD",TEST,SEQ,CTNT)) Q:'CTNT  D
"RTN","YTWJSON",41,0)
 . . S X0=^YTT(601.76,CTNT,0),QSTN=$P(X0,U,4),DISP=$P(X0,U,8)
"RTN","YTWJSON",42,0)
 . . S X2=^YTT(601.72,QSTN,2),RTYP=$P(X2,U,2),CTYP=$P(X2,U,3)
"RTN","YTWJSON",43,0)
 . . ; TEMPORARY for patch 130, if section header and intro text are
"RTN","YTWJSON",44,0)
 . . ; both there, prepend section header to intro
"RTN","YTWJSON",45,0)
 . . I $P(X2,U)'=LSTINTRO S LSTINTRO=$P(X2,U) D
"RTN","YTWJSON",46,0)
 . . . N SECTHDR S SECTHDR=""
"RTN","YTWJSON",47,0)
 . . . I $D(SECTIONS(QSTN)) S SECTHDR=$P(SECTIONS(QSTN),U,5)
"RTN","YTWJSON",48,0)
 . . . I $L(SECTHDR) S SECTHDR=SECTHDR_"<br />"
"RTN","YTWJSON",49,0)
 . . . D ADDINTRO($P(X2,U),$P(X0,U,7),SECTHDR)
"RTN","YTWJSON",50,0)
 . . E  D
"RTN","YTWJSON",51,0)
 . . . I $D(SECTIONS(QSTN)) D ADDSECT(SECTIONS(QSTN))
"RTN","YTWJSON",52,0)
 . . ; code was:
"RTN","YTWJSON",53,0)
 . . ; I $D(SECTIONS(QSTN)) D ADDSECT(SECTIONS(QSTN))
"RTN","YTWJSON",54,0)
 . . ; I $P(X2,U)'=LSTINTRO S LSTINTRO=$P(X2,U) D ADDINTRO($P(X2,U),$P(X0,U,7))
"RTN","YTWJSON",55,0)
 . . D ADDQSTN(QSTN,$P(X0,U,5),$P(X0,U,6))
"RTN","YTWJSON",56,0)
 . . ;
"RTN","YTWJSON",57,0)
 . . ; add additional properties based on response type
"RTN","YTWJSON",58,0)
 . . ; DISP is the MH DISPLAY entry for MHCHOICEDISPLAYID
"RTN","YTWJSON",59,0)
 . . ; (the entries for question and intro don't appear to do much)
"RTN","YTWJSON",60,0)
 . . I RTYP=1 D RADIO(QSTN,DISP,CTYP)
"RTN","YTWJSON",61,0)
 . . I RTYP=2 D SPIN(QSTN,DISP)
"RTN","YTWJSON",62,0)
 . . I RTYP=3 D TEXT(QSTN,DISP)
"RTN","YTWJSON",63,0)
 . . I RTYP=4 D DATE(QSTN,DISP)
"RTN","YTWJSON",64,0)
 . . I RTYP=5 D MEMO(QSTN,DISP)
"RTN","YTWJSON",65,0)
 . . I RTYP=7 D RANGE(QSTN,DISP,CTYP)
"RTN","YTWJSON",66,0)
 . . I RTYP=11 D CHECK(QSTN,DISP,CTYP)
"RTN","YTWJSON",67,0)
 Q
"RTN","YTWJSON",68,0)
 ;
"RTN","YTWJSON",69,0)
 ; -- for the control type entry points below --
"RTN","YTWJSON",70,0)
 ; expects CTNTIDX to be index of current question
"RTN","YTWJSON",71,0)
 ; QSTN: question id (file 601.72 ien)
"RTN","YTWJSON",72,0)
 ; CTYP: choice type (file 601.751 ien, multiple)
"RTN","YTWJSON",73,0)
 ; DISP: choice display id (file 601.88 ien)
"RTN","YTWJSON",74,0)
 ;
"RTN","YTWJSON",75,0)
RADIO(QSTN,DISP,CTYP) ; add properties for radio group (1 MCHOICE)
"RTN","YTWJSON",76,0)
 ; add choices, inline/columns
"RTN","YTWJSON",77,0)
 S TREE("content",CTNTIDX,"type")="ChoiceQuestion"
"RTN","YTWJSON",78,0)
 D CHLOOP(CTYP,1) ; 1=MCHOICE -- add choices
"RTN","YTWJSON",79,0)
 Q:'$G(DISP)  ; no choice level MH DISPAY ENTRY
"RTN","YTWJSON",80,0)
 N X0 S X0=$G(^YTT(601.88,DISP,0))
"RTN","YTWJSON",81,0)
 ; for now, make inline if columns > 1
"RTN","YTWJSON",82,0)
 S TREE("content",CTNTIDX,"inline")=$S($P(X0,U,11)>1:"true",1:"false")
"RTN","YTWJSON",83,0)
 I $P(X0,U,11) S TREE("content",CTNTIDX,"columns")=$P(X0,U,11)
"RTN","YTWJSON",84,0)
 ; I $P(X0,U,11)>2 W !,"Test:",TEST,"  Qstn:",QSTN,"  Cols:",$P(X0,U,11)
"RTN","YTWJSON",85,0)
 Q
"RTN","YTWJSON",86,0)
SPIN(QSTN,DISP) ; add properties for spin control (2 INTEGER)
"RTN","YTWJSON",87,0)
 ; add inline, default value, max, min
"RTN","YTWJSON",88,0)
 S TREE("content",CTNTIDX,"type")="IntegerQuestion"
"RTN","YTWJSON",89,0)
 D MINMAX(QSTN)
"RTN","YTWJSON",90,0)
 D MASK(DISP)
"RTN","YTWJSON",91,0)
 Q
"RTN","YTWJSON",92,0)
TEXT(QSTN,DISP) ; add properties for edit control (3 STRING)
"RTN","YTWJSON",93,0)
 ;inline, width, default value (mask), max, min
"RTN","YTWJSON",94,0)
 S TREE("content",CTNTIDX,"type")="StringQuestion"
"RTN","YTWJSON",95,0)
 D MINMAX(QSTN)
"RTN","YTWJSON",96,0)
 D MASK(DISP)
"RTN","YTWJSON",97,0)
 Q
"RTN","YTWJSON",98,0)
DATE(QSTN,DISP) ; add properties for date picker  (4 DATE)
"RTN","YTWJSON",99,0)
 ;add inline, default value
"RTN","YTWJSON",100,0)
 S TREE("content",CTNTIDX,"type")="DateQuestion"
"RTN","YTWJSON",101,0)
 D MASK(DISP)
"RTN","YTWJSON",102,0)
 Q
"RTN","YTWJSON",103,0)
MEMO(QSTN,DISP) ; add properties for memo control (5 MEMO)
"RTN","YTWJSON",104,0)
 ; add width, default value
"RTN","YTWJSON",105,0)
 S TREE("content",CTNTIDX,"type")="MemoQuestion"
"RTN","YTWJSON",106,0)
 D MASK(DISP)
"RTN","YTWJSON",107,0)
 Q
"RTN","YTWJSON",108,0)
RANGE(QSTN,DISP,CTYP) ; add properties for range/slider (7 TRACK BAR)
"RTN","YTWJSON",109,0)
 ;add min, max, legend (choices), {labels}
"RTN","YTWJSON",110,0)
 S TREE("content",CTNTIDX,"type")="SliderQuestion"
"RTN","YTWJSON",111,0)
 D MINMAX(QSTN)
"RTN","YTWJSON",112,0)
 D CHLOOP(CTYP,7) ; 7=TRACK BAR 
"RTN","YTWJSON",113,0)
 Q
"RTN","YTWJSON",114,0)
CHECK(QSTN,DISP,CTYP) ; add properties for check list  (11 CHECKLIST)
"RTN","YTWJSON",115,0)
 ; add choices, inline/columns
"RTN","YTWJSON",116,0)
 S TREE("content",CTNTIDX,"type")="CheckQuestion"
"RTN","YTWJSON",117,0)
 D CHLOOP(CTYP,11) ; 11=CHECKLIST
"RTN","YTWJSON",118,0)
 N X0 S X0=$G(^YTT(601.88,DISP,0))
"RTN","YTWJSON",119,0)
 ; for now, make inline if columns > 1
"RTN","YTWJSON",120,0)
 S TREE("content",CTNTIDX,"inline")=$S($P(X0,U,11)>1:"true",1:"false")
"RTN","YTWJSON",121,0)
 I $P(X0,U,11) S TREE("content",CTNTIDX,"columns")=$P(X0,U,11)
"RTN","YTWJSON",122,0)
 Q
"RTN","YTWJSON",123,0)
 ;
"RTN","YTWJSON",124,0)
MINMAX(QSTN) ; set max/min properties
"RTN","YTWJSON",125,0)
 N X2 S X2=$G(^YTT(601.72,QSTN,2))
"RTN","YTWJSON",126,0)
 I +$P(X2,U,4)=$P(X2,U,4) S TREE("content",CTNTIDX,"min")=+$P(X2,U,4)
"RTN","YTWJSON",127,0)
 I +$P(X2,U,5)=$P(X2,U,5) S TREE("content",CTNTIDX,"max")=+$P(X2,U,5)
"RTN","YTWJSON",128,0)
 Q
"RTN","YTWJSON",129,0)
MASK(DISP) ; set properties from |-delimited MASK field
"RTN","YTWJSON",130,0)
 Q:'DISP                     ; some instruments have no display pointer
"RTN","YTWJSON",131,0)
 Q:'$D(^YTT(601.88,DISP,0))  ; some instruments have broken pointers
"RTN","YTWJSON",132,0)
 N MASK S MASK=$P(^YTT(601.88,DISP,0),U,10)
"RTN","YTWJSON",133,0)
 I +MASK S TREE("content",CTNTIDX,"controlWidth")=+MASK
"RTN","YTWJSON",134,0)
 I $L($P(MASK,"|",2)) S TREE("content",CTNTIDX,"default")=$P(MASK,"|",2)
"RTN","YTWJSON",135,0)
 I $P(MASK,"|",3)="S" S TREE("content",CTNTIDX,"inline")="true"
"RTN","YTWJSON",136,0)
 Q
"RTN","YTWJSON",137,0)
CHLOOP(CTYP,CALL) ; loop through choices for a choice type
"RTN","YTWJSON",138,0)
 ; CTYP: Id for ChoiceTypes (601.751) and ChoiceIdentifier (601.89)
"RTN","YTWJSON",139,0)
 ; CALL: Code to call for building appropriate type of node
"RTN","YTWJSON",140,0)
 N CIDF,CSEQ,CHID,CIEN,CIDX
"RTN","YTWJSON",141,0)
 S CIDX=0,CIDF=$O(^YTT(601.89,"B",CTYP,0)) ; choice identifier ien
"RTN","YTWJSON",142,0)
 S CSEQ=0 F  S CSEQ=$O(^YTT(601.751,"AC",CTYP,CSEQ)) Q:'CSEQ  D
"RTN","YTWJSON",143,0)
 . S CHID=0 F  S CHID=$O(^YTT(601.751,"AC",CTYP,CSEQ,CHID)) Q:'CHID  D
"RTN","YTWJSON",144,0)
 . . ; removed the loop below, since it doesn't seem to buy us anything
"RTN","YTWJSON",145,0)
 . . ; and it was causing some instruments to have duplicate choices
"RTN","YTWJSON",146,0)
 . . ; S CIEN=0 F  S CIEN=$O(^YTT(601.751,"AC",CTYP,CSEQ,CHID,CIEN)) Q:'CIEN  D
"RTN","YTWJSON",147,0)
 . . S CIDX=CIDX+1
"RTN","YTWJSON",148,0)
 . . I CALL=1 D ADDCH(CIDX,CIDF,CHID) Q   ; radio buttons
"RTN","YTWJSON",149,0)
 . . I CALL=7 D ADDLGND(CIDX,CHID) Q      ; range control
"RTN","YTWJSON",150,0)
 . . I CALL=11 D ADDCH(CIDX,CIDF,CHID) Q  ; checklist
"RTN","YTWJSON",151,0)
 Q
"RTN","YTWJSON",152,0)
SECTIONS(TEST,SECTIONS) ; build list of sections for TEST
"RTN","YTWJSON",153,0)
 ; SECTIONS(questionIEN)=ID^TEST^Question^TabName^Header^Format
"RTN","YTWJSON",154,0)
 N IEN,X0,SCNT
"RTN","YTWJSON",155,0)
 S SCNT=0
"RTN","YTWJSON",156,0)
 S IEN=0 F  S IEN=$O(^YTT(601.81,"AC",TEST,IEN)) Q:'IEN  D
"RTN","YTWJSON",157,0)
 . S X0=^YTT(601.81,IEN,0)
"RTN","YTWJSON",158,0)
 . S SECTIONS($P(X0,U,3))=X0,SCNT=SCNT+1
"RTN","YTWJSON",159,0)
 ;I SCNT<2 K SECTIONS    ; only need sections if there are more than one
"RTN","YTWJSON",160,0)
 Q
"RTN","YTWJSON",161,0)
ADDSECT(X0) ; add section node
"RTN","YTWJSON",162,0)
 ; expects TREE, CTNTIDX from CONTENT
"RTN","YTWJSON",163,0)
 ; X0: ID^TEST^Question^TabName^Header^Format
"RTN","YTWJSON",164,0)
 S CTNTIDX=CTNTIDX+1
"RTN","YTWJSON",165,0)
 ; TEMPORARY for 130, treat Section Header as Intro
"RTN","YTWJSON",166,0)
 I '$L($P(X0,U,5)) QUIT
"RTN","YTWJSON",167,0)
 S TREE("content",CTNTIDX,"id")="s"_+X0
"RTN","YTWJSON",168,0)
 S TREE("content",CTNTIDX,"type")="IntroText"
"RTN","YTWJSON",169,0)
 S TREE("content",CTNTIDX,"text")=$P(X0,U,5)
"RTN","YTWJSON",170,0)
 ; code was:
"RTN","YTWJSON",171,0)
 ; S TREE("content",CTNTIDX,"id")="s"_+X0
"RTN","YTWJSON",172,0)
 ; S TREE("content",CTNTIDX,"type")="Section"
"RTN","YTWJSON",173,0)
 ; I $L($P(X0,U,4)) S TREE("content",CTNTIDX,"tab")=$P(X0,U,4)
"RTN","YTWJSON",174,0)
 ; I $L($P(X0,U,5)) S TREE("content",CTNTIDX,"text")=$P(X0,U,5)
"RTN","YTWJSON",175,0)
 Q
"RTN","YTWJSON",176,0)
ADDINTRO(IEN,FORMAT,PREPEND) ; add intro node
"RTN","YTWJSON",177,0)
 ; expects TREE, CTNTIDX from CONTENT
"RTN","YTWJSON",178,0)
 Q:'IEN
"RTN","YTWJSON",179,0)
 N TEXT
"RTN","YTWJSON",180,0)
 S CTNTIDX=CTNTIDX+1
"RTN","YTWJSON",181,0)
 S TREE("content",CTNTIDX,"id")="i"_+^YTT(601.73,IEN,0)
"RTN","YTWJSON",182,0)
 S TREE("content",CTNTIDX,"type")="IntroText"
"RTN","YTWJSON",183,0)
 D BLDTXT^YTWJSONU($NA(^YTT(601.73,IEN,1)),.TEXT)
"RTN","YTWJSON",184,0)
 S TEXT=PREPEND_TEXT ; TEMPORARY fix of section header
"RTN","YTWJSON",185,0)
 M TREE("content",CTNTIDX,"text")=TEXT
"RTN","YTWJSON",186,0)
 Q
"RTN","YTWJSON",187,0)
ADDQSTN(IEN,DESIG,FORMAT) ; add question node
"RTN","YTWJSON",188,0)
 N TEXT,X0,X2,ITEXT
"RTN","YTWJSON",189,0)
 S CTNTIDX=CTNTIDX+1
"RTN","YTWJSON",190,0)
 S X0=^YTT(601.72,IEN,0),X2=$G(^(2))
"RTN","YTWJSON",191,0)
 I $L(DESIG),($E(DESIG,$L(DESIG))'=".") S DESIG=DESIG_"."
"RTN","YTWJSON",192,0)
 S TREE("content",CTNTIDX,"id")="q"_+X0
"RTN","YTWJSON",193,0)
 D BLDTXT^YTWJSONU($NA(^YTT(601.72,IEN,1)),.TEXT)
"RTN","YTWJSON",194,0)
 M TREE("content",CTNTIDX,"text")=TEXT
"RTN","YTWJSON",195,0)
 S TREE("content",CTNTIDX,"text")=DESIG_" "_TREE("content",CTNTIDX,"text")
"RTN","YTWJSON",196,0)
 S TREE("content",CTNTIDX,"required")=$S($P(X2,U,6)="Y":"true",1:"false")
"RTN","YTWJSON",197,0)
 I +X2 D
"RTN","YTWJSON",198,0)
 . D BLDTXT^YTWJSONU($NA(^YTT(601.73,+X2,1)),.ITEXT)
"RTN","YTWJSON",199,0)
 . M TREE("content",CTNTIDX,"intro")=ITEXT
"RTN","YTWJSON",200,0)
 ; add HINT? -- not currently used by any of the active instruments
"RTN","YTWJSON",201,0)
 Q
"RTN","YTWJSON",202,0)
ADDCH(INDEX,IDENTIEN,CHIEN) ; add choice node
"RTN","YTWJSON",203,0)
 ; child of current question, use current CTNTIDX
"RTN","YTWJSON",204,0)
 N IDBASE,NUM,QUICK
"RTN","YTWJSON",205,0)
 S TREE("content",CTNTIDX,"choices",INDEX,"id")="c"_+^YTT(601.75,CHIEN,0)
"RTN","YTWJSON",206,0)
 ; default IDBASE to 1 if no file entry for legacy tests
"RTN","YTWJSON",207,0)
 S IDBASE=$S('IDENTIEN:1,1:$P(^YTT(601.89,IDENTIEN,0),U,2))
"RTN","YTWJSON",208,0)
 S NUM=$S(IDBASE=0:INDEX-1,IDBASE=1:INDEX,1:"") S:$L(NUM) NUM=NUM_"."
"RTN","YTWJSON",209,0)
 S TREE("content",CTNTIDX,"choices",INDEX,"text")=NUM_" "_$$HTMLESC^YTWJSONU(^YTT(601.75,CHIEN,1))
"RTN","YTWJSON",210,0)
 S QUICK=$P(NUM,"."),QUICK=$S(+QUICK=QUICK:+QUICK,1:"") ;S:QUICK QUICK=QUICK+48
"RTN","YTWJSON",211,0)
 I $L(QUICK) S TREE("content",CTNTIDX,"choices",INDEX,"quickKey")=QUICK
"RTN","YTWJSON",212,0)
 Q
"RTN","YTWJSON",213,0)
ADDLGND(INDEX,CHIEN) ; add legend based on choices
"RTN","YTWJSON",214,0)
 S TREE("content",CTNTIDX,"legend",INDEX)=^YTT(601.75,CHIEN,1)
"RTN","YTWJSON",215,0)
 Q
"RTN","YTWJSON",216,0)
RULES(TEST,TREE) ; add RULES for TEST to spec TREE for JSON conversion
"RTN","YTWJSON",217,0)
 N IRID,RID,RIDX,X,X0,X1,QSTN1,QSTN2
"RTN","YTWJSON",218,0)
 S RIDX=0
"RTN","YTWJSON",219,0)
 S QSTN1=0 F  S QSTN1=$O(^YTT(601.83,"AD",TEST,QSTN1)) Q:'QSTN1  D
"RTN","YTWJSON",220,0)
 . S IRID=0 F  S IRID=$O(^YTT(601.83,"AD",TEST,QSTN1,IRID)) Q:'IRID  D
"RTN","YTWJSON",221,0)
 . . S RID=$P(^YTT(601.83,IRID,0),U,4),RIDX=RIDX+1
"RTN","YTWJSON",222,0)
 . . S X0=^YTT(601.82,RID,0),X1=$G(^(1)),X=$P(X0,U,5)
"RTN","YTWJSON",223,0)
 . . S TREE("rules",RIDX,"question")="q"_QSTN1
"RTN","YTWJSON",224,0)
 . . S TREE("rules",RIDX,"operator")=$S(X="Does not equal":"NE",X="Equals":"EQ",1:X)
"RTN","YTWJSON",225,0)
 . . S TREE("rules",RIDX,"value")=$$TRUTHVAL(QSTN1,$P(X0,U,3))
"RTN","YTWJSON",226,0)
 . . I $L(X1),$P(X0,U,6)="AND" D
"RTN","YTWJSON",227,0)
 . . . S QSTN2=$P(X0,U,7),X=$P(X1,U,3) Q:'QSTN2
"RTN","YTWJSON",228,0)
 . . . S TREE("rules",RIDX,"conjunction")="and"
"RTN","YTWJSON",229,0)
 . . . S TREE("rules",RIDX,"question2")="q"_QSTN2
"RTN","YTWJSON",230,0)
 . . . S TREE("rules",RIDX,"operator2")=$S(X="Does not equal":"NE",X="Equals":"EQ",1:X)
"RTN","YTWJSON",231,0)
 . . . S TREE("rules",RIDX,"value2")=$$TRUTHVAL(QSTN2,$P(X1,U,1))
"RTN","YTWJSON",232,0)
 . . D SETSKIPS(RID,RIDX)
"RTN","YTWJSON",233,0)
 Q
"RTN","YTWJSON",234,0)
TRUTHVAL(QSTN,VALUE) ; return the target value for the rule
"RTN","YTWJSON",235,0)
 ; if MCHOICE, convert from Delphi itemIndex value to choice id
"RTN","YTWJSON",236,0)
 I $P($G(^YTT(601.72,QSTN,2)),U,2)'=1 Q VALUE  ; not MCHOICE so return value
"RTN","YTWJSON",237,0)
 N CTYP,CSEQ,CHID,IDX,DONE                     ; otherwise, find choice id
"RTN","YTWJSON",238,0)
 S CTYP=$P($G(^YTT(601.72,QSTN,2)),U,3),(CSEQ,CHID,DONE,IDX)=0
"RTN","YTWJSON",239,0)
 F  S CSEQ=$O(^YTT(601.751,"AC",CTYP,CSEQ)) Q:'CSEQ  D  Q:DONE 
"RTN","YTWJSON",240,0)
 . I IDX=VALUE S CHID=$O(^YTT(601.751,"AC",CTYP,CSEQ,CHID)),DONE=1 Q
"RTN","YTWJSON",241,0)
 . S IDX=IDX+1
"RTN","YTWJSON",242,0)
 Q "c"_CHID
"RTN","YTWJSON",243,0)
 ;
"RTN","YTWJSON",244,0)
SETSKIPS(RID,RIDX) ; set skipped questions for rule RID at index RIDX
"RTN","YTWJSON",245,0)
 N SID,QID,SIDX
"RTN","YTWJSON",246,0)
 S SIDX=0
"RTN","YTWJSON",247,0)
 S SID=0 F  S SID=$O(^YTT(601.79,"AE",RID,SID)) Q:'SID  D
"RTN","YTWJSON",248,0)
 . S QID=$P(^YTT(601.79,SID,0),U,4) Q:'QID
"RTN","YTWJSON",249,0)
 . S SIDX=SIDX+1
"RTN","YTWJSON",250,0)
 . S TREE("rules",RIDX,"skips",SIDX)="q"_QID
"RTN","YTWJSON",251,0)
 Q
"RTN","YTWJSONF")
0^8^B9425991^n/a
"RTN","YTWJSONF",1,0)
YTWJSONF ;SLC/KCM - File/Export JSON versions of instruments ; 7/20/2018
"RTN","YTWJSONF",2,0)
 ;;5.01;MENTAL HEALTH;**130**;Dec 30, 1994;Build 62
"RTN","YTWJSONF",3,0)
 ;
"RTN","YTWJSONF",4,0)
 ; External Reference    ICR#
"RTN","YTWJSONF",5,0)
 ; ------------------   -----
"RTN","YTWJSONF",6,0)
 ; %ZISH                 2320
"RTN","YTWJSONF",7,0)
 ; XPDUTL               10141
"RTN","YTWJSONF",8,0)
 ;
"RTN","YTWJSONF",9,0)
SAVEDIR ; Save all active instruments to directory
"RTN","YTWJSONF",10,0)
 ; may need to first remove current files from the destination directory
"RTN","YTWJSONF",11,0)
 ; (this doesn't clean up the destination directory first)
"RTN","YTWJSONF",12,0)
 N PATH
"RTN","YTWJSONF",13,0)
 S PATH=$$PROMPT^YTWJSONU("Destination Directory") Q:'$L(PATH)
"RTN","YTWJSONF",14,0)
 D LPACTV(PATH)
"RTN","YTWJSONF",15,0)
 D LIST(PATH)
"RTN","YTWJSONF",16,0)
 Q
"RTN","YTWJSONF",17,0)
SAVE96 ; Save all active instruments as JSON in 601.96
"RTN","YTWJSONF",18,0)
 D DEL96      ; remove the current entries for active instruments
"RTN","YTWJSONF",19,0)
 D LPACTV("") ; empty path causes save to 601.96
"RTN","YTWJSONF",20,0)
 D LIST96
"RTN","YTWJSONF",21,0)
 Q
"RTN","YTWJSONF",22,0)
 ;
"RTN","YTWJSONF",23,0)
LPACTV(PATH) ; Loop thru all active instruments to create JSON documents
"RTN","YTWJSONF",24,0)
 ; PATH: if empty, JSON documents are saved to 601.96
"RTN","YTWJSONF",25,0)
 ;       otherwise, this specifics the host directory
"RTN","YTWJSONF",26,0)
 N TEST
"RTN","YTWJSONF",27,0)
 S TEST=0 F  S TEST=$O(^YTT(601.71,TEST)) Q:'TEST  D
"RTN","YTWJSONF",28,0)
 . I $P($G(^YTT(601.71,TEST,2)),U,2)'="Y" QUIT
"RTN","YTWJSONF",29,0)
 . I '$L($G(PATH)) D FILE96(TEST) W "."
"RTN","YTWJSONF",30,0)
 . I $L($G(PATH)) D FILE(TEST,PATH) W "."
"RTN","YTWJSONF",31,0)
 Q
"RTN","YTWJSONF",32,0)
 ;
"RTN","YTWJSONF",33,0)
 ; -- calls to write to 601.96
"RTN","YTWJSONF",34,0)
 ;
"RTN","YTWJSONF",35,0)
DEL96 ; Delete active instruments from 601.96
"RTN","YTWJSONF",36,0)
 N NM,IEN
"RTN","YTWJSONF",37,0)
 S NM="YTT " F  S NM=$O(^YTT(601.96,"B",NM)) Q:$E(NM,1,4)'="YTT "  D
"RTN","YTWJSONF",38,0)
 . S IEN=$O(^YTT(601.96,"B",NM,0))
"RTN","YTWJSONF",39,0)
 . D FMDEL^YTXCHGU(601.96,IEN)
"RTN","YTWJSONF",40,0)
 S IEN=$O(^YTT(601.96,"B","YTL ACTIVE",0))
"RTN","YTWJSONF",41,0)
 D FMDEL^YTXCHGU(601.96,IEN)
"RTN","YTWJSONF",42,0)
 Q
"RTN","YTWJSONF",43,0)
FILE96(TEST) ; save JSON test to 601.96
"RTN","YTWJSONF",44,0)
 I TEST'=+TEST S TEST=$O(^YTT(601.71,"B",TEST,0)) Q:'TEST
"RTN","YTWJSONF",45,0)
 Q:'$D(^YTT(601.71,TEST,0))
"RTN","YTWJSONF",46,0)
 ;
"RTN","YTWJSONF",47,0)
 N REC,JSON,IEN
"RTN","YTWJSONF",48,0)
 S REC(.01)="YTT "_$P(^YTT(601.71,TEST,0),U)
"RTN","YTWJSONF",49,0)
 S REC(.02)=1
"RTN","YTWJSONF",50,0)
 S REC(1)="JSON"
"RTN","YTWJSONF",51,0)
 S IEN=$O(^YTT(601.96,"B",REC(.01),0))
"RTN","YTWJSONF",52,0)
 D GETSPEC^YTWJSON(.JSON,TEST)
"RTN","YTWJSONF",53,0)
 I '$D(JSON) D  QUIT 
"RTN","YTWJSONF",54,0)
 . D MES^XPDUTL("Error creating JSON for "_$P(^YTT(601.71,TEST,0),U))
"RTN","YTWJSONF",55,0)
 ;
"RTN","YTWJSONF",56,0)
 I IEN D FMUPD^YTXCHGU(601.96,.REC,IEN) I 1
"RTN","YTWJSONF",57,0)
 E  D FMADD^YTXCHGU(601.96,.REC)
"RTN","YTWJSONF",58,0)
 Q
"RTN","YTWJSONF",59,0)
LIST96 ; Save list of instruments as JSON in 601.96
"RTN","YTWJSONF",60,0)
 N REC,JSON,IEN
"RTN","YTWJSONF",61,0)
 S REC(.01)="YTL ACTIVE"
"RTN","YTWJSONF",62,0)
 S REC(.02)=1
"RTN","YTWJSONF",63,0)
 S REC(1)="JSON"
"RTN","YTWJSONF",64,0)
 S IEN=$O(^YTT(601.96,"B","YTL ACTIVE",0))
"RTN","YTWJSONF",65,0)
 D NAMES^YTWJSONU(.JSON)
"RTN","YTWJSONF",66,0)
 I IEN D FMUPD^YTXCHGU(601.96,.REC,IEN) I 1
"RTN","YTWJSONF",67,0)
 E  D FMADD^YTXCHGU(601.96,.REC)
"RTN","YTWJSONF",68,0)
 Q
"RTN","YTWJSONF",69,0)
 ;
"RTN","YTWJSONF",70,0)
 ; -- calls to write to host directory
"RTN","YTWJSONF",71,0)
 ;
"RTN","YTWJSONF",72,0)
FILE(TEST,PATH) ; save JSON test to a file
"RTN","YTWJSONF",73,0)
 I TEST'=+TEST S TEST=$O(^YTT(601.71,"B",TEST,0)) Q:'TEST
"RTN","YTWJSONF",74,0)
 ;
"RTN","YTWJSONF",75,0)
 N JSON,OK
"RTN","YTWJSONF",76,0)
 D GETSPEC^YTWJSON(.JSON,TEST)
"RTN","YTWJSONF",77,0)
 I '$D(JSON) W !,"Error creating JSON for "_$P(^YTT(601.71,TEST,0),U) QUIT
"RTN","YTWJSONF",78,0)
 ;
"RTN","YTWJSONF",79,0)
 K ^TMP($J)
"RTN","YTWJSONF",80,0)
 M ^TMP($J)=JSON ; so can use $$GTF^%ZISH
"RTN","YTWJSONF",81,0)
 N NAME S NAME=$TR($P(^YTT(601.71,TEST,0),U)," ","_")_".json"
"RTN","YTWJSONF",82,0)
 S OK=$$GTF^%ZISH($NA(^TMP($J,1)),2,PATH,NAME)
"RTN","YTWJSONF",83,0)
 I 'OK W !,"Error writing file: "_NAME
"RTN","YTWJSONF",84,0)
 K ^TMP($J)
"RTN","YTWJSONF",85,0)
 Q
"RTN","YTWJSONF",86,0)
LIST(PATH) ; Save list of instruments as JSON to directory
"RTN","YTWJSONF",87,0)
 N JSON,OK
"RTN","YTWJSONF",88,0)
 D NAMES^YTWJSONU(.JSON)
"RTN","YTWJSONF",89,0)
 K ^TMP($J) M ^TMP($J)=JSON
"RTN","YTWJSONF",90,0)
 S OK=$$GTF^%ZISH($NA(^TMP($J,1)),2,PATH,"instrumentList.json")
"RTN","YTWJSONF",91,0)
 I 'OK W !,"Error writing file: instrumentList.json"
"RTN","YTWJSONF",92,0)
 K ^TMP($J)
"RTN","YTWJSONF",93,0)
 Q
"RTN","YTWJSONF",94,0)
 ;
"RTN","YTWJSONO")
0^9^B21552194^n/a
"RTN","YTWJSONO",1,0)
YTWJSONO ;SLC/KCM - Instrument Admin Spec Output ; 1/25/2017
"RTN","YTWJSONO",2,0)
 ;;5.01;MENTAL HEALTH;**130**;Dec 30, 1994;Build 62
"RTN","YTWJSONO",3,0)
 ;
"RTN","YTWJSONO",4,0)
 ; External Reference    ICR#
"RTN","YTWJSONO",5,0)
 ; ------------------   -----
"RTN","YTWJSONO",6,0)
 ; XLFSTR               10104
"RTN","YTWJSONO",7,0)
 ;
"RTN","YTWJSONO",8,0)
TEST ;
"RTN","YTWJSONO",9,0)
 N TEST,TREE,OUT
"RTN","YTWJSONO",10,0)
 S TEST=7 ;144 ; CSI |153 ; CDR |162 ; BAM
"RTN","YTWJSONO",11,0)
 D CONTENT^YTWJSON(TEST,.TREE)
"RTN","YTWJSONO",12,0)
 D FMTJSON(.TREE,.OUT)
"RTN","YTWJSONO",13,0)
 N I S I=0 F  S I=$O(OUT(I)) Q:'I  W !,OUT(I)
"RTN","YTWJSONO",14,0)
 Q
"RTN","YTWJSONO",15,0)
FMTJSON(TREE,OUT) ; format instrument spec in TREE as readable lines
"RTN","YTWJSONO",16,0)
 N LN,ROOT,SLOT,IDX
"RTN","YTWJSONO",17,0)
 S LN=1,ROOT="TREE"
"RTN","YTWJSONO",18,0)
 D TEXT("{")
"RTN","YTWJSONO",19,0)
 D PROP("name"),LF(1)
"RTN","YTWJSONO",20,0)
 I $L(@ROOT@("copyright")) D PROP("copyright"),LF(1)
"RTN","YTWJSONO",21,0)
 D PROP("restartDays"),LF(1)
"RTN","YTWJSONO",22,0)
 D COMMA,TEXT("""content"":[")
"RTN","YTWJSONO",23,0)
 S SLOT=0 F  S SLOT=$O(TREE("content",SLOT)) Q:'SLOT  D
"RTN","YTWJSONO",24,0)
 . S ROOT=$NA(TREE("content",SLOT))
"RTN","YTWJSONO",25,0)
 . D COMMA,LF(3)
"RTN","YTWJSONO",26,0)
 . D TEXT("{")
"RTN","YTWJSONO",27,0)
 . D PROP("id"),PROP("type"),PROP("required"),PROP("inline"),PROP("tab")
"RTN","YTWJSONO",28,0)
 . D LF(4)
"RTN","YTWJSONO",29,0)
 . D PROP("text")
"RTN","YTWJSONO",30,0)
 . D LF(4)
"RTN","YTWJSONO",31,0)
 . I $D(@ROOT@("intro")) D PROP("intro"),LF(4)
"RTN","YTWJSONO",32,0)
 . D PROP("columns"),PROP("left"),PROP("controlWidth"),PROP("min"),PROP("max")
"RTN","YTWJSONO",33,0)
 . ; output choices, if present
"RTN","YTWJSONO",34,0)
 . I $D(TREE("content",SLOT,"choices"))>1 D
"RTN","YTWJSONO",35,0)
 . . D COMMA,LF(4),TEXT("""choices"":[")
"RTN","YTWJSONO",36,0)
 . . S IDX=0 F  S IDX=$O(TREE("content",SLOT,"choices",IDX)) Q:'IDX  D
"RTN","YTWJSONO",37,0)
 . . . S ROOT=$NA(TREE("content",SLOT,"choices",IDX))
"RTN","YTWJSONO",38,0)
 . . . D COMMA,LF(5)
"RTN","YTWJSONO",39,0)
 . . . D TEXT("{"),PROP("id"),PROP("text"),PROP("quickKey"),TEXT("}")
"RTN","YTWJSONO",40,0)
 . . D LF(3),TEXT("]")                           ; end of choices array
"RTN","YTWJSONO",41,0)
 . ; output legend, if present
"RTN","YTWJSONO",42,0)
 . I $D(TREE("content",SLOT,"legend"))>1 D
"RTN","YTWJSONO",43,0)
 . . N LEGEND
"RTN","YTWJSONO",44,0)
 . . D COMMA,LF(4),TEXT("""legend"":[")
"RTN","YTWJSONO",45,0)
 . . S IDX=0 F  S IDX=$O(TREE("content",SLOT,"legend",IDX)) Q:'IDX  D
"RTN","YTWJSONO",46,0)
 . . . S LEGEND=TREE("content",SLOT,"legend",IDX)
"RTN","YTWJSONO",47,0)
 . . . D COMMA,TEXT(""""_LEGEND_"""")
"RTN","YTWJSONO",48,0)
 . . D TEXT("]")                                 ; end of legend array
"RTN","YTWJSONO",49,0)
 . D TEXT("}")                                   ; end of content object
"RTN","YTWJSONO",50,0)
 D TEXT("]")                                     ; end of content array
"RTN","YTWJSONO",51,0)
 I $D(TREE("rules"))>1 D
"RTN","YTWJSONO",52,0)
 . N RIDX,SIDX
"RTN","YTWJSONO",53,0)
 . D COMMA,LF(1),TEXT("""rules"":[")
"RTN","YTWJSONO",54,0)
 . S RIDX=0 F  S RIDX=$O(TREE("rules",RIDX)) Q:'RIDX  D
"RTN","YTWJSONO",55,0)
 . . S ROOT=$NA(TREE("rules",RIDX))
"RTN","YTWJSONO",56,0)
 . . D COMMA,LF(3),TEXT("{")
"RTN","YTWJSONO",57,0)
 . . D PROP("question"),PROP("operator"),PROP("value")
"RTN","YTWJSONO",58,0)
 . . I $D(TREE("rules",RIDX,"conjunction")) D
"RTN","YTWJSONO",59,0)
 . . . D LF(4)
"RTN","YTWJSONO",60,0)
 . . . D PROP("conjunction"),PROP("question2"),PROP("operator2"),PROP("value2")
"RTN","YTWJSONO",61,0)
 . . I $D(TREE("rules",RIDX,"skips"))>1 D
"RTN","YTWJSONO",62,0)
 . . . D COMMA,LF(4),TEXT("""skips"":[")
"RTN","YTWJSONO",63,0)
 . . . S SIDX=0 F  S SIDX=$O(TREE("rules",RIDX,"skips",SIDX)) Q:'SIDX  D
"RTN","YTWJSONO",64,0)
 . . . . I SIDX>1 D TEXT(",")
"RTN","YTWJSONO",65,0)
 . . . . D TEXT(""""_TREE("rules",RIDX,"skips",SIDX)_"""")
"RTN","YTWJSONO",66,0)
 . . . D TEXT("]")                               ; end of skips array
"RTN","YTWJSONO",67,0)
 . . D TEXT("}")                                 ; end of single rule object
"RTN","YTWJSONO",68,0)
 . D TEXT("]")                                   ; end of rules
"RTN","YTWJSONO",69,0)
 D LF(0),TEXT("}")                              ; end of spec
"RTN","YTWJSONO",70,0)
 Q
"RTN","YTWJSONO",71,0)
TEXT(X) ; Add text to output
"RTN","YTWJSONO",72,0)
 ; expects OUT,LN
"RTN","YTWJSONO",73,0)
 S OUT(LN)=$G(OUT(LN))_X
"RTN","YTWJSONO",74,0)
 Q
"RTN","YTWJSONO",75,0)
PROP(NAME) ; Add property to output, using JSON data types
"RTN","YTWJSONO",76,0)
 ; expects OUT,LN,ROOT
"RTN","YTWJSONO",77,0)
 N X,VALUE
"RTN","YTWJSONO",78,0)
 I '$D(@ROOT@(NAME)) QUIT                      ; property absent
"RTN","YTWJSONO",79,0)
 ;
"RTN","YTWJSONO",80,0)
 ; The "\n", "\s" qualifiers included for completeness but likely not needed
"RTN","YTWJSONO",81,0)
 ; for MH instruments. See VPRJSONE for more complete encoding of JSON
"RTN","YTWJSONO",82,0)
 ;
"RTN","YTWJSONO",83,0)
 S X=@ROOT@(NAME) Q:'$L(X)                      ; empty value so quit
"RTN","YTWJSONO",84,0)
 I $D(@ROOT@(NAME,"\n")) S VALUE=X              ; forced numeric
"RTN","YTWJSONO",85,0)
 I '$D(@ROOT@(NAME,"\s")) D                     ; if not forced string
"RTN","YTWJSONO",86,0)
 . I X']]$C(1) S VALUE=X                        ; collates as numeric
"RTN","YTWJSONO",87,0)
 . I X="true"!(X="false")!(X="null") S VALUE=X  ; boolean/null
"RTN","YTWJSONO",88,0)
 I $D(@ROOT@(NAME,"\")) D                       ; handle word proc nodes
"RTN","YTWJSONO",89,0)
 . N IDX S IDX=0
"RTN","YTWJSONO",90,0)
 . F  S IDX=$O(@ROOT@(NAME,"\",IDX)) Q:'IDX  S X=X_@ROOT@(NAME,"\",IDX)
"RTN","YTWJSONO",91,0)
 . ; assumption is that all intros, questions, etc. have $L < 4096
"RTN","YTWJSONO",92,0)
 . I $L(X)>4000 W !!,"ERROR, Length of "_ROOT_" "_NAME_" is "_$L(X)
"RTN","YTWJSONO",93,0)
 I '$D(VALUE) S VALUE=""""_X_""""               ; string
"RTN","YTWJSONO",94,0)
 D COMMA
"RTN","YTWJSONO",95,0)
 S OUT(LN)=OUT(LN)_""""_NAME_""": "_VALUE
"RTN","YTWJSONO",96,0)
 Q
"RTN","YTWJSONO",97,0)
COMMA ; Add comma, if needed, before adding property
"RTN","YTWJSONO",98,0)
 ; expects OUT,LN
"RTN","YTWJSONO",99,0)
 N LAST S LAST=$$LAST
"RTN","YTWJSONO",100,0)
 I "{["'[LAST D  ; see if we need a comma based on the last character
"RTN","YTWJSONO",101,0)
 . I $L($TR($G(OUT(LN))," ","")) S OUT(LN)=OUT(LN)_", " Q  ; use this line
"RTN","YTWJSONO",102,0)
 . S OUT(LN-1)=OUT(LN-1)_", "                              ; use last line
"RTN","YTWJSONO",103,0)
 Q
"RTN","YTWJSONO",104,0)
LAST() ; Return the last non-space character
"RTN","YTWJSONO",105,0)
 ; expects OUT,LN
"RTN","YTWJSONO",106,0)
 N X
"RTN","YTWJSONO",107,0)
 S X=$TR($G(OUT(LN))," ","")
"RTN","YTWJSONO",108,0)
 I '$L(X) S X=$TR($G(OUT(LN-1))," ","")
"RTN","YTWJSONO",109,0)
 Q $E(X,$L(X))
"RTN","YTWJSONO",110,0)
 ;
"RTN","YTWJSONO",111,0)
LF(SPACES) ; advance to next line, using indent level in SPACES
"RTN","YTWJSONO",112,0)
 ; expects OUT,LN
"RTN","YTWJSONO",113,0)
 S LN=+$G(LN)+1                                 ; line number
"RTN","YTWJSONO",114,0)
 S OUT(LN)=$$REPEAT^XLFSTR(" ",SPACES)
"RTN","YTWJSONO",115,0)
 Q
"RTN","YTWJSONU")
0^10^B5383901^n/a
"RTN","YTWJSONU",1,0)
YTWJSONU ;SLC/KCM - JSON Instrument Spec Utilities ; 7/20/2018
"RTN","YTWJSONU",2,0)
 ;;5.01;MENTAL HEALTH;**130**;Dec 30, 1994;Build 62
"RTN","YTWJSONU",3,0)
 ;
"RTN","YTWJSONU",4,0)
 ; External Reference    ICR#
"RTN","YTWJSONU",5,0)
 ; ------------------   -----
"RTN","YTWJSONU",6,0)
 ; DIR                  10026
"RTN","YTWJSONU",7,0)
 ; XLFDT                10103
"RTN","YTWJSONU",8,0)
 ; XLFSTR               10104
"RTN","YTWJSONU",9,0)
 ;
"RTN","YTWJSONU",10,0)
PROMPT(TEXT) ; prompt for text value and return, otherwise ""
"RTN","YTWJSONU",11,0)
 N DIR,X,Y,DTOUT,DUOUT,DIRUT,DIROUT
"RTN","YTWJSONU",12,0)
 S DIR(0)="F",DIR("A")=TEXT
"RTN","YTWJSONU",13,0)
 I $D(^XTMP("YTWPROMPTS",TEXT)) S DIR("B")=^XTMP("YTWPROMPTS",TEXT)
"RTN","YTWJSONU",14,0)
 D ^DIR I $G(DIRUT) S X=""
"RTN","YTWJSONU",15,0)
 I $L(X) D
"RTN","YTWJSONU",16,0)
 . S ^XTMP("YTWPROMPTS",0)=$$FMADD^XLFDT(DT,7)_U_DT_U_"MH Default Prompts"
"RTN","YTWJSONU",17,0)
 . S ^XTMP("YTWPROMPTS",TEXT)=X
"RTN","YTWJSONU",18,0)
 Q X
"RTN","YTWJSONU",19,0)
 ;W !,"X=",X,!,"Y=",Y,!,$G(DTOUT),?5,$G(DUOUT),?10,$G(DIRUT),?15,$G(DIROUT)
"RTN","YTWJSONU",20,0)
 ;
"RTN","YTWJSONU",21,0)
BLDTXT(WPREF,TEXT) ; build array of JSON text from WP field
"RTN","YTWJSONU",22,0)
 N I,LN,LASTLN,IDX
"RTN","YTWJSONU",23,0)
 S IDX=-1
"RTN","YTWJSONU",24,0)
 S I=0 F  S I=$O(@WPREF@(I)) Q:'I  D
"RTN","YTWJSONU",25,0)
 . S LN=@WPREF@(I,0),IDX=IDX+1
"RTN","YTWJSONU",26,0)
 . S LN=$$HTMLESC(LN)
"RTN","YTWJSONU",27,0)
 . I IDX=0 S TEXT=LN,LASTLN=LN Q
"RTN","YTWJSONU",28,0)
 . I ($E(LASTLN,$L(LASTLN))'=" "),($E(LN)'=" ") S LN=" "_LN
"RTN","YTWJSONU",29,0)
 . S TEXT("\",IDX)=LN,LASTLN=LN
"RTN","YTWJSONU",30,0)
 Q
"RTN","YTWJSONU",31,0)
HTMLESC(X) ; return X HTML escaped
"RTN","YTWJSONU",32,0)
 N SPEC
"RTN","YTWJSONU",33,0)
 S SPEC("|")="<br />"
"RTN","YTWJSONU",34,0)
 ; use unicode character since JSX treats &char; as code injection
"RTN","YTWJSONU",35,0)
 S SPEC("""")="\u0022"  ; "&quot;"
"RTN","YTWJSONU",36,0)
 S SPEC(">")="\u003E"   ; "&gt;"
"RTN","YTWJSONU",37,0)
 S SPEC("<")="\u003C"   ; "&lt;"
"RTN","YTWJSONU",38,0)
 Q $$REPLACE^XLFSTR(X,.SPEC)
"RTN","YTWJSONU",39,0)
 ;
"RTN","YTWJSONU",40,0)
 ;
"RTN","YTWJSONU",41,0)
NAMES(OUT) ; build JSON of all active test names
"RTN","YTWJSONU",42,0)
 N LN,NAME,TEST,STAFF
"RTN","YTWJSONU",43,0)
 S LN=1,OUT(LN)="{""instruments"":["
"RTN","YTWJSONU",44,0)
 S NAME=0 F  S NAME=$O(^YTT(601.71,"B",NAME)) Q:'$L(NAME)  D
"RTN","YTWJSONU",45,0)
 . S TEST=0 F  S TEST=$O(^YTT(601.71,"B",NAME,TEST)) Q:'TEST  D
"RTN","YTWJSONU",46,0)
 . . I $P($G(^YTT(601.71,TEST,2)),U,2)'="Y" QUIT
"RTN","YTWJSONU",47,0)
 . . D ADDPROP("name",NAME)
"RTN","YTWJSONU",48,0)
 . . D ADDPROP("fullName",$P(^YTT(601.71,TEST,0),U,3))
"RTN","YTWJSONU",49,0)
 . . D ADDPROP("isBattery","false")
"RTN","YTWJSONU",50,0)
 . . S STAFF=($P($G(^YTT(601.71,TEST,1)),U,7)="Y")
"RTN","YTWJSONU",51,0)
 . . D ADDPROP("staffOnly",$S(STAFF=1:"true",1:"false"))
"RTN","YTWJSONU",52,0)
 S OUT(LN)=$E(OUT(LN),1,$L(OUT(LN))-1)  ; remove last comma
"RTN","YTWJSONU",53,0)
 S LN=LN+1,OUT(LN)="]}"
"RTN","YTWJSONU",54,0)
 ;N I S I=0 F  S I=$O(OUT(I)) Q:'I  W !,OUT(I)
"RTN","YTWJSONU",55,0)
 Q
"RTN","YTWJSONU",56,0)
 ;
"RTN","YTWJSONU",57,0)
ADDPROP(NAME,VALUE) ; add property to test select object
"RTN","YTWJSONU",58,0)
 ; expects OUT,LN
"RTN","YTWJSONU",59,0)
 N X
"RTN","YTWJSONU",60,0)
 S X=""
"RTN","YTWJSONU",61,0)
 I NAME="name" S X=X_"{",LN=LN+1,OUT(LN)=""
"RTN","YTWJSONU",62,0)
 S X=X_""""_NAME_""":"
"RTN","YTWJSONU",63,0)
 I NAME="staffOnly" D
"RTN","YTWJSONU",64,0)
 . S X=X_VALUE_"},"
"RTN","YTWJSONU",65,0)
 E  S X=X_""""_VALUE_""","
"RTN","YTWJSONU",66,0)
 S OUT(LN)=OUT(LN)_X
"RTN","YTWJSONU",67,0)
 Q
"RTN","YTXCHG")
0^21^B70845213^B65891565
"RTN","YTXCHG",1,0)
YTXCHG ;SLC/KCM - Instrument Exchange Calls ; 9/15/2015
"RTN","YTXCHG",2,0)
 ;;5.01;MENTAL HEALTH;**121,123,130**;Dec 30, 1994;Build 62
"RTN","YTXCHG",3,0)
 ;
"RTN","YTXCHG",4,0)
 ; External Reference    ICR#
"RTN","YTXCHG",5,0)
 ; ------------------   -----
"RTN","YTXCHG",6,0)
 ; %ZISH                 2320
"RTN","YTXCHG",7,0)
 ; DIC                   2051
"RTN","YTXCHG",8,0)
 ; DIK                  10013
"RTN","YTXCHG",9,0)
 ; XPDUTL               10141
"RTN","YTXCHG",10,0)
 ; XTHC10                5515
"RTN","YTXCHG",11,0)
 ;
"RTN","YTXCHG",12,0)
VERSION ;; current Instrument Exchange version
"RTN","YTXCHG",13,0)
 ;;1.02
"RTN","YTXCHG",14,0)
 Q
"RTN","YTXCHG",15,0)
INCLUDE(Y,TAG,RTN) ; return true for Y in list produced by TAG^RTN
"RTN","YTXCHG",16,0)
 ; Y: IEN of entry currently being checked for inclusion
"RTN","YTXCHG",17,0)
 ; TAG^RTN(.ARRAY) is called to build list of 601.95 entries in ARRAY
"RTN","YTXCHG",18,0)
 ;         .ARRAY(n,1): name (.01) value in 601.95
"RTN","YTXCHG",19,0)
 ;         .ARRAY(n,2): date (.02) value in 601.95
"RTN","YTXCHG",20,0)
 ;
"RTN","YTXCHG",21,0)
 N ARRAY,IDX,FOUND,VALS,IEN
"RTN","YTXCHG",22,0)
 D @(TAG_U_RTN_"(.ARRAY)")
"RTN","YTXCHG",23,0)
 S FOUND=0
"RTN","YTXCHG",24,0)
 S IDX=0 F  S IDX=$O(ARRAY(IDX)) Q:'IDX  D  Q:FOUND
"RTN","YTXCHG",25,0)
 . M VALS=ARRAY(IDX)
"RTN","YTXCHG",26,0)
 . S IEN=+$$FIND1^DIC(601.95,"","KU",.VALS)
"RTN","YTXCHG",27,0)
 . I IEN=Y S FOUND=1
"RTN","YTXCHG",28,0)
 Q FOUND
"RTN","YTXCHG",29,0)
 ;
"RTN","YTXCHG",30,0)
CREATE(TESTS,XCHGREC) ; return IEN or error after creating exchange entry
"RTN","YTXCHG",31,0)
 ; .TESTS(n)=instrumentIEN  ; instruments to include in JSON spec
"RTN","YTXCHG",32,0)
 ; .XCHGREC(field)=value    ; values used to create exchange entry
"RTN","YTXCHG",33,0)
 N SEQ,XCHGIEN,OK
"RTN","YTXCHG",34,0)
 K ^TMP("YTXCHGE",$J,"TREE")
"RTN","YTXCHG",35,0)
 K ^TMP("YTXCHGE",$J,"JSON")
"RTN","YTXCHG",36,0)
 S SEQ=0 F  S SEQ=$O(TESTS(SEQ)) Q:'SEQ  D
"RTN","YTXCHG",37,0)
 . D MHA2TR^YTXCHGT(TESTS(SEQ),$NA(^TMP("YTXCHGE",$J,"TREE","test",SEQ)))
"RTN","YTXCHG",38,0)
 S ^TMP("YTXCHGE",$J,"TREE","xchg","name")=XCHGREC(.01)
"RTN","YTXCHG",39,0)
 S ^TMP("YTXCHGE",$J,"TREE","xchg","date")=XCHGREC(.02)
"RTN","YTXCHG",40,0)
 S ^TMP("YTXCHGE",$J,"TREE","xchg","source")=XCHGREC(.03)
"RTN","YTXCHG",41,0)
 S ^TMP("YTXCHGE",$J,"TREE","xchg","version")=+$P($T(VERSION+1),";;",2)
"RTN","YTXCHG",42,0)
 D WP2TR^YTXCHGT(XCHGREC(2),$NA(^TMP("YTXCHGE",$J,"TREE","xchg","description")))
"RTN","YTXCHG",43,0)
 S OK=$$TR2JSON^YTXCHGT($NA(^TMP("YTXCHGE",$J,"TREE")),$NA(^TMP("YTXCHGE",$J,"JSON")))
"RTN","YTXCHG",44,0)
 S XCHGREC(1)=$NA(^TMP("YTXCHGE",$J,"JSON"))
"RTN","YTXCHG",45,0)
 I OK D FMADD^YTXCHGU(601.95,.XCHGREC,.XCHGIEN)
"RTN","YTXCHG",46,0)
 K ^TMP("YTXCHGE",$J,"TREE")
"RTN","YTXCHG",47,0)
 K ^TMP("YTXCHGE",$J,"JSON")
"RTN","YTXCHG",48,0)
 Q $S(OK:XCHGIEN,1:-1)
"RTN","YTXCHG",49,0)
 ;
"RTN","YTXCHG",50,0)
INFO(XCHGIEN,INFO) ; put build information into .INFO
"RTN","YTXCHG",51,0)
 ; .INFO(fld)=value
"RTN","YTXCHG",52,0)
 ; .INFO("tests",n)=testName
"RTN","YTXCHG",53,0)
 I $D(^YTT(601.95,XCHGIEN,1))'>1 D LOG^YTXCHGU("error","Spec not found.") Q
"RTN","YTXCHG",54,0)
 N I,OK
"RTN","YTXCHG",55,0)
 K ^TMP("YTXCHG",$J,"TREE")
"RTN","YTXCHG",56,0)
 S OK=$$SPEC2TR^YTXCHGT(XCHGIEN,$NA(^TMP("YTXCHG",$J,"TREE"))) G:'OK XINFO
"RTN","YTXCHG",57,0)
 I $D(^YTT(601.95,XCHGIEN,4,1,0)) D  ; pull in addendum if it is there
"RTN","YTXCHG",58,0)
 . D WP2TR^YTXCHGT($NA(^YTT(601.95,XCHGIEN,4)),$NA(^TMP("YTXCHG",$J,"TREE","xchg","addendum")))
"RTN","YTXCHG",59,0)
 S I=0 F  S I=$O(^TMP("YTXCHG",$J,"TREE","test",I)) Q:'I  D
"RTN","YTXCHG",60,0)
 . S INFO("tests",I)=^TMP("YTXCHG",$J,"TREE","test",I,"info","name")
"RTN","YTXCHG",61,0)
 D SETINFO(.INFO,$NA(^TMP("YTXCHG",$J,"TREE")))
"RTN","YTXCHG",62,0)
XINFO ; exit here
"RTN","YTXCHG",63,0)
 K ^TMP("YTXCHG",$J,"TREE")
"RTN","YTXCHG",64,0)
 Q
"RTN","YTXCHG",65,0)
DELETE(XCHGIEN) ; delete instrument exchange entry
"RTN","YTXCHG",66,0)
 N DIK,DA
"RTN","YTXCHG",67,0)
 I '$D(^YTT(601.95,XCHGIEN)) D LOG^YTXCHGU("error","Entry not found.") Q
"RTN","YTXCHG",68,0)
 S DIK="^YTT(601.95,",DA=XCHGIEN
"RTN","YTXCHG",69,0)
 D ^DIK
"RTN","YTXCHG",70,0)
 Q
"RTN","YTXCHG",71,0)
INSTALL(XCHGIEN,DRYRUN) ; install instrument exchange entry locally
"RTN","YTXCHG",72,0)
 I $D(^YTT(601.95,XCHGIEN,1))'>1 D LOG^YTXCHGU("error","Install entry #"_XCHGIEN_" not found.") QUIT
"RTN","YTXCHG",73,0)
 ;
"RTN","YTXCHG",74,0)
 ; set up index across MH files
"RTN","YTXCHG",75,0)
 I $P($G(^XTMP("YTXIDX",0)),U,2)'=DT D IDXALL^YTXCHGV
"RTN","YTXCHG",76,0)
 I $P($G(^XTMP("YTXIDX",0)),U,2)'=DT D LOG^YTXCHGU("error","Unable to index") QUIT
"RTN","YTXCHG",77,0)
 ;
"RTN","YTXCHG",78,0)
 K ^TMP("YTXCHGI",$J,"TREE")
"RTN","YTXCHG",79,0)
 N OK
"RTN","YTXCHG",80,0)
 S OK=$$SPEC2TR^YTXCHGT(XCHGIEN,$NA(^TMP("YTXCHGI",$J,"TREE")))
"RTN","YTXCHG",81,0)
 I OK D
"RTN","YTXCHG",82,0)
 . I $$BADVER($G(^TMP("YTXCHGI",$J,"TREE","xchg","version"))) QUIT
"RTN","YTXCHG",83,0)
 . D TR2MHA^YTXCHGT($NA(^TMP("YTXCHGI",$J,"TREE")),$G(DRYRUN))
"RTN","YTXCHG",84,0)
 . I '$G(DRYRUN) D
"RTN","YTXCHG",85,0)
 . . D LOGINST^YTXCHGU(XCHGIEN)
"RTN","YTXCHG",86,0)
 . . D CHKSCORE^YTXCHGT(XCHGIEN)
"RTN","YTXCHG",87,0)
 . . D LIST96^YTWJSONF ; rebuild active instrument list
"RTN","YTXCHG",88,0)
 K ^TMP("YTXCHGI",$J,"TREE")
"RTN","YTXCHG",89,0)
 Q
"RTN","YTXCHG",90,0)
INSTALLQ(TAG,RTN) ; install exchange entries listed by TAG^RTN in post-init
"RTN","YTXCHG",91,0)
 ; TAG^RTN(.ARRAY) is called to build list of 601.95 entries in ARRAY
"RTN","YTXCHG",92,0)
 ;         .ARRAY(n,1): name (.01) value in 601.95
"RTN","YTXCHG",93,0)
 ;         .ARRAY(n,2): date (.02) value in 601.95
"RTN","YTXCHG",94,0)
 N ARRAY,XCHGI,VALS,XCHGIEN
"RTN","YTXCHG",95,0)
 D @(TAG_U_RTN_"(.ARRAY)")
"RTN","YTXCHG",96,0)
 S XCHGI=0 F  S XCHGI=$O(ARRAY(XCHGI)) Q:'XCHGI  D
"RTN","YTXCHG",97,0)
 . M VALS=ARRAY(XCHGI)
"RTN","YTXCHG",98,0)
 . S XCHGIEN=+$$FIND1^DIC(601.95,"","KU",.VALS)
"RTN","YTXCHG",99,0)
 . Q:'XCHGIEN
"RTN","YTXCHG",100,0)
 . D INSTALL(XCHGIEN)
"RTN","YTXCHG",101,0)
 . ; D FMDEL^YTXCHGU(601.95,XCHGIEN)  ; remove now that install is done
"RTN","YTXCHG",102,0)
 D BMES^XPDUTL("MH Instrument install complete.")
"RTN","YTXCHG",103,0)
 Q
"RTN","YTXCHG",104,0)
BADVER(VERSION) ; return true if version conflict
"RTN","YTXCHG",105,0)
 I VERSION'=+$P($T(VERSION+1),";;",2) D  QUIT 1
"RTN","YTXCHG",106,0)
 . D LOG^YTXCHGU("error","Version conflict, unable to continue.")
"RTN","YTXCHG",107,0)
 Q 0
"RTN","YTXCHG",108,0)
 ;
"RTN","YTXCHG",109,0)
BLDVIEW(TREE,DEST) ; create array for BROWSER view
"RTN","YTXCHG",110,0)
 ; TREE: $NA global reference for the instrument node of the tree
"RTN","YTXCHG",111,0)
 ; DEST: $NA global reference for the output lines
"RTN","YTXCHG",112,0)
 N MAP,IDX,CNTLINE,CNTROOT
"RTN","YTXCHG",113,0)
 S IDX=0,CNTLINE=0,CNTROOT=$QL(TREE)
"RTN","YTXCHG",114,0)
 D BLDSEQ^YTXCHGM(.MAP)
"RTN","YTXCHG",115,0)
 D ITER("MAP")
"RTN","YTXCHG",116,0)
 Q
"RTN","YTXCHG",117,0)
ITER(MAPREF) ;
"RTN","YTXCHG",118,0)
 ; expects IDX where IDX(IDX) is current index
"RTN","YTXCHG",119,0)
 ; MAPREF: $NA for the current reference in the map of JSON labels
"RTN","YTXCHG",120,0)
 N NODE,SEQ,LABEL
"RTN","YTXCHG",121,0)
 ;I $QS(MAPREF,4)="choiceIdentifier" B
"RTN","YTXCHG",122,0)
 I $D(@MAPREF)=1 S NODE=$$TREEREF(MAPREF,.IDX) D LINEOUT(NODE) QUIT
"RTN","YTXCHG",123,0)
 ;
"RTN","YTXCHG",124,0)
 S IDX=IDX+1,IDX(IDX)=0
"RTN","YTXCHG",125,0)
 S SEQ=0 F  S SEQ=$O(@MAPREF@(SEQ)) Q:'SEQ  D
"RTN","YTXCHG",126,0)
 . S LABEL=$O(@MAPREF@(SEQ,""))
"RTN","YTXCHG",127,0)
 . I $E(LABEL)="?" D  Q  ; iterate thru tree and call iter with varying ref
"RTN","YTXCHG",128,0)
 . . S NODE=$$TREEREF($NA(@MAPREF@(SEQ,LABEL)),.IDX)
"RTN","YTXCHG",129,0)
 . . F  S IDX(IDX)=$O(@NODE@(IDX(IDX))) Q:'IDX(IDX)  D ITER($NA(@MAPREF@(SEQ,LABEL)))
"RTN","YTXCHG",130,0)
 . E  D ITER($NA(@MAPREF@(SEQ,LABEL))) ; call iter with next label
"RTN","YTXCHG",131,0)
 S IDX=IDX-1
"RTN","YTXCHG",132,0)
 Q
"RTN","YTXCHG",133,0)
TREEREF(MAPREF,IDX) ; return reference to data tree given map reference
"RTN","YTXCHG",134,0)
 ; expects TREE from BLDVIEW for root tree reference
"RTN","YTXCHG",135,0)
 N LEVEL,RESULT,I,LABEL
"RTN","YTXCHG",136,0)
 S LEVEL=0,RESULT=""
"RTN","YTXCHG",137,0)
 F I=2:2:$QL(MAPREF) S LABEL=$QS(MAPREF,I) D
"RTN","YTXCHG",138,0)
 . S LEVEL=LEVEL+1
"RTN","YTXCHG",139,0)
 . I $L(RESULT) S RESULT=RESULT_","
"RTN","YTXCHG",140,0)
 . I $E(LABEL)="?" D  Q
"RTN","YTXCHG",141,0)
 . . S RESULT=RESULT_""""_$E(LABEL,2,$L(LABEL))_""""
"RTN","YTXCHG",142,0)
 . . I LEVEL<IDX S RESULT=RESULT_","_IDX(LEVEL)
"RTN","YTXCHG",143,0)
 . S RESULT=RESULT_""""_LABEL_""""
"RTN","YTXCHG",144,0)
 S RESULT=$E(TREE,1,$L(TREE)-1)_","_RESULT_")"
"RTN","YTXCHG",145,0)
 Q RESULT
"RTN","YTXCHG",146,0)
 ;
"RTN","YTXCHG",147,0)
LINEOUT(NODE) ; add output line
"RTN","YTXCHG",148,0)
 ; expects CNTROOT,CNTLINE,DEST from BLDVIEW
"RTN","YTXCHG",149,0)
 Q:'$L($G(@NODE))
"RTN","YTXCHG",150,0)
 I $QS(NODE,CNTROOT+2)="template" D TLTOUT(NODE) QUIT
"RTN","YTXCHG",151,0)
 N LINE,I,SUB
"RTN","YTXCHG",152,0)
 S LINE=""
"RTN","YTXCHG",153,0)
 F I=CNTROOT+1:1:($QL(NODE)) S SUB=$QS(NODE,I) D
"RTN","YTXCHG",154,0)
 . I +SUB,(+SUB=SUB) S SUB="["_SUB_"]" I 1
"RTN","YTXCHG",155,0)
 . E  S:$L(LINE) LINE=LINE_"."
"RTN","YTXCHG",156,0)
 . S LINE=LINE_SUB
"RTN","YTXCHG",157,0)
 S CNTLINE=CNTLINE+1,@DEST@(CNTLINE,0)=LINE_"="_@NODE
"RTN","YTXCHG",158,0)
 Q
"RTN","YTXCHG",159,0)
TLTOUT(NODE) ; output the report template
"RTN","YTXCHG",160,0)
 ; expects CNTLINE,DEST from BLDVIEW
"RTN","YTXCHG",161,0)
 Q:'$L($G(@NODE))
"RTN","YTXCHG",162,0)
 ;
"RTN","YTXCHG",163,0)
 K ^TMP("YTXCHG",$J,"TEMPLATE")
"RTN","YTXCHG",164,0)
 D TR2WP^YTXCHGT(NODE,$NA(^TMP("YTXCHG",$J,"TEMPLATE")))
"RTN","YTXCHG",165,0)
 S CNTLINE=CNTLINE+1,@DEST@(CNTLINE,0)="report.template="
"RTN","YTXCHG",166,0)
 S CNTLINE=CNTLINE+1
"RTN","YTXCHG",167,0)
 N I,J,X
"RTN","YTXCHG",168,0)
 S I=0 F  S I=$O(^TMP("YTXCHG",$J,"TEMPLATE",I)) Q:'I  D
"RTN","YTXCHG",169,0)
 . S X=^TMP("YTXCHG",$J,"TEMPLATE",I,0)
"RTN","YTXCHG",170,0)
 . F J=1:1:$L(X,"|") D
"RTN","YTXCHG",171,0)
 . . I J=1 S @DEST@(CNTLINE,0)=$G(@DEST@(CNTLINE,0))_$P(X,"|",1) I 1
"RTN","YTXCHG",172,0)
 . . E  S CNTLINE=CNTLINE+1,@DEST@(CNTLINE,0)=$P(X,"|",J)
"RTN","YTXCHG",173,0)
 K ^TMP("YTXCHG",$J,"TEMPLATE")
"RTN","YTXCHG",174,0)
 Q
"RTN","YTXCHG",175,0)
SAVEHFS(XCHGIEN,FULLNM) ; save instrument exchange entry to host file
"RTN","YTXCHG",176,0)
 ; return 1 if successful, otherwise 0
"RTN","YTXCHG",177,0)
 N SPECLOC,PATH,FILE,OK
"RTN","YTXCHG",178,0)
 S SPECLOC=$NA(^YTT(601.95,XCHGIEN,1,1,0))
"RTN","YTXCHG",179,0)
 I $D(^YTT(601.95,XCHGIEN,4,1,0)) D  ; insert addendum into spec
"RTN","YTXCHG",180,0)
 . K ^TMP("YTXCHG",$J,"TREE"),^TMP("YTXCHG",$J,"JSON")
"RTN","YTXCHG",181,0)
 . S OK=$$SPEC2TR^YTXCHGT(XCHGIEN,$NA(^TMP("YTXCHG",$J,"TREE")))
"RTN","YTXCHG",182,0)
 . D WP2TR^YTXCHGT($NA(^YTT(601.95,XCHGIEN,4)),$NA(^TMP("YTXCHG",$J,"TREE","xchg","addendum")))
"RTN","YTXCHG",183,0)
 . S OK=$$TR2JSON^YTXCHGT($NA(^TMP("YTXCHG",$J,"TREE")),$NA(^TMP("YTXCHG",$J,"JSON")))
"RTN","YTXCHG",184,0)
 . S SPECLOC=$NA(^TMP("YTXCHG",$J,"JSON",1))
"RTN","YTXCHG",185,0)
 ;
"RTN","YTXCHG",186,0)
 D SPLTDIR^YTXCHGU(FULLNM,.PATH,.FILE)
"RTN","YTXCHG",187,0)
 S OK=$$GTF^%ZISH(SPECLOC,4,PATH,FILE)
"RTN","YTXCHG",188,0)
 Q OK
"RTN","YTXCHG",189,0)
 ;
"RTN","YTXCHG",190,0)
LOADFILE(PATH,INFO) ; load file into JSON & tree structures
"RTN","YTXCHG",191,0)
 ; PATH is full HFS name or URL
"RTN","YTXCHG",192,0)
 ; .INFO returns the fields for 601.95 entry
"RTN","YTXCHG",193,0)
 ;       word processing values are in ^TMP("YTXCHG",$J,"WP",field)
"RTN","YTXCHG",194,0)
 ; Specification ends up in ^TMP("YTXCHG",$J,"WP",1)
"RTN","YTXCHG",195,0)
 ; Description content ends up in ^TMP("YTXCHG",$J,"WP",2)
"RTN","YTXCHG",196,0)
 K ^TMP("YTXCHG",$J,"JSON")
"RTN","YTXCHG",197,0)
 K ^TMP("YTXCHG",$J,"TREE")
"RTN","YTXCHG",198,0)
 K ^TMP("YTXCHG",$J,"WP",1),^TMP("YTXCHG",$J,"WP",2),^TMP("YTXCHG",$J,"WP",4)
"RTN","YTXCHG",199,0)
 I $E(PATH,1,5)="http:" D LOADURL(PATH,.INFO) I 1  ; load file from URL
"RTN","YTXCHG",200,0)
 E  D LOADHFS(PATH,.INFO)                          ; load file from HFS
"RTN","YTXCHG",201,0)
 Q:$G(INFO)=-1
"RTN","YTXCHG",202,0)
 N OK
"RTN","YTXCHG",203,0)
 S OK=$$JSON2TR^YTXCHGT($NA(^TMP("YTXCHG",$J,"JSON")),$NA(^TMP("YTXCHG",$J,"TREE")))
"RTN","YTXCHG",204,0)
 I 'OK S INFO=-1 G XLOADF
"RTN","YTXCHG",205,0)
 D SETINFO(.INFO,$NA(^TMP("YTXCHG",$J,"TREE")))
"RTN","YTXCHG",206,0)
 S INFO(1)=$NA(^TMP("YTXCHG",$J,"WP",1)) ; #1 is specification field
"RTN","YTXCHG",207,0)
 D JSON2WP^YTXCHGT($NA(^TMP("YTXCHG",$J,"JSON")),$NA(^TMP("YTXCHG",$J,"WP",1)))
"RTN","YTXCHG",208,0)
XLOADF ; exit LOADFILE here
"RTN","YTXCHG",209,0)
 ; ^TMP("YTXCHG",$J,"WP) should be cleaned up by caller
"RTN","YTXCHG",210,0)
 K ^TMP("YTXCHG",$J,"JSON")
"RTN","YTXCHG",211,0)
 K ^TMP("YTXCHG",$J,"TREE")
"RTN","YTXCHG",212,0)
 Q
"RTN","YTXCHG",213,0)
LOADHFS(FULLNM,INFO) ; load file from HFS into JSON & tree structures
"RTN","YTXCHG",214,0)
 N DIR,FILE,OK
"RTN","YTXCHG",215,0)
 D SPLTDIR^YTXCHGU(FULLNM,.DIR,.FILE)
"RTN","YTXCHG",216,0)
 S OK=$$FTG^%ZISH(DIR,FILE,$NA(^TMP("YTXCHG",$J,"JSON",1)),4)
"RTN","YTXCHG",217,0)
 I 'OK D LOG^YTXCHGU("error","Failed to load "_FULLNM) S INFO=-1 QUIT
"RTN","YTXCHG",218,0)
 Q
"RTN","YTXCHG",219,0)
LOADURL(URL,INFO) ; load file from URL into JSON & tree structures
"RTN","YTXCHG",220,0)
 N RESULT,HEADER
"RTN","YTXCHG",221,0)
 S RESULT=$$GETURL^XTHC10(URL,10,$NA(^TMP("YTXCHG",$J,"JSON")),.HEADER)
"RTN","YTXCHG",222,0)
 I $P(RESULT,U,1)'=200 D  QUIT
"RTN","YTXCHG",223,0)
 . D LOG^YTXCHGU("error","Could not load file: "_$P(RESULT,U,1)_" "_$P(RESULT,U,2))
"RTN","YTXCHG",224,0)
 . S INFO=-1
"RTN","YTXCHG",225,0)
 Q
"RTN","YTXCHG",226,0)
SETINFO(INFO,TREE) ; set .INFO array from specification TREE
"RTN","YTXCHG",227,0)
 S INFO(.01)=$G(@TREE@("xchg","name"))
"RTN","YTXCHG",228,0)
 S INFO(.02)=$G(@TREE@("xchg","date"))
"RTN","YTXCHG",229,0)
 S INFO(.03)=$G(@TREE@("xchg","source"))
"RTN","YTXCHG",230,0)
 S INFO(2)=$NA(^TMP("YTXCHG",$J,"WP",2)) ; #2 is description field
"RTN","YTXCHG",231,0)
 D TR2WP^YTXCHGT($NA(@TREE@("xchg","description")),INFO(2))
"RTN","YTXCHG",232,0)
 I '$D(@TREE@("xchg","addendum")) QUIT
"RTN","YTXCHG",233,0)
 S INFO(4)=$NA(^TMP("YTXCHG",$J,"WP",4)) ; #4 is addendum field
"RTN","YTXCHG",234,0)
 D TR2WP^YTXCHGT($NA(@TREE@("xchg","addendum")),INFO(4))
"RTN","YTXCHG",235,0)
 K @TREE@("xchg","addendum") ; remove so not included in spec
"RTN","YTXCHG",236,0)
 Q
"RTN","YTXCHG",237,0)
SENDMAIL ; interactive -- send instrument exchange entry in mail message
"RTN","YTXCHG",238,0)
 Q
"RTN","YTXCHG",239,0)
LOADMAIL ; interactive -- load instrument exchange entry from mail message
"RTN","YTXCHG",240,0)
 Q
"RTN","YTXCHGT")
0^22^B23916651^B22991016
"RTN","YTXCHGT",1,0)
YTXCHGT ;SLC/KCM - JSON / Tree Conversions ; 9/15/2015
"RTN","YTXCHGT",2,0)
 ;;5.01;MENTAL HEALTH;**121,123,130**;Dec 30, 1994;Build 62
"RTN","YTXCHGT",3,0)
 ;
"RTN","YTXCHGT",4,0)
 ; Reference to VPRJSON supported by IA #6411
"RTN","YTXCHGT",5,0)
 ;
"RTN","YTXCHGT",6,0)
 ; SRC,DEST are global or local array references
"RTN","YTXCHGT",7,0)
 ;
"RTN","YTXCHGT",8,0)
MHA2TR(TEST,DEST) ; Load MHA test into DEST tree
"RTN","YTXCHGT",9,0)
 D EXPORT^YTXCHGE(TEST,DEST)
"RTN","YTXCHGT",10,0)
 Q
"RTN","YTXCHGT",11,0)
TR2MHA(TREE,YTXDRY) ; Save SRC tree into MHA file entries
"RTN","YTXCHGT",12,0)
 ;   TREE: closed reference to node that represents 1 instrument
"RTN","YTXCHGT",13,0)
 ; YTXDRY: defined and true if this is just a dry run
"RTN","YTXCHGT",14,0)
 N SEQ,PREFIX,TESTNM,NEWDT
"RTN","YTXCHGT",15,0)
 S PREFIX=$S($G(YTXDRY):"Trial install for ",1:"Installing ")
"RTN","YTXCHGT",16,0)
 S SEQ=0 F  S SEQ=$O(@TREE@("test",SEQ)) Q:'SEQ  D
"RTN","YTXCHGT",17,0)
 . N YTXLOG S YTXLOG=1
"RTN","YTXCHGT",18,0)
 . S TESTNM=@TREE@("test",SEQ,"info","name")
"RTN","YTXCHGT",19,0)
 . D LOG^YTXCHGU("info",PREFIX_TESTNM)
"RTN","YTXCHGT",20,0)
 . ; if not a dry run, do a test pass first and look for conflicts
"RTN","YTXCHGT",21,0)
 . I '$G(YTXDRY) D IMPTREE^YTXCHGI($NA(@TREE@("test",SEQ)),2)
"RTN","YTXCHGT",22,0)
 . I $G(YTXLOG("conflict")) D SHOSUMM^YTXCHGP(.YTXLOG,1) QUIT
"RTN","YTXCHGT",23,0)
 . ; do a dry run or actual pass
"RTN","YTXCHGT",24,0)
 . K YTXLOG S YTXLOG=1
"RTN","YTXCHGT",25,0)
 . I '$G(YTXDRY) D BACKUP^YTXCHGU(@TREE@("test",SEQ,"info","name"))
"RTN","YTXCHGT",26,0)
 . D IMPTREE^YTXCHGI($NA(@TREE@("test",SEQ)),YTXDRY)
"RTN","YTXCHGT",27,0)
 . D SHOSUMM^YTXCHGP(.YTXLOG,YTXDRY)
"RTN","YTXCHGT",28,0)
 . D LOG^YTXCHGU("info",$S($G(DRYRUN):"Trial install",1:"Installation")_" complete."_$S($G(DRYRUN):"  (No changes made)",1:""))
"RTN","YTXCHGT",29,0)
 . Q:$G(YTXDRY)
"RTN","YTXCHGT",30,0)
 . S NEWDT=@TREE@("test",SEQ,"info","lastEditDate")
"RTN","YTXCHGT",31,0)
 . I ($G(YTXLOG("added"))+$G(YTXLOG("updated")))>0 D NEWDATE^YTXCHGU(TESTNM,NEWDT)
"RTN","YTXCHGT",32,0)
 . D FILE96^YTWJSONF(@TREE@("test",SEQ,"info","name")) ; move new instrument to 601.96
"RTN","YTXCHGT",33,0)
 Q
"RTN","YTXCHGT",34,0)
TR2JSON(SRC,DEST) ; Convert tree representation to JSON
"RTN","YTXCHGT",35,0)
 N JSONERR,INTERIM,OK
"RTN","YTXCHGT",36,0)
 S INTERIM=$NA(^TMP("YTXCHG",$J,"INTERIM"))
"RTN","YTXCHGT",37,0)
 K @INTERIM
"RTN","YTXCHGT",38,0)
 I $E(DEST)=U,($E(DEST,1,4)'="^TMP") K @DEST  ; empty DEST
"RTN","YTXCHGT",39,0)
 D ENCODE^VPRJSON(SRC,INTERIM,"JSONERR")
"RTN","YTXCHGT",40,0)
 I $D(JSONERR) D LOG^YTXCHGU("error","JSON encode, "_$G(JSONERR(1))) Q 0
"RTN","YTXCHGT",41,0)
 D SPLITLN(INTERIM,DEST) ; split into smaller lines for Fileman
"RTN","YTXCHGT",42,0)
 K @INTERIM
"RTN","YTXCHGT",43,0)
 Q 1
"RTN","YTXCHGT",44,0)
 ;
"RTN","YTXCHGT",45,0)
JSON2TR(SRC,DEST) ; Convert JSON to tree representation
"RTN","YTXCHGT",46,0)
 ; returns 1 if converted without error
"RTN","YTXCHGT",47,0)
 ;  SRC contains JSON representation
"RTN","YTXCHGT",48,0)
 ; DEST is $NA value and should be empty
"RTN","YTXCHGT",49,0)
 N JSONERR
"RTN","YTXCHGT",50,0)
 D DECODE^VPRJSON(SRC,DEST,"JSONERR")
"RTN","YTXCHGT",51,0)
 I $D(JSONERR) D LOG^YTXCHGU("error","JSON decode, "_$G(JSONERR(1))) Q 0
"RTN","YTXCHGT",52,0)
 Q 1
"RTN","YTXCHGT",53,0)
 ;
"RTN","YTXCHGT",54,0)
SPEC2TR(XCHGIEN,DEST) ; Convert JSON WP entry in 601.95 to tree representation
"RTN","YTXCHGT",55,0)
 ; returns 1 if converted without error
"RTN","YTXCHGT",56,0)
 ; DEST is $NA value and should be empty
"RTN","YTXCHGT",57,0)
 K ^TMP("YTXCHG",$J,"JSONTMP")
"RTN","YTXCHGT",58,0)
 N I,JSONERR
"RTN","YTXCHGT",59,0)
 ; convert main specification from JSON to TREE
"RTN","YTXCHGT",60,0)
 S I=0 F  S I=$O(^YTT(601.95,XCHGIEN,1,I)) Q:'I  S ^TMP("YTXCHG",$J,"JSONTMP",I)=^YTT(601.95,XCHGIEN,1,I,0)
"RTN","YTXCHGT",61,0)
 D DECODE^VPRJSON($NA(^TMP("YTXCHG",$J,"JSONTMP")),DEST,"JSONERR")
"RTN","YTXCHGT",62,0)
 K ^TMP("YTXCHG",$J,"JSONTMP")
"RTN","YTXCHGT",63,0)
 I $D(JSONERR) D LOG^YTXCHGU("error","JSON decode, "_$G(JSONERR(1))) Q 0
"RTN","YTXCHGT",64,0)
 D ADDEND(XCHGIEN)
"RTN","YTXCHGT",65,0)
 Q 1
"RTN","YTXCHGT",66,0)
 ;
"RTN","YTXCHGT",67,0)
ADDEND(XCHGIEN) ; Process any contents in addendum
"RTN","YTXCHGT",68,0)
 ; example: {"ignoreConflicts": ["601.72:6488","601.72:6491","601.72:6734"]}
"RTN","YTXCHGT",69,0)
 N I,X,ARRAY
"RTN","YTXCHGT",70,0)
 D ADD2TR(XCHGIEN,.ARRAY) Q:'$D(ARRAY)
"RTN","YTXCHGT",71,0)
 K ^XTMP("YTXIDX","ignore")
"RTN","YTXCHGT",72,0)
 S I=0 F  S I=$O(ARRAY("ignoreConflicts",I)) Q:'I  D
"RTN","YTXCHGT",73,0)
 . S X=ARRAY("ignoreConflicts",I)
"RTN","YTXCHGT",74,0)
 . S ^XTMP("YTXIDX","ignore",+$P(X,":"),+$P(X,":",2))=""
"RTN","YTXCHGT",75,0)
 Q
"RTN","YTXCHGT",76,0)
CHKSCORE(XCHGIEN) ; Check addendum for instruments that should be re-scored
"RTN","YTXCHGT",77,0)
 ; example: {"rescoreInstruments":["PCL-5"]}
"RTN","YTXCHGT",78,0)
 N I,X,ARRAY,IEN,REV
"RTN","YTXCHGT",79,0)
 D ADD2TR(XCHGIEN,.ARRAY) Q:'$D(ARRAY)
"RTN","YTXCHGT",80,0)
 S I=0 F  S I=$O(ARRAY("rescoreInstruments",I)) Q:'I  D
"RTN","YTXCHGT",81,0)
 . S X=ARRAY("rescoreInstruments",I)
"RTN","YTXCHGT",82,0)
 . S IEN=$O(^YTT(601.71,"B",X,0)) Q:'IEN
"RTN","YTXCHGT",83,0)
 . S REV=$P($G(^YTT(601.71,IEN,9)),U,3) Q:'REV
"RTN","YTXCHGT",84,0)
 . D QTASK^YTSCOREV(IEN_"~"_REV,($H+1)_",3600") ; queue rescoring (T+1@1am)
"RTN","YTXCHGT",85,0)
 Q
"RTN","YTXCHGT",86,0)
ADD2TR(XCHGIEN,ARRAY) ; Load Addendum JSON into TREE
"RTN","YTXCHGT",87,0)
 N I,JSONTMP,JSONERR
"RTN","YTXCHGT",88,0)
 S I=0 F  S I=$O(^YTT(601.95,XCHGIEN,4,I)) Q:'I  S JSONTMP(I)=^YTT(601.95,XCHGIEN,4,I,0)
"RTN","YTXCHGT",89,0)
 Q:'$D(JSONTMP)
"RTN","YTXCHGT",90,0)
 D DECODE^VPRJSON("JSONTMP","ARRAY","JSONERR")
"RTN","YTXCHGT",91,0)
 I $D(JSONERR) D LOG^YTXCHGU("error","Addendum decode, "_$G(JSONERR(1))) Q
"RTN","YTXCHGT",92,0)
 Q
"RTN","YTXCHGT",93,0)
JSON2WP(SRC,DEST) ; Convert JSON array (n) to WP array (n,0)
"RTN","YTXCHGT",94,0)
 N I
"RTN","YTXCHGT",95,0)
 S I=0 F  S I=$O(@SRC@(I)) Q:'I  S @DEST@(I,0)=@SRC@(I)
"RTN","YTXCHGT",96,0)
 Q
"RTN","YTXCHGT",97,0)
WP2TR(SRC,DEST) ; Convert FM WP field to tree representation
"RTN","YTXCHGT",98,0)
 ;  SRC: glvn of source array
"RTN","YTXCHGT",99,0)
 ; DEST: glvn of destination array
"RTN","YTXCHGT",100,0)
 I $E(DEST)=U,($E(DEST,1,4)'="^TMP") K @DEST  ; empty DEST
"RTN","YTXCHGT",101,0)
 N LN S LN=0
"RTN","YTXCHGT",102,0)
 F  S LN=$O(@SRC@(LN)) Q:'LN  D
"RTN","YTXCHGT",103,0)
 . I LN=1 S @DEST=@SRC@(LN,0) I 1
"RTN","YTXCHGT",104,0)
 . E  S @DEST@("\",LN-1)=$C(13,10)_@SRC@(LN,0)
"RTN","YTXCHGT",105,0)
 Q
"RTN","YTXCHGT",106,0)
TR2WP(SRC,DEST) ; Convert tree representation to FM WP
"RTN","YTXCHGT",107,0)
 ;  SRC: glvn of source array (JSON node with wp text)
"RTN","YTXCHGT",108,0)
 ; DEST: glvn of destination array (will add [line,0] nodes)
"RTN","YTXCHGT",109,0)
 N I,J,X,LN
"RTN","YTXCHGT",110,0)
 S LN=0,X=$G(@SRC)
"RTN","YTXCHGT",111,0)
 F J=1:1:$L(X,$C(13,10)) S LN=LN+1,@DEST@(LN,0)=$P(X,$C(13,10),J)
"RTN","YTXCHGT",112,0)
 S I=0 F  S I=$O(@SRC@("\",I)) Q:'I  D
"RTN","YTXCHGT",113,0)
 . S X=@SRC@("\",I)
"RTN","YTXCHGT",114,0)
 . F J=1:1:$L(X,$C(13,10)) D
"RTN","YTXCHGT",115,0)
 . . I J=1 S @DEST@(LN,0)=@DEST@(LN,0)_$P(X,$C(13,10),1) I 1
"RTN","YTXCHGT",116,0)
 . . E  S LN=LN+1,@DEST@(LN,0)=$P(X,$C(13,10),J)
"RTN","YTXCHGT",117,0)
 Q
"RTN","YTXCHGT",118,0)
SPLITLN(SRC,DEST,MAX) ; Split JSON lines into lines of MAX length
"RTN","YTXCHGT",119,0)
 N I,LN,X
"RTN","YTXCHGT",120,0)
 S MAX=$G(MAX,240) S:MAX'>0 MAX=240 ; MAX default is 240
"RTN","YTXCHGT",121,0)
 S LN=0,I=0 F  S I=$O(@SRC@(I)) Q:'I  D
"RTN","YTXCHGT",122,0)
 . S X=@SRC@(I)
"RTN","YTXCHGT",123,0)
 . F  S LN=LN+1,@DEST@(LN)=$E(X,1,MAX),X=$E(X,MAX+1,99999) Q:'$L(X)
"RTN","YTXCHGT",124,0)
 Q
"RTN","YTXCHGT",125,0)
 ;
"RTN","YTXCHGT",126,0)
TEST2WP ; test TR2WP entry point
"RTN","YTXCHGT",127,0)
 N JSON,TEXT
"RTN","YTXCHGT",128,0)
 S JSON("wp")="This is line 1."_$C(13,10)_"This is line 2."_$C(13,10)_"This is "
"RTN","YTXCHGT",129,0)
 S JSON("wp","\",1)="line 3."_$C(13,10)_"This is line 4."_$C(13,10)_"This is line "
"RTN","YTXCHGT",130,0)
 S JSON("wp","\",2)="5."_$C(13,10)_"This is the last line."
"RTN","YTXCHGT",131,0)
 D TR2WP($NA(JSON("wp")),$NA(TEXT(2)))
"RTN","YTXCHGT",132,0)
 ; ZW TEXT
"RTN","YTXCHGT",133,0)
 Q
"SEC","^DIC",601.96,601.96,0,"AUDIT")
@
"SEC","^DIC",601.96,601.96,0,"DD")
@
"SEC","^DIC",601.96,601.96,0,"DEL")
@
"SEC","^DIC",601.96,601.96,0,"LAYGO")
@
"SEC","^DIC",601.96,601.96,0,"RD")
@
"SEC","^DIC",601.96,601.96,0,"WR")
@
"SEC","^DIC",601.97,601.97,0,"AUDIT")
@
"SEC","^DIC",601.97,601.97,0,"DD")
@
"SEC","^DIC",601.97,601.97,0,"DEL")
@
"SEC","^DIC",601.97,601.97,0,"LAYGO")
@
"SEC","^DIC",601.97,601.97,0,"RD")
@
"SEC","^DIC",601.97,601.97,0,"WR")
@
"UP",601.71,601.71101,-1)
601.71^10
"UP",601.71,601.71101,0)
601.71101
"VER")
8.0^22.2
"^DD",601.71,601.71,94,0)
STAFF ENTRY ONLY^S^Y:Yes;N:No;^9;4^Q
"^DD",601.71,601.71,94,3)
Enter "Yes" if this instrument should not be entered by the patient.
"^DD",601.71,601.71,94,21,0)
^.001^3^3^3190419^^
"^DD",601.71,601.71,94,21,1,0)
This field controls whether patient entry of the instrument is allowed.
"^DD",601.71,601.71,94,21,2,0)
The field should be set to "Yes" if the instrument should only be used
"^DD",601.71,601.71,94,21,3,0)
by staff and not patients.
"^DD",601.71,601.71,94,"DT")
3190404
"^DD",601.71,601.71,101,0)
CATEGORY^601.71101P^^10;0
"^DD",601.71,601.71,101,21,0)
^^3^3^3190617^
"^DD",601.71,601.71,101,21,1,0)
This multiple contains the categories to which an instrument belongs.  
"^DD",601.71,601.71,101,21,2,0)
This allows an instrument to be organized as a member of one or more 
"^DD",601.71,601.71,101,21,3,0)
sub-groups.
"^DD",601.71,601.71101,0)
CATEGORY SUB-FIELD^^.01^1
"^DD",601.71,601.71101,0,"NM","CATEGORY")

"^DD",601.71,601.71101,.01,0)
CATEGORY^MP601.97'^YTT(601.97,^0;1^Q
"^DD",601.71,601.71101,.01,1,0)
^.1
"^DD",601.71,601.71101,.01,1,1,0)
601.71101^B
"^DD",601.71,601.71101,.01,1,1,1)
S ^YTT(601.71,DA(1),10,"B",$E(X,1,30),DA)=""
"^DD",601.71,601.71101,.01,1,1,2)
K ^YTT(601.71,DA(1),10,"B",$E(X,1,30),DA)
"^DD",601.71,601.71101,.01,3)
Select the category for this instrument from the list of possible categories.
"^DD",601.71,601.71101,.01,21,0)
^.001^2^2^3190617^^^
"^DD",601.71,601.71101,.01,21,1,0)
This points to a pre-determined list of categories.  The instrument will 
"^DD",601.71,601.71101,.01,21,2,0)
appear under each selected category.
"^DD",601.71,601.71101,.01,"DT")
3190617
"^DD",601.96,601.96,0)
FIELD^^1^4
"^DD",601.96,601.96,0,"DT")
3191021
"^DD",601.96,601.96,0,"IX","B",601.96,.01)

"^DD",601.96,601.96,0,"NM","MH STAGED DOCUMENTS")

"^DD",601.96,601.96,0,"VRPK")
YS
"^DD",601.96,601.96,.01,0)
NAME^RFJ80X^^0;1^K:$L(X)>80!($L(X)<3)!'(X'?1P.E) X
"^DD",601.96,601.96,.01,1,0)
^.1^^-1
"^DD",601.96,601.96,.01,1,1,0)
601.96^B
"^DD",601.96,601.96,.01,1,1,1)
S ^YTT(601.96,"B",$E(X,1,30),DA)=""
"^DD",601.96,601.96,.01,1,1,2)
K ^YTT(601.96,"B",$E(X,1,30),DA)
"^DD",601.96,601.96,.01,3)
Answer must be 3-80 characters in length.
"^DD",601.96,601.96,.01,21,0)
^^4^4^3190617^
"^DD",601.96,601.96,.01,21,1,0)
This is a name that can be used to retrieve a staged document.  It is
"^DD",601.96,601.96,.01,21,2,0)
helpful to use namespacing to avoid collisions.  For example, names
"^DD",601.96,601.96,.01,21,3,0)
beginning with YTT represent instrument specifications.  Names beginning 
"^DD",601.96,601.96,.01,21,4,0)
with YTL represent instrument lists.
"^DD",601.96,601.96,.01,"DT")
3190617
"^DD",601.96,601.96,.02,0)
REVISION^NJ6,0^^0;2^K:+X'=X!(X>999999)!(X<0)!(X?.E1"."1N.N) X
"^DD",601.96,601.96,.02,3)
Type a number between 0 and 999999, 0 decimal digits.
"^DD",601.96,601.96,.02,21,0)
^^2^2^3190612^
"^DD",601.96,601.96,.02,21,1,0)
This optional field may be used to store a version number for the 
"^DD",601.96,601.96,.02,21,2,0)
document content.
"^DD",601.96,601.96,.02,"DT")
3190612
"^DD",601.96,601.96,.03,0)
DIGEST^FJ30^^0;3^K:$L(X)>30!($L(X)<3) X
"^DD",601.96,601.96,.03,3)
Answer must be 3-30 characters in length.
"^DD",601.96,601.96,.03,21,0)
^^2^2^3190612^
"^DD",601.96,601.96,.03,21,1,0)
This optional field may be used to store a hash to validate the content 
"^DD",601.96,601.96,.03,21,2,0)
of the document.
"^DD",601.96,601.96,.03,"DT")
3190612
"^DD",601.96,601.96,1,0)
CONTENT^601.961^^1;0
"^DD",601.96,601.96,1,21,0)
^^2^2^3190612^
"^DD",601.96,601.96,1,21,1,0)
This word processing field contains the content of the document.  It is 
"^DD",601.96,601.96,1,21,2,0)
generally a JSON-formatted document.
"^DD",601.96,601.961,0)
CONTENT SUB-FIELD^^.01^1
"^DD",601.96,601.961,0,"DT")
3190612
"^DD",601.96,601.961,0,"NM","CONTENT")

"^DD",601.96,601.961,0,"UP")
601.96
"^DD",601.96,601.961,.01,0)
CONTENT^WLx^^0;1^Q
"^DD",601.96,601.961,.01,3)
Enter the structured content for this document.
"^DD",601.96,601.961,.01,21,0)
^^2^2^3190612^
"^DD",601.96,601.961,.01,21,1,0)
This word processing field contains the content of the document.  It is 
"^DD",601.96,601.961,.01,21,2,0)
generally a JSON-formatted document.
"^DD",601.96,601.961,.01,"DT")
3190612
"^DD",601.97,601.97,0)
FIELD^^.01^1
"^DD",601.97,601.97,0,"DT")
3191021
"^DD",601.97,601.97,0,"IX","B",601.97,.01)

"^DD",601.97,601.97,0,"NM","MH INSTRUMENT CATEGORY")

"^DD",601.97,601.97,0,"PT",601.71101,.01)

"^DD",601.97,601.97,0,"VRPK")
YS
"^DD",601.97,601.97,.01,0)
NAME^RFJ30^^0;1^K:$L(X)>30!($L(X)<3)!'(X'?1P.E) X
"^DD",601.97,601.97,.01,1,0)
^.1
"^DD",601.97,601.97,.01,1,1,0)
601.97^B
"^DD",601.97,601.97,.01,1,1,1)
S ^YTT(601.97,"B",$E(X,1,30),DA)=""
"^DD",601.97,601.97,.01,1,1,2)
K ^YTT(601.97,"B",$E(X,1,30),DA)
"^DD",601.97,601.97,.01,3)
Answer must be 3-30 characters in length.
"^DD",601.97,601.97,.01,21,0)
^^2^2^3190617^
"^DD",601.97,601.97,.01,21,1,0)
The category name is used to organize the instruments into sub-groups that
"^DD",601.97,601.97,.01,21,2,0)
make instrument selection easier for the user in the MHA Web application.
"^DD",601.97,601.97,.01,"DT")
3190425
"^DIC",601.96,601.96,0)
MH STAGED DOCUMENTS^601.96
"^DIC",601.96,601.96,0,"GL")
^YTT(601.96,
"^DIC",601.96,601.96,"%D",0)
^^10^10^3190612^
"^DIC",601.96,601.96,"%D",1,0)
This file contains infrequently changing documents that represent objects 
"^DIC",601.96,601.96,"%D",2,0)
in the Mental Health package.  These documents are constructed in a 
"^DIC",601.96,601.96,"%D",3,0)
"web-ready" format, such as JSON.  Other formats, such as XML, are also 
"^DIC",601.96,601.96,"%D",4,0)
possible.  Staging pre-compiled documents into this file allows web 
"^DIC",601.96,601.96,"%D",5,0)
applications to quickly retrieve mental health structures in a consistent 
"^DIC",601.96,601.96,"%D",6,0)
format.
"^DIC",601.96,601.96,"%D",7,0)
 
"^DIC",601.96,601.96,"%D",8,0)
Examples of the kinds of documents contained in this file include JSON
"^DIC",601.96,601.96,"%D",9,0)
specifications for mental health instruments and lists of active mental
"^DIC",601.96,601.96,"%D",10,0)
health instruments.
"^DIC",601.96,"B","MH STAGED DOCUMENTS",601.96)

"^DIC",601.97,601.97,0)
MH INSTRUMENT CATEGORY^601.97
"^DIC",601.97,601.97,0,"GL")
^YTT(601.97,
"^DIC",601.97,601.97,"%",0)
^1.005^^0
"^DIC",601.97,601.97,"%D",0)
^^2^2^3190617^
"^DIC",601.97,601.97,"%D",1,0)
This file contains the categories used by the MHA Web application to 
"^DIC",601.97,601.97,"%D",2,0)
organize the instruments into sub-groups for easier selection.
"^DIC",601.97,"B","MH INSTRUMENT CATEGORY",601.97)

"BLD",10730,6)
^119
**END**
**END**

